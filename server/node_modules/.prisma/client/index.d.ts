
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Warehouse
 * 
 */
export type Warehouse = $Result.DefaultSelection<Prisma.$WarehousePayload>
/**
 * Model Bin
 * 
 */
export type Bin = $Result.DefaultSelection<Prisma.$BinPayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>
/**
 * Model Bom
 * 
 */
export type Bom = $Result.DefaultSelection<Prisma.$BomPayload>
/**
 * Model BomLine
 * 
 */
export type BomLine = $Result.DefaultSelection<Prisma.$BomLinePayload>
/**
 * Model InventoryBatch
 * 
 */
export type InventoryBatch = $Result.DefaultSelection<Prisma.$InventoryBatchPayload>
/**
 * Model InventoryLedger
 * 
 */
export type InventoryLedger = $Result.DefaultSelection<Prisma.$InventoryLedgerPayload>
/**
 * Model ProductionOrder
 * 
 */
export type ProductionOrder = $Result.DefaultSelection<Prisma.$ProductionOrderPayload>
/**
 * Model WipLedger
 * 
 */
export type WipLedger = $Result.DefaultSelection<Prisma.$WipLedgerPayload>
/**
 * Model LaborTime
 * 
 */
export type LaborTime = $Result.DefaultSelection<Prisma.$LaborTimePayload>
/**
 * Model Vendor
 * 
 */
export type Vendor = $Result.DefaultSelection<Prisma.$VendorPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Purchase
 * 
 */
export type Purchase = $Result.DefaultSelection<Prisma.$PurchasePayload>
/**
 * Model PurchaseLine
 * 
 */
export type PurchaseLine = $Result.DefaultSelection<Prisma.$PurchaseLinePayload>
/**
 * Model Sale
 * 
 */
export type Sale = $Result.DefaultSelection<Prisma.$SalePayload>
/**
 * Model SaleLine
 * 
 */
export type SaleLine = $Result.DefaultSelection<Prisma.$SaleLinePayload>
/**
 * Model ChartOfAccount
 * 
 */
export type ChartOfAccount = $Result.DefaultSelection<Prisma.$ChartOfAccountPayload>
/**
 * Model Journal
 * 
 */
export type Journal = $Result.DefaultSelection<Prisma.$JournalPayload>
/**
 * Model JournalLine
 * 
 */
export type JournalLine = $Result.DefaultSelection<Prisma.$JournalLinePayload>
/**
 * Model Policy
 * 
 */
export type Policy = $Result.DefaultSelection<Prisma.$PolicyPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model CashAccount
 * 
 */
export type CashAccount = $Result.DefaultSelection<Prisma.$CashAccountPayload>
/**
 * Model CashTransaction
 * 
 */
export type CashTransaction = $Result.DefaultSelection<Prisma.$CashTransactionPayload>
/**
 * Model SalesReceipt
 * 
 */
export type SalesReceipt = $Result.DefaultSelection<Prisma.$SalesReceiptPayload>
/**
 * Model PurchasePayment
 * 
 */
export type PurchasePayment = $Result.DefaultSelection<Prisma.$PurchasePaymentPayload>
/**
 * Model SystemSetting
 * 
 */
export type SystemSetting = $Result.DefaultSelection<Prisma.$SystemSettingPayload>
/**
 * Model FiscalYear
 * 
 */
export type FiscalYear = $Result.DefaultSelection<Prisma.$FiscalYearPayload>
/**
 * Model FiscalPeriod
 * 
 */
export type FiscalPeriod = $Result.DefaultSelection<Prisma.$FiscalPeriodPayload>
/**
 * Model ApprovalWorkflow
 * 
 */
export type ApprovalWorkflow = $Result.DefaultSelection<Prisma.$ApprovalWorkflowPayload>
/**
 * Model ApprovalStep
 * 
 */
export type ApprovalStep = $Result.DefaultSelection<Prisma.$ApprovalStepPayload>
/**
 * Model ApprovalRequest
 * 
 */
export type ApprovalRequest = $Result.DefaultSelection<Prisma.$ApprovalRequestPayload>
/**
 * Model ApprovalAction
 * 
 */
export type ApprovalAction = $Result.DefaultSelection<Prisma.$ApprovalActionPayload>
/**
 * Model AssetCategory
 * 
 */
export type AssetCategory = $Result.DefaultSelection<Prisma.$AssetCategoryPayload>
/**
 * Model Asset
 * 
 */
export type Asset = $Result.DefaultSelection<Prisma.$AssetPayload>
/**
 * Model AssetDepreciation
 * 
 */
export type AssetDepreciation = $Result.DefaultSelection<Prisma.$AssetDepreciationPayload>
/**
 * Model AssetDisposal
 * 
 */
export type AssetDisposal = $Result.DefaultSelection<Prisma.$AssetDisposalPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ItemType: {
  RAW_MATERIAL: 'RAW_MATERIAL',
  WORK_IN_PROGRESS: 'WORK_IN_PROGRESS',
  FINISHED_GOODS: 'FINISHED_GOODS',
  CONSUMABLE: 'CONSUMABLE'
};

export type ItemType = (typeof ItemType)[keyof typeof ItemType]


export const CostingMethod: {
  GLOBAL: 'GLOBAL',
  FIFO: 'FIFO',
  WEIGHTED_AVG: 'WEIGHTED_AVG'
};

export type CostingMethod = (typeof CostingMethod)[keyof typeof CostingMethod]


export const LedgerDirection: {
  IN: 'IN',
  OUT: 'OUT'
};

export type LedgerDirection = (typeof LedgerDirection)[keyof typeof LedgerDirection]


export const ProductionOrderStatus: {
  PLANNED: 'PLANNED',
  RELEASED: 'RELEASED',
  IN_PROGRESS: 'IN_PROGRESS',
  FINISHED: 'FINISHED',
  CLOSED: 'CLOSED'
};

export type ProductionOrderStatus = (typeof ProductionOrderStatus)[keyof typeof ProductionOrderStatus]


export const WipLedgerType: {
  ISSUE: 'ISSUE',
  LABOR: 'LABOR',
  OVERHEAD: 'OVERHEAD',
  RECEIPT: 'RECEIPT'
};

export type WipLedgerType = (typeof WipLedgerType)[keyof typeof WipLedgerType]


export const PurchaseStatus: {
  DRAFT: 'DRAFT',
  ORDERED: 'ORDERED',
  RECEIVED: 'RECEIVED',
  INVOICED: 'INVOICED',
  PAID: 'PAID'
};

export type PurchaseStatus = (typeof PurchaseStatus)[keyof typeof PurchaseStatus]


export const SaleStatus: {
  DRAFT: 'DRAFT',
  CONFIRMED: 'CONFIRMED',
  DELIVERED: 'DELIVERED',
  INVOICED: 'INVOICED',
  PAID: 'PAID'
};

export type SaleStatus = (typeof SaleStatus)[keyof typeof SaleStatus]

}

export type ItemType = $Enums.ItemType

export const ItemType: typeof $Enums.ItemType

export type CostingMethod = $Enums.CostingMethod

export const CostingMethod: typeof $Enums.CostingMethod

export type LedgerDirection = $Enums.LedgerDirection

export const LedgerDirection: typeof $Enums.LedgerDirection

export type ProductionOrderStatus = $Enums.ProductionOrderStatus

export const ProductionOrderStatus: typeof $Enums.ProductionOrderStatus

export type WipLedgerType = $Enums.WipLedgerType

export const WipLedgerType: typeof $Enums.WipLedgerType

export type PurchaseStatus = $Enums.PurchaseStatus

export const PurchaseStatus: typeof $Enums.PurchaseStatus

export type SaleStatus = $Enums.SaleStatus

export const SaleStatus: typeof $Enums.SaleStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs>;

  /**
   * `prisma.warehouse`: Exposes CRUD operations for the **Warehouse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Warehouses
    * const warehouses = await prisma.warehouse.findMany()
    * ```
    */
  get warehouse(): Prisma.WarehouseDelegate<ExtArgs>;

  /**
   * `prisma.bin`: Exposes CRUD operations for the **Bin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bins
    * const bins = await prisma.bin.findMany()
    * ```
    */
  get bin(): Prisma.BinDelegate<ExtArgs>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs>;

  /**
   * `prisma.bom`: Exposes CRUD operations for the **Bom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Boms
    * const boms = await prisma.bom.findMany()
    * ```
    */
  get bom(): Prisma.BomDelegate<ExtArgs>;

  /**
   * `prisma.bomLine`: Exposes CRUD operations for the **BomLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BomLines
    * const bomLines = await prisma.bomLine.findMany()
    * ```
    */
  get bomLine(): Prisma.BomLineDelegate<ExtArgs>;

  /**
   * `prisma.inventoryBatch`: Exposes CRUD operations for the **InventoryBatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryBatches
    * const inventoryBatches = await prisma.inventoryBatch.findMany()
    * ```
    */
  get inventoryBatch(): Prisma.InventoryBatchDelegate<ExtArgs>;

  /**
   * `prisma.inventoryLedger`: Exposes CRUD operations for the **InventoryLedger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryLedgers
    * const inventoryLedgers = await prisma.inventoryLedger.findMany()
    * ```
    */
  get inventoryLedger(): Prisma.InventoryLedgerDelegate<ExtArgs>;

  /**
   * `prisma.productionOrder`: Exposes CRUD operations for the **ProductionOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionOrders
    * const productionOrders = await prisma.productionOrder.findMany()
    * ```
    */
  get productionOrder(): Prisma.ProductionOrderDelegate<ExtArgs>;

  /**
   * `prisma.wipLedger`: Exposes CRUD operations for the **WipLedger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WipLedgers
    * const wipLedgers = await prisma.wipLedger.findMany()
    * ```
    */
  get wipLedger(): Prisma.WipLedgerDelegate<ExtArgs>;

  /**
   * `prisma.laborTime`: Exposes CRUD operations for the **LaborTime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaborTimes
    * const laborTimes = await prisma.laborTime.findMany()
    * ```
    */
  get laborTime(): Prisma.LaborTimeDelegate<ExtArgs>;

  /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<ExtArgs>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs>;

  /**
   * `prisma.purchase`: Exposes CRUD operations for the **Purchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchases
    * const purchases = await prisma.purchase.findMany()
    * ```
    */
  get purchase(): Prisma.PurchaseDelegate<ExtArgs>;

  /**
   * `prisma.purchaseLine`: Exposes CRUD operations for the **PurchaseLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseLines
    * const purchaseLines = await prisma.purchaseLine.findMany()
    * ```
    */
  get purchaseLine(): Prisma.PurchaseLineDelegate<ExtArgs>;

  /**
   * `prisma.sale`: Exposes CRUD operations for the **Sale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sales
    * const sales = await prisma.sale.findMany()
    * ```
    */
  get sale(): Prisma.SaleDelegate<ExtArgs>;

  /**
   * `prisma.saleLine`: Exposes CRUD operations for the **SaleLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleLines
    * const saleLines = await prisma.saleLine.findMany()
    * ```
    */
  get saleLine(): Prisma.SaleLineDelegate<ExtArgs>;

  /**
   * `prisma.chartOfAccount`: Exposes CRUD operations for the **ChartOfAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChartOfAccounts
    * const chartOfAccounts = await prisma.chartOfAccount.findMany()
    * ```
    */
  get chartOfAccount(): Prisma.ChartOfAccountDelegate<ExtArgs>;

  /**
   * `prisma.journal`: Exposes CRUD operations for the **Journal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Journals
    * const journals = await prisma.journal.findMany()
    * ```
    */
  get journal(): Prisma.JournalDelegate<ExtArgs>;

  /**
   * `prisma.journalLine`: Exposes CRUD operations for the **JournalLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalLines
    * const journalLines = await prisma.journalLine.findMany()
    * ```
    */
  get journalLine(): Prisma.JournalLineDelegate<ExtArgs>;

  /**
   * `prisma.policy`: Exposes CRUD operations for the **Policy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Policies
    * const policies = await prisma.policy.findMany()
    * ```
    */
  get policy(): Prisma.PolicyDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.cashAccount`: Exposes CRUD operations for the **CashAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashAccounts
    * const cashAccounts = await prisma.cashAccount.findMany()
    * ```
    */
  get cashAccount(): Prisma.CashAccountDelegate<ExtArgs>;

  /**
   * `prisma.cashTransaction`: Exposes CRUD operations for the **CashTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashTransactions
    * const cashTransactions = await prisma.cashTransaction.findMany()
    * ```
    */
  get cashTransaction(): Prisma.CashTransactionDelegate<ExtArgs>;

  /**
   * `prisma.salesReceipt`: Exposes CRUD operations for the **SalesReceipt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesReceipts
    * const salesReceipts = await prisma.salesReceipt.findMany()
    * ```
    */
  get salesReceipt(): Prisma.SalesReceiptDelegate<ExtArgs>;

  /**
   * `prisma.purchasePayment`: Exposes CRUD operations for the **PurchasePayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchasePayments
    * const purchasePayments = await prisma.purchasePayment.findMany()
    * ```
    */
  get purchasePayment(): Prisma.PurchasePaymentDelegate<ExtArgs>;

  /**
   * `prisma.systemSetting`: Exposes CRUD operations for the **SystemSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSetting.findMany()
    * ```
    */
  get systemSetting(): Prisma.SystemSettingDelegate<ExtArgs>;

  /**
   * `prisma.fiscalYear`: Exposes CRUD operations for the **FiscalYear** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FiscalYears
    * const fiscalYears = await prisma.fiscalYear.findMany()
    * ```
    */
  get fiscalYear(): Prisma.FiscalYearDelegate<ExtArgs>;

  /**
   * `prisma.fiscalPeriod`: Exposes CRUD operations for the **FiscalPeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FiscalPeriods
    * const fiscalPeriods = await prisma.fiscalPeriod.findMany()
    * ```
    */
  get fiscalPeriod(): Prisma.FiscalPeriodDelegate<ExtArgs>;

  /**
   * `prisma.approvalWorkflow`: Exposes CRUD operations for the **ApprovalWorkflow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApprovalWorkflows
    * const approvalWorkflows = await prisma.approvalWorkflow.findMany()
    * ```
    */
  get approvalWorkflow(): Prisma.ApprovalWorkflowDelegate<ExtArgs>;

  /**
   * `prisma.approvalStep`: Exposes CRUD operations for the **ApprovalStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApprovalSteps
    * const approvalSteps = await prisma.approvalStep.findMany()
    * ```
    */
  get approvalStep(): Prisma.ApprovalStepDelegate<ExtArgs>;

  /**
   * `prisma.approvalRequest`: Exposes CRUD operations for the **ApprovalRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApprovalRequests
    * const approvalRequests = await prisma.approvalRequest.findMany()
    * ```
    */
  get approvalRequest(): Prisma.ApprovalRequestDelegate<ExtArgs>;

  /**
   * `prisma.approvalAction`: Exposes CRUD operations for the **ApprovalAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApprovalActions
    * const approvalActions = await prisma.approvalAction.findMany()
    * ```
    */
  get approvalAction(): Prisma.ApprovalActionDelegate<ExtArgs>;

  /**
   * `prisma.assetCategory`: Exposes CRUD operations for the **AssetCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssetCategories
    * const assetCategories = await prisma.assetCategory.findMany()
    * ```
    */
  get assetCategory(): Prisma.AssetCategoryDelegate<ExtArgs>;

  /**
   * `prisma.asset`: Exposes CRUD operations for the **Asset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assets
    * const assets = await prisma.asset.findMany()
    * ```
    */
  get asset(): Prisma.AssetDelegate<ExtArgs>;

  /**
   * `prisma.assetDepreciation`: Exposes CRUD operations for the **AssetDepreciation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssetDepreciations
    * const assetDepreciations = await prisma.assetDepreciation.findMany()
    * ```
    */
  get assetDepreciation(): Prisma.AssetDepreciationDelegate<ExtArgs>;

  /**
   * `prisma.assetDisposal`: Exposes CRUD operations for the **AssetDisposal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssetDisposals
    * const assetDisposals = await prisma.assetDisposal.findMany()
    * ```
    */
  get assetDisposal(): Prisma.AssetDisposalDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Role: 'Role',
    Permission: 'Permission',
    UserRole: 'UserRole',
    RolePermission: 'RolePermission',
    Company: 'Company',
    Location: 'Location',
    Warehouse: 'Warehouse',
    Bin: 'Bin',
    Item: 'Item',
    Bom: 'Bom',
    BomLine: 'BomLine',
    InventoryBatch: 'InventoryBatch',
    InventoryLedger: 'InventoryLedger',
    ProductionOrder: 'ProductionOrder',
    WipLedger: 'WipLedger',
    LaborTime: 'LaborTime',
    Vendor: 'Vendor',
    Customer: 'Customer',
    Purchase: 'Purchase',
    PurchaseLine: 'PurchaseLine',
    Sale: 'Sale',
    SaleLine: 'SaleLine',
    ChartOfAccount: 'ChartOfAccount',
    Journal: 'Journal',
    JournalLine: 'JournalLine',
    Policy: 'Policy',
    AuditLog: 'AuditLog',
    CashAccount: 'CashAccount',
    CashTransaction: 'CashTransaction',
    SalesReceipt: 'SalesReceipt',
    PurchasePayment: 'PurchasePayment',
    SystemSetting: 'SystemSetting',
    FiscalYear: 'FiscalYear',
    FiscalPeriod: 'FiscalPeriod',
    ApprovalWorkflow: 'ApprovalWorkflow',
    ApprovalStep: 'ApprovalStep',
    ApprovalRequest: 'ApprovalRequest',
    ApprovalAction: 'ApprovalAction',
    AssetCategory: 'AssetCategory',
    Asset: 'Asset',
    AssetDepreciation: 'AssetDepreciation',
    AssetDisposal: 'AssetDisposal'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "role" | "permission" | "userRole" | "rolePermission" | "company" | "location" | "warehouse" | "bin" | "item" | "bom" | "bomLine" | "inventoryBatch" | "inventoryLedger" | "productionOrder" | "wipLedger" | "laborTime" | "vendor" | "customer" | "purchase" | "purchaseLine" | "sale" | "saleLine" | "chartOfAccount" | "journal" | "journalLine" | "policy" | "auditLog" | "cashAccount" | "cashTransaction" | "salesReceipt" | "purchasePayment" | "systemSetting" | "fiscalYear" | "fiscalPeriod" | "approvalWorkflow" | "approvalStep" | "approvalRequest" | "approvalAction" | "assetCategory" | "asset" | "assetDepreciation" | "assetDisposal"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Warehouse: {
        payload: Prisma.$WarehousePayload<ExtArgs>
        fields: Prisma.WarehouseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          findFirst: {
            args: Prisma.WarehouseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          findMany: {
            args: Prisma.WarehouseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          create: {
            args: Prisma.WarehouseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          createMany: {
            args: Prisma.WarehouseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarehouseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          delete: {
            args: Prisma.WarehouseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          update: {
            args: Prisma.WarehouseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          deleteMany: {
            args: Prisma.WarehouseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WarehouseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          aggregate: {
            args: Prisma.WarehouseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouse>
          }
          groupBy: {
            args: Prisma.WarehouseGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseCountAggregateOutputType> | number
          }
        }
      }
      Bin: {
        payload: Prisma.$BinPayload<ExtArgs>
        fields: Prisma.BinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BinPayload>
          }
          findFirst: {
            args: Prisma.BinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BinPayload>
          }
          findMany: {
            args: Prisma.BinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BinPayload>[]
          }
          create: {
            args: Prisma.BinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BinPayload>
          }
          createMany: {
            args: Prisma.BinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BinCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BinPayload>[]
          }
          delete: {
            args: Prisma.BinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BinPayload>
          }
          update: {
            args: Prisma.BinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BinPayload>
          }
          deleteMany: {
            args: Prisma.BinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BinPayload>
          }
          aggregate: {
            args: Prisma.BinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBin>
          }
          groupBy: {
            args: Prisma.BinGroupByArgs<ExtArgs>
            result: $Utils.Optional<BinGroupByOutputType>[]
          }
          count: {
            args: Prisma.BinCountArgs<ExtArgs>
            result: $Utils.Optional<BinCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      Bom: {
        payload: Prisma.$BomPayload<ExtArgs>
        fields: Prisma.BomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BomPayload>
          }
          findFirst: {
            args: Prisma.BomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BomPayload>
          }
          findMany: {
            args: Prisma.BomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BomPayload>[]
          }
          create: {
            args: Prisma.BomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BomPayload>
          }
          createMany: {
            args: Prisma.BomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BomPayload>[]
          }
          delete: {
            args: Prisma.BomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BomPayload>
          }
          update: {
            args: Prisma.BomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BomPayload>
          }
          deleteMany: {
            args: Prisma.BomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BomPayload>
          }
          aggregate: {
            args: Prisma.BomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBom>
          }
          groupBy: {
            args: Prisma.BomGroupByArgs<ExtArgs>
            result: $Utils.Optional<BomGroupByOutputType>[]
          }
          count: {
            args: Prisma.BomCountArgs<ExtArgs>
            result: $Utils.Optional<BomCountAggregateOutputType> | number
          }
        }
      }
      BomLine: {
        payload: Prisma.$BomLinePayload<ExtArgs>
        fields: Prisma.BomLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BomLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BomLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BomLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BomLinePayload>
          }
          findFirst: {
            args: Prisma.BomLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BomLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BomLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BomLinePayload>
          }
          findMany: {
            args: Prisma.BomLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BomLinePayload>[]
          }
          create: {
            args: Prisma.BomLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BomLinePayload>
          }
          createMany: {
            args: Prisma.BomLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BomLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BomLinePayload>[]
          }
          delete: {
            args: Prisma.BomLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BomLinePayload>
          }
          update: {
            args: Prisma.BomLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BomLinePayload>
          }
          deleteMany: {
            args: Prisma.BomLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BomLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BomLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BomLinePayload>
          }
          aggregate: {
            args: Prisma.BomLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBomLine>
          }
          groupBy: {
            args: Prisma.BomLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<BomLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.BomLineCountArgs<ExtArgs>
            result: $Utils.Optional<BomLineCountAggregateOutputType> | number
          }
        }
      }
      InventoryBatch: {
        payload: Prisma.$InventoryBatchPayload<ExtArgs>
        fields: Prisma.InventoryBatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryBatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryBatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryBatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryBatchPayload>
          }
          findFirst: {
            args: Prisma.InventoryBatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryBatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryBatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryBatchPayload>
          }
          findMany: {
            args: Prisma.InventoryBatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryBatchPayload>[]
          }
          create: {
            args: Prisma.InventoryBatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryBatchPayload>
          }
          createMany: {
            args: Prisma.InventoryBatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryBatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryBatchPayload>[]
          }
          delete: {
            args: Prisma.InventoryBatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryBatchPayload>
          }
          update: {
            args: Prisma.InventoryBatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryBatchPayload>
          }
          deleteMany: {
            args: Prisma.InventoryBatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryBatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryBatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryBatchPayload>
          }
          aggregate: {
            args: Prisma.InventoryBatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryBatch>
          }
          groupBy: {
            args: Prisma.InventoryBatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryBatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryBatchCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryBatchCountAggregateOutputType> | number
          }
        }
      }
      InventoryLedger: {
        payload: Prisma.$InventoryLedgerPayload<ExtArgs>
        fields: Prisma.InventoryLedgerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryLedgerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLedgerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryLedgerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLedgerPayload>
          }
          findFirst: {
            args: Prisma.InventoryLedgerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLedgerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryLedgerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLedgerPayload>
          }
          findMany: {
            args: Prisma.InventoryLedgerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLedgerPayload>[]
          }
          create: {
            args: Prisma.InventoryLedgerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLedgerPayload>
          }
          createMany: {
            args: Prisma.InventoryLedgerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryLedgerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLedgerPayload>[]
          }
          delete: {
            args: Prisma.InventoryLedgerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLedgerPayload>
          }
          update: {
            args: Prisma.InventoryLedgerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLedgerPayload>
          }
          deleteMany: {
            args: Prisma.InventoryLedgerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryLedgerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryLedgerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryLedgerPayload>
          }
          aggregate: {
            args: Prisma.InventoryLedgerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryLedger>
          }
          groupBy: {
            args: Prisma.InventoryLedgerGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryLedgerGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryLedgerCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryLedgerCountAggregateOutputType> | number
          }
        }
      }
      ProductionOrder: {
        payload: Prisma.$ProductionOrderPayload<ExtArgs>
        fields: Prisma.ProductionOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload>
          }
          findFirst: {
            args: Prisma.ProductionOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload>
          }
          findMany: {
            args: Prisma.ProductionOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload>[]
          }
          create: {
            args: Prisma.ProductionOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload>
          }
          createMany: {
            args: Prisma.ProductionOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload>[]
          }
          delete: {
            args: Prisma.ProductionOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload>
          }
          update: {
            args: Prisma.ProductionOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload>
          }
          deleteMany: {
            args: Prisma.ProductionOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductionOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionOrderPayload>
          }
          aggregate: {
            args: Prisma.ProductionOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionOrder>
          }
          groupBy: {
            args: Prisma.ProductionOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionOrderCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionOrderCountAggregateOutputType> | number
          }
        }
      }
      WipLedger: {
        payload: Prisma.$WipLedgerPayload<ExtArgs>
        fields: Prisma.WipLedgerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WipLedgerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WipLedgerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WipLedgerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WipLedgerPayload>
          }
          findFirst: {
            args: Prisma.WipLedgerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WipLedgerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WipLedgerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WipLedgerPayload>
          }
          findMany: {
            args: Prisma.WipLedgerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WipLedgerPayload>[]
          }
          create: {
            args: Prisma.WipLedgerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WipLedgerPayload>
          }
          createMany: {
            args: Prisma.WipLedgerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WipLedgerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WipLedgerPayload>[]
          }
          delete: {
            args: Prisma.WipLedgerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WipLedgerPayload>
          }
          update: {
            args: Prisma.WipLedgerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WipLedgerPayload>
          }
          deleteMany: {
            args: Prisma.WipLedgerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WipLedgerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WipLedgerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WipLedgerPayload>
          }
          aggregate: {
            args: Prisma.WipLedgerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWipLedger>
          }
          groupBy: {
            args: Prisma.WipLedgerGroupByArgs<ExtArgs>
            result: $Utils.Optional<WipLedgerGroupByOutputType>[]
          }
          count: {
            args: Prisma.WipLedgerCountArgs<ExtArgs>
            result: $Utils.Optional<WipLedgerCountAggregateOutputType> | number
          }
        }
      }
      LaborTime: {
        payload: Prisma.$LaborTimePayload<ExtArgs>
        fields: Prisma.LaborTimeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LaborTimeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaborTimePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LaborTimeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaborTimePayload>
          }
          findFirst: {
            args: Prisma.LaborTimeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaborTimePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LaborTimeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaborTimePayload>
          }
          findMany: {
            args: Prisma.LaborTimeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaborTimePayload>[]
          }
          create: {
            args: Prisma.LaborTimeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaborTimePayload>
          }
          createMany: {
            args: Prisma.LaborTimeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LaborTimeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaborTimePayload>[]
          }
          delete: {
            args: Prisma.LaborTimeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaborTimePayload>
          }
          update: {
            args: Prisma.LaborTimeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaborTimePayload>
          }
          deleteMany: {
            args: Prisma.LaborTimeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LaborTimeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LaborTimeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaborTimePayload>
          }
          aggregate: {
            args: Prisma.LaborTimeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLaborTime>
          }
          groupBy: {
            args: Prisma.LaborTimeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LaborTimeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LaborTimeCountArgs<ExtArgs>
            result: $Utils.Optional<LaborTimeCountAggregateOutputType> | number
          }
        }
      }
      Vendor: {
        payload: Prisma.$VendorPayload<ExtArgs>
        fields: Prisma.VendorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findFirst: {
            args: Prisma.VendorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findMany: {
            args: Prisma.VendorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          create: {
            args: Prisma.VendorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          createMany: {
            args: Prisma.VendorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          delete: {
            args: Prisma.VendorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          update: {
            args: Prisma.VendorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          deleteMany: {
            args: Prisma.VendorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VendorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          aggregate: {
            args: Prisma.VendorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendor>
          }
          groupBy: {
            args: Prisma.VendorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorCountArgs<ExtArgs>
            result: $Utils.Optional<VendorCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Purchase: {
        payload: Prisma.$PurchasePayload<ExtArgs>
        fields: Prisma.PurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findFirst: {
            args: Prisma.PurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findMany: {
            args: Prisma.PurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          create: {
            args: Prisma.PurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          createMany: {
            args: Prisma.PurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          delete: {
            args: Prisma.PurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          update: {
            args: Prisma.PurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          aggregate: {
            args: Prisma.PurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchase>
          }
          groupBy: {
            args: Prisma.PurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseCountAggregateOutputType> | number
          }
        }
      }
      PurchaseLine: {
        payload: Prisma.$PurchaseLinePayload<ExtArgs>
        fields: Prisma.PurchaseLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLinePayload>
          }
          findFirst: {
            args: Prisma.PurchaseLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLinePayload>
          }
          findMany: {
            args: Prisma.PurchaseLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLinePayload>[]
          }
          create: {
            args: Prisma.PurchaseLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLinePayload>
          }
          createMany: {
            args: Prisma.PurchaseLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLinePayload>[]
          }
          delete: {
            args: Prisma.PurchaseLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLinePayload>
          }
          update: {
            args: Prisma.PurchaseLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLinePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseLinePayload>
          }
          aggregate: {
            args: Prisma.PurchaseLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseLine>
          }
          groupBy: {
            args: Prisma.PurchaseLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseLineCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseLineCountAggregateOutputType> | number
          }
        }
      }
      Sale: {
        payload: Prisma.$SalePayload<ExtArgs>
        fields: Prisma.SaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findFirst: {
            args: Prisma.SaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findMany: {
            args: Prisma.SaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          create: {
            args: Prisma.SaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          createMany: {
            args: Prisma.SaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          delete: {
            args: Prisma.SaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          update: {
            args: Prisma.SaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          deleteMany: {
            args: Prisma.SaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          aggregate: {
            args: Prisma.SaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSale>
          }
          groupBy: {
            args: Prisma.SaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleCountArgs<ExtArgs>
            result: $Utils.Optional<SaleCountAggregateOutputType> | number
          }
        }
      }
      SaleLine: {
        payload: Prisma.$SaleLinePayload<ExtArgs>
        fields: Prisma.SaleLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleLinePayload>
          }
          findFirst: {
            args: Prisma.SaleLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleLinePayload>
          }
          findMany: {
            args: Prisma.SaleLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleLinePayload>[]
          }
          create: {
            args: Prisma.SaleLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleLinePayload>
          }
          createMany: {
            args: Prisma.SaleLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleLinePayload>[]
          }
          delete: {
            args: Prisma.SaleLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleLinePayload>
          }
          update: {
            args: Prisma.SaleLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleLinePayload>
          }
          deleteMany: {
            args: Prisma.SaleLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SaleLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleLinePayload>
          }
          aggregate: {
            args: Prisma.SaleLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleLine>
          }
          groupBy: {
            args: Prisma.SaleLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleLineCountArgs<ExtArgs>
            result: $Utils.Optional<SaleLineCountAggregateOutputType> | number
          }
        }
      }
      ChartOfAccount: {
        payload: Prisma.$ChartOfAccountPayload<ExtArgs>
        fields: Prisma.ChartOfAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChartOfAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartOfAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChartOfAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartOfAccountPayload>
          }
          findFirst: {
            args: Prisma.ChartOfAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartOfAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChartOfAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartOfAccountPayload>
          }
          findMany: {
            args: Prisma.ChartOfAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartOfAccountPayload>[]
          }
          create: {
            args: Prisma.ChartOfAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartOfAccountPayload>
          }
          createMany: {
            args: Prisma.ChartOfAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChartOfAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartOfAccountPayload>[]
          }
          delete: {
            args: Prisma.ChartOfAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartOfAccountPayload>
          }
          update: {
            args: Prisma.ChartOfAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartOfAccountPayload>
          }
          deleteMany: {
            args: Prisma.ChartOfAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChartOfAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChartOfAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChartOfAccountPayload>
          }
          aggregate: {
            args: Prisma.ChartOfAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChartOfAccount>
          }
          groupBy: {
            args: Prisma.ChartOfAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChartOfAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChartOfAccountCountArgs<ExtArgs>
            result: $Utils.Optional<ChartOfAccountCountAggregateOutputType> | number
          }
        }
      }
      Journal: {
        payload: Prisma.$JournalPayload<ExtArgs>
        fields: Prisma.JournalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          findFirst: {
            args: Prisma.JournalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          findMany: {
            args: Prisma.JournalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>[]
          }
          create: {
            args: Prisma.JournalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          createMany: {
            args: Prisma.JournalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>[]
          }
          delete: {
            args: Prisma.JournalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          update: {
            args: Prisma.JournalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          deleteMany: {
            args: Prisma.JournalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JournalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          aggregate: {
            args: Prisma.JournalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournal>
          }
          groupBy: {
            args: Prisma.JournalGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalCountArgs<ExtArgs>
            result: $Utils.Optional<JournalCountAggregateOutputType> | number
          }
        }
      }
      JournalLine: {
        payload: Prisma.$JournalLinePayload<ExtArgs>
        fields: Prisma.JournalLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          findFirst: {
            args: Prisma.JournalLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          findMany: {
            args: Prisma.JournalLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>[]
          }
          create: {
            args: Prisma.JournalLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          createMany: {
            args: Prisma.JournalLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>[]
          }
          delete: {
            args: Prisma.JournalLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          update: {
            args: Prisma.JournalLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          deleteMany: {
            args: Prisma.JournalLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JournalLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          aggregate: {
            args: Prisma.JournalLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalLine>
          }
          groupBy: {
            args: Prisma.JournalLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalLineCountArgs<ExtArgs>
            result: $Utils.Optional<JournalLineCountAggregateOutputType> | number
          }
        }
      }
      Policy: {
        payload: Prisma.$PolicyPayload<ExtArgs>
        fields: Prisma.PolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          findFirst: {
            args: Prisma.PolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          findMany: {
            args: Prisma.PolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>[]
          }
          create: {
            args: Prisma.PolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          createMany: {
            args: Prisma.PolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>[]
          }
          delete: {
            args: Prisma.PolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          update: {
            args: Prisma.PolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          deleteMany: {
            args: Prisma.PolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PolicyPayload>
          }
          aggregate: {
            args: Prisma.PolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePolicy>
          }
          groupBy: {
            args: Prisma.PolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PolicyCountArgs<ExtArgs>
            result: $Utils.Optional<PolicyCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      CashAccount: {
        payload: Prisma.$CashAccountPayload<ExtArgs>
        fields: Prisma.CashAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashAccountPayload>
          }
          findFirst: {
            args: Prisma.CashAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashAccountPayload>
          }
          findMany: {
            args: Prisma.CashAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashAccountPayload>[]
          }
          create: {
            args: Prisma.CashAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashAccountPayload>
          }
          createMany: {
            args: Prisma.CashAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CashAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashAccountPayload>[]
          }
          delete: {
            args: Prisma.CashAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashAccountPayload>
          }
          update: {
            args: Prisma.CashAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashAccountPayload>
          }
          deleteMany: {
            args: Prisma.CashAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CashAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashAccountPayload>
          }
          aggregate: {
            args: Prisma.CashAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashAccount>
          }
          groupBy: {
            args: Prisma.CashAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashAccountCountArgs<ExtArgs>
            result: $Utils.Optional<CashAccountCountAggregateOutputType> | number
          }
        }
      }
      CashTransaction: {
        payload: Prisma.$CashTransactionPayload<ExtArgs>
        fields: Prisma.CashTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>
          }
          findFirst: {
            args: Prisma.CashTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>
          }
          findMany: {
            args: Prisma.CashTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>[]
          }
          create: {
            args: Prisma.CashTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>
          }
          createMany: {
            args: Prisma.CashTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CashTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>[]
          }
          delete: {
            args: Prisma.CashTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>
          }
          update: {
            args: Prisma.CashTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>
          }
          deleteMany: {
            args: Prisma.CashTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CashTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>
          }
          aggregate: {
            args: Prisma.CashTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashTransaction>
          }
          groupBy: {
            args: Prisma.CashTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<CashTransactionCountAggregateOutputType> | number
          }
        }
      }
      SalesReceipt: {
        payload: Prisma.$SalesReceiptPayload<ExtArgs>
        fields: Prisma.SalesReceiptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesReceiptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReceiptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesReceiptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReceiptPayload>
          }
          findFirst: {
            args: Prisma.SalesReceiptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReceiptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesReceiptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReceiptPayload>
          }
          findMany: {
            args: Prisma.SalesReceiptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReceiptPayload>[]
          }
          create: {
            args: Prisma.SalesReceiptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReceiptPayload>
          }
          createMany: {
            args: Prisma.SalesReceiptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesReceiptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReceiptPayload>[]
          }
          delete: {
            args: Prisma.SalesReceiptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReceiptPayload>
          }
          update: {
            args: Prisma.SalesReceiptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReceiptPayload>
          }
          deleteMany: {
            args: Prisma.SalesReceiptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesReceiptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SalesReceiptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReceiptPayload>
          }
          aggregate: {
            args: Prisma.SalesReceiptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesReceipt>
          }
          groupBy: {
            args: Prisma.SalesReceiptGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesReceiptGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesReceiptCountArgs<ExtArgs>
            result: $Utils.Optional<SalesReceiptCountAggregateOutputType> | number
          }
        }
      }
      PurchasePayment: {
        payload: Prisma.$PurchasePaymentPayload<ExtArgs>
        fields: Prisma.PurchasePaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchasePaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchasePaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePaymentPayload>
          }
          findFirst: {
            args: Prisma.PurchasePaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchasePaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePaymentPayload>
          }
          findMany: {
            args: Prisma.PurchasePaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePaymentPayload>[]
          }
          create: {
            args: Prisma.PurchasePaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePaymentPayload>
          }
          createMany: {
            args: Prisma.PurchasePaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchasePaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePaymentPayload>[]
          }
          delete: {
            args: Prisma.PurchasePaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePaymentPayload>
          }
          update: {
            args: Prisma.PurchasePaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePaymentPayload>
          }
          deleteMany: {
            args: Prisma.PurchasePaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchasePaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchasePaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePaymentPayload>
          }
          aggregate: {
            args: Prisma.PurchasePaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchasePayment>
          }
          groupBy: {
            args: Prisma.PurchasePaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchasePaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchasePaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PurchasePaymentCountAggregateOutputType> | number
          }
        }
      }
      SystemSetting: {
        payload: Prisma.$SystemSettingPayload<ExtArgs>
        fields: Prisma.SystemSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findMany: {
            args: Prisma.SystemSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          create: {
            args: Prisma.SystemSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          createMany: {
            args: Prisma.SystemSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          delete: {
            args: Prisma.SystemSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          update: {
            args: Prisma.SystemSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSetting>
          }
          groupBy: {
            args: Prisma.SystemSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingCountAggregateOutputType> | number
          }
        }
      }
      FiscalYear: {
        payload: Prisma.$FiscalYearPayload<ExtArgs>
        fields: Prisma.FiscalYearFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FiscalYearFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FiscalYearFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>
          }
          findFirst: {
            args: Prisma.FiscalYearFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FiscalYearFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>
          }
          findMany: {
            args: Prisma.FiscalYearFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>[]
          }
          create: {
            args: Prisma.FiscalYearCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>
          }
          createMany: {
            args: Prisma.FiscalYearCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FiscalYearCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>[]
          }
          delete: {
            args: Prisma.FiscalYearDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>
          }
          update: {
            args: Prisma.FiscalYearUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>
          }
          deleteMany: {
            args: Prisma.FiscalYearDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FiscalYearUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FiscalYearUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>
          }
          aggregate: {
            args: Prisma.FiscalYearAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFiscalYear>
          }
          groupBy: {
            args: Prisma.FiscalYearGroupByArgs<ExtArgs>
            result: $Utils.Optional<FiscalYearGroupByOutputType>[]
          }
          count: {
            args: Prisma.FiscalYearCountArgs<ExtArgs>
            result: $Utils.Optional<FiscalYearCountAggregateOutputType> | number
          }
        }
      }
      FiscalPeriod: {
        payload: Prisma.$FiscalPeriodPayload<ExtArgs>
        fields: Prisma.FiscalPeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FiscalPeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalPeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FiscalPeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalPeriodPayload>
          }
          findFirst: {
            args: Prisma.FiscalPeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalPeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FiscalPeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalPeriodPayload>
          }
          findMany: {
            args: Prisma.FiscalPeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalPeriodPayload>[]
          }
          create: {
            args: Prisma.FiscalPeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalPeriodPayload>
          }
          createMany: {
            args: Prisma.FiscalPeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FiscalPeriodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalPeriodPayload>[]
          }
          delete: {
            args: Prisma.FiscalPeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalPeriodPayload>
          }
          update: {
            args: Prisma.FiscalPeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalPeriodPayload>
          }
          deleteMany: {
            args: Prisma.FiscalPeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FiscalPeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FiscalPeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalPeriodPayload>
          }
          aggregate: {
            args: Prisma.FiscalPeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFiscalPeriod>
          }
          groupBy: {
            args: Prisma.FiscalPeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<FiscalPeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.FiscalPeriodCountArgs<ExtArgs>
            result: $Utils.Optional<FiscalPeriodCountAggregateOutputType> | number
          }
        }
      }
      ApprovalWorkflow: {
        payload: Prisma.$ApprovalWorkflowPayload<ExtArgs>
        fields: Prisma.ApprovalWorkflowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApprovalWorkflowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApprovalWorkflowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowPayload>
          }
          findFirst: {
            args: Prisma.ApprovalWorkflowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApprovalWorkflowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowPayload>
          }
          findMany: {
            args: Prisma.ApprovalWorkflowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowPayload>[]
          }
          create: {
            args: Prisma.ApprovalWorkflowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowPayload>
          }
          createMany: {
            args: Prisma.ApprovalWorkflowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApprovalWorkflowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowPayload>[]
          }
          delete: {
            args: Prisma.ApprovalWorkflowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowPayload>
          }
          update: {
            args: Prisma.ApprovalWorkflowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowPayload>
          }
          deleteMany: {
            args: Prisma.ApprovalWorkflowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApprovalWorkflowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApprovalWorkflowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowPayload>
          }
          aggregate: {
            args: Prisma.ApprovalWorkflowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApprovalWorkflow>
          }
          groupBy: {
            args: Prisma.ApprovalWorkflowGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApprovalWorkflowGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApprovalWorkflowCountArgs<ExtArgs>
            result: $Utils.Optional<ApprovalWorkflowCountAggregateOutputType> | number
          }
        }
      }
      ApprovalStep: {
        payload: Prisma.$ApprovalStepPayload<ExtArgs>
        fields: Prisma.ApprovalStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApprovalStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApprovalStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalStepPayload>
          }
          findFirst: {
            args: Prisma.ApprovalStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApprovalStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalStepPayload>
          }
          findMany: {
            args: Prisma.ApprovalStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalStepPayload>[]
          }
          create: {
            args: Prisma.ApprovalStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalStepPayload>
          }
          createMany: {
            args: Prisma.ApprovalStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApprovalStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalStepPayload>[]
          }
          delete: {
            args: Prisma.ApprovalStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalStepPayload>
          }
          update: {
            args: Prisma.ApprovalStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalStepPayload>
          }
          deleteMany: {
            args: Prisma.ApprovalStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApprovalStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApprovalStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalStepPayload>
          }
          aggregate: {
            args: Prisma.ApprovalStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApprovalStep>
          }
          groupBy: {
            args: Prisma.ApprovalStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApprovalStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApprovalStepCountArgs<ExtArgs>
            result: $Utils.Optional<ApprovalStepCountAggregateOutputType> | number
          }
        }
      }
      ApprovalRequest: {
        payload: Prisma.$ApprovalRequestPayload<ExtArgs>
        fields: Prisma.ApprovalRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApprovalRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApprovalRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>
          }
          findFirst: {
            args: Prisma.ApprovalRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApprovalRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>
          }
          findMany: {
            args: Prisma.ApprovalRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>[]
          }
          create: {
            args: Prisma.ApprovalRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>
          }
          createMany: {
            args: Prisma.ApprovalRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApprovalRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>[]
          }
          delete: {
            args: Prisma.ApprovalRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>
          }
          update: {
            args: Prisma.ApprovalRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>
          }
          deleteMany: {
            args: Prisma.ApprovalRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApprovalRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApprovalRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>
          }
          aggregate: {
            args: Prisma.ApprovalRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApprovalRequest>
          }
          groupBy: {
            args: Prisma.ApprovalRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApprovalRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApprovalRequestCountArgs<ExtArgs>
            result: $Utils.Optional<ApprovalRequestCountAggregateOutputType> | number
          }
        }
      }
      ApprovalAction: {
        payload: Prisma.$ApprovalActionPayload<ExtArgs>
        fields: Prisma.ApprovalActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApprovalActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApprovalActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalActionPayload>
          }
          findFirst: {
            args: Prisma.ApprovalActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApprovalActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalActionPayload>
          }
          findMany: {
            args: Prisma.ApprovalActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalActionPayload>[]
          }
          create: {
            args: Prisma.ApprovalActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalActionPayload>
          }
          createMany: {
            args: Prisma.ApprovalActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApprovalActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalActionPayload>[]
          }
          delete: {
            args: Prisma.ApprovalActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalActionPayload>
          }
          update: {
            args: Prisma.ApprovalActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalActionPayload>
          }
          deleteMany: {
            args: Prisma.ApprovalActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApprovalActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApprovalActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalActionPayload>
          }
          aggregate: {
            args: Prisma.ApprovalActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApprovalAction>
          }
          groupBy: {
            args: Prisma.ApprovalActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApprovalActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApprovalActionCountArgs<ExtArgs>
            result: $Utils.Optional<ApprovalActionCountAggregateOutputType> | number
          }
        }
      }
      AssetCategory: {
        payload: Prisma.$AssetCategoryPayload<ExtArgs>
        fields: Prisma.AssetCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetCategoryPayload>
          }
          findFirst: {
            args: Prisma.AssetCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetCategoryPayload>
          }
          findMany: {
            args: Prisma.AssetCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetCategoryPayload>[]
          }
          create: {
            args: Prisma.AssetCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetCategoryPayload>
          }
          createMany: {
            args: Prisma.AssetCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetCategoryPayload>[]
          }
          delete: {
            args: Prisma.AssetCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetCategoryPayload>
          }
          update: {
            args: Prisma.AssetCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetCategoryPayload>
          }
          deleteMany: {
            args: Prisma.AssetCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssetCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetCategoryPayload>
          }
          aggregate: {
            args: Prisma.AssetCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssetCategory>
          }
          groupBy: {
            args: Prisma.AssetCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<AssetCategoryCountAggregateOutputType> | number
          }
        }
      }
      Asset: {
        payload: Prisma.$AssetPayload<ExtArgs>
        fields: Prisma.AssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findFirst: {
            args: Prisma.AssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findMany: {
            args: Prisma.AssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          create: {
            args: Prisma.AssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          createMany: {
            args: Prisma.AssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          delete: {
            args: Prisma.AssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          update: {
            args: Prisma.AssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          deleteMany: {
            args: Prisma.AssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          aggregate: {
            args: Prisma.AssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAsset>
          }
          groupBy: {
            args: Prisma.AssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetCountArgs<ExtArgs>
            result: $Utils.Optional<AssetCountAggregateOutputType> | number
          }
        }
      }
      AssetDepreciation: {
        payload: Prisma.$AssetDepreciationPayload<ExtArgs>
        fields: Prisma.AssetDepreciationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetDepreciationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetDepreciationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetDepreciationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>
          }
          findFirst: {
            args: Prisma.AssetDepreciationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetDepreciationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetDepreciationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>
          }
          findMany: {
            args: Prisma.AssetDepreciationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>[]
          }
          create: {
            args: Prisma.AssetDepreciationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>
          }
          createMany: {
            args: Prisma.AssetDepreciationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetDepreciationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>[]
          }
          delete: {
            args: Prisma.AssetDepreciationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>
          }
          update: {
            args: Prisma.AssetDepreciationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>
          }
          deleteMany: {
            args: Prisma.AssetDepreciationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetDepreciationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssetDepreciationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetDepreciationPayload>
          }
          aggregate: {
            args: Prisma.AssetDepreciationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssetDepreciation>
          }
          groupBy: {
            args: Prisma.AssetDepreciationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetDepreciationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetDepreciationCountArgs<ExtArgs>
            result: $Utils.Optional<AssetDepreciationCountAggregateOutputType> | number
          }
        }
      }
      AssetDisposal: {
        payload: Prisma.$AssetDisposalPayload<ExtArgs>
        fields: Prisma.AssetDisposalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetDisposalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetDisposalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetDisposalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetDisposalPayload>
          }
          findFirst: {
            args: Prisma.AssetDisposalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetDisposalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetDisposalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetDisposalPayload>
          }
          findMany: {
            args: Prisma.AssetDisposalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetDisposalPayload>[]
          }
          create: {
            args: Prisma.AssetDisposalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetDisposalPayload>
          }
          createMany: {
            args: Prisma.AssetDisposalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetDisposalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetDisposalPayload>[]
          }
          delete: {
            args: Prisma.AssetDisposalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetDisposalPayload>
          }
          update: {
            args: Prisma.AssetDisposalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetDisposalPayload>
          }
          deleteMany: {
            args: Prisma.AssetDisposalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetDisposalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssetDisposalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetDisposalPayload>
          }
          aggregate: {
            args: Prisma.AssetDisposalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssetDisposal>
          }
          groupBy: {
            args: Prisma.AssetDisposalGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetDisposalGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetDisposalCountArgs<ExtArgs>
            result: $Utils.Optional<AssetDisposalCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    userRoles: number
    auditLogs: number
    journals: number
    inventoryLedger: number
    cashTransactions: number
    salesReceipts: number
    purchasePayments: number
    SystemSetting: number
    ApprovalRequest: number
    ApprovalAction: number
    assetsCreated: number
    assetDisposals: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | UserCountOutputTypeCountUserRolesArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    journals?: boolean | UserCountOutputTypeCountJournalsArgs
    inventoryLedger?: boolean | UserCountOutputTypeCountInventoryLedgerArgs
    cashTransactions?: boolean | UserCountOutputTypeCountCashTransactionsArgs
    salesReceipts?: boolean | UserCountOutputTypeCountSalesReceiptsArgs
    purchasePayments?: boolean | UserCountOutputTypeCountPurchasePaymentsArgs
    SystemSetting?: boolean | UserCountOutputTypeCountSystemSettingArgs
    ApprovalRequest?: boolean | UserCountOutputTypeCountApprovalRequestArgs
    ApprovalAction?: boolean | UserCountOutputTypeCountApprovalActionArgs
    assetsCreated?: boolean | UserCountOutputTypeCountAssetsCreatedArgs
    assetDisposals?: boolean | UserCountOutputTypeCountAssetDisposalsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJournalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryLedgerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCashTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSalesReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesReceiptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPurchasePaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasePaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSystemSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovalRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovalActionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalActionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssetsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssetDisposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetDisposalWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    rolePermissions: number
    userRoles: number
    ApprovalStep: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | RoleCountOutputTypeCountRolePermissionsArgs
    userRoles?: boolean | RoleCountOutputTypeCountUserRolesArgs
    ApprovalStep?: boolean | RoleCountOutputTypeCountApprovalStepArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountRolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountApprovalStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalStepWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    rolePermissions: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | PermissionCountOutputTypeCountRolePermissionsArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    warehouses: number
    assets: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouses?: boolean | LocationCountOutputTypeCountWarehousesArgs
    assets?: boolean | LocationCountOutputTypeCountAssetsArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountWarehousesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }


  /**
   * Count Type WarehouseCountOutputType
   */

  export type WarehouseCountOutputType = {
    bins: number
    inventoryBatches: number
    inventoryLedger: number
    productionOrders: number
  }

  export type WarehouseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bins?: boolean | WarehouseCountOutputTypeCountBinsArgs
    inventoryBatches?: boolean | WarehouseCountOutputTypeCountInventoryBatchesArgs
    inventoryLedger?: boolean | WarehouseCountOutputTypeCountInventoryLedgerArgs
    productionOrders?: boolean | WarehouseCountOutputTypeCountProductionOrdersArgs
  }

  // Custom InputTypes
  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseCountOutputType
     */
    select?: WarehouseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountBinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BinWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountInventoryBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryBatchWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountInventoryLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryLedgerWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountProductionOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionOrderWhereInput
  }


  /**
   * Count Type BinCountOutputType
   */

  export type BinCountOutputType = {
    inventoryBatches: number
  }

  export type BinCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryBatches?: boolean | BinCountOutputTypeCountInventoryBatchesArgs
  }

  // Custom InputTypes
  /**
   * BinCountOutputType without action
   */
  export type BinCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BinCountOutputType
     */
    select?: BinCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BinCountOutputType without action
   */
  export type BinCountOutputTypeCountInventoryBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryBatchWhereInput
  }


  /**
   * Count Type ItemCountOutputType
   */

  export type ItemCountOutputType = {
    boms: number
    bomLines: number
    inventoryBatches: number
    inventoryLedger: number
    productionOrders: number
    purchaseLines: number
    saleLines: number
  }

  export type ItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boms?: boolean | ItemCountOutputTypeCountBomsArgs
    bomLines?: boolean | ItemCountOutputTypeCountBomLinesArgs
    inventoryBatches?: boolean | ItemCountOutputTypeCountInventoryBatchesArgs
    inventoryLedger?: boolean | ItemCountOutputTypeCountInventoryLedgerArgs
    productionOrders?: boolean | ItemCountOutputTypeCountProductionOrdersArgs
    purchaseLines?: boolean | ItemCountOutputTypeCountPurchaseLinesArgs
    saleLines?: boolean | ItemCountOutputTypeCountSaleLinesArgs
  }

  // Custom InputTypes
  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     */
    select?: ItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountBomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BomWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountBomLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BomLineWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountInventoryBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryBatchWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountInventoryLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryLedgerWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountProductionOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionOrderWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountPurchaseLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseLineWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountSaleLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleLineWhereInput
  }


  /**
   * Count Type BomCountOutputType
   */

  export type BomCountOutputType = {
    bomLines: number
    productionOrders: number
  }

  export type BomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bomLines?: boolean | BomCountOutputTypeCountBomLinesArgs
    productionOrders?: boolean | BomCountOutputTypeCountProductionOrdersArgs
  }

  // Custom InputTypes
  /**
   * BomCountOutputType without action
   */
  export type BomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BomCountOutputType
     */
    select?: BomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BomCountOutputType without action
   */
  export type BomCountOutputTypeCountBomLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BomLineWhereInput
  }

  /**
   * BomCountOutputType without action
   */
  export type BomCountOutputTypeCountProductionOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionOrderWhereInput
  }


  /**
   * Count Type InventoryBatchCountOutputType
   */

  export type InventoryBatchCountOutputType = {
    inventoryLedger: number
  }

  export type InventoryBatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryLedger?: boolean | InventoryBatchCountOutputTypeCountInventoryLedgerArgs
  }

  // Custom InputTypes
  /**
   * InventoryBatchCountOutputType without action
   */
  export type InventoryBatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryBatchCountOutputType
     */
    select?: InventoryBatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryBatchCountOutputType without action
   */
  export type InventoryBatchCountOutputTypeCountInventoryLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryLedgerWhereInput
  }


  /**
   * Count Type ProductionOrderCountOutputType
   */

  export type ProductionOrderCountOutputType = {
    wipLedger: number
    laborTimes: number
  }

  export type ProductionOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wipLedger?: boolean | ProductionOrderCountOutputTypeCountWipLedgerArgs
    laborTimes?: boolean | ProductionOrderCountOutputTypeCountLaborTimesArgs
  }

  // Custom InputTypes
  /**
   * ProductionOrderCountOutputType without action
   */
  export type ProductionOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrderCountOutputType
     */
    select?: ProductionOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductionOrderCountOutputType without action
   */
  export type ProductionOrderCountOutputTypeCountWipLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WipLedgerWhereInput
  }

  /**
   * ProductionOrderCountOutputType without action
   */
  export type ProductionOrderCountOutputTypeCountLaborTimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaborTimeWhereInput
  }


  /**
   * Count Type VendorCountOutputType
   */

  export type VendorCountOutputType = {
    purchases: number
    purchasePayments: number
    assets: number
  }

  export type VendorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchases?: boolean | VendorCountOutputTypeCountPurchasesArgs
    purchasePayments?: boolean | VendorCountOutputTypeCountPurchasePaymentsArgs
    assets?: boolean | VendorCountOutputTypeCountAssetsArgs
  }

  // Custom InputTypes
  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCountOutputType
     */
    select?: VendorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountPurchasePaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasePaymentWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    sales: number
    salesReceipts: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | CustomerCountOutputTypeCountSalesArgs
    salesReceipts?: boolean | CustomerCountOutputTypeCountSalesReceiptsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSalesReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesReceiptWhereInput
  }


  /**
   * Count Type PurchaseCountOutputType
   */

  export type PurchaseCountOutputType = {
    purchaseLines: number
    purchasePayments: number
    assets: number
  }

  export type PurchaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseLines?: boolean | PurchaseCountOutputTypeCountPurchaseLinesArgs
    purchasePayments?: boolean | PurchaseCountOutputTypeCountPurchasePaymentsArgs
    assets?: boolean | PurchaseCountOutputTypeCountAssetsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseCountOutputType
     */
    select?: PurchaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeCountPurchaseLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseLineWhereInput
  }

  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeCountPurchasePaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasePaymentWhereInput
  }

  /**
   * PurchaseCountOutputType without action
   */
  export type PurchaseCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }


  /**
   * Count Type SaleCountOutputType
   */

  export type SaleCountOutputType = {
    saleLines: number
    salesReceipts: number
  }

  export type SaleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saleLines?: boolean | SaleCountOutputTypeCountSaleLinesArgs
    salesReceipts?: boolean | SaleCountOutputTypeCountSalesReceiptsArgs
  }

  // Custom InputTypes
  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleCountOutputType
     */
    select?: SaleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountSaleLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleLineWhereInput
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountSalesReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesReceiptWhereInput
  }


  /**
   * Count Type ChartOfAccountCountOutputType
   */

  export type ChartOfAccountCountOutputType = {
    children: number
    journalLines: number
    cashTransactionsGL: number
    cashTransactionsContra: number
    cashAccounts: number
    assetCategoriesAsset: number
    assetCategoriesDepreciation: number
    assetCategoriesAccumulated: number
  }

  export type ChartOfAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ChartOfAccountCountOutputTypeCountChildrenArgs
    journalLines?: boolean | ChartOfAccountCountOutputTypeCountJournalLinesArgs
    cashTransactionsGL?: boolean | ChartOfAccountCountOutputTypeCountCashTransactionsGLArgs
    cashTransactionsContra?: boolean | ChartOfAccountCountOutputTypeCountCashTransactionsContraArgs
    cashAccounts?: boolean | ChartOfAccountCountOutputTypeCountCashAccountsArgs
    assetCategoriesAsset?: boolean | ChartOfAccountCountOutputTypeCountAssetCategoriesAssetArgs
    assetCategoriesDepreciation?: boolean | ChartOfAccountCountOutputTypeCountAssetCategoriesDepreciationArgs
    assetCategoriesAccumulated?: boolean | ChartOfAccountCountOutputTypeCountAssetCategoriesAccumulatedArgs
  }

  // Custom InputTypes
  /**
   * ChartOfAccountCountOutputType without action
   */
  export type ChartOfAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccountCountOutputType
     */
    select?: ChartOfAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChartOfAccountCountOutputType without action
   */
  export type ChartOfAccountCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChartOfAccountWhereInput
  }

  /**
   * ChartOfAccountCountOutputType without action
   */
  export type ChartOfAccountCountOutputTypeCountJournalLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalLineWhereInput
  }

  /**
   * ChartOfAccountCountOutputType without action
   */
  export type ChartOfAccountCountOutputTypeCountCashTransactionsGLArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashTransactionWhereInput
  }

  /**
   * ChartOfAccountCountOutputType without action
   */
  export type ChartOfAccountCountOutputTypeCountCashTransactionsContraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashTransactionWhereInput
  }

  /**
   * ChartOfAccountCountOutputType without action
   */
  export type ChartOfAccountCountOutputTypeCountCashAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashAccountWhereInput
  }

  /**
   * ChartOfAccountCountOutputType without action
   */
  export type ChartOfAccountCountOutputTypeCountAssetCategoriesAssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetCategoryWhereInput
  }

  /**
   * ChartOfAccountCountOutputType without action
   */
  export type ChartOfAccountCountOutputTypeCountAssetCategoriesDepreciationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetCategoryWhereInput
  }

  /**
   * ChartOfAccountCountOutputType without action
   */
  export type ChartOfAccountCountOutputTypeCountAssetCategoriesAccumulatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetCategoryWhereInput
  }


  /**
   * Count Type JournalCountOutputType
   */

  export type JournalCountOutputType = {
    journalLines: number
    assetDepreciation: number
    assetDisposals: number
  }

  export type JournalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journalLines?: boolean | JournalCountOutputTypeCountJournalLinesArgs
    assetDepreciation?: boolean | JournalCountOutputTypeCountAssetDepreciationArgs
    assetDisposals?: boolean | JournalCountOutputTypeCountAssetDisposalsArgs
  }

  // Custom InputTypes
  /**
   * JournalCountOutputType without action
   */
  export type JournalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCountOutputType
     */
    select?: JournalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JournalCountOutputType without action
   */
  export type JournalCountOutputTypeCountJournalLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalLineWhereInput
  }

  /**
   * JournalCountOutputType without action
   */
  export type JournalCountOutputTypeCountAssetDepreciationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetDepreciationWhereInput
  }

  /**
   * JournalCountOutputType without action
   */
  export type JournalCountOutputTypeCountAssetDisposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetDisposalWhereInput
  }


  /**
   * Count Type CashAccountCountOutputType
   */

  export type CashAccountCountOutputType = {
    cashTransactions: number
    salesReceipts: number
    purchasePayments: number
  }

  export type CashAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cashTransactions?: boolean | CashAccountCountOutputTypeCountCashTransactionsArgs
    salesReceipts?: boolean | CashAccountCountOutputTypeCountSalesReceiptsArgs
    purchasePayments?: boolean | CashAccountCountOutputTypeCountPurchasePaymentsArgs
  }

  // Custom InputTypes
  /**
   * CashAccountCountOutputType without action
   */
  export type CashAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashAccountCountOutputType
     */
    select?: CashAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CashAccountCountOutputType without action
   */
  export type CashAccountCountOutputTypeCountCashTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashTransactionWhereInput
  }

  /**
   * CashAccountCountOutputType without action
   */
  export type CashAccountCountOutputTypeCountSalesReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesReceiptWhereInput
  }

  /**
   * CashAccountCountOutputType without action
   */
  export type CashAccountCountOutputTypeCountPurchasePaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasePaymentWhereInput
  }


  /**
   * Count Type FiscalYearCountOutputType
   */

  export type FiscalYearCountOutputType = {
    periods: number
  }

  export type FiscalYearCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    periods?: boolean | FiscalYearCountOutputTypeCountPeriodsArgs
  }

  // Custom InputTypes
  /**
   * FiscalYearCountOutputType without action
   */
  export type FiscalYearCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYearCountOutputType
     */
    select?: FiscalYearCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FiscalYearCountOutputType without action
   */
  export type FiscalYearCountOutputTypeCountPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FiscalPeriodWhereInput
  }


  /**
   * Count Type ApprovalWorkflowCountOutputType
   */

  export type ApprovalWorkflowCountOutputType = {
    steps: number
    ApprovalRequest: number
  }

  export type ApprovalWorkflowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | ApprovalWorkflowCountOutputTypeCountStepsArgs
    ApprovalRequest?: boolean | ApprovalWorkflowCountOutputTypeCountApprovalRequestArgs
  }

  // Custom InputTypes
  /**
   * ApprovalWorkflowCountOutputType without action
   */
  export type ApprovalWorkflowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflowCountOutputType
     */
    select?: ApprovalWorkflowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApprovalWorkflowCountOutputType without action
   */
  export type ApprovalWorkflowCountOutputTypeCountStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalStepWhereInput
  }

  /**
   * ApprovalWorkflowCountOutputType without action
   */
  export type ApprovalWorkflowCountOutputTypeCountApprovalRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalRequestWhereInput
  }


  /**
   * Count Type ApprovalStepCountOutputType
   */

  export type ApprovalStepCountOutputType = {
    ApprovalRequest: number
    ApprovalAction: number
  }

  export type ApprovalStepCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ApprovalRequest?: boolean | ApprovalStepCountOutputTypeCountApprovalRequestArgs
    ApprovalAction?: boolean | ApprovalStepCountOutputTypeCountApprovalActionArgs
  }

  // Custom InputTypes
  /**
   * ApprovalStepCountOutputType without action
   */
  export type ApprovalStepCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStepCountOutputType
     */
    select?: ApprovalStepCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApprovalStepCountOutputType without action
   */
  export type ApprovalStepCountOutputTypeCountApprovalRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalRequestWhereInput
  }

  /**
   * ApprovalStepCountOutputType without action
   */
  export type ApprovalStepCountOutputTypeCountApprovalActionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalActionWhereInput
  }


  /**
   * Count Type ApprovalRequestCountOutputType
   */

  export type ApprovalRequestCountOutputType = {
    actions: number
  }

  export type ApprovalRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actions?: boolean | ApprovalRequestCountOutputTypeCountActionsArgs
  }

  // Custom InputTypes
  /**
   * ApprovalRequestCountOutputType without action
   */
  export type ApprovalRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequestCountOutputType
     */
    select?: ApprovalRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApprovalRequestCountOutputType without action
   */
  export type ApprovalRequestCountOutputTypeCountActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalActionWhereInput
  }


  /**
   * Count Type AssetCategoryCountOutputType
   */

  export type AssetCategoryCountOutputType = {
    assets: number
  }

  export type AssetCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assets?: boolean | AssetCategoryCountOutputTypeCountAssetsArgs
  }

  // Custom InputTypes
  /**
   * AssetCategoryCountOutputType without action
   */
  export type AssetCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetCategoryCountOutputType
     */
    select?: AssetCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssetCategoryCountOutputType without action
   */
  export type AssetCategoryCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }


  /**
   * Count Type AssetCountOutputType
   */

  export type AssetCountOutputType = {
    depreciationEntries: number
    disposals: number
  }

  export type AssetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    depreciationEntries?: boolean | AssetCountOutputTypeCountDepreciationEntriesArgs
    disposals?: boolean | AssetCountOutputTypeCountDisposalsArgs
  }

  // Custom InputTypes
  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetCountOutputType
     */
    select?: AssetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountDepreciationEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetDepreciationWhereInput
  }

  /**
   * AssetCountOutputType without action
   */
  export type AssetCountOutputTypeCountDisposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetDisposalWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    status: string | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    status: string | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    status: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    status?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    status?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    status?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    password: string
    status: string
    lastLoginAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    status?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    journals?: boolean | User$journalsArgs<ExtArgs>
    inventoryLedger?: boolean | User$inventoryLedgerArgs<ExtArgs>
    cashTransactions?: boolean | User$cashTransactionsArgs<ExtArgs>
    salesReceipts?: boolean | User$salesReceiptsArgs<ExtArgs>
    purchasePayments?: boolean | User$purchasePaymentsArgs<ExtArgs>
    SystemSetting?: boolean | User$SystemSettingArgs<ExtArgs>
    ApprovalRequest?: boolean | User$ApprovalRequestArgs<ExtArgs>
    ApprovalAction?: boolean | User$ApprovalActionArgs<ExtArgs>
    assetsCreated?: boolean | User$assetsCreatedArgs<ExtArgs>
    assetDisposals?: boolean | User$assetDisposalsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    status?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    status?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    journals?: boolean | User$journalsArgs<ExtArgs>
    inventoryLedger?: boolean | User$inventoryLedgerArgs<ExtArgs>
    cashTransactions?: boolean | User$cashTransactionsArgs<ExtArgs>
    salesReceipts?: boolean | User$salesReceiptsArgs<ExtArgs>
    purchasePayments?: boolean | User$purchasePaymentsArgs<ExtArgs>
    SystemSetting?: boolean | User$SystemSettingArgs<ExtArgs>
    ApprovalRequest?: boolean | User$ApprovalRequestArgs<ExtArgs>
    ApprovalAction?: boolean | User$ApprovalActionArgs<ExtArgs>
    assetsCreated?: boolean | User$assetsCreatedArgs<ExtArgs>
    assetDisposals?: boolean | User$assetDisposalsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      journals: Prisma.$JournalPayload<ExtArgs>[]
      inventoryLedger: Prisma.$InventoryLedgerPayload<ExtArgs>[]
      cashTransactions: Prisma.$CashTransactionPayload<ExtArgs>[]
      salesReceipts: Prisma.$SalesReceiptPayload<ExtArgs>[]
      purchasePayments: Prisma.$PurchasePaymentPayload<ExtArgs>[]
      SystemSetting: Prisma.$SystemSettingPayload<ExtArgs>[]
      ApprovalRequest: Prisma.$ApprovalRequestPayload<ExtArgs>[]
      ApprovalAction: Prisma.$ApprovalActionPayload<ExtArgs>[]
      assetsCreated: Prisma.$AssetPayload<ExtArgs>[]
      assetDisposals: Prisma.$AssetDisposalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      password: string
      status: string
      lastLoginAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userRoles<T extends User$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, User$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    journals<T extends User$journalsArgs<ExtArgs> = {}>(args?: Subset<T, User$journalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findMany"> | Null>
    inventoryLedger<T extends User$inventoryLedgerArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryLedgerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "findMany"> | Null>
    cashTransactions<T extends User$cashTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$cashTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    salesReceipts<T extends User$salesReceiptsArgs<ExtArgs> = {}>(args?: Subset<T, User$salesReceiptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReceiptPayload<ExtArgs>, T, "findMany"> | Null>
    purchasePayments<T extends User$purchasePaymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$purchasePaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePaymentPayload<ExtArgs>, T, "findMany"> | Null>
    SystemSetting<T extends User$SystemSettingArgs<ExtArgs> = {}>(args?: Subset<T, User$SystemSettingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findMany"> | Null>
    ApprovalRequest<T extends User$ApprovalRequestArgs<ExtArgs> = {}>(args?: Subset<T, User$ApprovalRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findMany"> | Null>
    ApprovalAction<T extends User$ApprovalActionArgs<ExtArgs> = {}>(args?: Subset<T, User$ApprovalActionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "findMany"> | Null>
    assetsCreated<T extends User$assetsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$assetsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany"> | Null>
    assetDisposals<T extends User$assetDisposalsArgs<ExtArgs> = {}>(args?: Subset<T, User$assetDisposalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetDisposalPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'String'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.userRoles
   */
  export type User$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.journals
   */
  export type User$journalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    where?: JournalWhereInput
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    cursor?: JournalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalScalarFieldEnum | JournalScalarFieldEnum[]
  }

  /**
   * User.inventoryLedger
   */
  export type User$inventoryLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
    where?: InventoryLedgerWhereInput
    orderBy?: InventoryLedgerOrderByWithRelationInput | InventoryLedgerOrderByWithRelationInput[]
    cursor?: InventoryLedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryLedgerScalarFieldEnum | InventoryLedgerScalarFieldEnum[]
  }

  /**
   * User.cashTransactions
   */
  export type User$cashTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    where?: CashTransactionWhereInput
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    cursor?: CashTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashTransactionScalarFieldEnum | CashTransactionScalarFieldEnum[]
  }

  /**
   * User.salesReceipts
   */
  export type User$salesReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReceipt
     */
    select?: SalesReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReceiptInclude<ExtArgs> | null
    where?: SalesReceiptWhereInput
    orderBy?: SalesReceiptOrderByWithRelationInput | SalesReceiptOrderByWithRelationInput[]
    cursor?: SalesReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesReceiptScalarFieldEnum | SalesReceiptScalarFieldEnum[]
  }

  /**
   * User.purchasePayments
   */
  export type User$purchasePaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePayment
     */
    select?: PurchasePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePaymentInclude<ExtArgs> | null
    where?: PurchasePaymentWhereInput
    orderBy?: PurchasePaymentOrderByWithRelationInput | PurchasePaymentOrderByWithRelationInput[]
    cursor?: PurchasePaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasePaymentScalarFieldEnum | PurchasePaymentScalarFieldEnum[]
  }

  /**
   * User.SystemSetting
   */
  export type User$SystemSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    where?: SystemSettingWhereInput
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    cursor?: SystemSettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * User.ApprovalRequest
   */
  export type User$ApprovalRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    where?: ApprovalRequestWhereInput
    orderBy?: ApprovalRequestOrderByWithRelationInput | ApprovalRequestOrderByWithRelationInput[]
    cursor?: ApprovalRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalRequestScalarFieldEnum | ApprovalRequestScalarFieldEnum[]
  }

  /**
   * User.ApprovalAction
   */
  export type User$ApprovalActionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
    where?: ApprovalActionWhereInput
    orderBy?: ApprovalActionOrderByWithRelationInput | ApprovalActionOrderByWithRelationInput[]
    cursor?: ApprovalActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalActionScalarFieldEnum | ApprovalActionScalarFieldEnum[]
  }

  /**
   * User.assetsCreated
   */
  export type User$assetsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * User.assetDisposals
   */
  export type User$assetDisposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDisposal
     */
    select?: AssetDisposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDisposalInclude<ExtArgs> | null
    where?: AssetDisposalWhereInput
    orderBy?: AssetDisposalOrderByWithRelationInput | AssetDisposalOrderByWithRelationInput[]
    cursor?: AssetDisposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetDisposalScalarFieldEnum | AssetDisposalScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    rolePermissions?: boolean | Role$rolePermissionsArgs<ExtArgs>
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    ApprovalStep?: boolean | Role$ApprovalStepArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | Role$rolePermissionsArgs<ExtArgs>
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    ApprovalStep?: boolean | Role$ApprovalStepArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      rolePermissions: Prisma.$RolePermissionPayload<ExtArgs>[]
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
      ApprovalStep: Prisma.$ApprovalStepPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rolePermissions<T extends Role$rolePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$rolePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany"> | Null>
    userRoles<T extends Role$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, Role$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    ApprovalStep<T extends Role$ApprovalStepArgs<ExtArgs> = {}>(args?: Subset<T, Role$ApprovalStepArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }

  /**
   * Role.rolePermissions
   */
  export type Role$rolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Role.userRoles
   */
  export type Role$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role.ApprovalStep
   */
  export type Role$ApprovalStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepInclude<ExtArgs> | null
    where?: ApprovalStepWhereInput
    orderBy?: ApprovalStepOrderByWithRelationInput | ApprovalStepOrderByWithRelationInput[]
    cursor?: ApprovalStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalStepScalarFieldEnum | ApprovalStepScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    name: string | null
    resource: string | null
    action: string | null
    description: string | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    resource: string | null
    action: string | null
    description: string | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    name: number
    resource: number
    action: number
    description: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    name?: true
    resource?: true
    action?: true
    description?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    name?: true
    resource?: true
    action?: true
    description?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    name?: true
    resource?: true
    action?: true
    description?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    name: string
    resource: string
    action: string
    description: string | null
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    resource?: boolean
    action?: boolean
    description?: boolean
    rolePermissions?: boolean | Permission$rolePermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    resource?: boolean
    action?: boolean
    description?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    name?: boolean
    resource?: boolean
    action?: boolean
    description?: boolean
  }

  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | Permission$rolePermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      rolePermissions: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      resource: string
      action: string
      description: string | null
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rolePermissions<T extends Permission$rolePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */ 
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly resource: FieldRef<"Permission", 'String'>
    readonly action: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission.rolePermissions
   */
  export type Permission$rolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
  }

  export type UserRoleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
  }

  export type UserRoleCountAggregateOutputType = {
    id: number
    userId: number
    roleId: number
    _all: number
  }


  export type UserRoleMinAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
  }

  export type UserRoleMaxAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
  }

  export type UserRoleCountAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    id: string
    userId: string
    roleId: string
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    id?: boolean
    userId?: boolean
    roleId?: boolean
  }

  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      roleId: string
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRoleWithIdOnly = await prisma.userRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */ 
  interface UserRoleFieldRefs {
    readonly id: FieldRef<"UserRole", 'String'>
    readonly userId: FieldRef<"UserRole", 'String'>
    readonly roleId: FieldRef<"UserRole", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionMinAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
  }

  export type RolePermissionCountAggregateOutputType = {
    id: number
    roleId: number
    permissionId: number
    _all: number
  }


  export type RolePermissionMinAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionCountAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    id: string
    roleId: string
    permissionId: string
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectScalar = {
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
  }

  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roleId: string
      permissionId: string
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePermissions and returns the data saved in the database.
     * @param {RolePermissionCreateManyAndReturnArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePermissions and only return the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */ 
  interface RolePermissionFieldRefs {
    readonly id: FieldRef<"RolePermission", 'String'>
    readonly roleId: FieldRef<"RolePermission", 'String'>
    readonly permissionId: FieldRef<"RolePermission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermission createManyAndReturn
   */
  export type RolePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    baseCurrency: string | null
    timezone: string | null
    address: string | null
    phone: string | null
    email: string | null
    createdAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    baseCurrency: string | null
    timezone: string | null
    address: string | null
    phone: string | null
    email: string | null
    createdAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    baseCurrency: number
    timezone: number
    address: number
    phone: number
    email: number
    createdAt: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    baseCurrency?: true
    timezone?: true
    address?: true
    phone?: true
    email?: true
    createdAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    baseCurrency?: true
    timezone?: true
    address?: true
    phone?: true
    email?: true
    createdAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    baseCurrency?: true
    timezone?: true
    address?: true
    phone?: true
    email?: true
    createdAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    baseCurrency: string
    timezone: string
    address: string | null
    phone: string | null
    email: string | null
    createdAt: Date
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    baseCurrency?: boolean
    timezone?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    baseCurrency?: boolean
    timezone?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    baseCurrency?: boolean
    timezone?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    createdAt?: boolean
  }


  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      baseCurrency: string
      timezone: string
      address: string | null
      phone: string | null
      email: string | null
      createdAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */ 
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly baseCurrency: FieldRef<"Company", 'String'>
    readonly timezone: FieldRef<"Company", 'String'>
    readonly address: FieldRef<"Company", 'String'>
    readonly phone: FieldRef<"Company", 'String'>
    readonly email: FieldRef<"Company", 'String'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    code: number
    name: number
    address: number
    city: number
    state: number
    country: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type LocationMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    address?: true
    city?: true
    state?: true
    country?: true
    isActive?: true
    createdAt?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    address?: true
    city?: true
    state?: true
    country?: true
    isActive?: true
    createdAt?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    address?: true
    city?: true
    state?: true
    country?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    code: string
    name: string
    address: string | null
    city: string | null
    state: string | null
    country: string
    isActive: boolean
    createdAt: Date
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    isActive?: boolean
    createdAt?: boolean
    warehouses?: boolean | Location$warehousesArgs<ExtArgs>
    assets?: boolean | Location$assetsArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouses?: boolean | Location$warehousesArgs<ExtArgs>
    assets?: boolean | Location$assetsArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      warehouses: Prisma.$WarehousePayload<ExtArgs>[]
      assets: Prisma.$AssetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      address: string | null
      city: string | null
      state: string | null
      country: string
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    warehouses<T extends Location$warehousesArgs<ExtArgs> = {}>(args?: Subset<T, Location$warehousesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findMany"> | Null>
    assets<T extends Location$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Location$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */ 
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly code: FieldRef<"Location", 'String'>
    readonly name: FieldRef<"Location", 'String'>
    readonly address: FieldRef<"Location", 'String'>
    readonly city: FieldRef<"Location", 'String'>
    readonly state: FieldRef<"Location", 'String'>
    readonly country: FieldRef<"Location", 'String'>
    readonly isActive: FieldRef<"Location", 'Boolean'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
  }

  /**
   * Location.warehouses
   */
  export type Location$warehousesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    where?: WarehouseWhereInput
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    cursor?: WarehouseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Location.assets
   */
  export type Location$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Warehouse
   */

  export type AggregateWarehouse = {
    _count: WarehouseCountAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  export type WarehouseMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    locationId: string | null
    address: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type WarehouseMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    locationId: string | null
    address: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type WarehouseCountAggregateOutputType = {
    id: number
    code: number
    name: number
    locationId: number
    address: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type WarehouseMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    locationId?: true
    address?: true
    isActive?: true
    createdAt?: true
  }

  export type WarehouseMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    locationId?: true
    address?: true
    isActive?: true
    createdAt?: true
  }

  export type WarehouseCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    locationId?: true
    address?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type WarehouseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouse to aggregate.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Warehouses
    **/
    _count?: true | WarehouseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseMaxAggregateInputType
  }

  export type GetWarehouseAggregateType<T extends WarehouseAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouse[P]>
      : GetScalarType<T[P], AggregateWarehouse[P]>
  }




  export type WarehouseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseWhereInput
    orderBy?: WarehouseOrderByWithAggregationInput | WarehouseOrderByWithAggregationInput[]
    by: WarehouseScalarFieldEnum[] | WarehouseScalarFieldEnum
    having?: WarehouseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseCountAggregateInputType | true
    _min?: WarehouseMinAggregateInputType
    _max?: WarehouseMaxAggregateInputType
  }

  export type WarehouseGroupByOutputType = {
    id: string
    code: string
    name: string
    locationId: string
    address: string | null
    isActive: boolean
    createdAt: Date
    _count: WarehouseCountAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  type GetWarehouseGroupByPayload<T extends WarehouseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    locationId?: boolean
    address?: boolean
    isActive?: boolean
    createdAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    bins?: boolean | Warehouse$binsArgs<ExtArgs>
    inventoryBatches?: boolean | Warehouse$inventoryBatchesArgs<ExtArgs>
    inventoryLedger?: boolean | Warehouse$inventoryLedgerArgs<ExtArgs>
    productionOrders?: boolean | Warehouse$productionOrdersArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    locationId?: boolean
    address?: boolean
    isActive?: boolean
    createdAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    locationId?: boolean
    address?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type WarehouseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    bins?: boolean | Warehouse$binsArgs<ExtArgs>
    inventoryBatches?: boolean | Warehouse$inventoryBatchesArgs<ExtArgs>
    inventoryLedger?: boolean | Warehouse$inventoryLedgerArgs<ExtArgs>
    productionOrders?: boolean | Warehouse$productionOrdersArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WarehouseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $WarehousePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Warehouse"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
      bins: Prisma.$BinPayload<ExtArgs>[]
      inventoryBatches: Prisma.$InventoryBatchPayload<ExtArgs>[]
      inventoryLedger: Prisma.$InventoryLedgerPayload<ExtArgs>[]
      productionOrders: Prisma.$ProductionOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      locationId: string
      address: string | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["warehouse"]>
    composites: {}
  }

  type WarehouseGetPayload<S extends boolean | null | undefined | WarehouseDefaultArgs> = $Result.GetResult<Prisma.$WarehousePayload, S>

  type WarehouseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WarehouseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WarehouseCountAggregateInputType | true
    }

  export interface WarehouseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Warehouse'], meta: { name: 'Warehouse' } }
    /**
     * Find zero or one Warehouse that matches the filter.
     * @param {WarehouseFindUniqueArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarehouseFindUniqueArgs>(args: SelectSubset<T, WarehouseFindUniqueArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Warehouse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WarehouseFindUniqueOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarehouseFindUniqueOrThrowArgs>(args: SelectSubset<T, WarehouseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Warehouse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarehouseFindFirstArgs>(args?: SelectSubset<T, WarehouseFindFirstArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Warehouse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarehouseFindFirstOrThrowArgs>(args?: SelectSubset<T, WarehouseFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Warehouses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Warehouses
     * const warehouses = await prisma.warehouse.findMany()
     * 
     * // Get first 10 Warehouses
     * const warehouses = await prisma.warehouse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarehouseFindManyArgs>(args?: SelectSubset<T, WarehouseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Warehouse.
     * @param {WarehouseCreateArgs} args - Arguments to create a Warehouse.
     * @example
     * // Create one Warehouse
     * const Warehouse = await prisma.warehouse.create({
     *   data: {
     *     // ... data to create a Warehouse
     *   }
     * })
     * 
     */
    create<T extends WarehouseCreateArgs>(args: SelectSubset<T, WarehouseCreateArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Warehouses.
     * @param {WarehouseCreateManyArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarehouseCreateManyArgs>(args?: SelectSubset<T, WarehouseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Warehouses and returns the data saved in the database.
     * @param {WarehouseCreateManyAndReturnArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Warehouses and only return the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarehouseCreateManyAndReturnArgs>(args?: SelectSubset<T, WarehouseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Warehouse.
     * @param {WarehouseDeleteArgs} args - Arguments to delete one Warehouse.
     * @example
     * // Delete one Warehouse
     * const Warehouse = await prisma.warehouse.delete({
     *   where: {
     *     // ... filter to delete one Warehouse
     *   }
     * })
     * 
     */
    delete<T extends WarehouseDeleteArgs>(args: SelectSubset<T, WarehouseDeleteArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Warehouse.
     * @param {WarehouseUpdateArgs} args - Arguments to update one Warehouse.
     * @example
     * // Update one Warehouse
     * const warehouse = await prisma.warehouse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarehouseUpdateArgs>(args: SelectSubset<T, WarehouseUpdateArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Warehouses.
     * @param {WarehouseDeleteManyArgs} args - Arguments to filter Warehouses to delete.
     * @example
     * // Delete a few Warehouses
     * const { count } = await prisma.warehouse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarehouseDeleteManyArgs>(args?: SelectSubset<T, WarehouseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarehouseUpdateManyArgs>(args: SelectSubset<T, WarehouseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Warehouse.
     * @param {WarehouseUpsertArgs} args - Arguments to update or create a Warehouse.
     * @example
     * // Update or create a Warehouse
     * const warehouse = await prisma.warehouse.upsert({
     *   create: {
     *     // ... data to create a Warehouse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Warehouse we want to update
     *   }
     * })
     */
    upsert<T extends WarehouseUpsertArgs>(args: SelectSubset<T, WarehouseUpsertArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseCountArgs} args - Arguments to filter Warehouses to count.
     * @example
     * // Count the number of Warehouses
     * const count = await prisma.warehouse.count({
     *   where: {
     *     // ... the filter for the Warehouses we want to count
     *   }
     * })
    **/
    count<T extends WarehouseCountArgs>(
      args?: Subset<T, WarehouseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseAggregateArgs>(args: Subset<T, WarehouseAggregateArgs>): Prisma.PrismaPromise<GetWarehouseAggregateType<T>>

    /**
     * Group by Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Warehouse model
   */
  readonly fields: WarehouseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Warehouse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bins<T extends Warehouse$binsArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$binsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BinPayload<ExtArgs>, T, "findMany"> | Null>
    inventoryBatches<T extends Warehouse$inventoryBatchesArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$inventoryBatchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryBatchPayload<ExtArgs>, T, "findMany"> | Null>
    inventoryLedger<T extends Warehouse$inventoryLedgerArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$inventoryLedgerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "findMany"> | Null>
    productionOrders<T extends Warehouse$productionOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$productionOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Warehouse model
   */ 
  interface WarehouseFieldRefs {
    readonly id: FieldRef<"Warehouse", 'String'>
    readonly code: FieldRef<"Warehouse", 'String'>
    readonly name: FieldRef<"Warehouse", 'String'>
    readonly locationId: FieldRef<"Warehouse", 'String'>
    readonly address: FieldRef<"Warehouse", 'String'>
    readonly isActive: FieldRef<"Warehouse", 'Boolean'>
    readonly createdAt: FieldRef<"Warehouse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Warehouse findUnique
   */
  export type WarehouseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse findUniqueOrThrow
   */
  export type WarehouseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse findFirst
   */
  export type WarehouseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse findFirstOrThrow
   */
  export type WarehouseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse findMany
   */
  export type WarehouseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouses to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse create
   */
  export type WarehouseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The data needed to create a Warehouse.
     */
    data: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
  }

  /**
   * Warehouse createMany
   */
  export type WarehouseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Warehouses.
     */
    data: WarehouseCreateManyInput | WarehouseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Warehouse createManyAndReturn
   */
  export type WarehouseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Warehouses.
     */
    data: WarehouseCreateManyInput | WarehouseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Warehouse update
   */
  export type WarehouseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The data needed to update a Warehouse.
     */
    data: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
    /**
     * Choose, which Warehouse to update.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse updateMany
   */
  export type WarehouseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Warehouses.
     */
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyInput>
    /**
     * Filter which Warehouses to update
     */
    where?: WarehouseWhereInput
  }

  /**
   * Warehouse upsert
   */
  export type WarehouseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The filter to search for the Warehouse to update in case it exists.
     */
    where: WarehouseWhereUniqueInput
    /**
     * In case the Warehouse found by the `where` argument doesn't exist, create a new Warehouse with this data.
     */
    create: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
    /**
     * In case the Warehouse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
  }

  /**
   * Warehouse delete
   */
  export type WarehouseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter which Warehouse to delete.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse deleteMany
   */
  export type WarehouseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouses to delete
     */
    where?: WarehouseWhereInput
  }

  /**
   * Warehouse.bins
   */
  export type Warehouse$binsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bin
     */
    select?: BinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BinInclude<ExtArgs> | null
    where?: BinWhereInput
    orderBy?: BinOrderByWithRelationInput | BinOrderByWithRelationInput[]
    cursor?: BinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BinScalarFieldEnum | BinScalarFieldEnum[]
  }

  /**
   * Warehouse.inventoryBatches
   */
  export type Warehouse$inventoryBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryBatch
     */
    select?: InventoryBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryBatchInclude<ExtArgs> | null
    where?: InventoryBatchWhereInput
    orderBy?: InventoryBatchOrderByWithRelationInput | InventoryBatchOrderByWithRelationInput[]
    cursor?: InventoryBatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryBatchScalarFieldEnum | InventoryBatchScalarFieldEnum[]
  }

  /**
   * Warehouse.inventoryLedger
   */
  export type Warehouse$inventoryLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
    where?: InventoryLedgerWhereInput
    orderBy?: InventoryLedgerOrderByWithRelationInput | InventoryLedgerOrderByWithRelationInput[]
    cursor?: InventoryLedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryLedgerScalarFieldEnum | InventoryLedgerScalarFieldEnum[]
  }

  /**
   * Warehouse.productionOrders
   */
  export type Warehouse$productionOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOrderInclude<ExtArgs> | null
    where?: ProductionOrderWhereInput
    orderBy?: ProductionOrderOrderByWithRelationInput | ProductionOrderOrderByWithRelationInput[]
    cursor?: ProductionOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionOrderScalarFieldEnum | ProductionOrderScalarFieldEnum[]
  }

  /**
   * Warehouse without action
   */
  export type WarehouseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
  }


  /**
   * Model Bin
   */

  export type AggregateBin = {
    _count: BinCountAggregateOutputType | null
    _min: BinMinAggregateOutputType | null
    _max: BinMaxAggregateOutputType | null
  }

  export type BinMinAggregateOutputType = {
    id: string | null
    warehouseId: string | null
    code: string | null
    name: string | null
  }

  export type BinMaxAggregateOutputType = {
    id: string | null
    warehouseId: string | null
    code: string | null
    name: string | null
  }

  export type BinCountAggregateOutputType = {
    id: number
    warehouseId: number
    code: number
    name: number
    _all: number
  }


  export type BinMinAggregateInputType = {
    id?: true
    warehouseId?: true
    code?: true
    name?: true
  }

  export type BinMaxAggregateInputType = {
    id?: true
    warehouseId?: true
    code?: true
    name?: true
  }

  export type BinCountAggregateInputType = {
    id?: true
    warehouseId?: true
    code?: true
    name?: true
    _all?: true
  }

  export type BinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bin to aggregate.
     */
    where?: BinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bins to fetch.
     */
    orderBy?: BinOrderByWithRelationInput | BinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bins
    **/
    _count?: true | BinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BinMaxAggregateInputType
  }

  export type GetBinAggregateType<T extends BinAggregateArgs> = {
        [P in keyof T & keyof AggregateBin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBin[P]>
      : GetScalarType<T[P], AggregateBin[P]>
  }




  export type BinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BinWhereInput
    orderBy?: BinOrderByWithAggregationInput | BinOrderByWithAggregationInput[]
    by: BinScalarFieldEnum[] | BinScalarFieldEnum
    having?: BinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BinCountAggregateInputType | true
    _min?: BinMinAggregateInputType
    _max?: BinMaxAggregateInputType
  }

  export type BinGroupByOutputType = {
    id: string
    warehouseId: string
    code: string
    name: string | null
    _count: BinCountAggregateOutputType | null
    _min: BinMinAggregateOutputType | null
    _max: BinMaxAggregateOutputType | null
  }

  type GetBinGroupByPayload<T extends BinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BinGroupByOutputType[P]>
            : GetScalarType<T[P], BinGroupByOutputType[P]>
        }
      >
    >


  export type BinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    warehouseId?: boolean
    code?: boolean
    name?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    inventoryBatches?: boolean | Bin$inventoryBatchesArgs<ExtArgs>
    _count?: boolean | BinCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bin"]>

  export type BinSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    warehouseId?: boolean
    code?: boolean
    name?: boolean
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bin"]>

  export type BinSelectScalar = {
    id?: boolean
    warehouseId?: boolean
    code?: boolean
    name?: boolean
  }

  export type BinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    inventoryBatches?: boolean | Bin$inventoryBatchesArgs<ExtArgs>
    _count?: boolean | BinCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BinIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }

  export type $BinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bin"
    objects: {
      warehouse: Prisma.$WarehousePayload<ExtArgs>
      inventoryBatches: Prisma.$InventoryBatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      warehouseId: string
      code: string
      name: string | null
    }, ExtArgs["result"]["bin"]>
    composites: {}
  }

  type BinGetPayload<S extends boolean | null | undefined | BinDefaultArgs> = $Result.GetResult<Prisma.$BinPayload, S>

  type BinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BinFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BinCountAggregateInputType | true
    }

  export interface BinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bin'], meta: { name: 'Bin' } }
    /**
     * Find zero or one Bin that matches the filter.
     * @param {BinFindUniqueArgs} args - Arguments to find a Bin
     * @example
     * // Get one Bin
     * const bin = await prisma.bin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BinFindUniqueArgs>(args: SelectSubset<T, BinFindUniqueArgs<ExtArgs>>): Prisma__BinClient<$Result.GetResult<Prisma.$BinPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BinFindUniqueOrThrowArgs} args - Arguments to find a Bin
     * @example
     * // Get one Bin
     * const bin = await prisma.bin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BinFindUniqueOrThrowArgs>(args: SelectSubset<T, BinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BinClient<$Result.GetResult<Prisma.$BinPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinFindFirstArgs} args - Arguments to find a Bin
     * @example
     * // Get one Bin
     * const bin = await prisma.bin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BinFindFirstArgs>(args?: SelectSubset<T, BinFindFirstArgs<ExtArgs>>): Prisma__BinClient<$Result.GetResult<Prisma.$BinPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinFindFirstOrThrowArgs} args - Arguments to find a Bin
     * @example
     * // Get one Bin
     * const bin = await prisma.bin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BinFindFirstOrThrowArgs>(args?: SelectSubset<T, BinFindFirstOrThrowArgs<ExtArgs>>): Prisma__BinClient<$Result.GetResult<Prisma.$BinPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bins
     * const bins = await prisma.bin.findMany()
     * 
     * // Get first 10 Bins
     * const bins = await prisma.bin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const binWithIdOnly = await prisma.bin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BinFindManyArgs>(args?: SelectSubset<T, BinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BinPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bin.
     * @param {BinCreateArgs} args - Arguments to create a Bin.
     * @example
     * // Create one Bin
     * const Bin = await prisma.bin.create({
     *   data: {
     *     // ... data to create a Bin
     *   }
     * })
     * 
     */
    create<T extends BinCreateArgs>(args: SelectSubset<T, BinCreateArgs<ExtArgs>>): Prisma__BinClient<$Result.GetResult<Prisma.$BinPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bins.
     * @param {BinCreateManyArgs} args - Arguments to create many Bins.
     * @example
     * // Create many Bins
     * const bin = await prisma.bin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BinCreateManyArgs>(args?: SelectSubset<T, BinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bins and returns the data saved in the database.
     * @param {BinCreateManyAndReturnArgs} args - Arguments to create many Bins.
     * @example
     * // Create many Bins
     * const bin = await prisma.bin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bins and only return the `id`
     * const binWithIdOnly = await prisma.bin.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BinCreateManyAndReturnArgs>(args?: SelectSubset<T, BinCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BinPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bin.
     * @param {BinDeleteArgs} args - Arguments to delete one Bin.
     * @example
     * // Delete one Bin
     * const Bin = await prisma.bin.delete({
     *   where: {
     *     // ... filter to delete one Bin
     *   }
     * })
     * 
     */
    delete<T extends BinDeleteArgs>(args: SelectSubset<T, BinDeleteArgs<ExtArgs>>): Prisma__BinClient<$Result.GetResult<Prisma.$BinPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bin.
     * @param {BinUpdateArgs} args - Arguments to update one Bin.
     * @example
     * // Update one Bin
     * const bin = await prisma.bin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BinUpdateArgs>(args: SelectSubset<T, BinUpdateArgs<ExtArgs>>): Prisma__BinClient<$Result.GetResult<Prisma.$BinPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bins.
     * @param {BinDeleteManyArgs} args - Arguments to filter Bins to delete.
     * @example
     * // Delete a few Bins
     * const { count } = await prisma.bin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BinDeleteManyArgs>(args?: SelectSubset<T, BinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bins
     * const bin = await prisma.bin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BinUpdateManyArgs>(args: SelectSubset<T, BinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bin.
     * @param {BinUpsertArgs} args - Arguments to update or create a Bin.
     * @example
     * // Update or create a Bin
     * const bin = await prisma.bin.upsert({
     *   create: {
     *     // ... data to create a Bin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bin we want to update
     *   }
     * })
     */
    upsert<T extends BinUpsertArgs>(args: SelectSubset<T, BinUpsertArgs<ExtArgs>>): Prisma__BinClient<$Result.GetResult<Prisma.$BinPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinCountArgs} args - Arguments to filter Bins to count.
     * @example
     * // Count the number of Bins
     * const count = await prisma.bin.count({
     *   where: {
     *     // ... the filter for the Bins we want to count
     *   }
     * })
    **/
    count<T extends BinCountArgs>(
      args?: Subset<T, BinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BinAggregateArgs>(args: Subset<T, BinAggregateArgs>): Prisma.PrismaPromise<GetBinAggregateType<T>>

    /**
     * Group by Bin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BinGroupByArgs['orderBy'] }
        : { orderBy?: BinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bin model
   */
  readonly fields: BinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    inventoryBatches<T extends Bin$inventoryBatchesArgs<ExtArgs> = {}>(args?: Subset<T, Bin$inventoryBatchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryBatchPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bin model
   */ 
  interface BinFieldRefs {
    readonly id: FieldRef<"Bin", 'String'>
    readonly warehouseId: FieldRef<"Bin", 'String'>
    readonly code: FieldRef<"Bin", 'String'>
    readonly name: FieldRef<"Bin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Bin findUnique
   */
  export type BinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bin
     */
    select?: BinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BinInclude<ExtArgs> | null
    /**
     * Filter, which Bin to fetch.
     */
    where: BinWhereUniqueInput
  }

  /**
   * Bin findUniqueOrThrow
   */
  export type BinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bin
     */
    select?: BinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BinInclude<ExtArgs> | null
    /**
     * Filter, which Bin to fetch.
     */
    where: BinWhereUniqueInput
  }

  /**
   * Bin findFirst
   */
  export type BinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bin
     */
    select?: BinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BinInclude<ExtArgs> | null
    /**
     * Filter, which Bin to fetch.
     */
    where?: BinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bins to fetch.
     */
    orderBy?: BinOrderByWithRelationInput | BinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bins.
     */
    cursor?: BinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bins.
     */
    distinct?: BinScalarFieldEnum | BinScalarFieldEnum[]
  }

  /**
   * Bin findFirstOrThrow
   */
  export type BinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bin
     */
    select?: BinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BinInclude<ExtArgs> | null
    /**
     * Filter, which Bin to fetch.
     */
    where?: BinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bins to fetch.
     */
    orderBy?: BinOrderByWithRelationInput | BinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bins.
     */
    cursor?: BinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bins.
     */
    distinct?: BinScalarFieldEnum | BinScalarFieldEnum[]
  }

  /**
   * Bin findMany
   */
  export type BinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bin
     */
    select?: BinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BinInclude<ExtArgs> | null
    /**
     * Filter, which Bins to fetch.
     */
    where?: BinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bins to fetch.
     */
    orderBy?: BinOrderByWithRelationInput | BinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bins.
     */
    cursor?: BinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bins.
     */
    skip?: number
    distinct?: BinScalarFieldEnum | BinScalarFieldEnum[]
  }

  /**
   * Bin create
   */
  export type BinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bin
     */
    select?: BinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BinInclude<ExtArgs> | null
    /**
     * The data needed to create a Bin.
     */
    data: XOR<BinCreateInput, BinUncheckedCreateInput>
  }

  /**
   * Bin createMany
   */
  export type BinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bins.
     */
    data: BinCreateManyInput | BinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bin createManyAndReturn
   */
  export type BinCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bin
     */
    select?: BinSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bins.
     */
    data: BinCreateManyInput | BinCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BinIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bin update
   */
  export type BinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bin
     */
    select?: BinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BinInclude<ExtArgs> | null
    /**
     * The data needed to update a Bin.
     */
    data: XOR<BinUpdateInput, BinUncheckedUpdateInput>
    /**
     * Choose, which Bin to update.
     */
    where: BinWhereUniqueInput
  }

  /**
   * Bin updateMany
   */
  export type BinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bins.
     */
    data: XOR<BinUpdateManyMutationInput, BinUncheckedUpdateManyInput>
    /**
     * Filter which Bins to update
     */
    where?: BinWhereInput
  }

  /**
   * Bin upsert
   */
  export type BinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bin
     */
    select?: BinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BinInclude<ExtArgs> | null
    /**
     * The filter to search for the Bin to update in case it exists.
     */
    where: BinWhereUniqueInput
    /**
     * In case the Bin found by the `where` argument doesn't exist, create a new Bin with this data.
     */
    create: XOR<BinCreateInput, BinUncheckedCreateInput>
    /**
     * In case the Bin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BinUpdateInput, BinUncheckedUpdateInput>
  }

  /**
   * Bin delete
   */
  export type BinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bin
     */
    select?: BinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BinInclude<ExtArgs> | null
    /**
     * Filter which Bin to delete.
     */
    where: BinWhereUniqueInput
  }

  /**
   * Bin deleteMany
   */
  export type BinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bins to delete
     */
    where?: BinWhereInput
  }

  /**
   * Bin.inventoryBatches
   */
  export type Bin$inventoryBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryBatch
     */
    select?: InventoryBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryBatchInclude<ExtArgs> | null
    where?: InventoryBatchWhereInput
    orderBy?: InventoryBatchOrderByWithRelationInput | InventoryBatchOrderByWithRelationInput[]
    cursor?: InventoryBatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryBatchScalarFieldEnum | InventoryBatchScalarFieldEnum[]
  }

  /**
   * Bin without action
   */
  export type BinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bin
     */
    select?: BinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BinInclude<ExtArgs> | null
  }


  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    standardCost: Decimal | null
    sellingPriceOrdinary: Decimal | null
    sellingPriceBulk: Decimal | null
    sellingPriceWIC: Decimal | null
  }

  export type ItemSumAggregateOutputType = {
    standardCost: Decimal | null
    sellingPriceOrdinary: Decimal | null
    sellingPriceBulk: Decimal | null
    sellingPriceWIC: Decimal | null
  }

  export type ItemMinAggregateOutputType = {
    id: string | null
    sku: string | null
    name: string | null
    description: string | null
    type: $Enums.ItemType | null
    uom: string | null
    costingMethod: $Enums.CostingMethod | null
    standardCost: Decimal | null
    sellingPriceOrdinary: Decimal | null
    sellingPriceBulk: Decimal | null
    sellingPriceWIC: Decimal | null
    taxCode: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemMaxAggregateOutputType = {
    id: string | null
    sku: string | null
    name: string | null
    description: string | null
    type: $Enums.ItemType | null
    uom: string | null
    costingMethod: $Enums.CostingMethod | null
    standardCost: Decimal | null
    sellingPriceOrdinary: Decimal | null
    sellingPriceBulk: Decimal | null
    sellingPriceWIC: Decimal | null
    taxCode: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    sku: number
    name: number
    description: number
    type: number
    uom: number
    costingMethod: number
    standardCost: number
    sellingPriceOrdinary: number
    sellingPriceBulk: number
    sellingPriceWIC: number
    taxCode: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    standardCost?: true
    sellingPriceOrdinary?: true
    sellingPriceBulk?: true
    sellingPriceWIC?: true
  }

  export type ItemSumAggregateInputType = {
    standardCost?: true
    sellingPriceOrdinary?: true
    sellingPriceBulk?: true
    sellingPriceWIC?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    type?: true
    uom?: true
    costingMethod?: true
    standardCost?: true
    sellingPriceOrdinary?: true
    sellingPriceBulk?: true
    sellingPriceWIC?: true
    taxCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    type?: true
    uom?: true
    costingMethod?: true
    standardCost?: true
    sellingPriceOrdinary?: true
    sellingPriceBulk?: true
    sellingPriceWIC?: true
    taxCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    sku?: true
    name?: true
    description?: true
    type?: true
    uom?: true
    costingMethod?: true
    standardCost?: true
    sellingPriceOrdinary?: true
    sellingPriceBulk?: true
    sellingPriceWIC?: true
    taxCode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    id: string
    sku: string
    name: string
    description: string | null
    type: $Enums.ItemType
    uom: string
    costingMethod: $Enums.CostingMethod
    standardCost: Decimal | null
    sellingPriceOrdinary: Decimal | null
    sellingPriceBulk: Decimal | null
    sellingPriceWIC: Decimal | null
    taxCode: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    uom?: boolean
    costingMethod?: boolean
    standardCost?: boolean
    sellingPriceOrdinary?: boolean
    sellingPriceBulk?: boolean
    sellingPriceWIC?: boolean
    taxCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    boms?: boolean | Item$bomsArgs<ExtArgs>
    bomLines?: boolean | Item$bomLinesArgs<ExtArgs>
    inventoryBatches?: boolean | Item$inventoryBatchesArgs<ExtArgs>
    inventoryLedger?: boolean | Item$inventoryLedgerArgs<ExtArgs>
    productionOrders?: boolean | Item$productionOrdersArgs<ExtArgs>
    purchaseLines?: boolean | Item$purchaseLinesArgs<ExtArgs>
    saleLines?: boolean | Item$saleLinesArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    uom?: boolean
    costingMethod?: boolean
    standardCost?: boolean
    sellingPriceOrdinary?: boolean
    sellingPriceBulk?: boolean
    sellingPriceWIC?: boolean
    taxCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["item"]>

  export type ItemSelectScalar = {
    id?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    uom?: boolean
    costingMethod?: boolean
    standardCost?: boolean
    sellingPriceOrdinary?: boolean
    sellingPriceBulk?: boolean
    sellingPriceWIC?: boolean
    taxCode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boms?: boolean | Item$bomsArgs<ExtArgs>
    bomLines?: boolean | Item$bomLinesArgs<ExtArgs>
    inventoryBatches?: boolean | Item$inventoryBatchesArgs<ExtArgs>
    inventoryLedger?: boolean | Item$inventoryLedgerArgs<ExtArgs>
    productionOrders?: boolean | Item$productionOrdersArgs<ExtArgs>
    purchaseLines?: boolean | Item$purchaseLinesArgs<ExtArgs>
    saleLines?: boolean | Item$saleLinesArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {
      boms: Prisma.$BomPayload<ExtArgs>[]
      bomLines: Prisma.$BomLinePayload<ExtArgs>[]
      inventoryBatches: Prisma.$InventoryBatchPayload<ExtArgs>[]
      inventoryLedger: Prisma.$InventoryLedgerPayload<ExtArgs>[]
      productionOrders: Prisma.$ProductionOrderPayload<ExtArgs>[]
      purchaseLines: Prisma.$PurchaseLinePayload<ExtArgs>[]
      saleLines: Prisma.$SaleLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sku: string
      name: string
      description: string | null
      type: $Enums.ItemType
      uom: string
      costingMethod: $Enums.CostingMethod
      standardCost: Prisma.Decimal | null
      sellingPriceOrdinary: Prisma.Decimal | null
      sellingPriceBulk: Prisma.Decimal | null
      sellingPriceWIC: Prisma.Decimal | null
      taxCode: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["item"]>
    composites: {}
  }

  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemFindUniqueArgs>(args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Item that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemFindFirstArgs>(args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemFindManyArgs>(args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
     */
    create<T extends ItemCreateArgs>(args: SelectSubset<T, ItemCreateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Items.
     * @param {ItemCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCreateManyArgs>(args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Items and returns the data saved in the database.
     * @param {ItemCreateManyAndReturnArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
     */
    delete<T extends ItemDeleteArgs>(args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemUpdateArgs>(args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemDeleteManyArgs>(args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemUpdateManyArgs>(args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
     */
    upsert<T extends ItemUpsertArgs>(args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    boms<T extends Item$bomsArgs<ExtArgs> = {}>(args?: Subset<T, Item$bomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BomPayload<ExtArgs>, T, "findMany"> | Null>
    bomLines<T extends Item$bomLinesArgs<ExtArgs> = {}>(args?: Subset<T, Item$bomLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BomLinePayload<ExtArgs>, T, "findMany"> | Null>
    inventoryBatches<T extends Item$inventoryBatchesArgs<ExtArgs> = {}>(args?: Subset<T, Item$inventoryBatchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryBatchPayload<ExtArgs>, T, "findMany"> | Null>
    inventoryLedger<T extends Item$inventoryLedgerArgs<ExtArgs> = {}>(args?: Subset<T, Item$inventoryLedgerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "findMany"> | Null>
    productionOrders<T extends Item$productionOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Item$productionOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "findMany"> | Null>
    purchaseLines<T extends Item$purchaseLinesArgs<ExtArgs> = {}>(args?: Subset<T, Item$purchaseLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "findMany"> | Null>
    saleLines<T extends Item$saleLinesArgs<ExtArgs> = {}>(args?: Subset<T, Item$saleLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleLinePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Item model
   */ 
  interface ItemFieldRefs {
    readonly id: FieldRef<"Item", 'String'>
    readonly sku: FieldRef<"Item", 'String'>
    readonly name: FieldRef<"Item", 'String'>
    readonly description: FieldRef<"Item", 'String'>
    readonly type: FieldRef<"Item", 'ItemType'>
    readonly uom: FieldRef<"Item", 'String'>
    readonly costingMethod: FieldRef<"Item", 'CostingMethod'>
    readonly standardCost: FieldRef<"Item", 'Decimal'>
    readonly sellingPriceOrdinary: FieldRef<"Item", 'Decimal'>
    readonly sellingPriceBulk: FieldRef<"Item", 'Decimal'>
    readonly sellingPriceWIC: FieldRef<"Item", 'Decimal'>
    readonly taxCode: FieldRef<"Item", 'String'>
    readonly isActive: FieldRef<"Item", 'Boolean'>
    readonly createdAt: FieldRef<"Item", 'DateTime'>
    readonly updatedAt: FieldRef<"Item", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }

  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item createManyAndReturn
   */
  export type ItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
  }

  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }

  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
  }

  /**
   * Item.boms
   */
  export type Item$bomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bom
     */
    select?: BomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomInclude<ExtArgs> | null
    where?: BomWhereInput
    orderBy?: BomOrderByWithRelationInput | BomOrderByWithRelationInput[]
    cursor?: BomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BomScalarFieldEnum | BomScalarFieldEnum[]
  }

  /**
   * Item.bomLines
   */
  export type Item$bomLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BomLine
     */
    select?: BomLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomLineInclude<ExtArgs> | null
    where?: BomLineWhereInput
    orderBy?: BomLineOrderByWithRelationInput | BomLineOrderByWithRelationInput[]
    cursor?: BomLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BomLineScalarFieldEnum | BomLineScalarFieldEnum[]
  }

  /**
   * Item.inventoryBatches
   */
  export type Item$inventoryBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryBatch
     */
    select?: InventoryBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryBatchInclude<ExtArgs> | null
    where?: InventoryBatchWhereInput
    orderBy?: InventoryBatchOrderByWithRelationInput | InventoryBatchOrderByWithRelationInput[]
    cursor?: InventoryBatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryBatchScalarFieldEnum | InventoryBatchScalarFieldEnum[]
  }

  /**
   * Item.inventoryLedger
   */
  export type Item$inventoryLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
    where?: InventoryLedgerWhereInput
    orderBy?: InventoryLedgerOrderByWithRelationInput | InventoryLedgerOrderByWithRelationInput[]
    cursor?: InventoryLedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryLedgerScalarFieldEnum | InventoryLedgerScalarFieldEnum[]
  }

  /**
   * Item.productionOrders
   */
  export type Item$productionOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOrderInclude<ExtArgs> | null
    where?: ProductionOrderWhereInput
    orderBy?: ProductionOrderOrderByWithRelationInput | ProductionOrderOrderByWithRelationInput[]
    cursor?: ProductionOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionOrderScalarFieldEnum | ProductionOrderScalarFieldEnum[]
  }

  /**
   * Item.purchaseLines
   */
  export type Item$purchaseLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineInclude<ExtArgs> | null
    where?: PurchaseLineWhereInput
    orderBy?: PurchaseLineOrderByWithRelationInput | PurchaseLineOrderByWithRelationInput[]
    cursor?: PurchaseLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseLineScalarFieldEnum | PurchaseLineScalarFieldEnum[]
  }

  /**
   * Item.saleLines
   */
  export type Item$saleLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleLine
     */
    select?: SaleLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleLineInclude<ExtArgs> | null
    where?: SaleLineWhereInput
    orderBy?: SaleLineOrderByWithRelationInput | SaleLineOrderByWithRelationInput[]
    cursor?: SaleLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleLineScalarFieldEnum | SaleLineScalarFieldEnum[]
  }

  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
  }


  /**
   * Model Bom
   */

  export type AggregateBom = {
    _count: BomCountAggregateOutputType | null
    _min: BomMinAggregateOutputType | null
    _max: BomMaxAggregateOutputType | null
  }

  export type BomMinAggregateOutputType = {
    id: string | null
    itemId: string | null
    version: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BomMaxAggregateOutputType = {
    id: string | null
    itemId: string | null
    version: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BomCountAggregateOutputType = {
    id: number
    itemId: number
    version: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BomMinAggregateInputType = {
    id?: true
    itemId?: true
    version?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BomMaxAggregateInputType = {
    id?: true
    itemId?: true
    version?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BomCountAggregateInputType = {
    id?: true
    itemId?: true
    version?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bom to aggregate.
     */
    where?: BomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boms to fetch.
     */
    orderBy?: BomOrderByWithRelationInput | BomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Boms
    **/
    _count?: true | BomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BomMaxAggregateInputType
  }

  export type GetBomAggregateType<T extends BomAggregateArgs> = {
        [P in keyof T & keyof AggregateBom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBom[P]>
      : GetScalarType<T[P], AggregateBom[P]>
  }




  export type BomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BomWhereInput
    orderBy?: BomOrderByWithAggregationInput | BomOrderByWithAggregationInput[]
    by: BomScalarFieldEnum[] | BomScalarFieldEnum
    having?: BomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BomCountAggregateInputType | true
    _min?: BomMinAggregateInputType
    _max?: BomMaxAggregateInputType
  }

  export type BomGroupByOutputType = {
    id: string
    itemId: string
    version: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BomCountAggregateOutputType | null
    _min: BomMinAggregateOutputType | null
    _max: BomMaxAggregateOutputType | null
  }

  type GetBomGroupByPayload<T extends BomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BomGroupByOutputType[P]>
            : GetScalarType<T[P], BomGroupByOutputType[P]>
        }
      >
    >


  export type BomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    version?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    bomLines?: boolean | Bom$bomLinesArgs<ExtArgs>
    productionOrders?: boolean | Bom$productionOrdersArgs<ExtArgs>
    _count?: boolean | BomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bom"]>

  export type BomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    version?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bom"]>

  export type BomSelectScalar = {
    id?: boolean
    itemId?: boolean
    version?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    bomLines?: boolean | Bom$bomLinesArgs<ExtArgs>
    productionOrders?: boolean | Bom$productionOrdersArgs<ExtArgs>
    _count?: boolean | BomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $BomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bom"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
      bomLines: Prisma.$BomLinePayload<ExtArgs>[]
      productionOrders: Prisma.$ProductionOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      itemId: string
      version: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bom"]>
    composites: {}
  }

  type BomGetPayload<S extends boolean | null | undefined | BomDefaultArgs> = $Result.GetResult<Prisma.$BomPayload, S>

  type BomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BomCountAggregateInputType | true
    }

  export interface BomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bom'], meta: { name: 'Bom' } }
    /**
     * Find zero or one Bom that matches the filter.
     * @param {BomFindUniqueArgs} args - Arguments to find a Bom
     * @example
     * // Get one Bom
     * const bom = await prisma.bom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BomFindUniqueArgs>(args: SelectSubset<T, BomFindUniqueArgs<ExtArgs>>): Prisma__BomClient<$Result.GetResult<Prisma.$BomPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bom that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BomFindUniqueOrThrowArgs} args - Arguments to find a Bom
     * @example
     * // Get one Bom
     * const bom = await prisma.bom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BomFindUniqueOrThrowArgs>(args: SelectSubset<T, BomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BomClient<$Result.GetResult<Prisma.$BomPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BomFindFirstArgs} args - Arguments to find a Bom
     * @example
     * // Get one Bom
     * const bom = await prisma.bom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BomFindFirstArgs>(args?: SelectSubset<T, BomFindFirstArgs<ExtArgs>>): Prisma__BomClient<$Result.GetResult<Prisma.$BomPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BomFindFirstOrThrowArgs} args - Arguments to find a Bom
     * @example
     * // Get one Bom
     * const bom = await prisma.bom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BomFindFirstOrThrowArgs>(args?: SelectSubset<T, BomFindFirstOrThrowArgs<ExtArgs>>): Prisma__BomClient<$Result.GetResult<Prisma.$BomPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Boms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Boms
     * const boms = await prisma.bom.findMany()
     * 
     * // Get first 10 Boms
     * const boms = await prisma.bom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bomWithIdOnly = await prisma.bom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BomFindManyArgs>(args?: SelectSubset<T, BomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BomPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bom.
     * @param {BomCreateArgs} args - Arguments to create a Bom.
     * @example
     * // Create one Bom
     * const Bom = await prisma.bom.create({
     *   data: {
     *     // ... data to create a Bom
     *   }
     * })
     * 
     */
    create<T extends BomCreateArgs>(args: SelectSubset<T, BomCreateArgs<ExtArgs>>): Prisma__BomClient<$Result.GetResult<Prisma.$BomPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Boms.
     * @param {BomCreateManyArgs} args - Arguments to create many Boms.
     * @example
     * // Create many Boms
     * const bom = await prisma.bom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BomCreateManyArgs>(args?: SelectSubset<T, BomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Boms and returns the data saved in the database.
     * @param {BomCreateManyAndReturnArgs} args - Arguments to create many Boms.
     * @example
     * // Create many Boms
     * const bom = await prisma.bom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Boms and only return the `id`
     * const bomWithIdOnly = await prisma.bom.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BomCreateManyAndReturnArgs>(args?: SelectSubset<T, BomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BomPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bom.
     * @param {BomDeleteArgs} args - Arguments to delete one Bom.
     * @example
     * // Delete one Bom
     * const Bom = await prisma.bom.delete({
     *   where: {
     *     // ... filter to delete one Bom
     *   }
     * })
     * 
     */
    delete<T extends BomDeleteArgs>(args: SelectSubset<T, BomDeleteArgs<ExtArgs>>): Prisma__BomClient<$Result.GetResult<Prisma.$BomPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bom.
     * @param {BomUpdateArgs} args - Arguments to update one Bom.
     * @example
     * // Update one Bom
     * const bom = await prisma.bom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BomUpdateArgs>(args: SelectSubset<T, BomUpdateArgs<ExtArgs>>): Prisma__BomClient<$Result.GetResult<Prisma.$BomPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Boms.
     * @param {BomDeleteManyArgs} args - Arguments to filter Boms to delete.
     * @example
     * // Delete a few Boms
     * const { count } = await prisma.bom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BomDeleteManyArgs>(args?: SelectSubset<T, BomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Boms
     * const bom = await prisma.bom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BomUpdateManyArgs>(args: SelectSubset<T, BomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bom.
     * @param {BomUpsertArgs} args - Arguments to update or create a Bom.
     * @example
     * // Update or create a Bom
     * const bom = await prisma.bom.upsert({
     *   create: {
     *     // ... data to create a Bom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bom we want to update
     *   }
     * })
     */
    upsert<T extends BomUpsertArgs>(args: SelectSubset<T, BomUpsertArgs<ExtArgs>>): Prisma__BomClient<$Result.GetResult<Prisma.$BomPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Boms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BomCountArgs} args - Arguments to filter Boms to count.
     * @example
     * // Count the number of Boms
     * const count = await prisma.bom.count({
     *   where: {
     *     // ... the filter for the Boms we want to count
     *   }
     * })
    **/
    count<T extends BomCountArgs>(
      args?: Subset<T, BomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BomAggregateArgs>(args: Subset<T, BomAggregateArgs>): Prisma.PrismaPromise<GetBomAggregateType<T>>

    /**
     * Group by Bom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BomGroupByArgs['orderBy'] }
        : { orderBy?: BomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bom model
   */
  readonly fields: BomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bomLines<T extends Bom$bomLinesArgs<ExtArgs> = {}>(args?: Subset<T, Bom$bomLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BomLinePayload<ExtArgs>, T, "findMany"> | Null>
    productionOrders<T extends Bom$productionOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Bom$productionOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bom model
   */ 
  interface BomFieldRefs {
    readonly id: FieldRef<"Bom", 'String'>
    readonly itemId: FieldRef<"Bom", 'String'>
    readonly version: FieldRef<"Bom", 'String'>
    readonly isActive: FieldRef<"Bom", 'Boolean'>
    readonly createdAt: FieldRef<"Bom", 'DateTime'>
    readonly updatedAt: FieldRef<"Bom", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bom findUnique
   */
  export type BomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bom
     */
    select?: BomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomInclude<ExtArgs> | null
    /**
     * Filter, which Bom to fetch.
     */
    where: BomWhereUniqueInput
  }

  /**
   * Bom findUniqueOrThrow
   */
  export type BomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bom
     */
    select?: BomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomInclude<ExtArgs> | null
    /**
     * Filter, which Bom to fetch.
     */
    where: BomWhereUniqueInput
  }

  /**
   * Bom findFirst
   */
  export type BomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bom
     */
    select?: BomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomInclude<ExtArgs> | null
    /**
     * Filter, which Bom to fetch.
     */
    where?: BomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boms to fetch.
     */
    orderBy?: BomOrderByWithRelationInput | BomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Boms.
     */
    cursor?: BomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Boms.
     */
    distinct?: BomScalarFieldEnum | BomScalarFieldEnum[]
  }

  /**
   * Bom findFirstOrThrow
   */
  export type BomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bom
     */
    select?: BomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomInclude<ExtArgs> | null
    /**
     * Filter, which Bom to fetch.
     */
    where?: BomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boms to fetch.
     */
    orderBy?: BomOrderByWithRelationInput | BomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Boms.
     */
    cursor?: BomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Boms.
     */
    distinct?: BomScalarFieldEnum | BomScalarFieldEnum[]
  }

  /**
   * Bom findMany
   */
  export type BomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bom
     */
    select?: BomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomInclude<ExtArgs> | null
    /**
     * Filter, which Boms to fetch.
     */
    where?: BomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boms to fetch.
     */
    orderBy?: BomOrderByWithRelationInput | BomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Boms.
     */
    cursor?: BomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boms.
     */
    skip?: number
    distinct?: BomScalarFieldEnum | BomScalarFieldEnum[]
  }

  /**
   * Bom create
   */
  export type BomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bom
     */
    select?: BomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomInclude<ExtArgs> | null
    /**
     * The data needed to create a Bom.
     */
    data: XOR<BomCreateInput, BomUncheckedCreateInput>
  }

  /**
   * Bom createMany
   */
  export type BomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Boms.
     */
    data: BomCreateManyInput | BomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bom createManyAndReturn
   */
  export type BomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bom
     */
    select?: BomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Boms.
     */
    data: BomCreateManyInput | BomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bom update
   */
  export type BomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bom
     */
    select?: BomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomInclude<ExtArgs> | null
    /**
     * The data needed to update a Bom.
     */
    data: XOR<BomUpdateInput, BomUncheckedUpdateInput>
    /**
     * Choose, which Bom to update.
     */
    where: BomWhereUniqueInput
  }

  /**
   * Bom updateMany
   */
  export type BomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Boms.
     */
    data: XOR<BomUpdateManyMutationInput, BomUncheckedUpdateManyInput>
    /**
     * Filter which Boms to update
     */
    where?: BomWhereInput
  }

  /**
   * Bom upsert
   */
  export type BomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bom
     */
    select?: BomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomInclude<ExtArgs> | null
    /**
     * The filter to search for the Bom to update in case it exists.
     */
    where: BomWhereUniqueInput
    /**
     * In case the Bom found by the `where` argument doesn't exist, create a new Bom with this data.
     */
    create: XOR<BomCreateInput, BomUncheckedCreateInput>
    /**
     * In case the Bom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BomUpdateInput, BomUncheckedUpdateInput>
  }

  /**
   * Bom delete
   */
  export type BomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bom
     */
    select?: BomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomInclude<ExtArgs> | null
    /**
     * Filter which Bom to delete.
     */
    where: BomWhereUniqueInput
  }

  /**
   * Bom deleteMany
   */
  export type BomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Boms to delete
     */
    where?: BomWhereInput
  }

  /**
   * Bom.bomLines
   */
  export type Bom$bomLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BomLine
     */
    select?: BomLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomLineInclude<ExtArgs> | null
    where?: BomLineWhereInput
    orderBy?: BomLineOrderByWithRelationInput | BomLineOrderByWithRelationInput[]
    cursor?: BomLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BomLineScalarFieldEnum | BomLineScalarFieldEnum[]
  }

  /**
   * Bom.productionOrders
   */
  export type Bom$productionOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOrderInclude<ExtArgs> | null
    where?: ProductionOrderWhereInput
    orderBy?: ProductionOrderOrderByWithRelationInput | ProductionOrderOrderByWithRelationInput[]
    cursor?: ProductionOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionOrderScalarFieldEnum | ProductionOrderScalarFieldEnum[]
  }

  /**
   * Bom without action
   */
  export type BomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bom
     */
    select?: BomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomInclude<ExtArgs> | null
  }


  /**
   * Model BomLine
   */

  export type AggregateBomLine = {
    _count: BomLineCountAggregateOutputType | null
    _avg: BomLineAvgAggregateOutputType | null
    _sum: BomLineSumAggregateOutputType | null
    _min: BomLineMinAggregateOutputType | null
    _max: BomLineMaxAggregateOutputType | null
  }

  export type BomLineAvgAggregateOutputType = {
    qtyPer: Decimal | null
    scrapPercent: Decimal | null
  }

  export type BomLineSumAggregateOutputType = {
    qtyPer: Decimal | null
    scrapPercent: Decimal | null
  }

  export type BomLineMinAggregateOutputType = {
    id: string | null
    bomId: string | null
    componentItemId: string | null
    qtyPer: Decimal | null
    scrapPercent: Decimal | null
  }

  export type BomLineMaxAggregateOutputType = {
    id: string | null
    bomId: string | null
    componentItemId: string | null
    qtyPer: Decimal | null
    scrapPercent: Decimal | null
  }

  export type BomLineCountAggregateOutputType = {
    id: number
    bomId: number
    componentItemId: number
    qtyPer: number
    scrapPercent: number
    _all: number
  }


  export type BomLineAvgAggregateInputType = {
    qtyPer?: true
    scrapPercent?: true
  }

  export type BomLineSumAggregateInputType = {
    qtyPer?: true
    scrapPercent?: true
  }

  export type BomLineMinAggregateInputType = {
    id?: true
    bomId?: true
    componentItemId?: true
    qtyPer?: true
    scrapPercent?: true
  }

  export type BomLineMaxAggregateInputType = {
    id?: true
    bomId?: true
    componentItemId?: true
    qtyPer?: true
    scrapPercent?: true
  }

  export type BomLineCountAggregateInputType = {
    id?: true
    bomId?: true
    componentItemId?: true
    qtyPer?: true
    scrapPercent?: true
    _all?: true
  }

  export type BomLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BomLine to aggregate.
     */
    where?: BomLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BomLines to fetch.
     */
    orderBy?: BomLineOrderByWithRelationInput | BomLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BomLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BomLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BomLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BomLines
    **/
    _count?: true | BomLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BomLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BomLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BomLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BomLineMaxAggregateInputType
  }

  export type GetBomLineAggregateType<T extends BomLineAggregateArgs> = {
        [P in keyof T & keyof AggregateBomLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBomLine[P]>
      : GetScalarType<T[P], AggregateBomLine[P]>
  }




  export type BomLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BomLineWhereInput
    orderBy?: BomLineOrderByWithAggregationInput | BomLineOrderByWithAggregationInput[]
    by: BomLineScalarFieldEnum[] | BomLineScalarFieldEnum
    having?: BomLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BomLineCountAggregateInputType | true
    _avg?: BomLineAvgAggregateInputType
    _sum?: BomLineSumAggregateInputType
    _min?: BomLineMinAggregateInputType
    _max?: BomLineMaxAggregateInputType
  }

  export type BomLineGroupByOutputType = {
    id: string
    bomId: string
    componentItemId: string
    qtyPer: Decimal
    scrapPercent: Decimal
    _count: BomLineCountAggregateOutputType | null
    _avg: BomLineAvgAggregateOutputType | null
    _sum: BomLineSumAggregateOutputType | null
    _min: BomLineMinAggregateOutputType | null
    _max: BomLineMaxAggregateOutputType | null
  }

  type GetBomLineGroupByPayload<T extends BomLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BomLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BomLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BomLineGroupByOutputType[P]>
            : GetScalarType<T[P], BomLineGroupByOutputType[P]>
        }
      >
    >


  export type BomLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bomId?: boolean
    componentItemId?: boolean
    qtyPer?: boolean
    scrapPercent?: boolean
    bom?: boolean | BomDefaultArgs<ExtArgs>
    componentItem?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bomLine"]>

  export type BomLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bomId?: boolean
    componentItemId?: boolean
    qtyPer?: boolean
    scrapPercent?: boolean
    bom?: boolean | BomDefaultArgs<ExtArgs>
    componentItem?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bomLine"]>

  export type BomLineSelectScalar = {
    id?: boolean
    bomId?: boolean
    componentItemId?: boolean
    qtyPer?: boolean
    scrapPercent?: boolean
  }

  export type BomLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bom?: boolean | BomDefaultArgs<ExtArgs>
    componentItem?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type BomLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bom?: boolean | BomDefaultArgs<ExtArgs>
    componentItem?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $BomLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BomLine"
    objects: {
      bom: Prisma.$BomPayload<ExtArgs>
      componentItem: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bomId: string
      componentItemId: string
      qtyPer: Prisma.Decimal
      scrapPercent: Prisma.Decimal
    }, ExtArgs["result"]["bomLine"]>
    composites: {}
  }

  type BomLineGetPayload<S extends boolean | null | undefined | BomLineDefaultArgs> = $Result.GetResult<Prisma.$BomLinePayload, S>

  type BomLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BomLineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BomLineCountAggregateInputType | true
    }

  export interface BomLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BomLine'], meta: { name: 'BomLine' } }
    /**
     * Find zero or one BomLine that matches the filter.
     * @param {BomLineFindUniqueArgs} args - Arguments to find a BomLine
     * @example
     * // Get one BomLine
     * const bomLine = await prisma.bomLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BomLineFindUniqueArgs>(args: SelectSubset<T, BomLineFindUniqueArgs<ExtArgs>>): Prisma__BomLineClient<$Result.GetResult<Prisma.$BomLinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BomLine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BomLineFindUniqueOrThrowArgs} args - Arguments to find a BomLine
     * @example
     * // Get one BomLine
     * const bomLine = await prisma.bomLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BomLineFindUniqueOrThrowArgs>(args: SelectSubset<T, BomLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BomLineClient<$Result.GetResult<Prisma.$BomLinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BomLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BomLineFindFirstArgs} args - Arguments to find a BomLine
     * @example
     * // Get one BomLine
     * const bomLine = await prisma.bomLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BomLineFindFirstArgs>(args?: SelectSubset<T, BomLineFindFirstArgs<ExtArgs>>): Prisma__BomLineClient<$Result.GetResult<Prisma.$BomLinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BomLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BomLineFindFirstOrThrowArgs} args - Arguments to find a BomLine
     * @example
     * // Get one BomLine
     * const bomLine = await prisma.bomLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BomLineFindFirstOrThrowArgs>(args?: SelectSubset<T, BomLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__BomLineClient<$Result.GetResult<Prisma.$BomLinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BomLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BomLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BomLines
     * const bomLines = await prisma.bomLine.findMany()
     * 
     * // Get first 10 BomLines
     * const bomLines = await prisma.bomLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bomLineWithIdOnly = await prisma.bomLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BomLineFindManyArgs>(args?: SelectSubset<T, BomLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BomLinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BomLine.
     * @param {BomLineCreateArgs} args - Arguments to create a BomLine.
     * @example
     * // Create one BomLine
     * const BomLine = await prisma.bomLine.create({
     *   data: {
     *     // ... data to create a BomLine
     *   }
     * })
     * 
     */
    create<T extends BomLineCreateArgs>(args: SelectSubset<T, BomLineCreateArgs<ExtArgs>>): Prisma__BomLineClient<$Result.GetResult<Prisma.$BomLinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BomLines.
     * @param {BomLineCreateManyArgs} args - Arguments to create many BomLines.
     * @example
     * // Create many BomLines
     * const bomLine = await prisma.bomLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BomLineCreateManyArgs>(args?: SelectSubset<T, BomLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BomLines and returns the data saved in the database.
     * @param {BomLineCreateManyAndReturnArgs} args - Arguments to create many BomLines.
     * @example
     * // Create many BomLines
     * const bomLine = await prisma.bomLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BomLines and only return the `id`
     * const bomLineWithIdOnly = await prisma.bomLine.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BomLineCreateManyAndReturnArgs>(args?: SelectSubset<T, BomLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BomLinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BomLine.
     * @param {BomLineDeleteArgs} args - Arguments to delete one BomLine.
     * @example
     * // Delete one BomLine
     * const BomLine = await prisma.bomLine.delete({
     *   where: {
     *     // ... filter to delete one BomLine
     *   }
     * })
     * 
     */
    delete<T extends BomLineDeleteArgs>(args: SelectSubset<T, BomLineDeleteArgs<ExtArgs>>): Prisma__BomLineClient<$Result.GetResult<Prisma.$BomLinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BomLine.
     * @param {BomLineUpdateArgs} args - Arguments to update one BomLine.
     * @example
     * // Update one BomLine
     * const bomLine = await prisma.bomLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BomLineUpdateArgs>(args: SelectSubset<T, BomLineUpdateArgs<ExtArgs>>): Prisma__BomLineClient<$Result.GetResult<Prisma.$BomLinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BomLines.
     * @param {BomLineDeleteManyArgs} args - Arguments to filter BomLines to delete.
     * @example
     * // Delete a few BomLines
     * const { count } = await prisma.bomLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BomLineDeleteManyArgs>(args?: SelectSubset<T, BomLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BomLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BomLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BomLines
     * const bomLine = await prisma.bomLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BomLineUpdateManyArgs>(args: SelectSubset<T, BomLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BomLine.
     * @param {BomLineUpsertArgs} args - Arguments to update or create a BomLine.
     * @example
     * // Update or create a BomLine
     * const bomLine = await prisma.bomLine.upsert({
     *   create: {
     *     // ... data to create a BomLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BomLine we want to update
     *   }
     * })
     */
    upsert<T extends BomLineUpsertArgs>(args: SelectSubset<T, BomLineUpsertArgs<ExtArgs>>): Prisma__BomLineClient<$Result.GetResult<Prisma.$BomLinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BomLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BomLineCountArgs} args - Arguments to filter BomLines to count.
     * @example
     * // Count the number of BomLines
     * const count = await prisma.bomLine.count({
     *   where: {
     *     // ... the filter for the BomLines we want to count
     *   }
     * })
    **/
    count<T extends BomLineCountArgs>(
      args?: Subset<T, BomLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BomLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BomLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BomLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BomLineAggregateArgs>(args: Subset<T, BomLineAggregateArgs>): Prisma.PrismaPromise<GetBomLineAggregateType<T>>

    /**
     * Group by BomLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BomLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BomLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BomLineGroupByArgs['orderBy'] }
        : { orderBy?: BomLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BomLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBomLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BomLine model
   */
  readonly fields: BomLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BomLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BomLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bom<T extends BomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BomDefaultArgs<ExtArgs>>): Prisma__BomClient<$Result.GetResult<Prisma.$BomPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    componentItem<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BomLine model
   */ 
  interface BomLineFieldRefs {
    readonly id: FieldRef<"BomLine", 'String'>
    readonly bomId: FieldRef<"BomLine", 'String'>
    readonly componentItemId: FieldRef<"BomLine", 'String'>
    readonly qtyPer: FieldRef<"BomLine", 'Decimal'>
    readonly scrapPercent: FieldRef<"BomLine", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * BomLine findUnique
   */
  export type BomLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BomLine
     */
    select?: BomLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomLineInclude<ExtArgs> | null
    /**
     * Filter, which BomLine to fetch.
     */
    where: BomLineWhereUniqueInput
  }

  /**
   * BomLine findUniqueOrThrow
   */
  export type BomLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BomLine
     */
    select?: BomLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomLineInclude<ExtArgs> | null
    /**
     * Filter, which BomLine to fetch.
     */
    where: BomLineWhereUniqueInput
  }

  /**
   * BomLine findFirst
   */
  export type BomLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BomLine
     */
    select?: BomLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomLineInclude<ExtArgs> | null
    /**
     * Filter, which BomLine to fetch.
     */
    where?: BomLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BomLines to fetch.
     */
    orderBy?: BomLineOrderByWithRelationInput | BomLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BomLines.
     */
    cursor?: BomLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BomLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BomLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BomLines.
     */
    distinct?: BomLineScalarFieldEnum | BomLineScalarFieldEnum[]
  }

  /**
   * BomLine findFirstOrThrow
   */
  export type BomLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BomLine
     */
    select?: BomLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomLineInclude<ExtArgs> | null
    /**
     * Filter, which BomLine to fetch.
     */
    where?: BomLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BomLines to fetch.
     */
    orderBy?: BomLineOrderByWithRelationInput | BomLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BomLines.
     */
    cursor?: BomLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BomLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BomLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BomLines.
     */
    distinct?: BomLineScalarFieldEnum | BomLineScalarFieldEnum[]
  }

  /**
   * BomLine findMany
   */
  export type BomLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BomLine
     */
    select?: BomLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomLineInclude<ExtArgs> | null
    /**
     * Filter, which BomLines to fetch.
     */
    where?: BomLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BomLines to fetch.
     */
    orderBy?: BomLineOrderByWithRelationInput | BomLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BomLines.
     */
    cursor?: BomLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BomLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BomLines.
     */
    skip?: number
    distinct?: BomLineScalarFieldEnum | BomLineScalarFieldEnum[]
  }

  /**
   * BomLine create
   */
  export type BomLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BomLine
     */
    select?: BomLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomLineInclude<ExtArgs> | null
    /**
     * The data needed to create a BomLine.
     */
    data: XOR<BomLineCreateInput, BomLineUncheckedCreateInput>
  }

  /**
   * BomLine createMany
   */
  export type BomLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BomLines.
     */
    data: BomLineCreateManyInput | BomLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BomLine createManyAndReturn
   */
  export type BomLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BomLine
     */
    select?: BomLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BomLines.
     */
    data: BomLineCreateManyInput | BomLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BomLine update
   */
  export type BomLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BomLine
     */
    select?: BomLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomLineInclude<ExtArgs> | null
    /**
     * The data needed to update a BomLine.
     */
    data: XOR<BomLineUpdateInput, BomLineUncheckedUpdateInput>
    /**
     * Choose, which BomLine to update.
     */
    where: BomLineWhereUniqueInput
  }

  /**
   * BomLine updateMany
   */
  export type BomLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BomLines.
     */
    data: XOR<BomLineUpdateManyMutationInput, BomLineUncheckedUpdateManyInput>
    /**
     * Filter which BomLines to update
     */
    where?: BomLineWhereInput
  }

  /**
   * BomLine upsert
   */
  export type BomLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BomLine
     */
    select?: BomLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomLineInclude<ExtArgs> | null
    /**
     * The filter to search for the BomLine to update in case it exists.
     */
    where: BomLineWhereUniqueInput
    /**
     * In case the BomLine found by the `where` argument doesn't exist, create a new BomLine with this data.
     */
    create: XOR<BomLineCreateInput, BomLineUncheckedCreateInput>
    /**
     * In case the BomLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BomLineUpdateInput, BomLineUncheckedUpdateInput>
  }

  /**
   * BomLine delete
   */
  export type BomLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BomLine
     */
    select?: BomLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomLineInclude<ExtArgs> | null
    /**
     * Filter which BomLine to delete.
     */
    where: BomLineWhereUniqueInput
  }

  /**
   * BomLine deleteMany
   */
  export type BomLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BomLines to delete
     */
    where?: BomLineWhereInput
  }

  /**
   * BomLine without action
   */
  export type BomLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BomLine
     */
    select?: BomLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomLineInclude<ExtArgs> | null
  }


  /**
   * Model InventoryBatch
   */

  export type AggregateInventoryBatch = {
    _count: InventoryBatchCountAggregateOutputType | null
    _avg: InventoryBatchAvgAggregateOutputType | null
    _sum: InventoryBatchSumAggregateOutputType | null
    _min: InventoryBatchMinAggregateOutputType | null
    _max: InventoryBatchMaxAggregateOutputType | null
  }

  export type InventoryBatchAvgAggregateOutputType = {
    qtyOnHand: Decimal | null
    unitCost: Decimal | null
  }

  export type InventoryBatchSumAggregateOutputType = {
    qtyOnHand: Decimal | null
    unitCost: Decimal | null
  }

  export type InventoryBatchMinAggregateOutputType = {
    id: string | null
    itemId: string | null
    warehouseId: string | null
    binId: string | null
    qtyOnHand: Decimal | null
    unitCost: Decimal | null
    receivedAt: Date | null
  }

  export type InventoryBatchMaxAggregateOutputType = {
    id: string | null
    itemId: string | null
    warehouseId: string | null
    binId: string | null
    qtyOnHand: Decimal | null
    unitCost: Decimal | null
    receivedAt: Date | null
  }

  export type InventoryBatchCountAggregateOutputType = {
    id: number
    itemId: number
    warehouseId: number
    binId: number
    qtyOnHand: number
    unitCost: number
    receivedAt: number
    _all: number
  }


  export type InventoryBatchAvgAggregateInputType = {
    qtyOnHand?: true
    unitCost?: true
  }

  export type InventoryBatchSumAggregateInputType = {
    qtyOnHand?: true
    unitCost?: true
  }

  export type InventoryBatchMinAggregateInputType = {
    id?: true
    itemId?: true
    warehouseId?: true
    binId?: true
    qtyOnHand?: true
    unitCost?: true
    receivedAt?: true
  }

  export type InventoryBatchMaxAggregateInputType = {
    id?: true
    itemId?: true
    warehouseId?: true
    binId?: true
    qtyOnHand?: true
    unitCost?: true
    receivedAt?: true
  }

  export type InventoryBatchCountAggregateInputType = {
    id?: true
    itemId?: true
    warehouseId?: true
    binId?: true
    qtyOnHand?: true
    unitCost?: true
    receivedAt?: true
    _all?: true
  }

  export type InventoryBatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryBatch to aggregate.
     */
    where?: InventoryBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryBatches to fetch.
     */
    orderBy?: InventoryBatchOrderByWithRelationInput | InventoryBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryBatches
    **/
    _count?: true | InventoryBatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryBatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryBatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryBatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryBatchMaxAggregateInputType
  }

  export type GetInventoryBatchAggregateType<T extends InventoryBatchAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryBatch[P]>
      : GetScalarType<T[P], AggregateInventoryBatch[P]>
  }




  export type InventoryBatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryBatchWhereInput
    orderBy?: InventoryBatchOrderByWithAggregationInput | InventoryBatchOrderByWithAggregationInput[]
    by: InventoryBatchScalarFieldEnum[] | InventoryBatchScalarFieldEnum
    having?: InventoryBatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryBatchCountAggregateInputType | true
    _avg?: InventoryBatchAvgAggregateInputType
    _sum?: InventoryBatchSumAggregateInputType
    _min?: InventoryBatchMinAggregateInputType
    _max?: InventoryBatchMaxAggregateInputType
  }

  export type InventoryBatchGroupByOutputType = {
    id: string
    itemId: string
    warehouseId: string
    binId: string | null
    qtyOnHand: Decimal
    unitCost: Decimal
    receivedAt: Date
    _count: InventoryBatchCountAggregateOutputType | null
    _avg: InventoryBatchAvgAggregateOutputType | null
    _sum: InventoryBatchSumAggregateOutputType | null
    _min: InventoryBatchMinAggregateOutputType | null
    _max: InventoryBatchMaxAggregateOutputType | null
  }

  type GetInventoryBatchGroupByPayload<T extends InventoryBatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryBatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryBatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryBatchGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryBatchGroupByOutputType[P]>
        }
      >
    >


  export type InventoryBatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    warehouseId?: boolean
    binId?: boolean
    qtyOnHand?: boolean
    unitCost?: boolean
    receivedAt?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    bin?: boolean | InventoryBatch$binArgs<ExtArgs>
    inventoryLedger?: boolean | InventoryBatch$inventoryLedgerArgs<ExtArgs>
    _count?: boolean | InventoryBatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryBatch"]>

  export type InventoryBatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    warehouseId?: boolean
    binId?: boolean
    qtyOnHand?: boolean
    unitCost?: boolean
    receivedAt?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    bin?: boolean | InventoryBatch$binArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryBatch"]>

  export type InventoryBatchSelectScalar = {
    id?: boolean
    itemId?: boolean
    warehouseId?: boolean
    binId?: boolean
    qtyOnHand?: boolean
    unitCost?: boolean
    receivedAt?: boolean
  }

  export type InventoryBatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    bin?: boolean | InventoryBatch$binArgs<ExtArgs>
    inventoryLedger?: boolean | InventoryBatch$inventoryLedgerArgs<ExtArgs>
    _count?: boolean | InventoryBatchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InventoryBatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    bin?: boolean | InventoryBatch$binArgs<ExtArgs>
  }

  export type $InventoryBatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryBatch"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
      warehouse: Prisma.$WarehousePayload<ExtArgs>
      bin: Prisma.$BinPayload<ExtArgs> | null
      inventoryLedger: Prisma.$InventoryLedgerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      itemId: string
      warehouseId: string
      binId: string | null
      qtyOnHand: Prisma.Decimal
      unitCost: Prisma.Decimal
      receivedAt: Date
    }, ExtArgs["result"]["inventoryBatch"]>
    composites: {}
  }

  type InventoryBatchGetPayload<S extends boolean | null | undefined | InventoryBatchDefaultArgs> = $Result.GetResult<Prisma.$InventoryBatchPayload, S>

  type InventoryBatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryBatchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventoryBatchCountAggregateInputType | true
    }

  export interface InventoryBatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryBatch'], meta: { name: 'InventoryBatch' } }
    /**
     * Find zero or one InventoryBatch that matches the filter.
     * @param {InventoryBatchFindUniqueArgs} args - Arguments to find a InventoryBatch
     * @example
     * // Get one InventoryBatch
     * const inventoryBatch = await prisma.inventoryBatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryBatchFindUniqueArgs>(args: SelectSubset<T, InventoryBatchFindUniqueArgs<ExtArgs>>): Prisma__InventoryBatchClient<$Result.GetResult<Prisma.$InventoryBatchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InventoryBatch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InventoryBatchFindUniqueOrThrowArgs} args - Arguments to find a InventoryBatch
     * @example
     * // Get one InventoryBatch
     * const inventoryBatch = await prisma.inventoryBatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryBatchFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryBatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryBatchClient<$Result.GetResult<Prisma.$InventoryBatchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InventoryBatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryBatchFindFirstArgs} args - Arguments to find a InventoryBatch
     * @example
     * // Get one InventoryBatch
     * const inventoryBatch = await prisma.inventoryBatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryBatchFindFirstArgs>(args?: SelectSubset<T, InventoryBatchFindFirstArgs<ExtArgs>>): Prisma__InventoryBatchClient<$Result.GetResult<Prisma.$InventoryBatchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InventoryBatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryBatchFindFirstOrThrowArgs} args - Arguments to find a InventoryBatch
     * @example
     * // Get one InventoryBatch
     * const inventoryBatch = await prisma.inventoryBatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryBatchFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryBatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryBatchClient<$Result.GetResult<Prisma.$InventoryBatchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InventoryBatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryBatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryBatches
     * const inventoryBatches = await prisma.inventoryBatch.findMany()
     * 
     * // Get first 10 InventoryBatches
     * const inventoryBatches = await prisma.inventoryBatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryBatchWithIdOnly = await prisma.inventoryBatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryBatchFindManyArgs>(args?: SelectSubset<T, InventoryBatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryBatchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InventoryBatch.
     * @param {InventoryBatchCreateArgs} args - Arguments to create a InventoryBatch.
     * @example
     * // Create one InventoryBatch
     * const InventoryBatch = await prisma.inventoryBatch.create({
     *   data: {
     *     // ... data to create a InventoryBatch
     *   }
     * })
     * 
     */
    create<T extends InventoryBatchCreateArgs>(args: SelectSubset<T, InventoryBatchCreateArgs<ExtArgs>>): Prisma__InventoryBatchClient<$Result.GetResult<Prisma.$InventoryBatchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InventoryBatches.
     * @param {InventoryBatchCreateManyArgs} args - Arguments to create many InventoryBatches.
     * @example
     * // Create many InventoryBatches
     * const inventoryBatch = await prisma.inventoryBatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryBatchCreateManyArgs>(args?: SelectSubset<T, InventoryBatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryBatches and returns the data saved in the database.
     * @param {InventoryBatchCreateManyAndReturnArgs} args - Arguments to create many InventoryBatches.
     * @example
     * // Create many InventoryBatches
     * const inventoryBatch = await prisma.inventoryBatch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryBatches and only return the `id`
     * const inventoryBatchWithIdOnly = await prisma.inventoryBatch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryBatchCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryBatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryBatchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InventoryBatch.
     * @param {InventoryBatchDeleteArgs} args - Arguments to delete one InventoryBatch.
     * @example
     * // Delete one InventoryBatch
     * const InventoryBatch = await prisma.inventoryBatch.delete({
     *   where: {
     *     // ... filter to delete one InventoryBatch
     *   }
     * })
     * 
     */
    delete<T extends InventoryBatchDeleteArgs>(args: SelectSubset<T, InventoryBatchDeleteArgs<ExtArgs>>): Prisma__InventoryBatchClient<$Result.GetResult<Prisma.$InventoryBatchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InventoryBatch.
     * @param {InventoryBatchUpdateArgs} args - Arguments to update one InventoryBatch.
     * @example
     * // Update one InventoryBatch
     * const inventoryBatch = await prisma.inventoryBatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryBatchUpdateArgs>(args: SelectSubset<T, InventoryBatchUpdateArgs<ExtArgs>>): Prisma__InventoryBatchClient<$Result.GetResult<Prisma.$InventoryBatchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InventoryBatches.
     * @param {InventoryBatchDeleteManyArgs} args - Arguments to filter InventoryBatches to delete.
     * @example
     * // Delete a few InventoryBatches
     * const { count } = await prisma.inventoryBatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryBatchDeleteManyArgs>(args?: SelectSubset<T, InventoryBatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryBatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryBatches
     * const inventoryBatch = await prisma.inventoryBatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryBatchUpdateManyArgs>(args: SelectSubset<T, InventoryBatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryBatch.
     * @param {InventoryBatchUpsertArgs} args - Arguments to update or create a InventoryBatch.
     * @example
     * // Update or create a InventoryBatch
     * const inventoryBatch = await prisma.inventoryBatch.upsert({
     *   create: {
     *     // ... data to create a InventoryBatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryBatch we want to update
     *   }
     * })
     */
    upsert<T extends InventoryBatchUpsertArgs>(args: SelectSubset<T, InventoryBatchUpsertArgs<ExtArgs>>): Prisma__InventoryBatchClient<$Result.GetResult<Prisma.$InventoryBatchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InventoryBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryBatchCountArgs} args - Arguments to filter InventoryBatches to count.
     * @example
     * // Count the number of InventoryBatches
     * const count = await prisma.inventoryBatch.count({
     *   where: {
     *     // ... the filter for the InventoryBatches we want to count
     *   }
     * })
    **/
    count<T extends InventoryBatchCountArgs>(
      args?: Subset<T, InventoryBatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryBatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryBatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryBatchAggregateArgs>(args: Subset<T, InventoryBatchAggregateArgs>): Prisma.PrismaPromise<GetInventoryBatchAggregateType<T>>

    /**
     * Group by InventoryBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryBatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryBatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryBatchGroupByArgs['orderBy'] }
        : { orderBy?: InventoryBatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryBatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryBatch model
   */
  readonly fields: InventoryBatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryBatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryBatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bin<T extends InventoryBatch$binArgs<ExtArgs> = {}>(args?: Subset<T, InventoryBatch$binArgs<ExtArgs>>): Prisma__BinClient<$Result.GetResult<Prisma.$BinPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    inventoryLedger<T extends InventoryBatch$inventoryLedgerArgs<ExtArgs> = {}>(args?: Subset<T, InventoryBatch$inventoryLedgerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryBatch model
   */ 
  interface InventoryBatchFieldRefs {
    readonly id: FieldRef<"InventoryBatch", 'String'>
    readonly itemId: FieldRef<"InventoryBatch", 'String'>
    readonly warehouseId: FieldRef<"InventoryBatch", 'String'>
    readonly binId: FieldRef<"InventoryBatch", 'String'>
    readonly qtyOnHand: FieldRef<"InventoryBatch", 'Decimal'>
    readonly unitCost: FieldRef<"InventoryBatch", 'Decimal'>
    readonly receivedAt: FieldRef<"InventoryBatch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryBatch findUnique
   */
  export type InventoryBatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryBatch
     */
    select?: InventoryBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryBatchInclude<ExtArgs> | null
    /**
     * Filter, which InventoryBatch to fetch.
     */
    where: InventoryBatchWhereUniqueInput
  }

  /**
   * InventoryBatch findUniqueOrThrow
   */
  export type InventoryBatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryBatch
     */
    select?: InventoryBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryBatchInclude<ExtArgs> | null
    /**
     * Filter, which InventoryBatch to fetch.
     */
    where: InventoryBatchWhereUniqueInput
  }

  /**
   * InventoryBatch findFirst
   */
  export type InventoryBatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryBatch
     */
    select?: InventoryBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryBatchInclude<ExtArgs> | null
    /**
     * Filter, which InventoryBatch to fetch.
     */
    where?: InventoryBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryBatches to fetch.
     */
    orderBy?: InventoryBatchOrderByWithRelationInput | InventoryBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryBatches.
     */
    cursor?: InventoryBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryBatches.
     */
    distinct?: InventoryBatchScalarFieldEnum | InventoryBatchScalarFieldEnum[]
  }

  /**
   * InventoryBatch findFirstOrThrow
   */
  export type InventoryBatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryBatch
     */
    select?: InventoryBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryBatchInclude<ExtArgs> | null
    /**
     * Filter, which InventoryBatch to fetch.
     */
    where?: InventoryBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryBatches to fetch.
     */
    orderBy?: InventoryBatchOrderByWithRelationInput | InventoryBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryBatches.
     */
    cursor?: InventoryBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryBatches.
     */
    distinct?: InventoryBatchScalarFieldEnum | InventoryBatchScalarFieldEnum[]
  }

  /**
   * InventoryBatch findMany
   */
  export type InventoryBatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryBatch
     */
    select?: InventoryBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryBatchInclude<ExtArgs> | null
    /**
     * Filter, which InventoryBatches to fetch.
     */
    where?: InventoryBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryBatches to fetch.
     */
    orderBy?: InventoryBatchOrderByWithRelationInput | InventoryBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryBatches.
     */
    cursor?: InventoryBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryBatches.
     */
    skip?: number
    distinct?: InventoryBatchScalarFieldEnum | InventoryBatchScalarFieldEnum[]
  }

  /**
   * InventoryBatch create
   */
  export type InventoryBatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryBatch
     */
    select?: InventoryBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryBatchInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryBatch.
     */
    data: XOR<InventoryBatchCreateInput, InventoryBatchUncheckedCreateInput>
  }

  /**
   * InventoryBatch createMany
   */
  export type InventoryBatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryBatches.
     */
    data: InventoryBatchCreateManyInput | InventoryBatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryBatch createManyAndReturn
   */
  export type InventoryBatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryBatch
     */
    select?: InventoryBatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InventoryBatches.
     */
    data: InventoryBatchCreateManyInput | InventoryBatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryBatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryBatch update
   */
  export type InventoryBatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryBatch
     */
    select?: InventoryBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryBatchInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryBatch.
     */
    data: XOR<InventoryBatchUpdateInput, InventoryBatchUncheckedUpdateInput>
    /**
     * Choose, which InventoryBatch to update.
     */
    where: InventoryBatchWhereUniqueInput
  }

  /**
   * InventoryBatch updateMany
   */
  export type InventoryBatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryBatches.
     */
    data: XOR<InventoryBatchUpdateManyMutationInput, InventoryBatchUncheckedUpdateManyInput>
    /**
     * Filter which InventoryBatches to update
     */
    where?: InventoryBatchWhereInput
  }

  /**
   * InventoryBatch upsert
   */
  export type InventoryBatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryBatch
     */
    select?: InventoryBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryBatchInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryBatch to update in case it exists.
     */
    where: InventoryBatchWhereUniqueInput
    /**
     * In case the InventoryBatch found by the `where` argument doesn't exist, create a new InventoryBatch with this data.
     */
    create: XOR<InventoryBatchCreateInput, InventoryBatchUncheckedCreateInput>
    /**
     * In case the InventoryBatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryBatchUpdateInput, InventoryBatchUncheckedUpdateInput>
  }

  /**
   * InventoryBatch delete
   */
  export type InventoryBatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryBatch
     */
    select?: InventoryBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryBatchInclude<ExtArgs> | null
    /**
     * Filter which InventoryBatch to delete.
     */
    where: InventoryBatchWhereUniqueInput
  }

  /**
   * InventoryBatch deleteMany
   */
  export type InventoryBatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryBatches to delete
     */
    where?: InventoryBatchWhereInput
  }

  /**
   * InventoryBatch.bin
   */
  export type InventoryBatch$binArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bin
     */
    select?: BinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BinInclude<ExtArgs> | null
    where?: BinWhereInput
  }

  /**
   * InventoryBatch.inventoryLedger
   */
  export type InventoryBatch$inventoryLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
    where?: InventoryLedgerWhereInput
    orderBy?: InventoryLedgerOrderByWithRelationInput | InventoryLedgerOrderByWithRelationInput[]
    cursor?: InventoryLedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryLedgerScalarFieldEnum | InventoryLedgerScalarFieldEnum[]
  }

  /**
   * InventoryBatch without action
   */
  export type InventoryBatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryBatch
     */
    select?: InventoryBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryBatchInclude<ExtArgs> | null
  }


  /**
   * Model InventoryLedger
   */

  export type AggregateInventoryLedger = {
    _count: InventoryLedgerCountAggregateOutputType | null
    _avg: InventoryLedgerAvgAggregateOutputType | null
    _sum: InventoryLedgerSumAggregateOutputType | null
    _min: InventoryLedgerMinAggregateOutputType | null
    _max: InventoryLedgerMaxAggregateOutputType | null
  }

  export type InventoryLedgerAvgAggregateOutputType = {
    qty: Decimal | null
    unitCost: Decimal | null
    value: Decimal | null
    runningQty: Decimal | null
    runningValue: Decimal | null
    runningAvgCost: Decimal | null
  }

  export type InventoryLedgerSumAggregateOutputType = {
    qty: Decimal | null
    unitCost: Decimal | null
    value: Decimal | null
    runningQty: Decimal | null
    runningValue: Decimal | null
    runningAvgCost: Decimal | null
  }

  export type InventoryLedgerMinAggregateOutputType = {
    id: string | null
    itemId: string | null
    warehouseId: string | null
    refType: string | null
    refId: string | null
    direction: $Enums.LedgerDirection | null
    qty: Decimal | null
    unitCost: Decimal | null
    value: Decimal | null
    runningQty: Decimal | null
    runningValue: Decimal | null
    runningAvgCost: Decimal | null
    batchId: string | null
    userId: string | null
    postedAt: Date | null
  }

  export type InventoryLedgerMaxAggregateOutputType = {
    id: string | null
    itemId: string | null
    warehouseId: string | null
    refType: string | null
    refId: string | null
    direction: $Enums.LedgerDirection | null
    qty: Decimal | null
    unitCost: Decimal | null
    value: Decimal | null
    runningQty: Decimal | null
    runningValue: Decimal | null
    runningAvgCost: Decimal | null
    batchId: string | null
    userId: string | null
    postedAt: Date | null
  }

  export type InventoryLedgerCountAggregateOutputType = {
    id: number
    itemId: number
    warehouseId: number
    refType: number
    refId: number
    direction: number
    qty: number
    unitCost: number
    value: number
    runningQty: number
    runningValue: number
    runningAvgCost: number
    batchId: number
    userId: number
    postedAt: number
    _all: number
  }


  export type InventoryLedgerAvgAggregateInputType = {
    qty?: true
    unitCost?: true
    value?: true
    runningQty?: true
    runningValue?: true
    runningAvgCost?: true
  }

  export type InventoryLedgerSumAggregateInputType = {
    qty?: true
    unitCost?: true
    value?: true
    runningQty?: true
    runningValue?: true
    runningAvgCost?: true
  }

  export type InventoryLedgerMinAggregateInputType = {
    id?: true
    itemId?: true
    warehouseId?: true
    refType?: true
    refId?: true
    direction?: true
    qty?: true
    unitCost?: true
    value?: true
    runningQty?: true
    runningValue?: true
    runningAvgCost?: true
    batchId?: true
    userId?: true
    postedAt?: true
  }

  export type InventoryLedgerMaxAggregateInputType = {
    id?: true
    itemId?: true
    warehouseId?: true
    refType?: true
    refId?: true
    direction?: true
    qty?: true
    unitCost?: true
    value?: true
    runningQty?: true
    runningValue?: true
    runningAvgCost?: true
    batchId?: true
    userId?: true
    postedAt?: true
  }

  export type InventoryLedgerCountAggregateInputType = {
    id?: true
    itemId?: true
    warehouseId?: true
    refType?: true
    refId?: true
    direction?: true
    qty?: true
    unitCost?: true
    value?: true
    runningQty?: true
    runningValue?: true
    runningAvgCost?: true
    batchId?: true
    userId?: true
    postedAt?: true
    _all?: true
  }

  export type InventoryLedgerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryLedger to aggregate.
     */
    where?: InventoryLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryLedgers to fetch.
     */
    orderBy?: InventoryLedgerOrderByWithRelationInput | InventoryLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryLedgers
    **/
    _count?: true | InventoryLedgerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryLedgerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryLedgerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryLedgerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryLedgerMaxAggregateInputType
  }

  export type GetInventoryLedgerAggregateType<T extends InventoryLedgerAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryLedger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryLedger[P]>
      : GetScalarType<T[P], AggregateInventoryLedger[P]>
  }




  export type InventoryLedgerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryLedgerWhereInput
    orderBy?: InventoryLedgerOrderByWithAggregationInput | InventoryLedgerOrderByWithAggregationInput[]
    by: InventoryLedgerScalarFieldEnum[] | InventoryLedgerScalarFieldEnum
    having?: InventoryLedgerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryLedgerCountAggregateInputType | true
    _avg?: InventoryLedgerAvgAggregateInputType
    _sum?: InventoryLedgerSumAggregateInputType
    _min?: InventoryLedgerMinAggregateInputType
    _max?: InventoryLedgerMaxAggregateInputType
  }

  export type InventoryLedgerGroupByOutputType = {
    id: string
    itemId: string
    warehouseId: string
    refType: string
    refId: string
    direction: $Enums.LedgerDirection
    qty: Decimal
    unitCost: Decimal
    value: Decimal
    runningQty: Decimal
    runningValue: Decimal
    runningAvgCost: Decimal
    batchId: string | null
    userId: string | null
    postedAt: Date
    _count: InventoryLedgerCountAggregateOutputType | null
    _avg: InventoryLedgerAvgAggregateOutputType | null
    _sum: InventoryLedgerSumAggregateOutputType | null
    _min: InventoryLedgerMinAggregateOutputType | null
    _max: InventoryLedgerMaxAggregateOutputType | null
  }

  type GetInventoryLedgerGroupByPayload<T extends InventoryLedgerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryLedgerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryLedgerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryLedgerGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryLedgerGroupByOutputType[P]>
        }
      >
    >


  export type InventoryLedgerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    warehouseId?: boolean
    refType?: boolean
    refId?: boolean
    direction?: boolean
    qty?: boolean
    unitCost?: boolean
    value?: boolean
    runningQty?: boolean
    runningValue?: boolean
    runningAvgCost?: boolean
    batchId?: boolean
    userId?: boolean
    postedAt?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    batch?: boolean | InventoryLedger$batchArgs<ExtArgs>
    user?: boolean | InventoryLedger$userArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryLedger"]>

  export type InventoryLedgerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    warehouseId?: boolean
    refType?: boolean
    refId?: boolean
    direction?: boolean
    qty?: boolean
    unitCost?: boolean
    value?: boolean
    runningQty?: boolean
    runningValue?: boolean
    runningAvgCost?: boolean
    batchId?: boolean
    userId?: boolean
    postedAt?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    batch?: boolean | InventoryLedger$batchArgs<ExtArgs>
    user?: boolean | InventoryLedger$userArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryLedger"]>

  export type InventoryLedgerSelectScalar = {
    id?: boolean
    itemId?: boolean
    warehouseId?: boolean
    refType?: boolean
    refId?: boolean
    direction?: boolean
    qty?: boolean
    unitCost?: boolean
    value?: boolean
    runningQty?: boolean
    runningValue?: boolean
    runningAvgCost?: boolean
    batchId?: boolean
    userId?: boolean
    postedAt?: boolean
  }

  export type InventoryLedgerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    batch?: boolean | InventoryLedger$batchArgs<ExtArgs>
    user?: boolean | InventoryLedger$userArgs<ExtArgs>
  }
  export type InventoryLedgerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    batch?: boolean | InventoryLedger$batchArgs<ExtArgs>
    user?: boolean | InventoryLedger$userArgs<ExtArgs>
  }

  export type $InventoryLedgerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryLedger"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
      warehouse: Prisma.$WarehousePayload<ExtArgs>
      batch: Prisma.$InventoryBatchPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      itemId: string
      warehouseId: string
      refType: string
      refId: string
      direction: $Enums.LedgerDirection
      qty: Prisma.Decimal
      unitCost: Prisma.Decimal
      value: Prisma.Decimal
      runningQty: Prisma.Decimal
      runningValue: Prisma.Decimal
      runningAvgCost: Prisma.Decimal
      batchId: string | null
      userId: string | null
      postedAt: Date
    }, ExtArgs["result"]["inventoryLedger"]>
    composites: {}
  }

  type InventoryLedgerGetPayload<S extends boolean | null | undefined | InventoryLedgerDefaultArgs> = $Result.GetResult<Prisma.$InventoryLedgerPayload, S>

  type InventoryLedgerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryLedgerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventoryLedgerCountAggregateInputType | true
    }

  export interface InventoryLedgerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryLedger'], meta: { name: 'InventoryLedger' } }
    /**
     * Find zero or one InventoryLedger that matches the filter.
     * @param {InventoryLedgerFindUniqueArgs} args - Arguments to find a InventoryLedger
     * @example
     * // Get one InventoryLedger
     * const inventoryLedger = await prisma.inventoryLedger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryLedgerFindUniqueArgs>(args: SelectSubset<T, InventoryLedgerFindUniqueArgs<ExtArgs>>): Prisma__InventoryLedgerClient<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InventoryLedger that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InventoryLedgerFindUniqueOrThrowArgs} args - Arguments to find a InventoryLedger
     * @example
     * // Get one InventoryLedger
     * const inventoryLedger = await prisma.inventoryLedger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryLedgerFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryLedgerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryLedgerClient<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InventoryLedger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryLedgerFindFirstArgs} args - Arguments to find a InventoryLedger
     * @example
     * // Get one InventoryLedger
     * const inventoryLedger = await prisma.inventoryLedger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryLedgerFindFirstArgs>(args?: SelectSubset<T, InventoryLedgerFindFirstArgs<ExtArgs>>): Prisma__InventoryLedgerClient<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InventoryLedger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryLedgerFindFirstOrThrowArgs} args - Arguments to find a InventoryLedger
     * @example
     * // Get one InventoryLedger
     * const inventoryLedger = await prisma.inventoryLedger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryLedgerFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryLedgerFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryLedgerClient<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InventoryLedgers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryLedgerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryLedgers
     * const inventoryLedgers = await prisma.inventoryLedger.findMany()
     * 
     * // Get first 10 InventoryLedgers
     * const inventoryLedgers = await prisma.inventoryLedger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryLedgerWithIdOnly = await prisma.inventoryLedger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryLedgerFindManyArgs>(args?: SelectSubset<T, InventoryLedgerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InventoryLedger.
     * @param {InventoryLedgerCreateArgs} args - Arguments to create a InventoryLedger.
     * @example
     * // Create one InventoryLedger
     * const InventoryLedger = await prisma.inventoryLedger.create({
     *   data: {
     *     // ... data to create a InventoryLedger
     *   }
     * })
     * 
     */
    create<T extends InventoryLedgerCreateArgs>(args: SelectSubset<T, InventoryLedgerCreateArgs<ExtArgs>>): Prisma__InventoryLedgerClient<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InventoryLedgers.
     * @param {InventoryLedgerCreateManyArgs} args - Arguments to create many InventoryLedgers.
     * @example
     * // Create many InventoryLedgers
     * const inventoryLedger = await prisma.inventoryLedger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryLedgerCreateManyArgs>(args?: SelectSubset<T, InventoryLedgerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryLedgers and returns the data saved in the database.
     * @param {InventoryLedgerCreateManyAndReturnArgs} args - Arguments to create many InventoryLedgers.
     * @example
     * // Create many InventoryLedgers
     * const inventoryLedger = await prisma.inventoryLedger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryLedgers and only return the `id`
     * const inventoryLedgerWithIdOnly = await prisma.inventoryLedger.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryLedgerCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryLedgerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InventoryLedger.
     * @param {InventoryLedgerDeleteArgs} args - Arguments to delete one InventoryLedger.
     * @example
     * // Delete one InventoryLedger
     * const InventoryLedger = await prisma.inventoryLedger.delete({
     *   where: {
     *     // ... filter to delete one InventoryLedger
     *   }
     * })
     * 
     */
    delete<T extends InventoryLedgerDeleteArgs>(args: SelectSubset<T, InventoryLedgerDeleteArgs<ExtArgs>>): Prisma__InventoryLedgerClient<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InventoryLedger.
     * @param {InventoryLedgerUpdateArgs} args - Arguments to update one InventoryLedger.
     * @example
     * // Update one InventoryLedger
     * const inventoryLedger = await prisma.inventoryLedger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryLedgerUpdateArgs>(args: SelectSubset<T, InventoryLedgerUpdateArgs<ExtArgs>>): Prisma__InventoryLedgerClient<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InventoryLedgers.
     * @param {InventoryLedgerDeleteManyArgs} args - Arguments to filter InventoryLedgers to delete.
     * @example
     * // Delete a few InventoryLedgers
     * const { count } = await prisma.inventoryLedger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryLedgerDeleteManyArgs>(args?: SelectSubset<T, InventoryLedgerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryLedgerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryLedgers
     * const inventoryLedger = await prisma.inventoryLedger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryLedgerUpdateManyArgs>(args: SelectSubset<T, InventoryLedgerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryLedger.
     * @param {InventoryLedgerUpsertArgs} args - Arguments to update or create a InventoryLedger.
     * @example
     * // Update or create a InventoryLedger
     * const inventoryLedger = await prisma.inventoryLedger.upsert({
     *   create: {
     *     // ... data to create a InventoryLedger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryLedger we want to update
     *   }
     * })
     */
    upsert<T extends InventoryLedgerUpsertArgs>(args: SelectSubset<T, InventoryLedgerUpsertArgs<ExtArgs>>): Prisma__InventoryLedgerClient<$Result.GetResult<Prisma.$InventoryLedgerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InventoryLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryLedgerCountArgs} args - Arguments to filter InventoryLedgers to count.
     * @example
     * // Count the number of InventoryLedgers
     * const count = await prisma.inventoryLedger.count({
     *   where: {
     *     // ... the filter for the InventoryLedgers we want to count
     *   }
     * })
    **/
    count<T extends InventoryLedgerCountArgs>(
      args?: Subset<T, InventoryLedgerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryLedgerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryLedgerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryLedgerAggregateArgs>(args: Subset<T, InventoryLedgerAggregateArgs>): Prisma.PrismaPromise<GetInventoryLedgerAggregateType<T>>

    /**
     * Group by InventoryLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryLedgerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryLedgerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryLedgerGroupByArgs['orderBy'] }
        : { orderBy?: InventoryLedgerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryLedgerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryLedgerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryLedger model
   */
  readonly fields: InventoryLedgerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryLedger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryLedgerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    batch<T extends InventoryLedger$batchArgs<ExtArgs> = {}>(args?: Subset<T, InventoryLedger$batchArgs<ExtArgs>>): Prisma__InventoryBatchClient<$Result.GetResult<Prisma.$InventoryBatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends InventoryLedger$userArgs<ExtArgs> = {}>(args?: Subset<T, InventoryLedger$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryLedger model
   */ 
  interface InventoryLedgerFieldRefs {
    readonly id: FieldRef<"InventoryLedger", 'String'>
    readonly itemId: FieldRef<"InventoryLedger", 'String'>
    readonly warehouseId: FieldRef<"InventoryLedger", 'String'>
    readonly refType: FieldRef<"InventoryLedger", 'String'>
    readonly refId: FieldRef<"InventoryLedger", 'String'>
    readonly direction: FieldRef<"InventoryLedger", 'LedgerDirection'>
    readonly qty: FieldRef<"InventoryLedger", 'Decimal'>
    readonly unitCost: FieldRef<"InventoryLedger", 'Decimal'>
    readonly value: FieldRef<"InventoryLedger", 'Decimal'>
    readonly runningQty: FieldRef<"InventoryLedger", 'Decimal'>
    readonly runningValue: FieldRef<"InventoryLedger", 'Decimal'>
    readonly runningAvgCost: FieldRef<"InventoryLedger", 'Decimal'>
    readonly batchId: FieldRef<"InventoryLedger", 'String'>
    readonly userId: FieldRef<"InventoryLedger", 'String'>
    readonly postedAt: FieldRef<"InventoryLedger", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryLedger findUnique
   */
  export type InventoryLedgerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
    /**
     * Filter, which InventoryLedger to fetch.
     */
    where: InventoryLedgerWhereUniqueInput
  }

  /**
   * InventoryLedger findUniqueOrThrow
   */
  export type InventoryLedgerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
    /**
     * Filter, which InventoryLedger to fetch.
     */
    where: InventoryLedgerWhereUniqueInput
  }

  /**
   * InventoryLedger findFirst
   */
  export type InventoryLedgerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
    /**
     * Filter, which InventoryLedger to fetch.
     */
    where?: InventoryLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryLedgers to fetch.
     */
    orderBy?: InventoryLedgerOrderByWithRelationInput | InventoryLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryLedgers.
     */
    cursor?: InventoryLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryLedgers.
     */
    distinct?: InventoryLedgerScalarFieldEnum | InventoryLedgerScalarFieldEnum[]
  }

  /**
   * InventoryLedger findFirstOrThrow
   */
  export type InventoryLedgerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
    /**
     * Filter, which InventoryLedger to fetch.
     */
    where?: InventoryLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryLedgers to fetch.
     */
    orderBy?: InventoryLedgerOrderByWithRelationInput | InventoryLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryLedgers.
     */
    cursor?: InventoryLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryLedgers.
     */
    distinct?: InventoryLedgerScalarFieldEnum | InventoryLedgerScalarFieldEnum[]
  }

  /**
   * InventoryLedger findMany
   */
  export type InventoryLedgerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
    /**
     * Filter, which InventoryLedgers to fetch.
     */
    where?: InventoryLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryLedgers to fetch.
     */
    orderBy?: InventoryLedgerOrderByWithRelationInput | InventoryLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryLedgers.
     */
    cursor?: InventoryLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryLedgers.
     */
    skip?: number
    distinct?: InventoryLedgerScalarFieldEnum | InventoryLedgerScalarFieldEnum[]
  }

  /**
   * InventoryLedger create
   */
  export type InventoryLedgerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryLedger.
     */
    data: XOR<InventoryLedgerCreateInput, InventoryLedgerUncheckedCreateInput>
  }

  /**
   * InventoryLedger createMany
   */
  export type InventoryLedgerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryLedgers.
     */
    data: InventoryLedgerCreateManyInput | InventoryLedgerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryLedger createManyAndReturn
   */
  export type InventoryLedgerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InventoryLedgers.
     */
    data: InventoryLedgerCreateManyInput | InventoryLedgerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryLedger update
   */
  export type InventoryLedgerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryLedger.
     */
    data: XOR<InventoryLedgerUpdateInput, InventoryLedgerUncheckedUpdateInput>
    /**
     * Choose, which InventoryLedger to update.
     */
    where: InventoryLedgerWhereUniqueInput
  }

  /**
   * InventoryLedger updateMany
   */
  export type InventoryLedgerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryLedgers.
     */
    data: XOR<InventoryLedgerUpdateManyMutationInput, InventoryLedgerUncheckedUpdateManyInput>
    /**
     * Filter which InventoryLedgers to update
     */
    where?: InventoryLedgerWhereInput
  }

  /**
   * InventoryLedger upsert
   */
  export type InventoryLedgerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryLedger to update in case it exists.
     */
    where: InventoryLedgerWhereUniqueInput
    /**
     * In case the InventoryLedger found by the `where` argument doesn't exist, create a new InventoryLedger with this data.
     */
    create: XOR<InventoryLedgerCreateInput, InventoryLedgerUncheckedCreateInput>
    /**
     * In case the InventoryLedger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryLedgerUpdateInput, InventoryLedgerUncheckedUpdateInput>
  }

  /**
   * InventoryLedger delete
   */
  export type InventoryLedgerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
    /**
     * Filter which InventoryLedger to delete.
     */
    where: InventoryLedgerWhereUniqueInput
  }

  /**
   * InventoryLedger deleteMany
   */
  export type InventoryLedgerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryLedgers to delete
     */
    where?: InventoryLedgerWhereInput
  }

  /**
   * InventoryLedger.batch
   */
  export type InventoryLedger$batchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryBatch
     */
    select?: InventoryBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryBatchInclude<ExtArgs> | null
    where?: InventoryBatchWhereInput
  }

  /**
   * InventoryLedger.user
   */
  export type InventoryLedger$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * InventoryLedger without action
   */
  export type InventoryLedgerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryLedger
     */
    select?: InventoryLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryLedgerInclude<ExtArgs> | null
  }


  /**
   * Model ProductionOrder
   */

  export type AggregateProductionOrder = {
    _count: ProductionOrderCountAggregateOutputType | null
    _avg: ProductionOrderAvgAggregateOutputType | null
    _sum: ProductionOrderSumAggregateOutputType | null
    _min: ProductionOrderMinAggregateOutputType | null
    _max: ProductionOrderMaxAggregateOutputType | null
  }

  export type ProductionOrderAvgAggregateOutputType = {
    qtyTarget: Decimal | null
    qtyProduced: Decimal | null
  }

  export type ProductionOrderSumAggregateOutputType = {
    qtyTarget: Decimal | null
    qtyProduced: Decimal | null
  }

  export type ProductionOrderMinAggregateOutputType = {
    id: string | null
    orderNo: string | null
    itemId: string | null
    qtyTarget: Decimal | null
    qtyProduced: Decimal | null
    status: $Enums.ProductionOrderStatus | null
    warehouseId: string | null
    bomId: string | null
    approvalStatus: string | null
    approvalRequestId: string | null
    approvedBy: string | null
    approvedAt: Date | null
    startedAt: Date | null
    finishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionOrderMaxAggregateOutputType = {
    id: string | null
    orderNo: string | null
    itemId: string | null
    qtyTarget: Decimal | null
    qtyProduced: Decimal | null
    status: $Enums.ProductionOrderStatus | null
    warehouseId: string | null
    bomId: string | null
    approvalStatus: string | null
    approvalRequestId: string | null
    approvedBy: string | null
    approvedAt: Date | null
    startedAt: Date | null
    finishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductionOrderCountAggregateOutputType = {
    id: number
    orderNo: number
    itemId: number
    qtyTarget: number
    qtyProduced: number
    status: number
    warehouseId: number
    bomId: number
    approvalStatus: number
    approvalRequestId: number
    approvedBy: number
    approvedAt: number
    startedAt: number
    finishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductionOrderAvgAggregateInputType = {
    qtyTarget?: true
    qtyProduced?: true
  }

  export type ProductionOrderSumAggregateInputType = {
    qtyTarget?: true
    qtyProduced?: true
  }

  export type ProductionOrderMinAggregateInputType = {
    id?: true
    orderNo?: true
    itemId?: true
    qtyTarget?: true
    qtyProduced?: true
    status?: true
    warehouseId?: true
    bomId?: true
    approvalStatus?: true
    approvalRequestId?: true
    approvedBy?: true
    approvedAt?: true
    startedAt?: true
    finishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionOrderMaxAggregateInputType = {
    id?: true
    orderNo?: true
    itemId?: true
    qtyTarget?: true
    qtyProduced?: true
    status?: true
    warehouseId?: true
    bomId?: true
    approvalStatus?: true
    approvalRequestId?: true
    approvedBy?: true
    approvedAt?: true
    startedAt?: true
    finishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductionOrderCountAggregateInputType = {
    id?: true
    orderNo?: true
    itemId?: true
    qtyTarget?: true
    qtyProduced?: true
    status?: true
    warehouseId?: true
    bomId?: true
    approvalStatus?: true
    approvalRequestId?: true
    approvedBy?: true
    approvedAt?: true
    startedAt?: true
    finishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductionOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionOrder to aggregate.
     */
    where?: ProductionOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionOrders to fetch.
     */
    orderBy?: ProductionOrderOrderByWithRelationInput | ProductionOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionOrders
    **/
    _count?: true | ProductionOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionOrderMaxAggregateInputType
  }

  export type GetProductionOrderAggregateType<T extends ProductionOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionOrder[P]>
      : GetScalarType<T[P], AggregateProductionOrder[P]>
  }




  export type ProductionOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionOrderWhereInput
    orderBy?: ProductionOrderOrderByWithAggregationInput | ProductionOrderOrderByWithAggregationInput[]
    by: ProductionOrderScalarFieldEnum[] | ProductionOrderScalarFieldEnum
    having?: ProductionOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionOrderCountAggregateInputType | true
    _avg?: ProductionOrderAvgAggregateInputType
    _sum?: ProductionOrderSumAggregateInputType
    _min?: ProductionOrderMinAggregateInputType
    _max?: ProductionOrderMaxAggregateInputType
  }

  export type ProductionOrderGroupByOutputType = {
    id: string
    orderNo: string
    itemId: string
    qtyTarget: Decimal
    qtyProduced: Decimal
    status: $Enums.ProductionOrderStatus
    warehouseId: string
    bomId: string | null
    approvalStatus: string | null
    approvalRequestId: string | null
    approvedBy: string | null
    approvedAt: Date | null
    startedAt: Date | null
    finishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ProductionOrderCountAggregateOutputType | null
    _avg: ProductionOrderAvgAggregateOutputType | null
    _sum: ProductionOrderSumAggregateOutputType | null
    _min: ProductionOrderMinAggregateOutputType | null
    _max: ProductionOrderMaxAggregateOutputType | null
  }

  type GetProductionOrderGroupByPayload<T extends ProductionOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionOrderGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionOrderGroupByOutputType[P]>
        }
      >
    >


  export type ProductionOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNo?: boolean
    itemId?: boolean
    qtyTarget?: boolean
    qtyProduced?: boolean
    status?: boolean
    warehouseId?: boolean
    bomId?: boolean
    approvalStatus?: boolean
    approvalRequestId?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    bom?: boolean | ProductionOrder$bomArgs<ExtArgs>
    wipLedger?: boolean | ProductionOrder$wipLedgerArgs<ExtArgs>
    laborTimes?: boolean | ProductionOrder$laborTimesArgs<ExtArgs>
    _count?: boolean | ProductionOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionOrder"]>

  export type ProductionOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNo?: boolean
    itemId?: boolean
    qtyTarget?: boolean
    qtyProduced?: boolean
    status?: boolean
    warehouseId?: boolean
    bomId?: boolean
    approvalStatus?: boolean
    approvalRequestId?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    bom?: boolean | ProductionOrder$bomArgs<ExtArgs>
  }, ExtArgs["result"]["productionOrder"]>

  export type ProductionOrderSelectScalar = {
    id?: boolean
    orderNo?: boolean
    itemId?: boolean
    qtyTarget?: boolean
    qtyProduced?: boolean
    status?: boolean
    warehouseId?: boolean
    bomId?: boolean
    approvalStatus?: boolean
    approvalRequestId?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductionOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    bom?: boolean | ProductionOrder$bomArgs<ExtArgs>
    wipLedger?: boolean | ProductionOrder$wipLedgerArgs<ExtArgs>
    laborTimes?: boolean | ProductionOrder$laborTimesArgs<ExtArgs>
    _count?: boolean | ProductionOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductionOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
    bom?: boolean | ProductionOrder$bomArgs<ExtArgs>
  }

  export type $ProductionOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionOrder"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
      warehouse: Prisma.$WarehousePayload<ExtArgs>
      bom: Prisma.$BomPayload<ExtArgs> | null
      wipLedger: Prisma.$WipLedgerPayload<ExtArgs>[]
      laborTimes: Prisma.$LaborTimePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNo: string
      itemId: string
      qtyTarget: Prisma.Decimal
      qtyProduced: Prisma.Decimal
      status: $Enums.ProductionOrderStatus
      warehouseId: string
      bomId: string | null
      approvalStatus: string | null
      approvalRequestId: string | null
      approvedBy: string | null
      approvedAt: Date | null
      startedAt: Date | null
      finishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productionOrder"]>
    composites: {}
  }

  type ProductionOrderGetPayload<S extends boolean | null | undefined | ProductionOrderDefaultArgs> = $Result.GetResult<Prisma.$ProductionOrderPayload, S>

  type ProductionOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductionOrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductionOrderCountAggregateInputType | true
    }

  export interface ProductionOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionOrder'], meta: { name: 'ProductionOrder' } }
    /**
     * Find zero or one ProductionOrder that matches the filter.
     * @param {ProductionOrderFindUniqueArgs} args - Arguments to find a ProductionOrder
     * @example
     * // Get one ProductionOrder
     * const productionOrder = await prisma.productionOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionOrderFindUniqueArgs>(args: SelectSubset<T, ProductionOrderFindUniqueArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductionOrder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductionOrderFindUniqueOrThrowArgs} args - Arguments to find a ProductionOrder
     * @example
     * // Get one ProductionOrder
     * const productionOrder = await prisma.productionOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductionOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOrderFindFirstArgs} args - Arguments to find a ProductionOrder
     * @example
     * // Get one ProductionOrder
     * const productionOrder = await prisma.productionOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionOrderFindFirstArgs>(args?: SelectSubset<T, ProductionOrderFindFirstArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductionOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOrderFindFirstOrThrowArgs} args - Arguments to find a ProductionOrder
     * @example
     * // Get one ProductionOrder
     * const productionOrder = await prisma.productionOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductionOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionOrders
     * const productionOrders = await prisma.productionOrder.findMany()
     * 
     * // Get first 10 ProductionOrders
     * const productionOrders = await prisma.productionOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionOrderWithIdOnly = await prisma.productionOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionOrderFindManyArgs>(args?: SelectSubset<T, ProductionOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductionOrder.
     * @param {ProductionOrderCreateArgs} args - Arguments to create a ProductionOrder.
     * @example
     * // Create one ProductionOrder
     * const ProductionOrder = await prisma.productionOrder.create({
     *   data: {
     *     // ... data to create a ProductionOrder
     *   }
     * })
     * 
     */
    create<T extends ProductionOrderCreateArgs>(args: SelectSubset<T, ProductionOrderCreateArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductionOrders.
     * @param {ProductionOrderCreateManyArgs} args - Arguments to create many ProductionOrders.
     * @example
     * // Create many ProductionOrders
     * const productionOrder = await prisma.productionOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionOrderCreateManyArgs>(args?: SelectSubset<T, ProductionOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionOrders and returns the data saved in the database.
     * @param {ProductionOrderCreateManyAndReturnArgs} args - Arguments to create many ProductionOrders.
     * @example
     * // Create many ProductionOrders
     * const productionOrder = await prisma.productionOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionOrders and only return the `id`
     * const productionOrderWithIdOnly = await prisma.productionOrder.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductionOrder.
     * @param {ProductionOrderDeleteArgs} args - Arguments to delete one ProductionOrder.
     * @example
     * // Delete one ProductionOrder
     * const ProductionOrder = await prisma.productionOrder.delete({
     *   where: {
     *     // ... filter to delete one ProductionOrder
     *   }
     * })
     * 
     */
    delete<T extends ProductionOrderDeleteArgs>(args: SelectSubset<T, ProductionOrderDeleteArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductionOrder.
     * @param {ProductionOrderUpdateArgs} args - Arguments to update one ProductionOrder.
     * @example
     * // Update one ProductionOrder
     * const productionOrder = await prisma.productionOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionOrderUpdateArgs>(args: SelectSubset<T, ProductionOrderUpdateArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductionOrders.
     * @param {ProductionOrderDeleteManyArgs} args - Arguments to filter ProductionOrders to delete.
     * @example
     * // Delete a few ProductionOrders
     * const { count } = await prisma.productionOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionOrderDeleteManyArgs>(args?: SelectSubset<T, ProductionOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionOrders
     * const productionOrder = await prisma.productionOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionOrderUpdateManyArgs>(args: SelectSubset<T, ProductionOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductionOrder.
     * @param {ProductionOrderUpsertArgs} args - Arguments to update or create a ProductionOrder.
     * @example
     * // Update or create a ProductionOrder
     * const productionOrder = await prisma.productionOrder.upsert({
     *   create: {
     *     // ... data to create a ProductionOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionOrder we want to update
     *   }
     * })
     */
    upsert<T extends ProductionOrderUpsertArgs>(args: SelectSubset<T, ProductionOrderUpsertArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductionOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOrderCountArgs} args - Arguments to filter ProductionOrders to count.
     * @example
     * // Count the number of ProductionOrders
     * const count = await prisma.productionOrder.count({
     *   where: {
     *     // ... the filter for the ProductionOrders we want to count
     *   }
     * })
    **/
    count<T extends ProductionOrderCountArgs>(
      args?: Subset<T, ProductionOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionOrderAggregateArgs>(args: Subset<T, ProductionOrderAggregateArgs>): Prisma.PrismaPromise<GetProductionOrderAggregateType<T>>

    /**
     * Group by ProductionOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionOrderGroupByArgs['orderBy'] }
        : { orderBy?: ProductionOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionOrder model
   */
  readonly fields: ProductionOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bom<T extends ProductionOrder$bomArgs<ExtArgs> = {}>(args?: Subset<T, ProductionOrder$bomArgs<ExtArgs>>): Prisma__BomClient<$Result.GetResult<Prisma.$BomPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    wipLedger<T extends ProductionOrder$wipLedgerArgs<ExtArgs> = {}>(args?: Subset<T, ProductionOrder$wipLedgerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WipLedgerPayload<ExtArgs>, T, "findMany"> | Null>
    laborTimes<T extends ProductionOrder$laborTimesArgs<ExtArgs> = {}>(args?: Subset<T, ProductionOrder$laborTimesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaborTimePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionOrder model
   */ 
  interface ProductionOrderFieldRefs {
    readonly id: FieldRef<"ProductionOrder", 'String'>
    readonly orderNo: FieldRef<"ProductionOrder", 'String'>
    readonly itemId: FieldRef<"ProductionOrder", 'String'>
    readonly qtyTarget: FieldRef<"ProductionOrder", 'Decimal'>
    readonly qtyProduced: FieldRef<"ProductionOrder", 'Decimal'>
    readonly status: FieldRef<"ProductionOrder", 'ProductionOrderStatus'>
    readonly warehouseId: FieldRef<"ProductionOrder", 'String'>
    readonly bomId: FieldRef<"ProductionOrder", 'String'>
    readonly approvalStatus: FieldRef<"ProductionOrder", 'String'>
    readonly approvalRequestId: FieldRef<"ProductionOrder", 'String'>
    readonly approvedBy: FieldRef<"ProductionOrder", 'String'>
    readonly approvedAt: FieldRef<"ProductionOrder", 'DateTime'>
    readonly startedAt: FieldRef<"ProductionOrder", 'DateTime'>
    readonly finishedAt: FieldRef<"ProductionOrder", 'DateTime'>
    readonly createdAt: FieldRef<"ProductionOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductionOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductionOrder findUnique
   */
  export type ProductionOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOrderInclude<ExtArgs> | null
    /**
     * Filter, which ProductionOrder to fetch.
     */
    where: ProductionOrderWhereUniqueInput
  }

  /**
   * ProductionOrder findUniqueOrThrow
   */
  export type ProductionOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOrderInclude<ExtArgs> | null
    /**
     * Filter, which ProductionOrder to fetch.
     */
    where: ProductionOrderWhereUniqueInput
  }

  /**
   * ProductionOrder findFirst
   */
  export type ProductionOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOrderInclude<ExtArgs> | null
    /**
     * Filter, which ProductionOrder to fetch.
     */
    where?: ProductionOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionOrders to fetch.
     */
    orderBy?: ProductionOrderOrderByWithRelationInput | ProductionOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionOrders.
     */
    cursor?: ProductionOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionOrders.
     */
    distinct?: ProductionOrderScalarFieldEnum | ProductionOrderScalarFieldEnum[]
  }

  /**
   * ProductionOrder findFirstOrThrow
   */
  export type ProductionOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOrderInclude<ExtArgs> | null
    /**
     * Filter, which ProductionOrder to fetch.
     */
    where?: ProductionOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionOrders to fetch.
     */
    orderBy?: ProductionOrderOrderByWithRelationInput | ProductionOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionOrders.
     */
    cursor?: ProductionOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionOrders.
     */
    distinct?: ProductionOrderScalarFieldEnum | ProductionOrderScalarFieldEnum[]
  }

  /**
   * ProductionOrder findMany
   */
  export type ProductionOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOrderInclude<ExtArgs> | null
    /**
     * Filter, which ProductionOrders to fetch.
     */
    where?: ProductionOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionOrders to fetch.
     */
    orderBy?: ProductionOrderOrderByWithRelationInput | ProductionOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionOrders.
     */
    cursor?: ProductionOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionOrders.
     */
    skip?: number
    distinct?: ProductionOrderScalarFieldEnum | ProductionOrderScalarFieldEnum[]
  }

  /**
   * ProductionOrder create
   */
  export type ProductionOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionOrder.
     */
    data: XOR<ProductionOrderCreateInput, ProductionOrderUncheckedCreateInput>
  }

  /**
   * ProductionOrder createMany
   */
  export type ProductionOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionOrders.
     */
    data: ProductionOrderCreateManyInput | ProductionOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductionOrder createManyAndReturn
   */
  export type ProductionOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductionOrders.
     */
    data: ProductionOrderCreateManyInput | ProductionOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionOrder update
   */
  export type ProductionOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionOrder.
     */
    data: XOR<ProductionOrderUpdateInput, ProductionOrderUncheckedUpdateInput>
    /**
     * Choose, which ProductionOrder to update.
     */
    where: ProductionOrderWhereUniqueInput
  }

  /**
   * ProductionOrder updateMany
   */
  export type ProductionOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionOrders.
     */
    data: XOR<ProductionOrderUpdateManyMutationInput, ProductionOrderUncheckedUpdateManyInput>
    /**
     * Filter which ProductionOrders to update
     */
    where?: ProductionOrderWhereInput
  }

  /**
   * ProductionOrder upsert
   */
  export type ProductionOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionOrder to update in case it exists.
     */
    where: ProductionOrderWhereUniqueInput
    /**
     * In case the ProductionOrder found by the `where` argument doesn't exist, create a new ProductionOrder with this data.
     */
    create: XOR<ProductionOrderCreateInput, ProductionOrderUncheckedCreateInput>
    /**
     * In case the ProductionOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionOrderUpdateInput, ProductionOrderUncheckedUpdateInput>
  }

  /**
   * ProductionOrder delete
   */
  export type ProductionOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOrderInclude<ExtArgs> | null
    /**
     * Filter which ProductionOrder to delete.
     */
    where: ProductionOrderWhereUniqueInput
  }

  /**
   * ProductionOrder deleteMany
   */
  export type ProductionOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionOrders to delete
     */
    where?: ProductionOrderWhereInput
  }

  /**
   * ProductionOrder.bom
   */
  export type ProductionOrder$bomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bom
     */
    select?: BomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BomInclude<ExtArgs> | null
    where?: BomWhereInput
  }

  /**
   * ProductionOrder.wipLedger
   */
  export type ProductionOrder$wipLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WipLedger
     */
    select?: WipLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WipLedgerInclude<ExtArgs> | null
    where?: WipLedgerWhereInput
    orderBy?: WipLedgerOrderByWithRelationInput | WipLedgerOrderByWithRelationInput[]
    cursor?: WipLedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WipLedgerScalarFieldEnum | WipLedgerScalarFieldEnum[]
  }

  /**
   * ProductionOrder.laborTimes
   */
  export type ProductionOrder$laborTimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaborTime
     */
    select?: LaborTimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaborTimeInclude<ExtArgs> | null
    where?: LaborTimeWhereInput
    orderBy?: LaborTimeOrderByWithRelationInput | LaborTimeOrderByWithRelationInput[]
    cursor?: LaborTimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LaborTimeScalarFieldEnum | LaborTimeScalarFieldEnum[]
  }

  /**
   * ProductionOrder without action
   */
  export type ProductionOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionOrder
     */
    select?: ProductionOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionOrderInclude<ExtArgs> | null
  }


  /**
   * Model WipLedger
   */

  export type AggregateWipLedger = {
    _count: WipLedgerCountAggregateOutputType | null
    _avg: WipLedgerAvgAggregateOutputType | null
    _sum: WipLedgerSumAggregateOutputType | null
    _min: WipLedgerMinAggregateOutputType | null
    _max: WipLedgerMaxAggregateOutputType | null
  }

  export type WipLedgerAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type WipLedgerSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type WipLedgerMinAggregateOutputType = {
    id: string | null
    productionOrderId: string | null
    type: $Enums.WipLedgerType | null
    amount: Decimal | null
    note: string | null
    postedAt: Date | null
  }

  export type WipLedgerMaxAggregateOutputType = {
    id: string | null
    productionOrderId: string | null
    type: $Enums.WipLedgerType | null
    amount: Decimal | null
    note: string | null
    postedAt: Date | null
  }

  export type WipLedgerCountAggregateOutputType = {
    id: number
    productionOrderId: number
    type: number
    amount: number
    note: number
    postedAt: number
    _all: number
  }


  export type WipLedgerAvgAggregateInputType = {
    amount?: true
  }

  export type WipLedgerSumAggregateInputType = {
    amount?: true
  }

  export type WipLedgerMinAggregateInputType = {
    id?: true
    productionOrderId?: true
    type?: true
    amount?: true
    note?: true
    postedAt?: true
  }

  export type WipLedgerMaxAggregateInputType = {
    id?: true
    productionOrderId?: true
    type?: true
    amount?: true
    note?: true
    postedAt?: true
  }

  export type WipLedgerCountAggregateInputType = {
    id?: true
    productionOrderId?: true
    type?: true
    amount?: true
    note?: true
    postedAt?: true
    _all?: true
  }

  export type WipLedgerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WipLedger to aggregate.
     */
    where?: WipLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WipLedgers to fetch.
     */
    orderBy?: WipLedgerOrderByWithRelationInput | WipLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WipLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WipLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WipLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WipLedgers
    **/
    _count?: true | WipLedgerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WipLedgerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WipLedgerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WipLedgerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WipLedgerMaxAggregateInputType
  }

  export type GetWipLedgerAggregateType<T extends WipLedgerAggregateArgs> = {
        [P in keyof T & keyof AggregateWipLedger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWipLedger[P]>
      : GetScalarType<T[P], AggregateWipLedger[P]>
  }




  export type WipLedgerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WipLedgerWhereInput
    orderBy?: WipLedgerOrderByWithAggregationInput | WipLedgerOrderByWithAggregationInput[]
    by: WipLedgerScalarFieldEnum[] | WipLedgerScalarFieldEnum
    having?: WipLedgerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WipLedgerCountAggregateInputType | true
    _avg?: WipLedgerAvgAggregateInputType
    _sum?: WipLedgerSumAggregateInputType
    _min?: WipLedgerMinAggregateInputType
    _max?: WipLedgerMaxAggregateInputType
  }

  export type WipLedgerGroupByOutputType = {
    id: string
    productionOrderId: string
    type: $Enums.WipLedgerType
    amount: Decimal
    note: string | null
    postedAt: Date
    _count: WipLedgerCountAggregateOutputType | null
    _avg: WipLedgerAvgAggregateOutputType | null
    _sum: WipLedgerSumAggregateOutputType | null
    _min: WipLedgerMinAggregateOutputType | null
    _max: WipLedgerMaxAggregateOutputType | null
  }

  type GetWipLedgerGroupByPayload<T extends WipLedgerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WipLedgerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WipLedgerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WipLedgerGroupByOutputType[P]>
            : GetScalarType<T[P], WipLedgerGroupByOutputType[P]>
        }
      >
    >


  export type WipLedgerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionOrderId?: boolean
    type?: boolean
    amount?: boolean
    note?: boolean
    postedAt?: boolean
    productionOrder?: boolean | ProductionOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wipLedger"]>

  export type WipLedgerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionOrderId?: boolean
    type?: boolean
    amount?: boolean
    note?: boolean
    postedAt?: boolean
    productionOrder?: boolean | ProductionOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wipLedger"]>

  export type WipLedgerSelectScalar = {
    id?: boolean
    productionOrderId?: boolean
    type?: boolean
    amount?: boolean
    note?: boolean
    postedAt?: boolean
  }

  export type WipLedgerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionOrder?: boolean | ProductionOrderDefaultArgs<ExtArgs>
  }
  export type WipLedgerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionOrder?: boolean | ProductionOrderDefaultArgs<ExtArgs>
  }

  export type $WipLedgerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WipLedger"
    objects: {
      productionOrder: Prisma.$ProductionOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productionOrderId: string
      type: $Enums.WipLedgerType
      amount: Prisma.Decimal
      note: string | null
      postedAt: Date
    }, ExtArgs["result"]["wipLedger"]>
    composites: {}
  }

  type WipLedgerGetPayload<S extends boolean | null | undefined | WipLedgerDefaultArgs> = $Result.GetResult<Prisma.$WipLedgerPayload, S>

  type WipLedgerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WipLedgerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WipLedgerCountAggregateInputType | true
    }

  export interface WipLedgerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WipLedger'], meta: { name: 'WipLedger' } }
    /**
     * Find zero or one WipLedger that matches the filter.
     * @param {WipLedgerFindUniqueArgs} args - Arguments to find a WipLedger
     * @example
     * // Get one WipLedger
     * const wipLedger = await prisma.wipLedger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WipLedgerFindUniqueArgs>(args: SelectSubset<T, WipLedgerFindUniqueArgs<ExtArgs>>): Prisma__WipLedgerClient<$Result.GetResult<Prisma.$WipLedgerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WipLedger that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WipLedgerFindUniqueOrThrowArgs} args - Arguments to find a WipLedger
     * @example
     * // Get one WipLedger
     * const wipLedger = await prisma.wipLedger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WipLedgerFindUniqueOrThrowArgs>(args: SelectSubset<T, WipLedgerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WipLedgerClient<$Result.GetResult<Prisma.$WipLedgerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WipLedger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WipLedgerFindFirstArgs} args - Arguments to find a WipLedger
     * @example
     * // Get one WipLedger
     * const wipLedger = await prisma.wipLedger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WipLedgerFindFirstArgs>(args?: SelectSubset<T, WipLedgerFindFirstArgs<ExtArgs>>): Prisma__WipLedgerClient<$Result.GetResult<Prisma.$WipLedgerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WipLedger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WipLedgerFindFirstOrThrowArgs} args - Arguments to find a WipLedger
     * @example
     * // Get one WipLedger
     * const wipLedger = await prisma.wipLedger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WipLedgerFindFirstOrThrowArgs>(args?: SelectSubset<T, WipLedgerFindFirstOrThrowArgs<ExtArgs>>): Prisma__WipLedgerClient<$Result.GetResult<Prisma.$WipLedgerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WipLedgers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WipLedgerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WipLedgers
     * const wipLedgers = await prisma.wipLedger.findMany()
     * 
     * // Get first 10 WipLedgers
     * const wipLedgers = await prisma.wipLedger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wipLedgerWithIdOnly = await prisma.wipLedger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WipLedgerFindManyArgs>(args?: SelectSubset<T, WipLedgerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WipLedgerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WipLedger.
     * @param {WipLedgerCreateArgs} args - Arguments to create a WipLedger.
     * @example
     * // Create one WipLedger
     * const WipLedger = await prisma.wipLedger.create({
     *   data: {
     *     // ... data to create a WipLedger
     *   }
     * })
     * 
     */
    create<T extends WipLedgerCreateArgs>(args: SelectSubset<T, WipLedgerCreateArgs<ExtArgs>>): Prisma__WipLedgerClient<$Result.GetResult<Prisma.$WipLedgerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WipLedgers.
     * @param {WipLedgerCreateManyArgs} args - Arguments to create many WipLedgers.
     * @example
     * // Create many WipLedgers
     * const wipLedger = await prisma.wipLedger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WipLedgerCreateManyArgs>(args?: SelectSubset<T, WipLedgerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WipLedgers and returns the data saved in the database.
     * @param {WipLedgerCreateManyAndReturnArgs} args - Arguments to create many WipLedgers.
     * @example
     * // Create many WipLedgers
     * const wipLedger = await prisma.wipLedger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WipLedgers and only return the `id`
     * const wipLedgerWithIdOnly = await prisma.wipLedger.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WipLedgerCreateManyAndReturnArgs>(args?: SelectSubset<T, WipLedgerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WipLedgerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WipLedger.
     * @param {WipLedgerDeleteArgs} args - Arguments to delete one WipLedger.
     * @example
     * // Delete one WipLedger
     * const WipLedger = await prisma.wipLedger.delete({
     *   where: {
     *     // ... filter to delete one WipLedger
     *   }
     * })
     * 
     */
    delete<T extends WipLedgerDeleteArgs>(args: SelectSubset<T, WipLedgerDeleteArgs<ExtArgs>>): Prisma__WipLedgerClient<$Result.GetResult<Prisma.$WipLedgerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WipLedger.
     * @param {WipLedgerUpdateArgs} args - Arguments to update one WipLedger.
     * @example
     * // Update one WipLedger
     * const wipLedger = await prisma.wipLedger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WipLedgerUpdateArgs>(args: SelectSubset<T, WipLedgerUpdateArgs<ExtArgs>>): Prisma__WipLedgerClient<$Result.GetResult<Prisma.$WipLedgerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WipLedgers.
     * @param {WipLedgerDeleteManyArgs} args - Arguments to filter WipLedgers to delete.
     * @example
     * // Delete a few WipLedgers
     * const { count } = await prisma.wipLedger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WipLedgerDeleteManyArgs>(args?: SelectSubset<T, WipLedgerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WipLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WipLedgerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WipLedgers
     * const wipLedger = await prisma.wipLedger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WipLedgerUpdateManyArgs>(args: SelectSubset<T, WipLedgerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WipLedger.
     * @param {WipLedgerUpsertArgs} args - Arguments to update or create a WipLedger.
     * @example
     * // Update or create a WipLedger
     * const wipLedger = await prisma.wipLedger.upsert({
     *   create: {
     *     // ... data to create a WipLedger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WipLedger we want to update
     *   }
     * })
     */
    upsert<T extends WipLedgerUpsertArgs>(args: SelectSubset<T, WipLedgerUpsertArgs<ExtArgs>>): Prisma__WipLedgerClient<$Result.GetResult<Prisma.$WipLedgerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WipLedgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WipLedgerCountArgs} args - Arguments to filter WipLedgers to count.
     * @example
     * // Count the number of WipLedgers
     * const count = await prisma.wipLedger.count({
     *   where: {
     *     // ... the filter for the WipLedgers we want to count
     *   }
     * })
    **/
    count<T extends WipLedgerCountArgs>(
      args?: Subset<T, WipLedgerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WipLedgerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WipLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WipLedgerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WipLedgerAggregateArgs>(args: Subset<T, WipLedgerAggregateArgs>): Prisma.PrismaPromise<GetWipLedgerAggregateType<T>>

    /**
     * Group by WipLedger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WipLedgerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WipLedgerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WipLedgerGroupByArgs['orderBy'] }
        : { orderBy?: WipLedgerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WipLedgerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWipLedgerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WipLedger model
   */
  readonly fields: WipLedgerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WipLedger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WipLedgerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productionOrder<T extends ProductionOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionOrderDefaultArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WipLedger model
   */ 
  interface WipLedgerFieldRefs {
    readonly id: FieldRef<"WipLedger", 'String'>
    readonly productionOrderId: FieldRef<"WipLedger", 'String'>
    readonly type: FieldRef<"WipLedger", 'WipLedgerType'>
    readonly amount: FieldRef<"WipLedger", 'Decimal'>
    readonly note: FieldRef<"WipLedger", 'String'>
    readonly postedAt: FieldRef<"WipLedger", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WipLedger findUnique
   */
  export type WipLedgerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WipLedger
     */
    select?: WipLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WipLedgerInclude<ExtArgs> | null
    /**
     * Filter, which WipLedger to fetch.
     */
    where: WipLedgerWhereUniqueInput
  }

  /**
   * WipLedger findUniqueOrThrow
   */
  export type WipLedgerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WipLedger
     */
    select?: WipLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WipLedgerInclude<ExtArgs> | null
    /**
     * Filter, which WipLedger to fetch.
     */
    where: WipLedgerWhereUniqueInput
  }

  /**
   * WipLedger findFirst
   */
  export type WipLedgerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WipLedger
     */
    select?: WipLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WipLedgerInclude<ExtArgs> | null
    /**
     * Filter, which WipLedger to fetch.
     */
    where?: WipLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WipLedgers to fetch.
     */
    orderBy?: WipLedgerOrderByWithRelationInput | WipLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WipLedgers.
     */
    cursor?: WipLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WipLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WipLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WipLedgers.
     */
    distinct?: WipLedgerScalarFieldEnum | WipLedgerScalarFieldEnum[]
  }

  /**
   * WipLedger findFirstOrThrow
   */
  export type WipLedgerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WipLedger
     */
    select?: WipLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WipLedgerInclude<ExtArgs> | null
    /**
     * Filter, which WipLedger to fetch.
     */
    where?: WipLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WipLedgers to fetch.
     */
    orderBy?: WipLedgerOrderByWithRelationInput | WipLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WipLedgers.
     */
    cursor?: WipLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WipLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WipLedgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WipLedgers.
     */
    distinct?: WipLedgerScalarFieldEnum | WipLedgerScalarFieldEnum[]
  }

  /**
   * WipLedger findMany
   */
  export type WipLedgerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WipLedger
     */
    select?: WipLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WipLedgerInclude<ExtArgs> | null
    /**
     * Filter, which WipLedgers to fetch.
     */
    where?: WipLedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WipLedgers to fetch.
     */
    orderBy?: WipLedgerOrderByWithRelationInput | WipLedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WipLedgers.
     */
    cursor?: WipLedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WipLedgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WipLedgers.
     */
    skip?: number
    distinct?: WipLedgerScalarFieldEnum | WipLedgerScalarFieldEnum[]
  }

  /**
   * WipLedger create
   */
  export type WipLedgerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WipLedger
     */
    select?: WipLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WipLedgerInclude<ExtArgs> | null
    /**
     * The data needed to create a WipLedger.
     */
    data: XOR<WipLedgerCreateInput, WipLedgerUncheckedCreateInput>
  }

  /**
   * WipLedger createMany
   */
  export type WipLedgerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WipLedgers.
     */
    data: WipLedgerCreateManyInput | WipLedgerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WipLedger createManyAndReturn
   */
  export type WipLedgerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WipLedger
     */
    select?: WipLedgerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WipLedgers.
     */
    data: WipLedgerCreateManyInput | WipLedgerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WipLedgerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WipLedger update
   */
  export type WipLedgerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WipLedger
     */
    select?: WipLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WipLedgerInclude<ExtArgs> | null
    /**
     * The data needed to update a WipLedger.
     */
    data: XOR<WipLedgerUpdateInput, WipLedgerUncheckedUpdateInput>
    /**
     * Choose, which WipLedger to update.
     */
    where: WipLedgerWhereUniqueInput
  }

  /**
   * WipLedger updateMany
   */
  export type WipLedgerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WipLedgers.
     */
    data: XOR<WipLedgerUpdateManyMutationInput, WipLedgerUncheckedUpdateManyInput>
    /**
     * Filter which WipLedgers to update
     */
    where?: WipLedgerWhereInput
  }

  /**
   * WipLedger upsert
   */
  export type WipLedgerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WipLedger
     */
    select?: WipLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WipLedgerInclude<ExtArgs> | null
    /**
     * The filter to search for the WipLedger to update in case it exists.
     */
    where: WipLedgerWhereUniqueInput
    /**
     * In case the WipLedger found by the `where` argument doesn't exist, create a new WipLedger with this data.
     */
    create: XOR<WipLedgerCreateInput, WipLedgerUncheckedCreateInput>
    /**
     * In case the WipLedger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WipLedgerUpdateInput, WipLedgerUncheckedUpdateInput>
  }

  /**
   * WipLedger delete
   */
  export type WipLedgerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WipLedger
     */
    select?: WipLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WipLedgerInclude<ExtArgs> | null
    /**
     * Filter which WipLedger to delete.
     */
    where: WipLedgerWhereUniqueInput
  }

  /**
   * WipLedger deleteMany
   */
  export type WipLedgerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WipLedgers to delete
     */
    where?: WipLedgerWhereInput
  }

  /**
   * WipLedger without action
   */
  export type WipLedgerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WipLedger
     */
    select?: WipLedgerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WipLedgerInclude<ExtArgs> | null
  }


  /**
   * Model LaborTime
   */

  export type AggregateLaborTime = {
    _count: LaborTimeCountAggregateOutputType | null
    _avg: LaborTimeAvgAggregateOutputType | null
    _sum: LaborTimeSumAggregateOutputType | null
    _min: LaborTimeMinAggregateOutputType | null
    _max: LaborTimeMaxAggregateOutputType | null
  }

  export type LaborTimeAvgAggregateOutputType = {
    hours: Decimal | null
    rate: Decimal | null
    amount: Decimal | null
  }

  export type LaborTimeSumAggregateOutputType = {
    hours: Decimal | null
    rate: Decimal | null
    amount: Decimal | null
  }

  export type LaborTimeMinAggregateOutputType = {
    id: string | null
    productionOrderId: string | null
    hours: Decimal | null
    rate: Decimal | null
    amount: Decimal | null
    employeeName: string | null
  }

  export type LaborTimeMaxAggregateOutputType = {
    id: string | null
    productionOrderId: string | null
    hours: Decimal | null
    rate: Decimal | null
    amount: Decimal | null
    employeeName: string | null
  }

  export type LaborTimeCountAggregateOutputType = {
    id: number
    productionOrderId: number
    hours: number
    rate: number
    amount: number
    employeeName: number
    _all: number
  }


  export type LaborTimeAvgAggregateInputType = {
    hours?: true
    rate?: true
    amount?: true
  }

  export type LaborTimeSumAggregateInputType = {
    hours?: true
    rate?: true
    amount?: true
  }

  export type LaborTimeMinAggregateInputType = {
    id?: true
    productionOrderId?: true
    hours?: true
    rate?: true
    amount?: true
    employeeName?: true
  }

  export type LaborTimeMaxAggregateInputType = {
    id?: true
    productionOrderId?: true
    hours?: true
    rate?: true
    amount?: true
    employeeName?: true
  }

  export type LaborTimeCountAggregateInputType = {
    id?: true
    productionOrderId?: true
    hours?: true
    rate?: true
    amount?: true
    employeeName?: true
    _all?: true
  }

  export type LaborTimeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LaborTime to aggregate.
     */
    where?: LaborTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaborTimes to fetch.
     */
    orderBy?: LaborTimeOrderByWithRelationInput | LaborTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaborTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaborTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaborTimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaborTimes
    **/
    _count?: true | LaborTimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaborTimeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaborTimeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaborTimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaborTimeMaxAggregateInputType
  }

  export type GetLaborTimeAggregateType<T extends LaborTimeAggregateArgs> = {
        [P in keyof T & keyof AggregateLaborTime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaborTime[P]>
      : GetScalarType<T[P], AggregateLaborTime[P]>
  }




  export type LaborTimeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaborTimeWhereInput
    orderBy?: LaborTimeOrderByWithAggregationInput | LaborTimeOrderByWithAggregationInput[]
    by: LaborTimeScalarFieldEnum[] | LaborTimeScalarFieldEnum
    having?: LaborTimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaborTimeCountAggregateInputType | true
    _avg?: LaborTimeAvgAggregateInputType
    _sum?: LaborTimeSumAggregateInputType
    _min?: LaborTimeMinAggregateInputType
    _max?: LaborTimeMaxAggregateInputType
  }

  export type LaborTimeGroupByOutputType = {
    id: string
    productionOrderId: string
    hours: Decimal
    rate: Decimal
    amount: Decimal
    employeeName: string | null
    _count: LaborTimeCountAggregateOutputType | null
    _avg: LaborTimeAvgAggregateOutputType | null
    _sum: LaborTimeSumAggregateOutputType | null
    _min: LaborTimeMinAggregateOutputType | null
    _max: LaborTimeMaxAggregateOutputType | null
  }

  type GetLaborTimeGroupByPayload<T extends LaborTimeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LaborTimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaborTimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaborTimeGroupByOutputType[P]>
            : GetScalarType<T[P], LaborTimeGroupByOutputType[P]>
        }
      >
    >


  export type LaborTimeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionOrderId?: boolean
    hours?: boolean
    rate?: boolean
    amount?: boolean
    employeeName?: boolean
    productionOrder?: boolean | ProductionOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["laborTime"]>

  export type LaborTimeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productionOrderId?: boolean
    hours?: boolean
    rate?: boolean
    amount?: boolean
    employeeName?: boolean
    productionOrder?: boolean | ProductionOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["laborTime"]>

  export type LaborTimeSelectScalar = {
    id?: boolean
    productionOrderId?: boolean
    hours?: boolean
    rate?: boolean
    amount?: boolean
    employeeName?: boolean
  }

  export type LaborTimeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionOrder?: boolean | ProductionOrderDefaultArgs<ExtArgs>
  }
  export type LaborTimeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionOrder?: boolean | ProductionOrderDefaultArgs<ExtArgs>
  }

  export type $LaborTimePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LaborTime"
    objects: {
      productionOrder: Prisma.$ProductionOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productionOrderId: string
      hours: Prisma.Decimal
      rate: Prisma.Decimal
      amount: Prisma.Decimal
      employeeName: string | null
    }, ExtArgs["result"]["laborTime"]>
    composites: {}
  }

  type LaborTimeGetPayload<S extends boolean | null | undefined | LaborTimeDefaultArgs> = $Result.GetResult<Prisma.$LaborTimePayload, S>

  type LaborTimeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LaborTimeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LaborTimeCountAggregateInputType | true
    }

  export interface LaborTimeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LaborTime'], meta: { name: 'LaborTime' } }
    /**
     * Find zero or one LaborTime that matches the filter.
     * @param {LaborTimeFindUniqueArgs} args - Arguments to find a LaborTime
     * @example
     * // Get one LaborTime
     * const laborTime = await prisma.laborTime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LaborTimeFindUniqueArgs>(args: SelectSubset<T, LaborTimeFindUniqueArgs<ExtArgs>>): Prisma__LaborTimeClient<$Result.GetResult<Prisma.$LaborTimePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LaborTime that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LaborTimeFindUniqueOrThrowArgs} args - Arguments to find a LaborTime
     * @example
     * // Get one LaborTime
     * const laborTime = await prisma.laborTime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LaborTimeFindUniqueOrThrowArgs>(args: SelectSubset<T, LaborTimeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LaborTimeClient<$Result.GetResult<Prisma.$LaborTimePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LaborTime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaborTimeFindFirstArgs} args - Arguments to find a LaborTime
     * @example
     * // Get one LaborTime
     * const laborTime = await prisma.laborTime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LaborTimeFindFirstArgs>(args?: SelectSubset<T, LaborTimeFindFirstArgs<ExtArgs>>): Prisma__LaborTimeClient<$Result.GetResult<Prisma.$LaborTimePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LaborTime that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaborTimeFindFirstOrThrowArgs} args - Arguments to find a LaborTime
     * @example
     * // Get one LaborTime
     * const laborTime = await prisma.laborTime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LaborTimeFindFirstOrThrowArgs>(args?: SelectSubset<T, LaborTimeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LaborTimeClient<$Result.GetResult<Prisma.$LaborTimePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LaborTimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaborTimeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaborTimes
     * const laborTimes = await prisma.laborTime.findMany()
     * 
     * // Get first 10 LaborTimes
     * const laborTimes = await prisma.laborTime.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laborTimeWithIdOnly = await prisma.laborTime.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LaborTimeFindManyArgs>(args?: SelectSubset<T, LaborTimeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaborTimePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LaborTime.
     * @param {LaborTimeCreateArgs} args - Arguments to create a LaborTime.
     * @example
     * // Create one LaborTime
     * const LaborTime = await prisma.laborTime.create({
     *   data: {
     *     // ... data to create a LaborTime
     *   }
     * })
     * 
     */
    create<T extends LaborTimeCreateArgs>(args: SelectSubset<T, LaborTimeCreateArgs<ExtArgs>>): Prisma__LaborTimeClient<$Result.GetResult<Prisma.$LaborTimePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LaborTimes.
     * @param {LaborTimeCreateManyArgs} args - Arguments to create many LaborTimes.
     * @example
     * // Create many LaborTimes
     * const laborTime = await prisma.laborTime.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LaborTimeCreateManyArgs>(args?: SelectSubset<T, LaborTimeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LaborTimes and returns the data saved in the database.
     * @param {LaborTimeCreateManyAndReturnArgs} args - Arguments to create many LaborTimes.
     * @example
     * // Create many LaborTimes
     * const laborTime = await prisma.laborTime.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LaborTimes and only return the `id`
     * const laborTimeWithIdOnly = await prisma.laborTime.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LaborTimeCreateManyAndReturnArgs>(args?: SelectSubset<T, LaborTimeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaborTimePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LaborTime.
     * @param {LaborTimeDeleteArgs} args - Arguments to delete one LaborTime.
     * @example
     * // Delete one LaborTime
     * const LaborTime = await prisma.laborTime.delete({
     *   where: {
     *     // ... filter to delete one LaborTime
     *   }
     * })
     * 
     */
    delete<T extends LaborTimeDeleteArgs>(args: SelectSubset<T, LaborTimeDeleteArgs<ExtArgs>>): Prisma__LaborTimeClient<$Result.GetResult<Prisma.$LaborTimePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LaborTime.
     * @param {LaborTimeUpdateArgs} args - Arguments to update one LaborTime.
     * @example
     * // Update one LaborTime
     * const laborTime = await prisma.laborTime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LaborTimeUpdateArgs>(args: SelectSubset<T, LaborTimeUpdateArgs<ExtArgs>>): Prisma__LaborTimeClient<$Result.GetResult<Prisma.$LaborTimePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LaborTimes.
     * @param {LaborTimeDeleteManyArgs} args - Arguments to filter LaborTimes to delete.
     * @example
     * // Delete a few LaborTimes
     * const { count } = await prisma.laborTime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LaborTimeDeleteManyArgs>(args?: SelectSubset<T, LaborTimeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaborTimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaborTimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaborTimes
     * const laborTime = await prisma.laborTime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LaborTimeUpdateManyArgs>(args: SelectSubset<T, LaborTimeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LaborTime.
     * @param {LaborTimeUpsertArgs} args - Arguments to update or create a LaborTime.
     * @example
     * // Update or create a LaborTime
     * const laborTime = await prisma.laborTime.upsert({
     *   create: {
     *     // ... data to create a LaborTime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaborTime we want to update
     *   }
     * })
     */
    upsert<T extends LaborTimeUpsertArgs>(args: SelectSubset<T, LaborTimeUpsertArgs<ExtArgs>>): Prisma__LaborTimeClient<$Result.GetResult<Prisma.$LaborTimePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LaborTimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaborTimeCountArgs} args - Arguments to filter LaborTimes to count.
     * @example
     * // Count the number of LaborTimes
     * const count = await prisma.laborTime.count({
     *   where: {
     *     // ... the filter for the LaborTimes we want to count
     *   }
     * })
    **/
    count<T extends LaborTimeCountArgs>(
      args?: Subset<T, LaborTimeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaborTimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaborTime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaborTimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaborTimeAggregateArgs>(args: Subset<T, LaborTimeAggregateArgs>): Prisma.PrismaPromise<GetLaborTimeAggregateType<T>>

    /**
     * Group by LaborTime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaborTimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaborTimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaborTimeGroupByArgs['orderBy'] }
        : { orderBy?: LaborTimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaborTimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaborTimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LaborTime model
   */
  readonly fields: LaborTimeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LaborTime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LaborTimeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productionOrder<T extends ProductionOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionOrderDefaultArgs<ExtArgs>>): Prisma__ProductionOrderClient<$Result.GetResult<Prisma.$ProductionOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LaborTime model
   */ 
  interface LaborTimeFieldRefs {
    readonly id: FieldRef<"LaborTime", 'String'>
    readonly productionOrderId: FieldRef<"LaborTime", 'String'>
    readonly hours: FieldRef<"LaborTime", 'Decimal'>
    readonly rate: FieldRef<"LaborTime", 'Decimal'>
    readonly amount: FieldRef<"LaborTime", 'Decimal'>
    readonly employeeName: FieldRef<"LaborTime", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LaborTime findUnique
   */
  export type LaborTimeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaborTime
     */
    select?: LaborTimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaborTimeInclude<ExtArgs> | null
    /**
     * Filter, which LaborTime to fetch.
     */
    where: LaborTimeWhereUniqueInput
  }

  /**
   * LaborTime findUniqueOrThrow
   */
  export type LaborTimeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaborTime
     */
    select?: LaborTimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaborTimeInclude<ExtArgs> | null
    /**
     * Filter, which LaborTime to fetch.
     */
    where: LaborTimeWhereUniqueInput
  }

  /**
   * LaborTime findFirst
   */
  export type LaborTimeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaborTime
     */
    select?: LaborTimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaborTimeInclude<ExtArgs> | null
    /**
     * Filter, which LaborTime to fetch.
     */
    where?: LaborTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaborTimes to fetch.
     */
    orderBy?: LaborTimeOrderByWithRelationInput | LaborTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaborTimes.
     */
    cursor?: LaborTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaborTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaborTimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaborTimes.
     */
    distinct?: LaborTimeScalarFieldEnum | LaborTimeScalarFieldEnum[]
  }

  /**
   * LaborTime findFirstOrThrow
   */
  export type LaborTimeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaborTime
     */
    select?: LaborTimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaborTimeInclude<ExtArgs> | null
    /**
     * Filter, which LaborTime to fetch.
     */
    where?: LaborTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaborTimes to fetch.
     */
    orderBy?: LaborTimeOrderByWithRelationInput | LaborTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaborTimes.
     */
    cursor?: LaborTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaborTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaborTimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaborTimes.
     */
    distinct?: LaborTimeScalarFieldEnum | LaborTimeScalarFieldEnum[]
  }

  /**
   * LaborTime findMany
   */
  export type LaborTimeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaborTime
     */
    select?: LaborTimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaborTimeInclude<ExtArgs> | null
    /**
     * Filter, which LaborTimes to fetch.
     */
    where?: LaborTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaborTimes to fetch.
     */
    orderBy?: LaborTimeOrderByWithRelationInput | LaborTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaborTimes.
     */
    cursor?: LaborTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaborTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaborTimes.
     */
    skip?: number
    distinct?: LaborTimeScalarFieldEnum | LaborTimeScalarFieldEnum[]
  }

  /**
   * LaborTime create
   */
  export type LaborTimeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaborTime
     */
    select?: LaborTimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaborTimeInclude<ExtArgs> | null
    /**
     * The data needed to create a LaborTime.
     */
    data: XOR<LaborTimeCreateInput, LaborTimeUncheckedCreateInput>
  }

  /**
   * LaborTime createMany
   */
  export type LaborTimeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LaborTimes.
     */
    data: LaborTimeCreateManyInput | LaborTimeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LaborTime createManyAndReturn
   */
  export type LaborTimeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaborTime
     */
    select?: LaborTimeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LaborTimes.
     */
    data: LaborTimeCreateManyInput | LaborTimeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaborTimeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LaborTime update
   */
  export type LaborTimeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaborTime
     */
    select?: LaborTimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaborTimeInclude<ExtArgs> | null
    /**
     * The data needed to update a LaborTime.
     */
    data: XOR<LaborTimeUpdateInput, LaborTimeUncheckedUpdateInput>
    /**
     * Choose, which LaborTime to update.
     */
    where: LaborTimeWhereUniqueInput
  }

  /**
   * LaborTime updateMany
   */
  export type LaborTimeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LaborTimes.
     */
    data: XOR<LaborTimeUpdateManyMutationInput, LaborTimeUncheckedUpdateManyInput>
    /**
     * Filter which LaborTimes to update
     */
    where?: LaborTimeWhereInput
  }

  /**
   * LaborTime upsert
   */
  export type LaborTimeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaborTime
     */
    select?: LaborTimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaborTimeInclude<ExtArgs> | null
    /**
     * The filter to search for the LaborTime to update in case it exists.
     */
    where: LaborTimeWhereUniqueInput
    /**
     * In case the LaborTime found by the `where` argument doesn't exist, create a new LaborTime with this data.
     */
    create: XOR<LaborTimeCreateInput, LaborTimeUncheckedCreateInput>
    /**
     * In case the LaborTime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaborTimeUpdateInput, LaborTimeUncheckedUpdateInput>
  }

  /**
   * LaborTime delete
   */
  export type LaborTimeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaborTime
     */
    select?: LaborTimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaborTimeInclude<ExtArgs> | null
    /**
     * Filter which LaborTime to delete.
     */
    where: LaborTimeWhereUniqueInput
  }

  /**
   * LaborTime deleteMany
   */
  export type LaborTimeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LaborTimes to delete
     */
    where?: LaborTimeWhereInput
  }

  /**
   * LaborTime without action
   */
  export type LaborTimeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaborTime
     */
    select?: LaborTimeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaborTimeInclude<ExtArgs> | null
  }


  /**
   * Model Vendor
   */

  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    paymentTerms: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type VendorMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    paymentTerms: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type VendorCountAggregateOutputType = {
    id: number
    code: number
    name: number
    address: number
    phone: number
    email: number
    paymentTerms: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type VendorMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    paymentTerms?: true
    isActive?: true
    createdAt?: true
  }

  export type VendorMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    paymentTerms?: true
    isActive?: true
    createdAt?: true
  }

  export type VendorCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    paymentTerms?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type VendorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendor to aggregate.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithAggregationInput | VendorOrderByWithAggregationInput[]
    by: VendorScalarFieldEnum[] | VendorScalarFieldEnum
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }

  export type VendorGroupByOutputType = {
    id: string
    code: string
    name: string
    address: string | null
    phone: string | null
    email: string | null
    paymentTerms: string | null
    isActive: boolean
    createdAt: Date
    _count: VendorCountAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    paymentTerms?: boolean
    isActive?: boolean
    createdAt?: boolean
    purchases?: boolean | Vendor$purchasesArgs<ExtArgs>
    purchasePayments?: boolean | Vendor$purchasePaymentsArgs<ExtArgs>
    assets?: boolean | Vendor$assetsArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    paymentTerms?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    paymentTerms?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type VendorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchases?: boolean | Vendor$purchasesArgs<ExtArgs>
    purchasePayments?: boolean | Vendor$purchasePaymentsArgs<ExtArgs>
    assets?: boolean | Vendor$assetsArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VendorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VendorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vendor"
    objects: {
      purchases: Prisma.$PurchasePayload<ExtArgs>[]
      purchasePayments: Prisma.$PurchasePaymentPayload<ExtArgs>[]
      assets: Prisma.$AssetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      address: string | null
      phone: string | null
      email: string | null
      paymentTerms: string | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["vendor"]>
    composites: {}
  }

  type VendorGetPayload<S extends boolean | null | undefined | VendorDefaultArgs> = $Result.GetResult<Prisma.$VendorPayload, S>

  type VendorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VendorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VendorCountAggregateInputType | true
    }

  export interface VendorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vendor'], meta: { name: 'Vendor' } }
    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorFindUniqueArgs>(args: SelectSubset<T, VendorFindUniqueArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Vendor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VendorFindUniqueOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorFindFirstArgs>(args?: SelectSubset<T, VendorFindFirstArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Vendor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorWithIdOnly = await prisma.vendor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorFindManyArgs>(args?: SelectSubset<T, VendorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
     */
    create<T extends VendorCreateArgs>(args: SelectSubset<T, VendorCreateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Vendors.
     * @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorCreateManyArgs>(args?: SelectSubset<T, VendorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vendors and returns the data saved in the database.
     * @param {VendorCreateManyAndReturnArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vendors and only return the `id`
     * const vendorWithIdOnly = await prisma.vendor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
     */
    delete<T extends VendorDeleteArgs>(args: SelectSubset<T, VendorDeleteArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorUpdateArgs>(args: SelectSubset<T, VendorUpdateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorDeleteManyArgs>(args?: SelectSubset<T, VendorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorUpdateManyArgs>(args: SelectSubset<T, VendorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
     */
    upsert<T extends VendorUpsertArgs>(args: SelectSubset<T, VendorUpsertArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): Prisma.PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vendor model
   */
  readonly fields: VendorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchases<T extends Vendor$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany"> | Null>
    purchasePayments<T extends Vendor$purchasePaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$purchasePaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePaymentPayload<ExtArgs>, T, "findMany"> | Null>
    assets<T extends Vendor$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vendor model
   */ 
  interface VendorFieldRefs {
    readonly id: FieldRef<"Vendor", 'String'>
    readonly code: FieldRef<"Vendor", 'String'>
    readonly name: FieldRef<"Vendor", 'String'>
    readonly address: FieldRef<"Vendor", 'String'>
    readonly phone: FieldRef<"Vendor", 'String'>
    readonly email: FieldRef<"Vendor", 'String'>
    readonly paymentTerms: FieldRef<"Vendor", 'String'>
    readonly isActive: FieldRef<"Vendor", 'Boolean'>
    readonly createdAt: FieldRef<"Vendor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vendor findUnique
   */
  export type VendorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findUniqueOrThrow
   */
  export type VendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findFirst
   */
  export type VendorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findFirstOrThrow
   */
  export type VendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendors to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor create
   */
  export type VendorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to create a Vendor.
     */
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }

  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendor createManyAndReturn
   */
  export type VendorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendor update
   */
  export type VendorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to update a Vendor.
     */
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
  }

  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     */
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     */
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }

  /**
   * Vendor delete
   */
  export type VendorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter which Vendor to delete.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendors to delete
     */
    where?: VendorWhereInput
  }

  /**
   * Vendor.purchases
   */
  export type Vendor$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Vendor.purchasePayments
   */
  export type Vendor$purchasePaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePayment
     */
    select?: PurchasePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePaymentInclude<ExtArgs> | null
    where?: PurchasePaymentWhereInput
    orderBy?: PurchasePaymentOrderByWithRelationInput | PurchasePaymentOrderByWithRelationInput[]
    cursor?: PurchasePaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasePaymentScalarFieldEnum | PurchasePaymentScalarFieldEnum[]
  }

  /**
   * Vendor.assets
   */
  export type Vendor$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Vendor without action
   */
  export type VendorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    creditLimit: Decimal | null
  }

  export type CustomerSumAggregateOutputType = {
    creditLimit: Decimal | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    creditLimit: Decimal | null
    CustomerGroup: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    creditLimit: Decimal | null
    CustomerGroup: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    code: number
    name: number
    address: number
    phone: number
    email: number
    creditLimit: number
    CustomerGroup: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    creditLimit?: true
  }

  export type CustomerSumAggregateInputType = {
    creditLimit?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    creditLimit?: true
    CustomerGroup?: true
    isActive?: true
    createdAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    creditLimit?: true
    CustomerGroup?: true
    isActive?: true
    createdAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    creditLimit?: true
    CustomerGroup?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    code: string
    name: string
    address: string | null
    phone: string | null
    email: string | null
    creditLimit: Decimal | null
    CustomerGroup: string
    isActive: boolean
    createdAt: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    creditLimit?: boolean
    CustomerGroup?: boolean
    isActive?: boolean
    createdAt?: boolean
    sales?: boolean | Customer$salesArgs<ExtArgs>
    salesReceipts?: boolean | Customer$salesReceiptsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    creditLimit?: boolean
    CustomerGroup?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    creditLimit?: boolean
    CustomerGroup?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | Customer$salesArgs<ExtArgs>
    salesReceipts?: boolean | Customer$salesReceiptsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      sales: Prisma.$SalePayload<ExtArgs>[]
      salesReceipts: Prisma.$SalesReceiptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      address: string | null
      phone: string | null
      email: string | null
      creditLimit: Prisma.Decimal | null
      CustomerGroup: string
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sales<T extends Customer$salesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany"> | Null>
    salesReceipts<T extends Customer$salesReceiptsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$salesReceiptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReceiptPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */ 
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly code: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly creditLimit: FieldRef<"Customer", 'Decimal'>
    readonly CustomerGroup: FieldRef<"Customer", 'String'>
    readonly isActive: FieldRef<"Customer", 'Boolean'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer.sales
   */
  export type Customer$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Customer.salesReceipts
   */
  export type Customer$salesReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReceipt
     */
    select?: SalesReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReceiptInclude<ExtArgs> | null
    where?: SalesReceiptWhereInput
    orderBy?: SalesReceiptOrderByWithRelationInput | SalesReceiptOrderByWithRelationInput[]
    cursor?: SalesReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesReceiptScalarFieldEnum | SalesReceiptScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Purchase
   */

  export type AggregatePurchase = {
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  export type PurchaseAvgAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type PurchaseSumAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type PurchaseMinAggregateOutputType = {
    id: string | null
    orderNo: string | null
    vendorId: string | null
    orderDate: Date | null
    status: $Enums.PurchaseStatus | null
    totalAmount: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseMaxAggregateOutputType = {
    id: string | null
    orderNo: string | null
    vendorId: string | null
    orderDate: Date | null
    status: $Enums.PurchaseStatus | null
    totalAmount: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseCountAggregateOutputType = {
    id: number
    orderNo: number
    vendorId: number
    orderDate: number
    status: number
    totalAmount: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseAvgAggregateInputType = {
    totalAmount?: true
  }

  export type PurchaseSumAggregateInputType = {
    totalAmount?: true
  }

  export type PurchaseMinAggregateInputType = {
    id?: true
    orderNo?: true
    vendorId?: true
    orderDate?: true
    status?: true
    totalAmount?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseMaxAggregateInputType = {
    id?: true
    orderNo?: true
    vendorId?: true
    orderDate?: true
    status?: true
    totalAmount?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseCountAggregateInputType = {
    id?: true
    orderNo?: true
    vendorId?: true
    orderDate?: true
    status?: true
    totalAmount?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchase to aggregate.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Purchases
    **/
    _count?: true | PurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseMaxAggregateInputType
  }

  export type GetPurchaseAggregateType<T extends PurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchase[P]>
      : GetScalarType<T[P], AggregatePurchase[P]>
  }




  export type PurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithAggregationInput | PurchaseOrderByWithAggregationInput[]
    by: PurchaseScalarFieldEnum[] | PurchaseScalarFieldEnum
    having?: PurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseCountAggregateInputType | true
    _avg?: PurchaseAvgAggregateInputType
    _sum?: PurchaseSumAggregateInputType
    _min?: PurchaseMinAggregateInputType
    _max?: PurchaseMaxAggregateInputType
  }

  export type PurchaseGroupByOutputType = {
    id: string
    orderNo: string
    vendorId: string
    orderDate: Date
    status: $Enums.PurchaseStatus
    totalAmount: Decimal
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  type GetPurchaseGroupByPayload<T extends PurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNo?: boolean
    vendorId?: boolean
    orderDate?: boolean
    status?: boolean
    totalAmount?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    purchaseLines?: boolean | Purchase$purchaseLinesArgs<ExtArgs>
    purchasePayments?: boolean | Purchase$purchasePaymentsArgs<ExtArgs>
    assets?: boolean | Purchase$assetsArgs<ExtArgs>
    _count?: boolean | PurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNo?: boolean
    vendorId?: boolean
    orderDate?: boolean
    status?: boolean
    totalAmount?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>

  export type PurchaseSelectScalar = {
    id?: boolean
    orderNo?: boolean
    vendorId?: boolean
    orderDate?: boolean
    status?: boolean
    totalAmount?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    purchaseLines?: boolean | Purchase$purchaseLinesArgs<ExtArgs>
    purchasePayments?: boolean | Purchase$purchasePaymentsArgs<ExtArgs>
    assets?: boolean | Purchase$assetsArgs<ExtArgs>
    _count?: boolean | PurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $PurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Purchase"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      purchaseLines: Prisma.$PurchaseLinePayload<ExtArgs>[]
      purchasePayments: Prisma.$PurchasePaymentPayload<ExtArgs>[]
      assets: Prisma.$AssetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNo: string
      vendorId: string
      orderDate: Date
      status: $Enums.PurchaseStatus
      totalAmount: Prisma.Decimal
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchase"]>
    composites: {}
  }

  type PurchaseGetPayload<S extends boolean | null | undefined | PurchaseDefaultArgs> = $Result.GetResult<Prisma.$PurchasePayload, S>

  type PurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseCountAggregateInputType | true
    }

  export interface PurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Purchase'], meta: { name: 'Purchase' } }
    /**
     * Find zero or one Purchase that matches the filter.
     * @param {PurchaseFindUniqueArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseFindUniqueArgs>(args: SelectSubset<T, PurchaseFindUniqueArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Purchase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchaseFindUniqueOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Purchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseFindFirstArgs>(args?: SelectSubset<T, PurchaseFindFirstArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Purchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchases
     * const purchases = await prisma.purchase.findMany()
     * 
     * // Get first 10 Purchases
     * const purchases = await prisma.purchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseWithIdOnly = await prisma.purchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseFindManyArgs>(args?: SelectSubset<T, PurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Purchase.
     * @param {PurchaseCreateArgs} args - Arguments to create a Purchase.
     * @example
     * // Create one Purchase
     * const Purchase = await prisma.purchase.create({
     *   data: {
     *     // ... data to create a Purchase
     *   }
     * })
     * 
     */
    create<T extends PurchaseCreateArgs>(args: SelectSubset<T, PurchaseCreateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Purchases.
     * @param {PurchaseCreateManyArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseCreateManyArgs>(args?: SelectSubset<T, PurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Purchases and returns the data saved in the database.
     * @param {PurchaseCreateManyAndReturnArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Purchases and only return the `id`
     * const purchaseWithIdOnly = await prisma.purchase.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Purchase.
     * @param {PurchaseDeleteArgs} args - Arguments to delete one Purchase.
     * @example
     * // Delete one Purchase
     * const Purchase = await prisma.purchase.delete({
     *   where: {
     *     // ... filter to delete one Purchase
     *   }
     * })
     * 
     */
    delete<T extends PurchaseDeleteArgs>(args: SelectSubset<T, PurchaseDeleteArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Purchase.
     * @param {PurchaseUpdateArgs} args - Arguments to update one Purchase.
     * @example
     * // Update one Purchase
     * const purchase = await prisma.purchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseUpdateArgs>(args: SelectSubset<T, PurchaseUpdateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Purchases.
     * @param {PurchaseDeleteManyArgs} args - Arguments to filter Purchases to delete.
     * @example
     * // Delete a few Purchases
     * const { count } = await prisma.purchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseDeleteManyArgs>(args?: SelectSubset<T, PurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseUpdateManyArgs>(args: SelectSubset<T, PurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Purchase.
     * @param {PurchaseUpsertArgs} args - Arguments to update or create a Purchase.
     * @example
     * // Update or create a Purchase
     * const purchase = await prisma.purchase.upsert({
     *   create: {
     *     // ... data to create a Purchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchase we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseUpsertArgs>(args: SelectSubset<T, PurchaseUpsertArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseCountArgs} args - Arguments to filter Purchases to count.
     * @example
     * // Count the number of Purchases
     * const count = await prisma.purchase.count({
     *   where: {
     *     // ... the filter for the Purchases we want to count
     *   }
     * })
    **/
    count<T extends PurchaseCountArgs>(
      args?: Subset<T, PurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseAggregateArgs>(args: Subset<T, PurchaseAggregateArgs>): Prisma.PrismaPromise<GetPurchaseAggregateType<T>>

    /**
     * Group by Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Purchase model
   */
  readonly fields: PurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Purchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    purchaseLines<T extends Purchase$purchaseLinesArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$purchaseLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "findMany"> | Null>
    purchasePayments<T extends Purchase$purchasePaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$purchasePaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePaymentPayload<ExtArgs>, T, "findMany"> | Null>
    assets<T extends Purchase$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Purchase$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Purchase model
   */ 
  interface PurchaseFieldRefs {
    readonly id: FieldRef<"Purchase", 'String'>
    readonly orderNo: FieldRef<"Purchase", 'String'>
    readonly vendorId: FieldRef<"Purchase", 'String'>
    readonly orderDate: FieldRef<"Purchase", 'DateTime'>
    readonly status: FieldRef<"Purchase", 'PurchaseStatus'>
    readonly totalAmount: FieldRef<"Purchase", 'Decimal'>
    readonly notes: FieldRef<"Purchase", 'String'>
    readonly createdAt: FieldRef<"Purchase", 'DateTime'>
    readonly updatedAt: FieldRef<"Purchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Purchase findUnique
   */
  export type PurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findUniqueOrThrow
   */
  export type PurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findFirst
   */
  export type PurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findFirstOrThrow
   */
  export type PurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findMany
   */
  export type PurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchases to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase create
   */
  export type PurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Purchase.
     */
    data: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
  }

  /**
   * Purchase createMany
   */
  export type PurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Purchase createManyAndReturn
   */
  export type PurchaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Purchase update
   */
  export type PurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Purchase.
     */
    data: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
    /**
     * Choose, which Purchase to update.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase updateMany
   */
  export type PurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
  }

  /**
   * Purchase upsert
   */
  export type PurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Purchase to update in case it exists.
     */
    where: PurchaseWhereUniqueInput
    /**
     * In case the Purchase found by the `where` argument doesn't exist, create a new Purchase with this data.
     */
    create: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
    /**
     * In case the Purchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
  }

  /**
   * Purchase delete
   */
  export type PurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter which Purchase to delete.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase deleteMany
   */
  export type PurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchases to delete
     */
    where?: PurchaseWhereInput
  }

  /**
   * Purchase.purchaseLines
   */
  export type Purchase$purchaseLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineInclude<ExtArgs> | null
    where?: PurchaseLineWhereInput
    orderBy?: PurchaseLineOrderByWithRelationInput | PurchaseLineOrderByWithRelationInput[]
    cursor?: PurchaseLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseLineScalarFieldEnum | PurchaseLineScalarFieldEnum[]
  }

  /**
   * Purchase.purchasePayments
   */
  export type Purchase$purchasePaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePayment
     */
    select?: PurchasePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePaymentInclude<ExtArgs> | null
    where?: PurchasePaymentWhereInput
    orderBy?: PurchasePaymentOrderByWithRelationInput | PurchasePaymentOrderByWithRelationInput[]
    cursor?: PurchasePaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasePaymentScalarFieldEnum | PurchasePaymentScalarFieldEnum[]
  }

  /**
   * Purchase.assets
   */
  export type Purchase$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Purchase without action
   */
  export type PurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseLine
   */

  export type AggregatePurchaseLine = {
    _count: PurchaseLineCountAggregateOutputType | null
    _avg: PurchaseLineAvgAggregateOutputType | null
    _sum: PurchaseLineSumAggregateOutputType | null
    _min: PurchaseLineMinAggregateOutputType | null
    _max: PurchaseLineMaxAggregateOutputType | null
  }

  export type PurchaseLineAvgAggregateOutputType = {
    qty: Decimal | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
  }

  export type PurchaseLineSumAggregateOutputType = {
    qty: Decimal | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
  }

  export type PurchaseLineMinAggregateOutputType = {
    id: string | null
    purchaseId: string | null
    itemId: string | null
    qty: Decimal | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
  }

  export type PurchaseLineMaxAggregateOutputType = {
    id: string | null
    purchaseId: string | null
    itemId: string | null
    qty: Decimal | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
  }

  export type PurchaseLineCountAggregateOutputType = {
    id: number
    purchaseId: number
    itemId: number
    qty: number
    unitPrice: number
    lineTotal: number
    _all: number
  }


  export type PurchaseLineAvgAggregateInputType = {
    qty?: true
    unitPrice?: true
    lineTotal?: true
  }

  export type PurchaseLineSumAggregateInputType = {
    qty?: true
    unitPrice?: true
    lineTotal?: true
  }

  export type PurchaseLineMinAggregateInputType = {
    id?: true
    purchaseId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    lineTotal?: true
  }

  export type PurchaseLineMaxAggregateInputType = {
    id?: true
    purchaseId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    lineTotal?: true
  }

  export type PurchaseLineCountAggregateInputType = {
    id?: true
    purchaseId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    lineTotal?: true
    _all?: true
  }

  export type PurchaseLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseLine to aggregate.
     */
    where?: PurchaseLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseLines to fetch.
     */
    orderBy?: PurchaseLineOrderByWithRelationInput | PurchaseLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseLines
    **/
    _count?: true | PurchaseLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseLineMaxAggregateInputType
  }

  export type GetPurchaseLineAggregateType<T extends PurchaseLineAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseLine[P]>
      : GetScalarType<T[P], AggregatePurchaseLine[P]>
  }




  export type PurchaseLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseLineWhereInput
    orderBy?: PurchaseLineOrderByWithAggregationInput | PurchaseLineOrderByWithAggregationInput[]
    by: PurchaseLineScalarFieldEnum[] | PurchaseLineScalarFieldEnum
    having?: PurchaseLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseLineCountAggregateInputType | true
    _avg?: PurchaseLineAvgAggregateInputType
    _sum?: PurchaseLineSumAggregateInputType
    _min?: PurchaseLineMinAggregateInputType
    _max?: PurchaseLineMaxAggregateInputType
  }

  export type PurchaseLineGroupByOutputType = {
    id: string
    purchaseId: string
    itemId: string
    qty: Decimal
    unitPrice: Decimal
    lineTotal: Decimal
    _count: PurchaseLineCountAggregateOutputType | null
    _avg: PurchaseLineAvgAggregateOutputType | null
    _sum: PurchaseLineSumAggregateOutputType | null
    _min: PurchaseLineMinAggregateOutputType | null
    _max: PurchaseLineMaxAggregateOutputType | null
  }

  type GetPurchaseLineGroupByPayload<T extends PurchaseLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseLineGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseLineGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseId?: boolean
    itemId?: boolean
    qty?: boolean
    unitPrice?: boolean
    lineTotal?: boolean
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseLine"]>

  export type PurchaseLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseId?: boolean
    itemId?: boolean
    qty?: boolean
    unitPrice?: boolean
    lineTotal?: boolean
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseLine"]>

  export type PurchaseLineSelectScalar = {
    id?: boolean
    purchaseId?: boolean
    itemId?: boolean
    qty?: boolean
    unitPrice?: boolean
    lineTotal?: boolean
  }

  export type PurchaseLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type PurchaseLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $PurchaseLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseLine"
    objects: {
      purchase: Prisma.$PurchasePayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      purchaseId: string
      itemId: string
      qty: Prisma.Decimal
      unitPrice: Prisma.Decimal
      lineTotal: Prisma.Decimal
    }, ExtArgs["result"]["purchaseLine"]>
    composites: {}
  }

  type PurchaseLineGetPayload<S extends boolean | null | undefined | PurchaseLineDefaultArgs> = $Result.GetResult<Prisma.$PurchaseLinePayload, S>

  type PurchaseLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchaseLineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseLineCountAggregateInputType | true
    }

  export interface PurchaseLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseLine'], meta: { name: 'PurchaseLine' } }
    /**
     * Find zero or one PurchaseLine that matches the filter.
     * @param {PurchaseLineFindUniqueArgs} args - Arguments to find a PurchaseLine
     * @example
     * // Get one PurchaseLine
     * const purchaseLine = await prisma.purchaseLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseLineFindUniqueArgs>(args: SelectSubset<T, PurchaseLineFindUniqueArgs<ExtArgs>>): Prisma__PurchaseLineClient<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PurchaseLine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchaseLineFindUniqueOrThrowArgs} args - Arguments to find a PurchaseLine
     * @example
     * // Get one PurchaseLine
     * const purchaseLine = await prisma.purchaseLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseLineFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseLineClient<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PurchaseLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseLineFindFirstArgs} args - Arguments to find a PurchaseLine
     * @example
     * // Get one PurchaseLine
     * const purchaseLine = await prisma.purchaseLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseLineFindFirstArgs>(args?: SelectSubset<T, PurchaseLineFindFirstArgs<ExtArgs>>): Prisma__PurchaseLineClient<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PurchaseLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseLineFindFirstOrThrowArgs} args - Arguments to find a PurchaseLine
     * @example
     * // Get one PurchaseLine
     * const purchaseLine = await prisma.purchaseLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseLineFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseLineClient<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PurchaseLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseLines
     * const purchaseLines = await prisma.purchaseLine.findMany()
     * 
     * // Get first 10 PurchaseLines
     * const purchaseLines = await prisma.purchaseLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseLineWithIdOnly = await prisma.purchaseLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseLineFindManyArgs>(args?: SelectSubset<T, PurchaseLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PurchaseLine.
     * @param {PurchaseLineCreateArgs} args - Arguments to create a PurchaseLine.
     * @example
     * // Create one PurchaseLine
     * const PurchaseLine = await prisma.purchaseLine.create({
     *   data: {
     *     // ... data to create a PurchaseLine
     *   }
     * })
     * 
     */
    create<T extends PurchaseLineCreateArgs>(args: SelectSubset<T, PurchaseLineCreateArgs<ExtArgs>>): Prisma__PurchaseLineClient<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PurchaseLines.
     * @param {PurchaseLineCreateManyArgs} args - Arguments to create many PurchaseLines.
     * @example
     * // Create many PurchaseLines
     * const purchaseLine = await prisma.purchaseLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseLineCreateManyArgs>(args?: SelectSubset<T, PurchaseLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseLines and returns the data saved in the database.
     * @param {PurchaseLineCreateManyAndReturnArgs} args - Arguments to create many PurchaseLines.
     * @example
     * // Create many PurchaseLines
     * const purchaseLine = await prisma.purchaseLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseLines and only return the `id`
     * const purchaseLineWithIdOnly = await prisma.purchaseLine.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseLineCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PurchaseLine.
     * @param {PurchaseLineDeleteArgs} args - Arguments to delete one PurchaseLine.
     * @example
     * // Delete one PurchaseLine
     * const PurchaseLine = await prisma.purchaseLine.delete({
     *   where: {
     *     // ... filter to delete one PurchaseLine
     *   }
     * })
     * 
     */
    delete<T extends PurchaseLineDeleteArgs>(args: SelectSubset<T, PurchaseLineDeleteArgs<ExtArgs>>): Prisma__PurchaseLineClient<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PurchaseLine.
     * @param {PurchaseLineUpdateArgs} args - Arguments to update one PurchaseLine.
     * @example
     * // Update one PurchaseLine
     * const purchaseLine = await prisma.purchaseLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseLineUpdateArgs>(args: SelectSubset<T, PurchaseLineUpdateArgs<ExtArgs>>): Prisma__PurchaseLineClient<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PurchaseLines.
     * @param {PurchaseLineDeleteManyArgs} args - Arguments to filter PurchaseLines to delete.
     * @example
     * // Delete a few PurchaseLines
     * const { count } = await prisma.purchaseLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseLineDeleteManyArgs>(args?: SelectSubset<T, PurchaseLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseLines
     * const purchaseLine = await prisma.purchaseLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseLineUpdateManyArgs>(args: SelectSubset<T, PurchaseLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseLine.
     * @param {PurchaseLineUpsertArgs} args - Arguments to update or create a PurchaseLine.
     * @example
     * // Update or create a PurchaseLine
     * const purchaseLine = await prisma.purchaseLine.upsert({
     *   create: {
     *     // ... data to create a PurchaseLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseLine we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseLineUpsertArgs>(args: SelectSubset<T, PurchaseLineUpsertArgs<ExtArgs>>): Prisma__PurchaseLineClient<$Result.GetResult<Prisma.$PurchaseLinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PurchaseLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseLineCountArgs} args - Arguments to filter PurchaseLines to count.
     * @example
     * // Count the number of PurchaseLines
     * const count = await prisma.purchaseLine.count({
     *   where: {
     *     // ... the filter for the PurchaseLines we want to count
     *   }
     * })
    **/
    count<T extends PurchaseLineCountArgs>(
      args?: Subset<T, PurchaseLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseLineAggregateArgs>(args: Subset<T, PurchaseLineAggregateArgs>): Prisma.PrismaPromise<GetPurchaseLineAggregateType<T>>

    /**
     * Group by PurchaseLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseLineGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseLine model
   */
  readonly fields: PurchaseLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchase<T extends PurchaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseDefaultArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseLine model
   */ 
  interface PurchaseLineFieldRefs {
    readonly id: FieldRef<"PurchaseLine", 'String'>
    readonly purchaseId: FieldRef<"PurchaseLine", 'String'>
    readonly itemId: FieldRef<"PurchaseLine", 'String'>
    readonly qty: FieldRef<"PurchaseLine", 'Decimal'>
    readonly unitPrice: FieldRef<"PurchaseLine", 'Decimal'>
    readonly lineTotal: FieldRef<"PurchaseLine", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseLine findUnique
   */
  export type PurchaseLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseLine to fetch.
     */
    where: PurchaseLineWhereUniqueInput
  }

  /**
   * PurchaseLine findUniqueOrThrow
   */
  export type PurchaseLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseLine to fetch.
     */
    where: PurchaseLineWhereUniqueInput
  }

  /**
   * PurchaseLine findFirst
   */
  export type PurchaseLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseLine to fetch.
     */
    where?: PurchaseLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseLines to fetch.
     */
    orderBy?: PurchaseLineOrderByWithRelationInput | PurchaseLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseLines.
     */
    cursor?: PurchaseLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseLines.
     */
    distinct?: PurchaseLineScalarFieldEnum | PurchaseLineScalarFieldEnum[]
  }

  /**
   * PurchaseLine findFirstOrThrow
   */
  export type PurchaseLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseLine to fetch.
     */
    where?: PurchaseLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseLines to fetch.
     */
    orderBy?: PurchaseLineOrderByWithRelationInput | PurchaseLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseLines.
     */
    cursor?: PurchaseLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseLines.
     */
    distinct?: PurchaseLineScalarFieldEnum | PurchaseLineScalarFieldEnum[]
  }

  /**
   * PurchaseLine findMany
   */
  export type PurchaseLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseLines to fetch.
     */
    where?: PurchaseLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseLines to fetch.
     */
    orderBy?: PurchaseLineOrderByWithRelationInput | PurchaseLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseLines.
     */
    cursor?: PurchaseLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseLines.
     */
    skip?: number
    distinct?: PurchaseLineScalarFieldEnum | PurchaseLineScalarFieldEnum[]
  }

  /**
   * PurchaseLine create
   */
  export type PurchaseLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseLine.
     */
    data: XOR<PurchaseLineCreateInput, PurchaseLineUncheckedCreateInput>
  }

  /**
   * PurchaseLine createMany
   */
  export type PurchaseLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseLines.
     */
    data: PurchaseLineCreateManyInput | PurchaseLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseLine createManyAndReturn
   */
  export type PurchaseLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PurchaseLines.
     */
    data: PurchaseLineCreateManyInput | PurchaseLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseLine update
   */
  export type PurchaseLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseLine.
     */
    data: XOR<PurchaseLineUpdateInput, PurchaseLineUncheckedUpdateInput>
    /**
     * Choose, which PurchaseLine to update.
     */
    where: PurchaseLineWhereUniqueInput
  }

  /**
   * PurchaseLine updateMany
   */
  export type PurchaseLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseLines.
     */
    data: XOR<PurchaseLineUpdateManyMutationInput, PurchaseLineUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseLines to update
     */
    where?: PurchaseLineWhereInput
  }

  /**
   * PurchaseLine upsert
   */
  export type PurchaseLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseLine to update in case it exists.
     */
    where: PurchaseLineWhereUniqueInput
    /**
     * In case the PurchaseLine found by the `where` argument doesn't exist, create a new PurchaseLine with this data.
     */
    create: XOR<PurchaseLineCreateInput, PurchaseLineUncheckedCreateInput>
    /**
     * In case the PurchaseLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseLineUpdateInput, PurchaseLineUncheckedUpdateInput>
  }

  /**
   * PurchaseLine delete
   */
  export type PurchaseLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineInclude<ExtArgs> | null
    /**
     * Filter which PurchaseLine to delete.
     */
    where: PurchaseLineWhereUniqueInput
  }

  /**
   * PurchaseLine deleteMany
   */
  export type PurchaseLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseLines to delete
     */
    where?: PurchaseLineWhereInput
  }

  /**
   * PurchaseLine without action
   */
  export type PurchaseLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseLine
     */
    select?: PurchaseLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseLineInclude<ExtArgs> | null
  }


  /**
   * Model Sale
   */

  export type AggregateSale = {
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  export type SaleAvgAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type SaleSumAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type SaleMinAggregateOutputType = {
    id: string | null
    orderNo: string | null
    customerId: string | null
    orderDate: Date | null
    status: $Enums.SaleStatus | null
    totalAmount: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaleMaxAggregateOutputType = {
    id: string | null
    orderNo: string | null
    customerId: string | null
    orderDate: Date | null
    status: $Enums.SaleStatus | null
    totalAmount: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaleCountAggregateOutputType = {
    id: number
    orderNo: number
    customerId: number
    orderDate: number
    status: number
    totalAmount: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SaleAvgAggregateInputType = {
    totalAmount?: true
  }

  export type SaleSumAggregateInputType = {
    totalAmount?: true
  }

  export type SaleMinAggregateInputType = {
    id?: true
    orderNo?: true
    customerId?: true
    orderDate?: true
    status?: true
    totalAmount?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaleMaxAggregateInputType = {
    id?: true
    orderNo?: true
    customerId?: true
    orderDate?: true
    status?: true
    totalAmount?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaleCountAggregateInputType = {
    id?: true
    orderNo?: true
    customerId?: true
    orderDate?: true
    status?: true
    totalAmount?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sale to aggregate.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sales
    **/
    _count?: true | SaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleMaxAggregateInputType
  }

  export type GetSaleAggregateType<T extends SaleAggregateArgs> = {
        [P in keyof T & keyof AggregateSale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSale[P]>
      : GetScalarType<T[P], AggregateSale[P]>
  }




  export type SaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithAggregationInput | SaleOrderByWithAggregationInput[]
    by: SaleScalarFieldEnum[] | SaleScalarFieldEnum
    having?: SaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleCountAggregateInputType | true
    _avg?: SaleAvgAggregateInputType
    _sum?: SaleSumAggregateInputType
    _min?: SaleMinAggregateInputType
    _max?: SaleMaxAggregateInputType
  }

  export type SaleGroupByOutputType = {
    id: string
    orderNo: string
    customerId: string
    orderDate: Date
    status: $Enums.SaleStatus
    totalAmount: Decimal
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  type GetSaleGroupByPayload<T extends SaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleGroupByOutputType[P]>
            : GetScalarType<T[P], SaleGroupByOutputType[P]>
        }
      >
    >


  export type SaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNo?: boolean
    customerId?: boolean
    orderDate?: boolean
    status?: boolean
    totalAmount?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    saleLines?: boolean | Sale$saleLinesArgs<ExtArgs>
    salesReceipts?: boolean | Sale$salesReceiptsArgs<ExtArgs>
    _count?: boolean | SaleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNo?: boolean
    customerId?: boolean
    orderDate?: boolean
    status?: boolean
    totalAmount?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectScalar = {
    id?: boolean
    orderNo?: boolean
    customerId?: boolean
    orderDate?: boolean
    status?: boolean
    totalAmount?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    saleLines?: boolean | Sale$saleLinesArgs<ExtArgs>
    salesReceipts?: boolean | Sale$salesReceiptsArgs<ExtArgs>
    _count?: boolean | SaleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $SalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sale"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      saleLines: Prisma.$SaleLinePayload<ExtArgs>[]
      salesReceipts: Prisma.$SalesReceiptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNo: string
      customerId: string
      orderDate: Date
      status: $Enums.SaleStatus
      totalAmount: Prisma.Decimal
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sale"]>
    composites: {}
  }

  type SaleGetPayload<S extends boolean | null | undefined | SaleDefaultArgs> = $Result.GetResult<Prisma.$SalePayload, S>

  type SaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SaleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SaleCountAggregateInputType | true
    }

  export interface SaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sale'], meta: { name: 'Sale' } }
    /**
     * Find zero or one Sale that matches the filter.
     * @param {SaleFindUniqueArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleFindUniqueArgs>(args: SelectSubset<T, SaleFindUniqueArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Sale that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SaleFindUniqueOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Sale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleFindFirstArgs>(args?: SelectSubset<T, SaleFindFirstArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Sale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sales
     * const sales = await prisma.sale.findMany()
     * 
     * // Get first 10 Sales
     * const sales = await prisma.sale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleWithIdOnly = await prisma.sale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleFindManyArgs>(args?: SelectSubset<T, SaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Sale.
     * @param {SaleCreateArgs} args - Arguments to create a Sale.
     * @example
     * // Create one Sale
     * const Sale = await prisma.sale.create({
     *   data: {
     *     // ... data to create a Sale
     *   }
     * })
     * 
     */
    create<T extends SaleCreateArgs>(args: SelectSubset<T, SaleCreateArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sales.
     * @param {SaleCreateManyArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sale = await prisma.sale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleCreateManyArgs>(args?: SelectSubset<T, SaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sales and returns the data saved in the database.
     * @param {SaleCreateManyAndReturnArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sale = await prisma.sale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sales and only return the `id`
     * const saleWithIdOnly = await prisma.sale.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Sale.
     * @param {SaleDeleteArgs} args - Arguments to delete one Sale.
     * @example
     * // Delete one Sale
     * const Sale = await prisma.sale.delete({
     *   where: {
     *     // ... filter to delete one Sale
     *   }
     * })
     * 
     */
    delete<T extends SaleDeleteArgs>(args: SelectSubset<T, SaleDeleteArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Sale.
     * @param {SaleUpdateArgs} args - Arguments to update one Sale.
     * @example
     * // Update one Sale
     * const sale = await prisma.sale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleUpdateArgs>(args: SelectSubset<T, SaleUpdateArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sales.
     * @param {SaleDeleteManyArgs} args - Arguments to filter Sales to delete.
     * @example
     * // Delete a few Sales
     * const { count } = await prisma.sale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleDeleteManyArgs>(args?: SelectSubset<T, SaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sales
     * const sale = await prisma.sale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleUpdateManyArgs>(args: SelectSubset<T, SaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sale.
     * @param {SaleUpsertArgs} args - Arguments to update or create a Sale.
     * @example
     * // Update or create a Sale
     * const sale = await prisma.sale.upsert({
     *   create: {
     *     // ... data to create a Sale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sale we want to update
     *   }
     * })
     */
    upsert<T extends SaleUpsertArgs>(args: SelectSubset<T, SaleUpsertArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleCountArgs} args - Arguments to filter Sales to count.
     * @example
     * // Count the number of Sales
     * const count = await prisma.sale.count({
     *   where: {
     *     // ... the filter for the Sales we want to count
     *   }
     * })
    **/
    count<T extends SaleCountArgs>(
      args?: Subset<T, SaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleAggregateArgs>(args: Subset<T, SaleAggregateArgs>): Prisma.PrismaPromise<GetSaleAggregateType<T>>

    /**
     * Group by Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleGroupByArgs['orderBy'] }
        : { orderBy?: SaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sale model
   */
  readonly fields: SaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    saleLines<T extends Sale$saleLinesArgs<ExtArgs> = {}>(args?: Subset<T, Sale$saleLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleLinePayload<ExtArgs>, T, "findMany"> | Null>
    salesReceipts<T extends Sale$salesReceiptsArgs<ExtArgs> = {}>(args?: Subset<T, Sale$salesReceiptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReceiptPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sale model
   */ 
  interface SaleFieldRefs {
    readonly id: FieldRef<"Sale", 'String'>
    readonly orderNo: FieldRef<"Sale", 'String'>
    readonly customerId: FieldRef<"Sale", 'String'>
    readonly orderDate: FieldRef<"Sale", 'DateTime'>
    readonly status: FieldRef<"Sale", 'SaleStatus'>
    readonly totalAmount: FieldRef<"Sale", 'Decimal'>
    readonly notes: FieldRef<"Sale", 'String'>
    readonly createdAt: FieldRef<"Sale", 'DateTime'>
    readonly updatedAt: FieldRef<"Sale", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sale findUnique
   */
  export type SaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale findUniqueOrThrow
   */
  export type SaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale findFirst
   */
  export type SaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale findFirstOrThrow
   */
  export type SaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale findMany
   */
  export type SaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sales to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale create
   */
  export type SaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The data needed to create a Sale.
     */
    data: XOR<SaleCreateInput, SaleUncheckedCreateInput>
  }

  /**
   * Sale createMany
   */
  export type SaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sales.
     */
    data: SaleCreateManyInput | SaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sale createManyAndReturn
   */
  export type SaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sales.
     */
    data: SaleCreateManyInput | SaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sale update
   */
  export type SaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The data needed to update a Sale.
     */
    data: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
    /**
     * Choose, which Sale to update.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale updateMany
   */
  export type SaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sales.
     */
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyInput>
    /**
     * Filter which Sales to update
     */
    where?: SaleWhereInput
  }

  /**
   * Sale upsert
   */
  export type SaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The filter to search for the Sale to update in case it exists.
     */
    where: SaleWhereUniqueInput
    /**
     * In case the Sale found by the `where` argument doesn't exist, create a new Sale with this data.
     */
    create: XOR<SaleCreateInput, SaleUncheckedCreateInput>
    /**
     * In case the Sale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
  }

  /**
   * Sale delete
   */
  export type SaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter which Sale to delete.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale deleteMany
   */
  export type SaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sales to delete
     */
    where?: SaleWhereInput
  }

  /**
   * Sale.saleLines
   */
  export type Sale$saleLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleLine
     */
    select?: SaleLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleLineInclude<ExtArgs> | null
    where?: SaleLineWhereInput
    orderBy?: SaleLineOrderByWithRelationInput | SaleLineOrderByWithRelationInput[]
    cursor?: SaleLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleLineScalarFieldEnum | SaleLineScalarFieldEnum[]
  }

  /**
   * Sale.salesReceipts
   */
  export type Sale$salesReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReceipt
     */
    select?: SalesReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReceiptInclude<ExtArgs> | null
    where?: SalesReceiptWhereInput
    orderBy?: SalesReceiptOrderByWithRelationInput | SalesReceiptOrderByWithRelationInput[]
    cursor?: SalesReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesReceiptScalarFieldEnum | SalesReceiptScalarFieldEnum[]
  }

  /**
   * Sale without action
   */
  export type SaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
  }


  /**
   * Model SaleLine
   */

  export type AggregateSaleLine = {
    _count: SaleLineCountAggregateOutputType | null
    _avg: SaleLineAvgAggregateOutputType | null
    _sum: SaleLineSumAggregateOutputType | null
    _min: SaleLineMinAggregateOutputType | null
    _max: SaleLineMaxAggregateOutputType | null
  }

  export type SaleLineAvgAggregateOutputType = {
    qty: Decimal | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
  }

  export type SaleLineSumAggregateOutputType = {
    qty: Decimal | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
  }

  export type SaleLineMinAggregateOutputType = {
    id: string | null
    saleId: string | null
    itemId: string | null
    qty: Decimal | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
  }

  export type SaleLineMaxAggregateOutputType = {
    id: string | null
    saleId: string | null
    itemId: string | null
    qty: Decimal | null
    unitPrice: Decimal | null
    lineTotal: Decimal | null
  }

  export type SaleLineCountAggregateOutputType = {
    id: number
    saleId: number
    itemId: number
    qty: number
    unitPrice: number
    lineTotal: number
    _all: number
  }


  export type SaleLineAvgAggregateInputType = {
    qty?: true
    unitPrice?: true
    lineTotal?: true
  }

  export type SaleLineSumAggregateInputType = {
    qty?: true
    unitPrice?: true
    lineTotal?: true
  }

  export type SaleLineMinAggregateInputType = {
    id?: true
    saleId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    lineTotal?: true
  }

  export type SaleLineMaxAggregateInputType = {
    id?: true
    saleId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    lineTotal?: true
  }

  export type SaleLineCountAggregateInputType = {
    id?: true
    saleId?: true
    itemId?: true
    qty?: true
    unitPrice?: true
    lineTotal?: true
    _all?: true
  }

  export type SaleLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleLine to aggregate.
     */
    where?: SaleLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleLines to fetch.
     */
    orderBy?: SaleLineOrderByWithRelationInput | SaleLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleLines
    **/
    _count?: true | SaleLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleLineMaxAggregateInputType
  }

  export type GetSaleLineAggregateType<T extends SaleLineAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleLine[P]>
      : GetScalarType<T[P], AggregateSaleLine[P]>
  }




  export type SaleLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleLineWhereInput
    orderBy?: SaleLineOrderByWithAggregationInput | SaleLineOrderByWithAggregationInput[]
    by: SaleLineScalarFieldEnum[] | SaleLineScalarFieldEnum
    having?: SaleLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleLineCountAggregateInputType | true
    _avg?: SaleLineAvgAggregateInputType
    _sum?: SaleLineSumAggregateInputType
    _min?: SaleLineMinAggregateInputType
    _max?: SaleLineMaxAggregateInputType
  }

  export type SaleLineGroupByOutputType = {
    id: string
    saleId: string
    itemId: string
    qty: Decimal
    unitPrice: Decimal
    lineTotal: Decimal
    _count: SaleLineCountAggregateOutputType | null
    _avg: SaleLineAvgAggregateOutputType | null
    _sum: SaleLineSumAggregateOutputType | null
    _min: SaleLineMinAggregateOutputType | null
    _max: SaleLineMaxAggregateOutputType | null
  }

  type GetSaleLineGroupByPayload<T extends SaleLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleLineGroupByOutputType[P]>
            : GetScalarType<T[P], SaleLineGroupByOutputType[P]>
        }
      >
    >


  export type SaleLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    itemId?: boolean
    qty?: boolean
    unitPrice?: boolean
    lineTotal?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleLine"]>

  export type SaleLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleId?: boolean
    itemId?: boolean
    qty?: boolean
    unitPrice?: boolean
    lineTotal?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleLine"]>

  export type SaleLineSelectScalar = {
    id?: boolean
    saleId?: boolean
    itemId?: boolean
    qty?: boolean
    unitPrice?: boolean
    lineTotal?: boolean
  }

  export type SaleLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type SaleLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $SaleLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleLine"
    objects: {
      sale: Prisma.$SalePayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      saleId: string
      itemId: string
      qty: Prisma.Decimal
      unitPrice: Prisma.Decimal
      lineTotal: Prisma.Decimal
    }, ExtArgs["result"]["saleLine"]>
    composites: {}
  }

  type SaleLineGetPayload<S extends boolean | null | undefined | SaleLineDefaultArgs> = $Result.GetResult<Prisma.$SaleLinePayload, S>

  type SaleLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SaleLineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SaleLineCountAggregateInputType | true
    }

  export interface SaleLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleLine'], meta: { name: 'SaleLine' } }
    /**
     * Find zero or one SaleLine that matches the filter.
     * @param {SaleLineFindUniqueArgs} args - Arguments to find a SaleLine
     * @example
     * // Get one SaleLine
     * const saleLine = await prisma.saleLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleLineFindUniqueArgs>(args: SelectSubset<T, SaleLineFindUniqueArgs<ExtArgs>>): Prisma__SaleLineClient<$Result.GetResult<Prisma.$SaleLinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SaleLine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SaleLineFindUniqueOrThrowArgs} args - Arguments to find a SaleLine
     * @example
     * // Get one SaleLine
     * const saleLine = await prisma.saleLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleLineFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleLineClient<$Result.GetResult<Prisma.$SaleLinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SaleLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleLineFindFirstArgs} args - Arguments to find a SaleLine
     * @example
     * // Get one SaleLine
     * const saleLine = await prisma.saleLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleLineFindFirstArgs>(args?: SelectSubset<T, SaleLineFindFirstArgs<ExtArgs>>): Prisma__SaleLineClient<$Result.GetResult<Prisma.$SaleLinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SaleLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleLineFindFirstOrThrowArgs} args - Arguments to find a SaleLine
     * @example
     * // Get one SaleLine
     * const saleLine = await prisma.saleLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleLineFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleLineClient<$Result.GetResult<Prisma.$SaleLinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SaleLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleLines
     * const saleLines = await prisma.saleLine.findMany()
     * 
     * // Get first 10 SaleLines
     * const saleLines = await prisma.saleLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleLineWithIdOnly = await prisma.saleLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleLineFindManyArgs>(args?: SelectSubset<T, SaleLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleLinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SaleLine.
     * @param {SaleLineCreateArgs} args - Arguments to create a SaleLine.
     * @example
     * // Create one SaleLine
     * const SaleLine = await prisma.saleLine.create({
     *   data: {
     *     // ... data to create a SaleLine
     *   }
     * })
     * 
     */
    create<T extends SaleLineCreateArgs>(args: SelectSubset<T, SaleLineCreateArgs<ExtArgs>>): Prisma__SaleLineClient<$Result.GetResult<Prisma.$SaleLinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SaleLines.
     * @param {SaleLineCreateManyArgs} args - Arguments to create many SaleLines.
     * @example
     * // Create many SaleLines
     * const saleLine = await prisma.saleLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleLineCreateManyArgs>(args?: SelectSubset<T, SaleLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaleLines and returns the data saved in the database.
     * @param {SaleLineCreateManyAndReturnArgs} args - Arguments to create many SaleLines.
     * @example
     * // Create many SaleLines
     * const saleLine = await prisma.saleLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaleLines and only return the `id`
     * const saleLineWithIdOnly = await prisma.saleLine.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleLineCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleLinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SaleLine.
     * @param {SaleLineDeleteArgs} args - Arguments to delete one SaleLine.
     * @example
     * // Delete one SaleLine
     * const SaleLine = await prisma.saleLine.delete({
     *   where: {
     *     // ... filter to delete one SaleLine
     *   }
     * })
     * 
     */
    delete<T extends SaleLineDeleteArgs>(args: SelectSubset<T, SaleLineDeleteArgs<ExtArgs>>): Prisma__SaleLineClient<$Result.GetResult<Prisma.$SaleLinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SaleLine.
     * @param {SaleLineUpdateArgs} args - Arguments to update one SaleLine.
     * @example
     * // Update one SaleLine
     * const saleLine = await prisma.saleLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleLineUpdateArgs>(args: SelectSubset<T, SaleLineUpdateArgs<ExtArgs>>): Prisma__SaleLineClient<$Result.GetResult<Prisma.$SaleLinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SaleLines.
     * @param {SaleLineDeleteManyArgs} args - Arguments to filter SaleLines to delete.
     * @example
     * // Delete a few SaleLines
     * const { count } = await prisma.saleLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleLineDeleteManyArgs>(args?: SelectSubset<T, SaleLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleLines
     * const saleLine = await prisma.saleLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleLineUpdateManyArgs>(args: SelectSubset<T, SaleLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SaleLine.
     * @param {SaleLineUpsertArgs} args - Arguments to update or create a SaleLine.
     * @example
     * // Update or create a SaleLine
     * const saleLine = await prisma.saleLine.upsert({
     *   create: {
     *     // ... data to create a SaleLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleLine we want to update
     *   }
     * })
     */
    upsert<T extends SaleLineUpsertArgs>(args: SelectSubset<T, SaleLineUpsertArgs<ExtArgs>>): Prisma__SaleLineClient<$Result.GetResult<Prisma.$SaleLinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SaleLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleLineCountArgs} args - Arguments to filter SaleLines to count.
     * @example
     * // Count the number of SaleLines
     * const count = await prisma.saleLine.count({
     *   where: {
     *     // ... the filter for the SaleLines we want to count
     *   }
     * })
    **/
    count<T extends SaleLineCountArgs>(
      args?: Subset<T, SaleLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleLineAggregateArgs>(args: Subset<T, SaleLineAggregateArgs>): Prisma.PrismaPromise<GetSaleLineAggregateType<T>>

    /**
     * Group by SaleLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleLineGroupByArgs['orderBy'] }
        : { orderBy?: SaleLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleLine model
   */
  readonly fields: SaleLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends SaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleDefaultArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleLine model
   */ 
  interface SaleLineFieldRefs {
    readonly id: FieldRef<"SaleLine", 'String'>
    readonly saleId: FieldRef<"SaleLine", 'String'>
    readonly itemId: FieldRef<"SaleLine", 'String'>
    readonly qty: FieldRef<"SaleLine", 'Decimal'>
    readonly unitPrice: FieldRef<"SaleLine", 'Decimal'>
    readonly lineTotal: FieldRef<"SaleLine", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * SaleLine findUnique
   */
  export type SaleLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleLine
     */
    select?: SaleLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleLineInclude<ExtArgs> | null
    /**
     * Filter, which SaleLine to fetch.
     */
    where: SaleLineWhereUniqueInput
  }

  /**
   * SaleLine findUniqueOrThrow
   */
  export type SaleLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleLine
     */
    select?: SaleLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleLineInclude<ExtArgs> | null
    /**
     * Filter, which SaleLine to fetch.
     */
    where: SaleLineWhereUniqueInput
  }

  /**
   * SaleLine findFirst
   */
  export type SaleLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleLine
     */
    select?: SaleLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleLineInclude<ExtArgs> | null
    /**
     * Filter, which SaleLine to fetch.
     */
    where?: SaleLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleLines to fetch.
     */
    orderBy?: SaleLineOrderByWithRelationInput | SaleLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleLines.
     */
    cursor?: SaleLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleLines.
     */
    distinct?: SaleLineScalarFieldEnum | SaleLineScalarFieldEnum[]
  }

  /**
   * SaleLine findFirstOrThrow
   */
  export type SaleLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleLine
     */
    select?: SaleLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleLineInclude<ExtArgs> | null
    /**
     * Filter, which SaleLine to fetch.
     */
    where?: SaleLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleLines to fetch.
     */
    orderBy?: SaleLineOrderByWithRelationInput | SaleLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleLines.
     */
    cursor?: SaleLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleLines.
     */
    distinct?: SaleLineScalarFieldEnum | SaleLineScalarFieldEnum[]
  }

  /**
   * SaleLine findMany
   */
  export type SaleLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleLine
     */
    select?: SaleLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleLineInclude<ExtArgs> | null
    /**
     * Filter, which SaleLines to fetch.
     */
    where?: SaleLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleLines to fetch.
     */
    orderBy?: SaleLineOrderByWithRelationInput | SaleLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleLines.
     */
    cursor?: SaleLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleLines.
     */
    skip?: number
    distinct?: SaleLineScalarFieldEnum | SaleLineScalarFieldEnum[]
  }

  /**
   * SaleLine create
   */
  export type SaleLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleLine
     */
    select?: SaleLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleLineInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleLine.
     */
    data: XOR<SaleLineCreateInput, SaleLineUncheckedCreateInput>
  }

  /**
   * SaleLine createMany
   */
  export type SaleLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleLines.
     */
    data: SaleLineCreateManyInput | SaleLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaleLine createManyAndReturn
   */
  export type SaleLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleLine
     */
    select?: SaleLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SaleLines.
     */
    data: SaleLineCreateManyInput | SaleLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleLine update
   */
  export type SaleLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleLine
     */
    select?: SaleLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleLineInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleLine.
     */
    data: XOR<SaleLineUpdateInput, SaleLineUncheckedUpdateInput>
    /**
     * Choose, which SaleLine to update.
     */
    where: SaleLineWhereUniqueInput
  }

  /**
   * SaleLine updateMany
   */
  export type SaleLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleLines.
     */
    data: XOR<SaleLineUpdateManyMutationInput, SaleLineUncheckedUpdateManyInput>
    /**
     * Filter which SaleLines to update
     */
    where?: SaleLineWhereInput
  }

  /**
   * SaleLine upsert
   */
  export type SaleLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleLine
     */
    select?: SaleLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleLineInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleLine to update in case it exists.
     */
    where: SaleLineWhereUniqueInput
    /**
     * In case the SaleLine found by the `where` argument doesn't exist, create a new SaleLine with this data.
     */
    create: XOR<SaleLineCreateInput, SaleLineUncheckedCreateInput>
    /**
     * In case the SaleLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleLineUpdateInput, SaleLineUncheckedUpdateInput>
  }

  /**
   * SaleLine delete
   */
  export type SaleLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleLine
     */
    select?: SaleLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleLineInclude<ExtArgs> | null
    /**
     * Filter which SaleLine to delete.
     */
    where: SaleLineWhereUniqueInput
  }

  /**
   * SaleLine deleteMany
   */
  export type SaleLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleLines to delete
     */
    where?: SaleLineWhereInput
  }

  /**
   * SaleLine without action
   */
  export type SaleLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleLine
     */
    select?: SaleLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleLineInclude<ExtArgs> | null
  }


  /**
   * Model ChartOfAccount
   */

  export type AggregateChartOfAccount = {
    _count: ChartOfAccountCountAggregateOutputType | null
    _min: ChartOfAccountMinAggregateOutputType | null
    _max: ChartOfAccountMaxAggregateOutputType | null
  }

  export type ChartOfAccountMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    accountType: string | null
    parentId: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ChartOfAccountMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    accountType: string | null
    parentId: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ChartOfAccountCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    accountType: number
    parentId: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type ChartOfAccountMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    accountType?: true
    parentId?: true
    isActive?: true
    createdAt?: true
  }

  export type ChartOfAccountMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    accountType?: true
    parentId?: true
    isActive?: true
    createdAt?: true
  }

  export type ChartOfAccountCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    accountType?: true
    parentId?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type ChartOfAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChartOfAccount to aggregate.
     */
    where?: ChartOfAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartOfAccounts to fetch.
     */
    orderBy?: ChartOfAccountOrderByWithRelationInput | ChartOfAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChartOfAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartOfAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartOfAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChartOfAccounts
    **/
    _count?: true | ChartOfAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChartOfAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChartOfAccountMaxAggregateInputType
  }

  export type GetChartOfAccountAggregateType<T extends ChartOfAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateChartOfAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChartOfAccount[P]>
      : GetScalarType<T[P], AggregateChartOfAccount[P]>
  }




  export type ChartOfAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChartOfAccountWhereInput
    orderBy?: ChartOfAccountOrderByWithAggregationInput | ChartOfAccountOrderByWithAggregationInput[]
    by: ChartOfAccountScalarFieldEnum[] | ChartOfAccountScalarFieldEnum
    having?: ChartOfAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChartOfAccountCountAggregateInputType | true
    _min?: ChartOfAccountMinAggregateInputType
    _max?: ChartOfAccountMaxAggregateInputType
  }

  export type ChartOfAccountGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    accountType: string
    parentId: string | null
    isActive: boolean
    createdAt: Date
    _count: ChartOfAccountCountAggregateOutputType | null
    _min: ChartOfAccountMinAggregateOutputType | null
    _max: ChartOfAccountMaxAggregateOutputType | null
  }

  type GetChartOfAccountGroupByPayload<T extends ChartOfAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChartOfAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChartOfAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChartOfAccountGroupByOutputType[P]>
            : GetScalarType<T[P], ChartOfAccountGroupByOutputType[P]>
        }
      >
    >


  export type ChartOfAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    accountType?: boolean
    parentId?: boolean
    isActive?: boolean
    createdAt?: boolean
    parent?: boolean | ChartOfAccount$parentArgs<ExtArgs>
    children?: boolean | ChartOfAccount$childrenArgs<ExtArgs>
    journalLines?: boolean | ChartOfAccount$journalLinesArgs<ExtArgs>
    cashTransactionsGL?: boolean | ChartOfAccount$cashTransactionsGLArgs<ExtArgs>
    cashTransactionsContra?: boolean | ChartOfAccount$cashTransactionsContraArgs<ExtArgs>
    cashAccounts?: boolean | ChartOfAccount$cashAccountsArgs<ExtArgs>
    assetCategoriesAsset?: boolean | ChartOfAccount$assetCategoriesAssetArgs<ExtArgs>
    assetCategoriesDepreciation?: boolean | ChartOfAccount$assetCategoriesDepreciationArgs<ExtArgs>
    assetCategoriesAccumulated?: boolean | ChartOfAccount$assetCategoriesAccumulatedArgs<ExtArgs>
    _count?: boolean | ChartOfAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chartOfAccount"]>

  export type ChartOfAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    accountType?: boolean
    parentId?: boolean
    isActive?: boolean
    createdAt?: boolean
    parent?: boolean | ChartOfAccount$parentArgs<ExtArgs>
  }, ExtArgs["result"]["chartOfAccount"]>

  export type ChartOfAccountSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    accountType?: boolean
    parentId?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type ChartOfAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ChartOfAccount$parentArgs<ExtArgs>
    children?: boolean | ChartOfAccount$childrenArgs<ExtArgs>
    journalLines?: boolean | ChartOfAccount$journalLinesArgs<ExtArgs>
    cashTransactionsGL?: boolean | ChartOfAccount$cashTransactionsGLArgs<ExtArgs>
    cashTransactionsContra?: boolean | ChartOfAccount$cashTransactionsContraArgs<ExtArgs>
    cashAccounts?: boolean | ChartOfAccount$cashAccountsArgs<ExtArgs>
    assetCategoriesAsset?: boolean | ChartOfAccount$assetCategoriesAssetArgs<ExtArgs>
    assetCategoriesDepreciation?: boolean | ChartOfAccount$assetCategoriesDepreciationArgs<ExtArgs>
    assetCategoriesAccumulated?: boolean | ChartOfAccount$assetCategoriesAccumulatedArgs<ExtArgs>
    _count?: boolean | ChartOfAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChartOfAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ChartOfAccount$parentArgs<ExtArgs>
  }

  export type $ChartOfAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChartOfAccount"
    objects: {
      parent: Prisma.$ChartOfAccountPayload<ExtArgs> | null
      children: Prisma.$ChartOfAccountPayload<ExtArgs>[]
      journalLines: Prisma.$JournalLinePayload<ExtArgs>[]
      cashTransactionsGL: Prisma.$CashTransactionPayload<ExtArgs>[]
      cashTransactionsContra: Prisma.$CashTransactionPayload<ExtArgs>[]
      cashAccounts: Prisma.$CashAccountPayload<ExtArgs>[]
      assetCategoriesAsset: Prisma.$AssetCategoryPayload<ExtArgs>[]
      assetCategoriesDepreciation: Prisma.$AssetCategoryPayload<ExtArgs>[]
      assetCategoriesAccumulated: Prisma.$AssetCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      accountType: string
      parentId: string | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["chartOfAccount"]>
    composites: {}
  }

  type ChartOfAccountGetPayload<S extends boolean | null | undefined | ChartOfAccountDefaultArgs> = $Result.GetResult<Prisma.$ChartOfAccountPayload, S>

  type ChartOfAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChartOfAccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChartOfAccountCountAggregateInputType | true
    }

  export interface ChartOfAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChartOfAccount'], meta: { name: 'ChartOfAccount' } }
    /**
     * Find zero or one ChartOfAccount that matches the filter.
     * @param {ChartOfAccountFindUniqueArgs} args - Arguments to find a ChartOfAccount
     * @example
     * // Get one ChartOfAccount
     * const chartOfAccount = await prisma.chartOfAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChartOfAccountFindUniqueArgs>(args: SelectSubset<T, ChartOfAccountFindUniqueArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChartOfAccount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChartOfAccountFindUniqueOrThrowArgs} args - Arguments to find a ChartOfAccount
     * @example
     * // Get one ChartOfAccount
     * const chartOfAccount = await prisma.chartOfAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChartOfAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, ChartOfAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChartOfAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartOfAccountFindFirstArgs} args - Arguments to find a ChartOfAccount
     * @example
     * // Get one ChartOfAccount
     * const chartOfAccount = await prisma.chartOfAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChartOfAccountFindFirstArgs>(args?: SelectSubset<T, ChartOfAccountFindFirstArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChartOfAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartOfAccountFindFirstOrThrowArgs} args - Arguments to find a ChartOfAccount
     * @example
     * // Get one ChartOfAccount
     * const chartOfAccount = await prisma.chartOfAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChartOfAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, ChartOfAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChartOfAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartOfAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChartOfAccounts
     * const chartOfAccounts = await prisma.chartOfAccount.findMany()
     * 
     * // Get first 10 ChartOfAccounts
     * const chartOfAccounts = await prisma.chartOfAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chartOfAccountWithIdOnly = await prisma.chartOfAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChartOfAccountFindManyArgs>(args?: SelectSubset<T, ChartOfAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChartOfAccount.
     * @param {ChartOfAccountCreateArgs} args - Arguments to create a ChartOfAccount.
     * @example
     * // Create one ChartOfAccount
     * const ChartOfAccount = await prisma.chartOfAccount.create({
     *   data: {
     *     // ... data to create a ChartOfAccount
     *   }
     * })
     * 
     */
    create<T extends ChartOfAccountCreateArgs>(args: SelectSubset<T, ChartOfAccountCreateArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChartOfAccounts.
     * @param {ChartOfAccountCreateManyArgs} args - Arguments to create many ChartOfAccounts.
     * @example
     * // Create many ChartOfAccounts
     * const chartOfAccount = await prisma.chartOfAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChartOfAccountCreateManyArgs>(args?: SelectSubset<T, ChartOfAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChartOfAccounts and returns the data saved in the database.
     * @param {ChartOfAccountCreateManyAndReturnArgs} args - Arguments to create many ChartOfAccounts.
     * @example
     * // Create many ChartOfAccounts
     * const chartOfAccount = await prisma.chartOfAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChartOfAccounts and only return the `id`
     * const chartOfAccountWithIdOnly = await prisma.chartOfAccount.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChartOfAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, ChartOfAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChartOfAccount.
     * @param {ChartOfAccountDeleteArgs} args - Arguments to delete one ChartOfAccount.
     * @example
     * // Delete one ChartOfAccount
     * const ChartOfAccount = await prisma.chartOfAccount.delete({
     *   where: {
     *     // ... filter to delete one ChartOfAccount
     *   }
     * })
     * 
     */
    delete<T extends ChartOfAccountDeleteArgs>(args: SelectSubset<T, ChartOfAccountDeleteArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChartOfAccount.
     * @param {ChartOfAccountUpdateArgs} args - Arguments to update one ChartOfAccount.
     * @example
     * // Update one ChartOfAccount
     * const chartOfAccount = await prisma.chartOfAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChartOfAccountUpdateArgs>(args: SelectSubset<T, ChartOfAccountUpdateArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChartOfAccounts.
     * @param {ChartOfAccountDeleteManyArgs} args - Arguments to filter ChartOfAccounts to delete.
     * @example
     * // Delete a few ChartOfAccounts
     * const { count } = await prisma.chartOfAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChartOfAccountDeleteManyArgs>(args?: SelectSubset<T, ChartOfAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChartOfAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartOfAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChartOfAccounts
     * const chartOfAccount = await prisma.chartOfAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChartOfAccountUpdateManyArgs>(args: SelectSubset<T, ChartOfAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChartOfAccount.
     * @param {ChartOfAccountUpsertArgs} args - Arguments to update or create a ChartOfAccount.
     * @example
     * // Update or create a ChartOfAccount
     * const chartOfAccount = await prisma.chartOfAccount.upsert({
     *   create: {
     *     // ... data to create a ChartOfAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChartOfAccount we want to update
     *   }
     * })
     */
    upsert<T extends ChartOfAccountUpsertArgs>(args: SelectSubset<T, ChartOfAccountUpsertArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChartOfAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartOfAccountCountArgs} args - Arguments to filter ChartOfAccounts to count.
     * @example
     * // Count the number of ChartOfAccounts
     * const count = await prisma.chartOfAccount.count({
     *   where: {
     *     // ... the filter for the ChartOfAccounts we want to count
     *   }
     * })
    **/
    count<T extends ChartOfAccountCountArgs>(
      args?: Subset<T, ChartOfAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChartOfAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChartOfAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartOfAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChartOfAccountAggregateArgs>(args: Subset<T, ChartOfAccountAggregateArgs>): Prisma.PrismaPromise<GetChartOfAccountAggregateType<T>>

    /**
     * Group by ChartOfAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChartOfAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChartOfAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChartOfAccountGroupByArgs['orderBy'] }
        : { orderBy?: ChartOfAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChartOfAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChartOfAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChartOfAccount model
   */
  readonly fields: ChartOfAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChartOfAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChartOfAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends ChartOfAccount$parentArgs<ExtArgs> = {}>(args?: Subset<T, ChartOfAccount$parentArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    children<T extends ChartOfAccount$childrenArgs<ExtArgs> = {}>(args?: Subset<T, ChartOfAccount$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "findMany"> | Null>
    journalLines<T extends ChartOfAccount$journalLinesArgs<ExtArgs> = {}>(args?: Subset<T, ChartOfAccount$journalLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findMany"> | Null>
    cashTransactionsGL<T extends ChartOfAccount$cashTransactionsGLArgs<ExtArgs> = {}>(args?: Subset<T, ChartOfAccount$cashTransactionsGLArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    cashTransactionsContra<T extends ChartOfAccount$cashTransactionsContraArgs<ExtArgs> = {}>(args?: Subset<T, ChartOfAccount$cashTransactionsContraArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    cashAccounts<T extends ChartOfAccount$cashAccountsArgs<ExtArgs> = {}>(args?: Subset<T, ChartOfAccount$cashAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashAccountPayload<ExtArgs>, T, "findMany"> | Null>
    assetCategoriesAsset<T extends ChartOfAccount$assetCategoriesAssetArgs<ExtArgs> = {}>(args?: Subset<T, ChartOfAccount$assetCategoriesAssetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    assetCategoriesDepreciation<T extends ChartOfAccount$assetCategoriesDepreciationArgs<ExtArgs> = {}>(args?: Subset<T, ChartOfAccount$assetCategoriesDepreciationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    assetCategoriesAccumulated<T extends ChartOfAccount$assetCategoriesAccumulatedArgs<ExtArgs> = {}>(args?: Subset<T, ChartOfAccount$assetCategoriesAccumulatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChartOfAccount model
   */ 
  interface ChartOfAccountFieldRefs {
    readonly id: FieldRef<"ChartOfAccount", 'String'>
    readonly code: FieldRef<"ChartOfAccount", 'String'>
    readonly name: FieldRef<"ChartOfAccount", 'String'>
    readonly description: FieldRef<"ChartOfAccount", 'String'>
    readonly accountType: FieldRef<"ChartOfAccount", 'String'>
    readonly parentId: FieldRef<"ChartOfAccount", 'String'>
    readonly isActive: FieldRef<"ChartOfAccount", 'Boolean'>
    readonly createdAt: FieldRef<"ChartOfAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChartOfAccount findUnique
   */
  export type ChartOfAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    /**
     * Filter, which ChartOfAccount to fetch.
     */
    where: ChartOfAccountWhereUniqueInput
  }

  /**
   * ChartOfAccount findUniqueOrThrow
   */
  export type ChartOfAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    /**
     * Filter, which ChartOfAccount to fetch.
     */
    where: ChartOfAccountWhereUniqueInput
  }

  /**
   * ChartOfAccount findFirst
   */
  export type ChartOfAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    /**
     * Filter, which ChartOfAccount to fetch.
     */
    where?: ChartOfAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartOfAccounts to fetch.
     */
    orderBy?: ChartOfAccountOrderByWithRelationInput | ChartOfAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChartOfAccounts.
     */
    cursor?: ChartOfAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartOfAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartOfAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChartOfAccounts.
     */
    distinct?: ChartOfAccountScalarFieldEnum | ChartOfAccountScalarFieldEnum[]
  }

  /**
   * ChartOfAccount findFirstOrThrow
   */
  export type ChartOfAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    /**
     * Filter, which ChartOfAccount to fetch.
     */
    where?: ChartOfAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartOfAccounts to fetch.
     */
    orderBy?: ChartOfAccountOrderByWithRelationInput | ChartOfAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChartOfAccounts.
     */
    cursor?: ChartOfAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartOfAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartOfAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChartOfAccounts.
     */
    distinct?: ChartOfAccountScalarFieldEnum | ChartOfAccountScalarFieldEnum[]
  }

  /**
   * ChartOfAccount findMany
   */
  export type ChartOfAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    /**
     * Filter, which ChartOfAccounts to fetch.
     */
    where?: ChartOfAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChartOfAccounts to fetch.
     */
    orderBy?: ChartOfAccountOrderByWithRelationInput | ChartOfAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChartOfAccounts.
     */
    cursor?: ChartOfAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChartOfAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChartOfAccounts.
     */
    skip?: number
    distinct?: ChartOfAccountScalarFieldEnum | ChartOfAccountScalarFieldEnum[]
  }

  /**
   * ChartOfAccount create
   */
  export type ChartOfAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a ChartOfAccount.
     */
    data: XOR<ChartOfAccountCreateInput, ChartOfAccountUncheckedCreateInput>
  }

  /**
   * ChartOfAccount createMany
   */
  export type ChartOfAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChartOfAccounts.
     */
    data: ChartOfAccountCreateManyInput | ChartOfAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChartOfAccount createManyAndReturn
   */
  export type ChartOfAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChartOfAccounts.
     */
    data: ChartOfAccountCreateManyInput | ChartOfAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChartOfAccount update
   */
  export type ChartOfAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a ChartOfAccount.
     */
    data: XOR<ChartOfAccountUpdateInput, ChartOfAccountUncheckedUpdateInput>
    /**
     * Choose, which ChartOfAccount to update.
     */
    where: ChartOfAccountWhereUniqueInput
  }

  /**
   * ChartOfAccount updateMany
   */
  export type ChartOfAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChartOfAccounts.
     */
    data: XOR<ChartOfAccountUpdateManyMutationInput, ChartOfAccountUncheckedUpdateManyInput>
    /**
     * Filter which ChartOfAccounts to update
     */
    where?: ChartOfAccountWhereInput
  }

  /**
   * ChartOfAccount upsert
   */
  export type ChartOfAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the ChartOfAccount to update in case it exists.
     */
    where: ChartOfAccountWhereUniqueInput
    /**
     * In case the ChartOfAccount found by the `where` argument doesn't exist, create a new ChartOfAccount with this data.
     */
    create: XOR<ChartOfAccountCreateInput, ChartOfAccountUncheckedCreateInput>
    /**
     * In case the ChartOfAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChartOfAccountUpdateInput, ChartOfAccountUncheckedUpdateInput>
  }

  /**
   * ChartOfAccount delete
   */
  export type ChartOfAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    /**
     * Filter which ChartOfAccount to delete.
     */
    where: ChartOfAccountWhereUniqueInput
  }

  /**
   * ChartOfAccount deleteMany
   */
  export type ChartOfAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChartOfAccounts to delete
     */
    where?: ChartOfAccountWhereInput
  }

  /**
   * ChartOfAccount.parent
   */
  export type ChartOfAccount$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    where?: ChartOfAccountWhereInput
  }

  /**
   * ChartOfAccount.children
   */
  export type ChartOfAccount$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    where?: ChartOfAccountWhereInput
    orderBy?: ChartOfAccountOrderByWithRelationInput | ChartOfAccountOrderByWithRelationInput[]
    cursor?: ChartOfAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChartOfAccountScalarFieldEnum | ChartOfAccountScalarFieldEnum[]
  }

  /**
   * ChartOfAccount.journalLines
   */
  export type ChartOfAccount$journalLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    where?: JournalLineWhereInput
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    cursor?: JournalLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * ChartOfAccount.cashTransactionsGL
   */
  export type ChartOfAccount$cashTransactionsGLArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    where?: CashTransactionWhereInput
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    cursor?: CashTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashTransactionScalarFieldEnum | CashTransactionScalarFieldEnum[]
  }

  /**
   * ChartOfAccount.cashTransactionsContra
   */
  export type ChartOfAccount$cashTransactionsContraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    where?: CashTransactionWhereInput
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    cursor?: CashTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashTransactionScalarFieldEnum | CashTransactionScalarFieldEnum[]
  }

  /**
   * ChartOfAccount.cashAccounts
   */
  export type ChartOfAccount$cashAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashAccount
     */
    select?: CashAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashAccountInclude<ExtArgs> | null
    where?: CashAccountWhereInput
    orderBy?: CashAccountOrderByWithRelationInput | CashAccountOrderByWithRelationInput[]
    cursor?: CashAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashAccountScalarFieldEnum | CashAccountScalarFieldEnum[]
  }

  /**
   * ChartOfAccount.assetCategoriesAsset
   */
  export type ChartOfAccount$assetCategoriesAssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetCategory
     */
    select?: AssetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCategoryInclude<ExtArgs> | null
    where?: AssetCategoryWhereInput
    orderBy?: AssetCategoryOrderByWithRelationInput | AssetCategoryOrderByWithRelationInput[]
    cursor?: AssetCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetCategoryScalarFieldEnum | AssetCategoryScalarFieldEnum[]
  }

  /**
   * ChartOfAccount.assetCategoriesDepreciation
   */
  export type ChartOfAccount$assetCategoriesDepreciationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetCategory
     */
    select?: AssetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCategoryInclude<ExtArgs> | null
    where?: AssetCategoryWhereInput
    orderBy?: AssetCategoryOrderByWithRelationInput | AssetCategoryOrderByWithRelationInput[]
    cursor?: AssetCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetCategoryScalarFieldEnum | AssetCategoryScalarFieldEnum[]
  }

  /**
   * ChartOfAccount.assetCategoriesAccumulated
   */
  export type ChartOfAccount$assetCategoriesAccumulatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetCategory
     */
    select?: AssetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCategoryInclude<ExtArgs> | null
    where?: AssetCategoryWhereInput
    orderBy?: AssetCategoryOrderByWithRelationInput | AssetCategoryOrderByWithRelationInput[]
    cursor?: AssetCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetCategoryScalarFieldEnum | AssetCategoryScalarFieldEnum[]
  }

  /**
   * ChartOfAccount without action
   */
  export type ChartOfAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
  }


  /**
   * Model Journal
   */

  export type AggregateJournal = {
    _count: JournalCountAggregateOutputType | null
    _min: JournalMinAggregateOutputType | null
    _max: JournalMaxAggregateOutputType | null
  }

  export type JournalMinAggregateOutputType = {
    id: string | null
    journalNo: string | null
    date: Date | null
    memo: string | null
    postedBy: string | null
    postedAt: Date | null
  }

  export type JournalMaxAggregateOutputType = {
    id: string | null
    journalNo: string | null
    date: Date | null
    memo: string | null
    postedBy: string | null
    postedAt: Date | null
  }

  export type JournalCountAggregateOutputType = {
    id: number
    journalNo: number
    date: number
    memo: number
    postedBy: number
    postedAt: number
    _all: number
  }


  export type JournalMinAggregateInputType = {
    id?: true
    journalNo?: true
    date?: true
    memo?: true
    postedBy?: true
    postedAt?: true
  }

  export type JournalMaxAggregateInputType = {
    id?: true
    journalNo?: true
    date?: true
    memo?: true
    postedBy?: true
    postedAt?: true
  }

  export type JournalCountAggregateInputType = {
    id?: true
    journalNo?: true
    date?: true
    memo?: true
    postedBy?: true
    postedAt?: true
    _all?: true
  }

  export type JournalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Journal to aggregate.
     */
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Journals
    **/
    _count?: true | JournalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalMaxAggregateInputType
  }

  export type GetJournalAggregateType<T extends JournalAggregateArgs> = {
        [P in keyof T & keyof AggregateJournal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournal[P]>
      : GetScalarType<T[P], AggregateJournal[P]>
  }




  export type JournalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalWhereInput
    orderBy?: JournalOrderByWithAggregationInput | JournalOrderByWithAggregationInput[]
    by: JournalScalarFieldEnum[] | JournalScalarFieldEnum
    having?: JournalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalCountAggregateInputType | true
    _min?: JournalMinAggregateInputType
    _max?: JournalMaxAggregateInputType
  }

  export type JournalGroupByOutputType = {
    id: string
    journalNo: string
    date: Date
    memo: string | null
    postedBy: string
    postedAt: Date
    _count: JournalCountAggregateOutputType | null
    _min: JournalMinAggregateOutputType | null
    _max: JournalMaxAggregateOutputType | null
  }

  type GetJournalGroupByPayload<T extends JournalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalGroupByOutputType[P]>
            : GetScalarType<T[P], JournalGroupByOutputType[P]>
        }
      >
    >


  export type JournalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalNo?: boolean
    date?: boolean
    memo?: boolean
    postedBy?: boolean
    postedAt?: boolean
    postedByUser?: boolean | UserDefaultArgs<ExtArgs>
    journalLines?: boolean | Journal$journalLinesArgs<ExtArgs>
    assetDepreciation?: boolean | Journal$assetDepreciationArgs<ExtArgs>
    assetDisposals?: boolean | Journal$assetDisposalsArgs<ExtArgs>
    _count?: boolean | JournalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journal"]>

  export type JournalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalNo?: boolean
    date?: boolean
    memo?: boolean
    postedBy?: boolean
    postedAt?: boolean
    postedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journal"]>

  export type JournalSelectScalar = {
    id?: boolean
    journalNo?: boolean
    date?: boolean
    memo?: boolean
    postedBy?: boolean
    postedAt?: boolean
  }

  export type JournalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    postedByUser?: boolean | UserDefaultArgs<ExtArgs>
    journalLines?: boolean | Journal$journalLinesArgs<ExtArgs>
    assetDepreciation?: boolean | Journal$assetDepreciationArgs<ExtArgs>
    assetDisposals?: boolean | Journal$assetDisposalsArgs<ExtArgs>
    _count?: boolean | JournalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JournalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    postedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $JournalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Journal"
    objects: {
      postedByUser: Prisma.$UserPayload<ExtArgs>
      journalLines: Prisma.$JournalLinePayload<ExtArgs>[]
      assetDepreciation: Prisma.$AssetDepreciationPayload<ExtArgs>[]
      assetDisposals: Prisma.$AssetDisposalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      journalNo: string
      date: Date
      memo: string | null
      postedBy: string
      postedAt: Date
    }, ExtArgs["result"]["journal"]>
    composites: {}
  }

  type JournalGetPayload<S extends boolean | null | undefined | JournalDefaultArgs> = $Result.GetResult<Prisma.$JournalPayload, S>

  type JournalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JournalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JournalCountAggregateInputType | true
    }

  export interface JournalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Journal'], meta: { name: 'Journal' } }
    /**
     * Find zero or one Journal that matches the filter.
     * @param {JournalFindUniqueArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalFindUniqueArgs>(args: SelectSubset<T, JournalFindUniqueArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Journal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JournalFindUniqueOrThrowArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Journal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFindFirstArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalFindFirstArgs>(args?: SelectSubset<T, JournalFindFirstArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Journal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFindFirstOrThrowArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Journals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Journals
     * const journals = await prisma.journal.findMany()
     * 
     * // Get first 10 Journals
     * const journals = await prisma.journal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalWithIdOnly = await prisma.journal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalFindManyArgs>(args?: SelectSubset<T, JournalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Journal.
     * @param {JournalCreateArgs} args - Arguments to create a Journal.
     * @example
     * // Create one Journal
     * const Journal = await prisma.journal.create({
     *   data: {
     *     // ... data to create a Journal
     *   }
     * })
     * 
     */
    create<T extends JournalCreateArgs>(args: SelectSubset<T, JournalCreateArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Journals.
     * @param {JournalCreateManyArgs} args - Arguments to create many Journals.
     * @example
     * // Create many Journals
     * const journal = await prisma.journal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalCreateManyArgs>(args?: SelectSubset<T, JournalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Journals and returns the data saved in the database.
     * @param {JournalCreateManyAndReturnArgs} args - Arguments to create many Journals.
     * @example
     * // Create many Journals
     * const journal = await prisma.journal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Journals and only return the `id`
     * const journalWithIdOnly = await prisma.journal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Journal.
     * @param {JournalDeleteArgs} args - Arguments to delete one Journal.
     * @example
     * // Delete one Journal
     * const Journal = await prisma.journal.delete({
     *   where: {
     *     // ... filter to delete one Journal
     *   }
     * })
     * 
     */
    delete<T extends JournalDeleteArgs>(args: SelectSubset<T, JournalDeleteArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Journal.
     * @param {JournalUpdateArgs} args - Arguments to update one Journal.
     * @example
     * // Update one Journal
     * const journal = await prisma.journal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalUpdateArgs>(args: SelectSubset<T, JournalUpdateArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Journals.
     * @param {JournalDeleteManyArgs} args - Arguments to filter Journals to delete.
     * @example
     * // Delete a few Journals
     * const { count } = await prisma.journal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalDeleteManyArgs>(args?: SelectSubset<T, JournalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Journals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Journals
     * const journal = await prisma.journal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalUpdateManyArgs>(args: SelectSubset<T, JournalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Journal.
     * @param {JournalUpsertArgs} args - Arguments to update or create a Journal.
     * @example
     * // Update or create a Journal
     * const journal = await prisma.journal.upsert({
     *   create: {
     *     // ... data to create a Journal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Journal we want to update
     *   }
     * })
     */
    upsert<T extends JournalUpsertArgs>(args: SelectSubset<T, JournalUpsertArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Journals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalCountArgs} args - Arguments to filter Journals to count.
     * @example
     * // Count the number of Journals
     * const count = await prisma.journal.count({
     *   where: {
     *     // ... the filter for the Journals we want to count
     *   }
     * })
    **/
    count<T extends JournalCountArgs>(
      args?: Subset<T, JournalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Journal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalAggregateArgs>(args: Subset<T, JournalAggregateArgs>): Prisma.PrismaPromise<GetJournalAggregateType<T>>

    /**
     * Group by Journal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalGroupByArgs['orderBy'] }
        : { orderBy?: JournalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Journal model
   */
  readonly fields: JournalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Journal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    postedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    journalLines<T extends Journal$journalLinesArgs<ExtArgs> = {}>(args?: Subset<T, Journal$journalLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findMany"> | Null>
    assetDepreciation<T extends Journal$assetDepreciationArgs<ExtArgs> = {}>(args?: Subset<T, Journal$assetDepreciationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetDepreciationPayload<ExtArgs>, T, "findMany"> | Null>
    assetDisposals<T extends Journal$assetDisposalsArgs<ExtArgs> = {}>(args?: Subset<T, Journal$assetDisposalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetDisposalPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Journal model
   */ 
  interface JournalFieldRefs {
    readonly id: FieldRef<"Journal", 'String'>
    readonly journalNo: FieldRef<"Journal", 'String'>
    readonly date: FieldRef<"Journal", 'DateTime'>
    readonly memo: FieldRef<"Journal", 'String'>
    readonly postedBy: FieldRef<"Journal", 'String'>
    readonly postedAt: FieldRef<"Journal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Journal findUnique
   */
  export type JournalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journal to fetch.
     */
    where: JournalWhereUniqueInput
  }

  /**
   * Journal findUniqueOrThrow
   */
  export type JournalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journal to fetch.
     */
    where: JournalWhereUniqueInput
  }

  /**
   * Journal findFirst
   */
  export type JournalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journal to fetch.
     */
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Journals.
     */
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Journals.
     */
    distinct?: JournalScalarFieldEnum | JournalScalarFieldEnum[]
  }

  /**
   * Journal findFirstOrThrow
   */
  export type JournalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journal to fetch.
     */
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Journals.
     */
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Journals.
     */
    distinct?: JournalScalarFieldEnum | JournalScalarFieldEnum[]
  }

  /**
   * Journal findMany
   */
  export type JournalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journals to fetch.
     */
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Journals.
     */
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    distinct?: JournalScalarFieldEnum | JournalScalarFieldEnum[]
  }

  /**
   * Journal create
   */
  export type JournalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * The data needed to create a Journal.
     */
    data: XOR<JournalCreateInput, JournalUncheckedCreateInput>
  }

  /**
   * Journal createMany
   */
  export type JournalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Journals.
     */
    data: JournalCreateManyInput | JournalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Journal createManyAndReturn
   */
  export type JournalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Journals.
     */
    data: JournalCreateManyInput | JournalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Journal update
   */
  export type JournalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * The data needed to update a Journal.
     */
    data: XOR<JournalUpdateInput, JournalUncheckedUpdateInput>
    /**
     * Choose, which Journal to update.
     */
    where: JournalWhereUniqueInput
  }

  /**
   * Journal updateMany
   */
  export type JournalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Journals.
     */
    data: XOR<JournalUpdateManyMutationInput, JournalUncheckedUpdateManyInput>
    /**
     * Filter which Journals to update
     */
    where?: JournalWhereInput
  }

  /**
   * Journal upsert
   */
  export type JournalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * The filter to search for the Journal to update in case it exists.
     */
    where: JournalWhereUniqueInput
    /**
     * In case the Journal found by the `where` argument doesn't exist, create a new Journal with this data.
     */
    create: XOR<JournalCreateInput, JournalUncheckedCreateInput>
    /**
     * In case the Journal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalUpdateInput, JournalUncheckedUpdateInput>
  }

  /**
   * Journal delete
   */
  export type JournalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter which Journal to delete.
     */
    where: JournalWhereUniqueInput
  }

  /**
   * Journal deleteMany
   */
  export type JournalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Journals to delete
     */
    where?: JournalWhereInput
  }

  /**
   * Journal.journalLines
   */
  export type Journal$journalLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    where?: JournalLineWhereInput
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    cursor?: JournalLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * Journal.assetDepreciation
   */
  export type Journal$assetDepreciationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDepreciation
     */
    select?: AssetDepreciationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDepreciationInclude<ExtArgs> | null
    where?: AssetDepreciationWhereInput
    orderBy?: AssetDepreciationOrderByWithRelationInput | AssetDepreciationOrderByWithRelationInput[]
    cursor?: AssetDepreciationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetDepreciationScalarFieldEnum | AssetDepreciationScalarFieldEnum[]
  }

  /**
   * Journal.assetDisposals
   */
  export type Journal$assetDisposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDisposal
     */
    select?: AssetDisposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDisposalInclude<ExtArgs> | null
    where?: AssetDisposalWhereInput
    orderBy?: AssetDisposalOrderByWithRelationInput | AssetDisposalOrderByWithRelationInput[]
    cursor?: AssetDisposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetDisposalScalarFieldEnum | AssetDisposalScalarFieldEnum[]
  }

  /**
   * Journal without action
   */
  export type JournalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
  }


  /**
   * Model JournalLine
   */

  export type AggregateJournalLine = {
    _count: JournalLineCountAggregateOutputType | null
    _avg: JournalLineAvgAggregateOutputType | null
    _sum: JournalLineSumAggregateOutputType | null
    _min: JournalLineMinAggregateOutputType | null
    _max: JournalLineMaxAggregateOutputType | null
  }

  export type JournalLineAvgAggregateOutputType = {
    debit: Decimal | null
    credit: Decimal | null
  }

  export type JournalLineSumAggregateOutputType = {
    debit: Decimal | null
    credit: Decimal | null
  }

  export type JournalLineMinAggregateOutputType = {
    id: string | null
    journalId: string | null
    accountId: string | null
    debit: Decimal | null
    credit: Decimal | null
    refType: string | null
    refId: string | null
  }

  export type JournalLineMaxAggregateOutputType = {
    id: string | null
    journalId: string | null
    accountId: string | null
    debit: Decimal | null
    credit: Decimal | null
    refType: string | null
    refId: string | null
  }

  export type JournalLineCountAggregateOutputType = {
    id: number
    journalId: number
    accountId: number
    debit: number
    credit: number
    refType: number
    refId: number
    _all: number
  }


  export type JournalLineAvgAggregateInputType = {
    debit?: true
    credit?: true
  }

  export type JournalLineSumAggregateInputType = {
    debit?: true
    credit?: true
  }

  export type JournalLineMinAggregateInputType = {
    id?: true
    journalId?: true
    accountId?: true
    debit?: true
    credit?: true
    refType?: true
    refId?: true
  }

  export type JournalLineMaxAggregateInputType = {
    id?: true
    journalId?: true
    accountId?: true
    debit?: true
    credit?: true
    refType?: true
    refId?: true
  }

  export type JournalLineCountAggregateInputType = {
    id?: true
    journalId?: true
    accountId?: true
    debit?: true
    credit?: true
    refType?: true
    refId?: true
    _all?: true
  }

  export type JournalLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalLine to aggregate.
     */
    where?: JournalLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLines to fetch.
     */
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalLines
    **/
    _count?: true | JournalLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JournalLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JournalLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalLineMaxAggregateInputType
  }

  export type GetJournalLineAggregateType<T extends JournalLineAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalLine[P]>
      : GetScalarType<T[P], AggregateJournalLine[P]>
  }




  export type JournalLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalLineWhereInput
    orderBy?: JournalLineOrderByWithAggregationInput | JournalLineOrderByWithAggregationInput[]
    by: JournalLineScalarFieldEnum[] | JournalLineScalarFieldEnum
    having?: JournalLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalLineCountAggregateInputType | true
    _avg?: JournalLineAvgAggregateInputType
    _sum?: JournalLineSumAggregateInputType
    _min?: JournalLineMinAggregateInputType
    _max?: JournalLineMaxAggregateInputType
  }

  export type JournalLineGroupByOutputType = {
    id: string
    journalId: string
    accountId: string
    debit: Decimal
    credit: Decimal
    refType: string | null
    refId: string | null
    _count: JournalLineCountAggregateOutputType | null
    _avg: JournalLineAvgAggregateOutputType | null
    _sum: JournalLineSumAggregateOutputType | null
    _min: JournalLineMinAggregateOutputType | null
    _max: JournalLineMaxAggregateOutputType | null
  }

  type GetJournalLineGroupByPayload<T extends JournalLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalLineGroupByOutputType[P]>
            : GetScalarType<T[P], JournalLineGroupByOutputType[P]>
        }
      >
    >


  export type JournalLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    accountId?: boolean
    debit?: boolean
    credit?: boolean
    refType?: boolean
    refId?: boolean
    journal?: boolean | JournalDefaultArgs<ExtArgs>
    account?: boolean | ChartOfAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalLine"]>

  export type JournalLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    accountId?: boolean
    debit?: boolean
    credit?: boolean
    refType?: boolean
    refId?: boolean
    journal?: boolean | JournalDefaultArgs<ExtArgs>
    account?: boolean | ChartOfAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalLine"]>

  export type JournalLineSelectScalar = {
    id?: boolean
    journalId?: boolean
    accountId?: boolean
    debit?: boolean
    credit?: boolean
    refType?: boolean
    refId?: boolean
  }

  export type JournalLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journal?: boolean | JournalDefaultArgs<ExtArgs>
    account?: boolean | ChartOfAccountDefaultArgs<ExtArgs>
  }
  export type JournalLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journal?: boolean | JournalDefaultArgs<ExtArgs>
    account?: boolean | ChartOfAccountDefaultArgs<ExtArgs>
  }

  export type $JournalLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalLine"
    objects: {
      journal: Prisma.$JournalPayload<ExtArgs>
      account: Prisma.$ChartOfAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      journalId: string
      accountId: string
      debit: Prisma.Decimal
      credit: Prisma.Decimal
      refType: string | null
      refId: string | null
    }, ExtArgs["result"]["journalLine"]>
    composites: {}
  }

  type JournalLineGetPayload<S extends boolean | null | undefined | JournalLineDefaultArgs> = $Result.GetResult<Prisma.$JournalLinePayload, S>

  type JournalLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JournalLineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JournalLineCountAggregateInputType | true
    }

  export interface JournalLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalLine'], meta: { name: 'JournalLine' } }
    /**
     * Find zero or one JournalLine that matches the filter.
     * @param {JournalLineFindUniqueArgs} args - Arguments to find a JournalLine
     * @example
     * // Get one JournalLine
     * const journalLine = await prisma.journalLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalLineFindUniqueArgs>(args: SelectSubset<T, JournalLineFindUniqueArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one JournalLine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JournalLineFindUniqueOrThrowArgs} args - Arguments to find a JournalLine
     * @example
     * // Get one JournalLine
     * const journalLine = await prisma.journalLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalLineFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first JournalLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineFindFirstArgs} args - Arguments to find a JournalLine
     * @example
     * // Get one JournalLine
     * const journalLine = await prisma.journalLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalLineFindFirstArgs>(args?: SelectSubset<T, JournalLineFindFirstArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first JournalLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineFindFirstOrThrowArgs} args - Arguments to find a JournalLine
     * @example
     * // Get one JournalLine
     * const journalLine = await prisma.journalLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalLineFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more JournalLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalLines
     * const journalLines = await prisma.journalLine.findMany()
     * 
     * // Get first 10 JournalLines
     * const journalLines = await prisma.journalLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalLineWithIdOnly = await prisma.journalLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalLineFindManyArgs>(args?: SelectSubset<T, JournalLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a JournalLine.
     * @param {JournalLineCreateArgs} args - Arguments to create a JournalLine.
     * @example
     * // Create one JournalLine
     * const JournalLine = await prisma.journalLine.create({
     *   data: {
     *     // ... data to create a JournalLine
     *   }
     * })
     * 
     */
    create<T extends JournalLineCreateArgs>(args: SelectSubset<T, JournalLineCreateArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many JournalLines.
     * @param {JournalLineCreateManyArgs} args - Arguments to create many JournalLines.
     * @example
     * // Create many JournalLines
     * const journalLine = await prisma.journalLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalLineCreateManyArgs>(args?: SelectSubset<T, JournalLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalLines and returns the data saved in the database.
     * @param {JournalLineCreateManyAndReturnArgs} args - Arguments to create many JournalLines.
     * @example
     * // Create many JournalLines
     * const journalLine = await prisma.journalLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalLines and only return the `id`
     * const journalLineWithIdOnly = await prisma.journalLine.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalLineCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a JournalLine.
     * @param {JournalLineDeleteArgs} args - Arguments to delete one JournalLine.
     * @example
     * // Delete one JournalLine
     * const JournalLine = await prisma.journalLine.delete({
     *   where: {
     *     // ... filter to delete one JournalLine
     *   }
     * })
     * 
     */
    delete<T extends JournalLineDeleteArgs>(args: SelectSubset<T, JournalLineDeleteArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one JournalLine.
     * @param {JournalLineUpdateArgs} args - Arguments to update one JournalLine.
     * @example
     * // Update one JournalLine
     * const journalLine = await prisma.journalLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalLineUpdateArgs>(args: SelectSubset<T, JournalLineUpdateArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more JournalLines.
     * @param {JournalLineDeleteManyArgs} args - Arguments to filter JournalLines to delete.
     * @example
     * // Delete a few JournalLines
     * const { count } = await prisma.journalLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalLineDeleteManyArgs>(args?: SelectSubset<T, JournalLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalLines
     * const journalLine = await prisma.journalLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalLineUpdateManyArgs>(args: SelectSubset<T, JournalLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JournalLine.
     * @param {JournalLineUpsertArgs} args - Arguments to update or create a JournalLine.
     * @example
     * // Update or create a JournalLine
     * const journalLine = await prisma.journalLine.upsert({
     *   create: {
     *     // ... data to create a JournalLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalLine we want to update
     *   }
     * })
     */
    upsert<T extends JournalLineUpsertArgs>(args: SelectSubset<T, JournalLineUpsertArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of JournalLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineCountArgs} args - Arguments to filter JournalLines to count.
     * @example
     * // Count the number of JournalLines
     * const count = await prisma.journalLine.count({
     *   where: {
     *     // ... the filter for the JournalLines we want to count
     *   }
     * })
    **/
    count<T extends JournalLineCountArgs>(
      args?: Subset<T, JournalLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalLineAggregateArgs>(args: Subset<T, JournalLineAggregateArgs>): Prisma.PrismaPromise<GetJournalLineAggregateType<T>>

    /**
     * Group by JournalLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalLineGroupByArgs['orderBy'] }
        : { orderBy?: JournalLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalLine model
   */
  readonly fields: JournalLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    journal<T extends JournalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JournalDefaultArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    account<T extends ChartOfAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChartOfAccountDefaultArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalLine model
   */ 
  interface JournalLineFieldRefs {
    readonly id: FieldRef<"JournalLine", 'String'>
    readonly journalId: FieldRef<"JournalLine", 'String'>
    readonly accountId: FieldRef<"JournalLine", 'String'>
    readonly debit: FieldRef<"JournalLine", 'Decimal'>
    readonly credit: FieldRef<"JournalLine", 'Decimal'>
    readonly refType: FieldRef<"JournalLine", 'String'>
    readonly refId: FieldRef<"JournalLine", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JournalLine findUnique
   */
  export type JournalLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLine to fetch.
     */
    where: JournalLineWhereUniqueInput
  }

  /**
   * JournalLine findUniqueOrThrow
   */
  export type JournalLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLine to fetch.
     */
    where: JournalLineWhereUniqueInput
  }

  /**
   * JournalLine findFirst
   */
  export type JournalLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLine to fetch.
     */
    where?: JournalLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLines to fetch.
     */
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalLines.
     */
    cursor?: JournalLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalLines.
     */
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * JournalLine findFirstOrThrow
   */
  export type JournalLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLine to fetch.
     */
    where?: JournalLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLines to fetch.
     */
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalLines.
     */
    cursor?: JournalLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalLines.
     */
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * JournalLine findMany
   */
  export type JournalLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLines to fetch.
     */
    where?: JournalLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLines to fetch.
     */
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalLines.
     */
    cursor?: JournalLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLines.
     */
    skip?: number
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * JournalLine create
   */
  export type JournalLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalLine.
     */
    data: XOR<JournalLineCreateInput, JournalLineUncheckedCreateInput>
  }

  /**
   * JournalLine createMany
   */
  export type JournalLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalLines.
     */
    data: JournalLineCreateManyInput | JournalLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalLine createManyAndReturn
   */
  export type JournalLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many JournalLines.
     */
    data: JournalLineCreateManyInput | JournalLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalLine update
   */
  export type JournalLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalLine.
     */
    data: XOR<JournalLineUpdateInput, JournalLineUncheckedUpdateInput>
    /**
     * Choose, which JournalLine to update.
     */
    where: JournalLineWhereUniqueInput
  }

  /**
   * JournalLine updateMany
   */
  export type JournalLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalLines.
     */
    data: XOR<JournalLineUpdateManyMutationInput, JournalLineUncheckedUpdateManyInput>
    /**
     * Filter which JournalLines to update
     */
    where?: JournalLineWhereInput
  }

  /**
   * JournalLine upsert
   */
  export type JournalLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalLine to update in case it exists.
     */
    where: JournalLineWhereUniqueInput
    /**
     * In case the JournalLine found by the `where` argument doesn't exist, create a new JournalLine with this data.
     */
    create: XOR<JournalLineCreateInput, JournalLineUncheckedCreateInput>
    /**
     * In case the JournalLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalLineUpdateInput, JournalLineUncheckedUpdateInput>
  }

  /**
   * JournalLine delete
   */
  export type JournalLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter which JournalLine to delete.
     */
    where: JournalLineWhereUniqueInput
  }

  /**
   * JournalLine deleteMany
   */
  export type JournalLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalLines to delete
     */
    where?: JournalLineWhereInput
  }

  /**
   * JournalLine without action
   */
  export type JournalLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
  }


  /**
   * Model Policy
   */

  export type AggregatePolicy = {
    _count: PolicyCountAggregateOutputType | null
    _min: PolicyMinAggregateOutputType | null
    _max: PolicyMaxAggregateOutputType | null
  }

  export type PolicyMinAggregateOutputType = {
    id: string | null
    key: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PolicyMaxAggregateOutputType = {
    id: string | null
    key: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PolicyCountAggregateOutputType = {
    id: number
    key: number
    valueJson: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PolicyMinAggregateInputType = {
    id?: true
    key?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PolicyMaxAggregateInputType = {
    id?: true
    key?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PolicyCountAggregateInputType = {
    id?: true
    key?: true
    valueJson?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Policy to aggregate.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Policies
    **/
    _count?: true | PolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PolicyMaxAggregateInputType
  }

  export type GetPolicyAggregateType<T extends PolicyAggregateArgs> = {
        [P in keyof T & keyof AggregatePolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolicy[P]>
      : GetScalarType<T[P], AggregatePolicy[P]>
  }




  export type PolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PolicyWhereInput
    orderBy?: PolicyOrderByWithAggregationInput | PolicyOrderByWithAggregationInput[]
    by: PolicyScalarFieldEnum[] | PolicyScalarFieldEnum
    having?: PolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PolicyCountAggregateInputType | true
    _min?: PolicyMinAggregateInputType
    _max?: PolicyMaxAggregateInputType
  }

  export type PolicyGroupByOutputType = {
    id: string
    key: string
    valueJson: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: PolicyCountAggregateOutputType | null
    _min: PolicyMinAggregateOutputType | null
    _max: PolicyMaxAggregateOutputType | null
  }

  type GetPolicyGroupByPayload<T extends PolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PolicyGroupByOutputType[P]>
            : GetScalarType<T[P], PolicyGroupByOutputType[P]>
        }
      >
    >


  export type PolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    valueJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["policy"]>

  export type PolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    valueJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["policy"]>

  export type PolicySelectScalar = {
    id?: boolean
    key?: boolean
    valueJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $PolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Policy"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      valueJson: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["policy"]>
    composites: {}
  }

  type PolicyGetPayload<S extends boolean | null | undefined | PolicyDefaultArgs> = $Result.GetResult<Prisma.$PolicyPayload, S>

  type PolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PolicyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PolicyCountAggregateInputType | true
    }

  export interface PolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Policy'], meta: { name: 'Policy' } }
    /**
     * Find zero or one Policy that matches the filter.
     * @param {PolicyFindUniqueArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PolicyFindUniqueArgs>(args: SelectSubset<T, PolicyFindUniqueArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Policy that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PolicyFindUniqueOrThrowArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, PolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Policy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindFirstArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PolicyFindFirstArgs>(args?: SelectSubset<T, PolicyFindFirstArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Policy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindFirstOrThrowArgs} args - Arguments to find a Policy
     * @example
     * // Get one Policy
     * const policy = await prisma.policy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, PolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Policies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Policies
     * const policies = await prisma.policy.findMany()
     * 
     * // Get first 10 Policies
     * const policies = await prisma.policy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const policyWithIdOnly = await prisma.policy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PolicyFindManyArgs>(args?: SelectSubset<T, PolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Policy.
     * @param {PolicyCreateArgs} args - Arguments to create a Policy.
     * @example
     * // Create one Policy
     * const Policy = await prisma.policy.create({
     *   data: {
     *     // ... data to create a Policy
     *   }
     * })
     * 
     */
    create<T extends PolicyCreateArgs>(args: SelectSubset<T, PolicyCreateArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Policies.
     * @param {PolicyCreateManyArgs} args - Arguments to create many Policies.
     * @example
     * // Create many Policies
     * const policy = await prisma.policy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PolicyCreateManyArgs>(args?: SelectSubset<T, PolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Policies and returns the data saved in the database.
     * @param {PolicyCreateManyAndReturnArgs} args - Arguments to create many Policies.
     * @example
     * // Create many Policies
     * const policy = await prisma.policy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Policies and only return the `id`
     * const policyWithIdOnly = await prisma.policy.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, PolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Policy.
     * @param {PolicyDeleteArgs} args - Arguments to delete one Policy.
     * @example
     * // Delete one Policy
     * const Policy = await prisma.policy.delete({
     *   where: {
     *     // ... filter to delete one Policy
     *   }
     * })
     * 
     */
    delete<T extends PolicyDeleteArgs>(args: SelectSubset<T, PolicyDeleteArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Policy.
     * @param {PolicyUpdateArgs} args - Arguments to update one Policy.
     * @example
     * // Update one Policy
     * const policy = await prisma.policy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PolicyUpdateArgs>(args: SelectSubset<T, PolicyUpdateArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Policies.
     * @param {PolicyDeleteManyArgs} args - Arguments to filter Policies to delete.
     * @example
     * // Delete a few Policies
     * const { count } = await prisma.policy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PolicyDeleteManyArgs>(args?: SelectSubset<T, PolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Policies
     * const policy = await prisma.policy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PolicyUpdateManyArgs>(args: SelectSubset<T, PolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Policy.
     * @param {PolicyUpsertArgs} args - Arguments to update or create a Policy.
     * @example
     * // Update or create a Policy
     * const policy = await prisma.policy.upsert({
     *   create: {
     *     // ... data to create a Policy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Policy we want to update
     *   }
     * })
     */
    upsert<T extends PolicyUpsertArgs>(args: SelectSubset<T, PolicyUpsertArgs<ExtArgs>>): Prisma__PolicyClient<$Result.GetResult<Prisma.$PolicyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyCountArgs} args - Arguments to filter Policies to count.
     * @example
     * // Count the number of Policies
     * const count = await prisma.policy.count({
     *   where: {
     *     // ... the filter for the Policies we want to count
     *   }
     * })
    **/
    count<T extends PolicyCountArgs>(
      args?: Subset<T, PolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Policy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PolicyAggregateArgs>(args: Subset<T, PolicyAggregateArgs>): Prisma.PrismaPromise<GetPolicyAggregateType<T>>

    /**
     * Group by Policy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PolicyGroupByArgs['orderBy'] }
        : { orderBy?: PolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Policy model
   */
  readonly fields: PolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Policy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Policy model
   */ 
  interface PolicyFieldRefs {
    readonly id: FieldRef<"Policy", 'String'>
    readonly key: FieldRef<"Policy", 'String'>
    readonly valueJson: FieldRef<"Policy", 'Json'>
    readonly createdAt: FieldRef<"Policy", 'DateTime'>
    readonly updatedAt: FieldRef<"Policy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Policy findUnique
   */
  export type PolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy findUniqueOrThrow
   */
  export type PolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy findFirst
   */
  export type PolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Policies.
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Policies.
     */
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Policy findFirstOrThrow
   */
  export type PolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Filter, which Policy to fetch.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Policies.
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Policies.
     */
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Policy findMany
   */
  export type PolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Filter, which Policies to fetch.
     */
    where?: PolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Policies to fetch.
     */
    orderBy?: PolicyOrderByWithRelationInput | PolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Policies.
     */
    cursor?: PolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Policies.
     */
    skip?: number
    distinct?: PolicyScalarFieldEnum | PolicyScalarFieldEnum[]
  }

  /**
   * Policy create
   */
  export type PolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * The data needed to create a Policy.
     */
    data: XOR<PolicyCreateInput, PolicyUncheckedCreateInput>
  }

  /**
   * Policy createMany
   */
  export type PolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Policies.
     */
    data: PolicyCreateManyInput | PolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Policy createManyAndReturn
   */
  export type PolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Policies.
     */
    data: PolicyCreateManyInput | PolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Policy update
   */
  export type PolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * The data needed to update a Policy.
     */
    data: XOR<PolicyUpdateInput, PolicyUncheckedUpdateInput>
    /**
     * Choose, which Policy to update.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy updateMany
   */
  export type PolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Policies.
     */
    data: XOR<PolicyUpdateManyMutationInput, PolicyUncheckedUpdateManyInput>
    /**
     * Filter which Policies to update
     */
    where?: PolicyWhereInput
  }

  /**
   * Policy upsert
   */
  export type PolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * The filter to search for the Policy to update in case it exists.
     */
    where: PolicyWhereUniqueInput
    /**
     * In case the Policy found by the `where` argument doesn't exist, create a new Policy with this data.
     */
    create: XOR<PolicyCreateInput, PolicyUncheckedCreateInput>
    /**
     * In case the Policy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PolicyUpdateInput, PolicyUncheckedUpdateInput>
  }

  /**
   * Policy delete
   */
  export type PolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
    /**
     * Filter which Policy to delete.
     */
    where: PolicyWhereUniqueInput
  }

  /**
   * Policy deleteMany
   */
  export type PolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Policies to delete
     */
    where?: PolicyWhereInput
  }

  /**
   * Policy without action
   */
  export type PolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Policy
     */
    select?: PolicySelect<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entity: number
    entityId: number
    beforeJson: number
    afterJson: number
    ipAddress: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    ipAddress?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    ipAddress?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    beforeJson?: true
    afterJson?: true
    ipAddress?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    entity: string
    entityId: string
    beforeJson: JsonValue | null
    afterJson: JsonValue | null
    ipAddress: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    beforeJson?: boolean
    afterJson?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    beforeJson?: boolean
    afterJson?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    beforeJson?: boolean
    afterJson?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      entity: string
      entityId: string
      beforeJson: Prisma.JsonValue | null
      afterJson: Prisma.JsonValue | null
      ipAddress: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly beforeJson: FieldRef<"AuditLog", 'Json'>
    readonly afterJson: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model CashAccount
   */

  export type AggregateCashAccount = {
    _count: CashAccountCountAggregateOutputType | null
    _avg: CashAccountAvgAggregateOutputType | null
    _sum: CashAccountSumAggregateOutputType | null
    _min: CashAccountMinAggregateOutputType | null
    _max: CashAccountMaxAggregateOutputType | null
  }

  export type CashAccountAvgAggregateOutputType = {
    balance: Decimal | null
  }

  export type CashAccountSumAggregateOutputType = {
    balance: Decimal | null
  }

  export type CashAccountMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    accountType: string | null
    accountNumber: string | null
    glAccountId: string | null
    bankName: string | null
    balance: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    chartOfAccountId: string | null
  }

  export type CashAccountMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    accountType: string | null
    accountNumber: string | null
    glAccountId: string | null
    bankName: string | null
    balance: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    chartOfAccountId: string | null
  }

  export type CashAccountCountAggregateOutputType = {
    id: number
    code: number
    name: number
    accountType: number
    accountNumber: number
    glAccountId: number
    bankName: number
    balance: number
    isActive: number
    createdAt: number
    chartOfAccountId: number
    _all: number
  }


  export type CashAccountAvgAggregateInputType = {
    balance?: true
  }

  export type CashAccountSumAggregateInputType = {
    balance?: true
  }

  export type CashAccountMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    accountType?: true
    accountNumber?: true
    glAccountId?: true
    bankName?: true
    balance?: true
    isActive?: true
    createdAt?: true
    chartOfAccountId?: true
  }

  export type CashAccountMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    accountType?: true
    accountNumber?: true
    glAccountId?: true
    bankName?: true
    balance?: true
    isActive?: true
    createdAt?: true
    chartOfAccountId?: true
  }

  export type CashAccountCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    accountType?: true
    accountNumber?: true
    glAccountId?: true
    bankName?: true
    balance?: true
    isActive?: true
    createdAt?: true
    chartOfAccountId?: true
    _all?: true
  }

  export type CashAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashAccount to aggregate.
     */
    where?: CashAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashAccounts to fetch.
     */
    orderBy?: CashAccountOrderByWithRelationInput | CashAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashAccounts
    **/
    _count?: true | CashAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashAccountMaxAggregateInputType
  }

  export type GetCashAccountAggregateType<T extends CashAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateCashAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashAccount[P]>
      : GetScalarType<T[P], AggregateCashAccount[P]>
  }




  export type CashAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashAccountWhereInput
    orderBy?: CashAccountOrderByWithAggregationInput | CashAccountOrderByWithAggregationInput[]
    by: CashAccountScalarFieldEnum[] | CashAccountScalarFieldEnum
    having?: CashAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashAccountCountAggregateInputType | true
    _avg?: CashAccountAvgAggregateInputType
    _sum?: CashAccountSumAggregateInputType
    _min?: CashAccountMinAggregateInputType
    _max?: CashAccountMaxAggregateInputType
  }

  export type CashAccountGroupByOutputType = {
    id: string
    code: string
    name: string
    accountType: string
    accountNumber: string | null
    glAccountId: string | null
    bankName: string | null
    balance: Decimal
    isActive: boolean
    createdAt: Date
    chartOfAccountId: string | null
    _count: CashAccountCountAggregateOutputType | null
    _avg: CashAccountAvgAggregateOutputType | null
    _sum: CashAccountSumAggregateOutputType | null
    _min: CashAccountMinAggregateOutputType | null
    _max: CashAccountMaxAggregateOutputType | null
  }

  type GetCashAccountGroupByPayload<T extends CashAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashAccountGroupByOutputType[P]>
            : GetScalarType<T[P], CashAccountGroupByOutputType[P]>
        }
      >
    >


  export type CashAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    accountType?: boolean
    accountNumber?: boolean
    glAccountId?: boolean
    bankName?: boolean
    balance?: boolean
    isActive?: boolean
    createdAt?: boolean
    chartOfAccountId?: boolean
    cashTransactions?: boolean | CashAccount$cashTransactionsArgs<ExtArgs>
    salesReceipts?: boolean | CashAccount$salesReceiptsArgs<ExtArgs>
    purchasePayments?: boolean | CashAccount$purchasePaymentsArgs<ExtArgs>
    chartOfAccount?: boolean | CashAccount$chartOfAccountArgs<ExtArgs>
    _count?: boolean | CashAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashAccount"]>

  export type CashAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    accountType?: boolean
    accountNumber?: boolean
    glAccountId?: boolean
    bankName?: boolean
    balance?: boolean
    isActive?: boolean
    createdAt?: boolean
    chartOfAccountId?: boolean
    chartOfAccount?: boolean | CashAccount$chartOfAccountArgs<ExtArgs>
  }, ExtArgs["result"]["cashAccount"]>

  export type CashAccountSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    accountType?: boolean
    accountNumber?: boolean
    glAccountId?: boolean
    bankName?: boolean
    balance?: boolean
    isActive?: boolean
    createdAt?: boolean
    chartOfAccountId?: boolean
  }

  export type CashAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cashTransactions?: boolean | CashAccount$cashTransactionsArgs<ExtArgs>
    salesReceipts?: boolean | CashAccount$salesReceiptsArgs<ExtArgs>
    purchasePayments?: boolean | CashAccount$purchasePaymentsArgs<ExtArgs>
    chartOfAccount?: boolean | CashAccount$chartOfAccountArgs<ExtArgs>
    _count?: boolean | CashAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CashAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chartOfAccount?: boolean | CashAccount$chartOfAccountArgs<ExtArgs>
  }

  export type $CashAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashAccount"
    objects: {
      cashTransactions: Prisma.$CashTransactionPayload<ExtArgs>[]
      salesReceipts: Prisma.$SalesReceiptPayload<ExtArgs>[]
      purchasePayments: Prisma.$PurchasePaymentPayload<ExtArgs>[]
      chartOfAccount: Prisma.$ChartOfAccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      accountType: string
      accountNumber: string | null
      glAccountId: string | null
      bankName: string | null
      balance: Prisma.Decimal
      isActive: boolean
      createdAt: Date
      chartOfAccountId: string | null
    }, ExtArgs["result"]["cashAccount"]>
    composites: {}
  }

  type CashAccountGetPayload<S extends boolean | null | undefined | CashAccountDefaultArgs> = $Result.GetResult<Prisma.$CashAccountPayload, S>

  type CashAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CashAccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CashAccountCountAggregateInputType | true
    }

  export interface CashAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashAccount'], meta: { name: 'CashAccount' } }
    /**
     * Find zero or one CashAccount that matches the filter.
     * @param {CashAccountFindUniqueArgs} args - Arguments to find a CashAccount
     * @example
     * // Get one CashAccount
     * const cashAccount = await prisma.cashAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashAccountFindUniqueArgs>(args: SelectSubset<T, CashAccountFindUniqueArgs<ExtArgs>>): Prisma__CashAccountClient<$Result.GetResult<Prisma.$CashAccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CashAccount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CashAccountFindUniqueOrThrowArgs} args - Arguments to find a CashAccount
     * @example
     * // Get one CashAccount
     * const cashAccount = await prisma.cashAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, CashAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashAccountClient<$Result.GetResult<Prisma.$CashAccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CashAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashAccountFindFirstArgs} args - Arguments to find a CashAccount
     * @example
     * // Get one CashAccount
     * const cashAccount = await prisma.cashAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashAccountFindFirstArgs>(args?: SelectSubset<T, CashAccountFindFirstArgs<ExtArgs>>): Prisma__CashAccountClient<$Result.GetResult<Prisma.$CashAccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CashAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashAccountFindFirstOrThrowArgs} args - Arguments to find a CashAccount
     * @example
     * // Get one CashAccount
     * const cashAccount = await prisma.cashAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, CashAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashAccountClient<$Result.GetResult<Prisma.$CashAccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CashAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashAccounts
     * const cashAccounts = await prisma.cashAccount.findMany()
     * 
     * // Get first 10 CashAccounts
     * const cashAccounts = await prisma.cashAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashAccountWithIdOnly = await prisma.cashAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashAccountFindManyArgs>(args?: SelectSubset<T, CashAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashAccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CashAccount.
     * @param {CashAccountCreateArgs} args - Arguments to create a CashAccount.
     * @example
     * // Create one CashAccount
     * const CashAccount = await prisma.cashAccount.create({
     *   data: {
     *     // ... data to create a CashAccount
     *   }
     * })
     * 
     */
    create<T extends CashAccountCreateArgs>(args: SelectSubset<T, CashAccountCreateArgs<ExtArgs>>): Prisma__CashAccountClient<$Result.GetResult<Prisma.$CashAccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CashAccounts.
     * @param {CashAccountCreateManyArgs} args - Arguments to create many CashAccounts.
     * @example
     * // Create many CashAccounts
     * const cashAccount = await prisma.cashAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashAccountCreateManyArgs>(args?: SelectSubset<T, CashAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CashAccounts and returns the data saved in the database.
     * @param {CashAccountCreateManyAndReturnArgs} args - Arguments to create many CashAccounts.
     * @example
     * // Create many CashAccounts
     * const cashAccount = await prisma.cashAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CashAccounts and only return the `id`
     * const cashAccountWithIdOnly = await prisma.cashAccount.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CashAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, CashAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashAccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CashAccount.
     * @param {CashAccountDeleteArgs} args - Arguments to delete one CashAccount.
     * @example
     * // Delete one CashAccount
     * const CashAccount = await prisma.cashAccount.delete({
     *   where: {
     *     // ... filter to delete one CashAccount
     *   }
     * })
     * 
     */
    delete<T extends CashAccountDeleteArgs>(args: SelectSubset<T, CashAccountDeleteArgs<ExtArgs>>): Prisma__CashAccountClient<$Result.GetResult<Prisma.$CashAccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CashAccount.
     * @param {CashAccountUpdateArgs} args - Arguments to update one CashAccount.
     * @example
     * // Update one CashAccount
     * const cashAccount = await prisma.cashAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashAccountUpdateArgs>(args: SelectSubset<T, CashAccountUpdateArgs<ExtArgs>>): Prisma__CashAccountClient<$Result.GetResult<Prisma.$CashAccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CashAccounts.
     * @param {CashAccountDeleteManyArgs} args - Arguments to filter CashAccounts to delete.
     * @example
     * // Delete a few CashAccounts
     * const { count } = await prisma.cashAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashAccountDeleteManyArgs>(args?: SelectSubset<T, CashAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashAccounts
     * const cashAccount = await prisma.cashAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashAccountUpdateManyArgs>(args: SelectSubset<T, CashAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CashAccount.
     * @param {CashAccountUpsertArgs} args - Arguments to update or create a CashAccount.
     * @example
     * // Update or create a CashAccount
     * const cashAccount = await prisma.cashAccount.upsert({
     *   create: {
     *     // ... data to create a CashAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashAccount we want to update
     *   }
     * })
     */
    upsert<T extends CashAccountUpsertArgs>(args: SelectSubset<T, CashAccountUpsertArgs<ExtArgs>>): Prisma__CashAccountClient<$Result.GetResult<Prisma.$CashAccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CashAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashAccountCountArgs} args - Arguments to filter CashAccounts to count.
     * @example
     * // Count the number of CashAccounts
     * const count = await prisma.cashAccount.count({
     *   where: {
     *     // ... the filter for the CashAccounts we want to count
     *   }
     * })
    **/
    count<T extends CashAccountCountArgs>(
      args?: Subset<T, CashAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashAccountAggregateArgs>(args: Subset<T, CashAccountAggregateArgs>): Prisma.PrismaPromise<GetCashAccountAggregateType<T>>

    /**
     * Group by CashAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashAccountGroupByArgs['orderBy'] }
        : { orderBy?: CashAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashAccount model
   */
  readonly fields: CashAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cashTransactions<T extends CashAccount$cashTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, CashAccount$cashTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    salesReceipts<T extends CashAccount$salesReceiptsArgs<ExtArgs> = {}>(args?: Subset<T, CashAccount$salesReceiptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReceiptPayload<ExtArgs>, T, "findMany"> | Null>
    purchasePayments<T extends CashAccount$purchasePaymentsArgs<ExtArgs> = {}>(args?: Subset<T, CashAccount$purchasePaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePaymentPayload<ExtArgs>, T, "findMany"> | Null>
    chartOfAccount<T extends CashAccount$chartOfAccountArgs<ExtArgs> = {}>(args?: Subset<T, CashAccount$chartOfAccountArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashAccount model
   */ 
  interface CashAccountFieldRefs {
    readonly id: FieldRef<"CashAccount", 'String'>
    readonly code: FieldRef<"CashAccount", 'String'>
    readonly name: FieldRef<"CashAccount", 'String'>
    readonly accountType: FieldRef<"CashAccount", 'String'>
    readonly accountNumber: FieldRef<"CashAccount", 'String'>
    readonly glAccountId: FieldRef<"CashAccount", 'String'>
    readonly bankName: FieldRef<"CashAccount", 'String'>
    readonly balance: FieldRef<"CashAccount", 'Decimal'>
    readonly isActive: FieldRef<"CashAccount", 'Boolean'>
    readonly createdAt: FieldRef<"CashAccount", 'DateTime'>
    readonly chartOfAccountId: FieldRef<"CashAccount", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CashAccount findUnique
   */
  export type CashAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashAccount
     */
    select?: CashAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashAccountInclude<ExtArgs> | null
    /**
     * Filter, which CashAccount to fetch.
     */
    where: CashAccountWhereUniqueInput
  }

  /**
   * CashAccount findUniqueOrThrow
   */
  export type CashAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashAccount
     */
    select?: CashAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashAccountInclude<ExtArgs> | null
    /**
     * Filter, which CashAccount to fetch.
     */
    where: CashAccountWhereUniqueInput
  }

  /**
   * CashAccount findFirst
   */
  export type CashAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashAccount
     */
    select?: CashAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashAccountInclude<ExtArgs> | null
    /**
     * Filter, which CashAccount to fetch.
     */
    where?: CashAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashAccounts to fetch.
     */
    orderBy?: CashAccountOrderByWithRelationInput | CashAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashAccounts.
     */
    cursor?: CashAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashAccounts.
     */
    distinct?: CashAccountScalarFieldEnum | CashAccountScalarFieldEnum[]
  }

  /**
   * CashAccount findFirstOrThrow
   */
  export type CashAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashAccount
     */
    select?: CashAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashAccountInclude<ExtArgs> | null
    /**
     * Filter, which CashAccount to fetch.
     */
    where?: CashAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashAccounts to fetch.
     */
    orderBy?: CashAccountOrderByWithRelationInput | CashAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashAccounts.
     */
    cursor?: CashAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashAccounts.
     */
    distinct?: CashAccountScalarFieldEnum | CashAccountScalarFieldEnum[]
  }

  /**
   * CashAccount findMany
   */
  export type CashAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashAccount
     */
    select?: CashAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashAccountInclude<ExtArgs> | null
    /**
     * Filter, which CashAccounts to fetch.
     */
    where?: CashAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashAccounts to fetch.
     */
    orderBy?: CashAccountOrderByWithRelationInput | CashAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashAccounts.
     */
    cursor?: CashAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashAccounts.
     */
    skip?: number
    distinct?: CashAccountScalarFieldEnum | CashAccountScalarFieldEnum[]
  }

  /**
   * CashAccount create
   */
  export type CashAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashAccount
     */
    select?: CashAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a CashAccount.
     */
    data: XOR<CashAccountCreateInput, CashAccountUncheckedCreateInput>
  }

  /**
   * CashAccount createMany
   */
  export type CashAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashAccounts.
     */
    data: CashAccountCreateManyInput | CashAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashAccount createManyAndReturn
   */
  export type CashAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashAccount
     */
    select?: CashAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CashAccounts.
     */
    data: CashAccountCreateManyInput | CashAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashAccount update
   */
  export type CashAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashAccount
     */
    select?: CashAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a CashAccount.
     */
    data: XOR<CashAccountUpdateInput, CashAccountUncheckedUpdateInput>
    /**
     * Choose, which CashAccount to update.
     */
    where: CashAccountWhereUniqueInput
  }

  /**
   * CashAccount updateMany
   */
  export type CashAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashAccounts.
     */
    data: XOR<CashAccountUpdateManyMutationInput, CashAccountUncheckedUpdateManyInput>
    /**
     * Filter which CashAccounts to update
     */
    where?: CashAccountWhereInput
  }

  /**
   * CashAccount upsert
   */
  export type CashAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashAccount
     */
    select?: CashAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the CashAccount to update in case it exists.
     */
    where: CashAccountWhereUniqueInput
    /**
     * In case the CashAccount found by the `where` argument doesn't exist, create a new CashAccount with this data.
     */
    create: XOR<CashAccountCreateInput, CashAccountUncheckedCreateInput>
    /**
     * In case the CashAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashAccountUpdateInput, CashAccountUncheckedUpdateInput>
  }

  /**
   * CashAccount delete
   */
  export type CashAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashAccount
     */
    select?: CashAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashAccountInclude<ExtArgs> | null
    /**
     * Filter which CashAccount to delete.
     */
    where: CashAccountWhereUniqueInput
  }

  /**
   * CashAccount deleteMany
   */
  export type CashAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashAccounts to delete
     */
    where?: CashAccountWhereInput
  }

  /**
   * CashAccount.cashTransactions
   */
  export type CashAccount$cashTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    where?: CashTransactionWhereInput
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    cursor?: CashTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashTransactionScalarFieldEnum | CashTransactionScalarFieldEnum[]
  }

  /**
   * CashAccount.salesReceipts
   */
  export type CashAccount$salesReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReceipt
     */
    select?: SalesReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReceiptInclude<ExtArgs> | null
    where?: SalesReceiptWhereInput
    orderBy?: SalesReceiptOrderByWithRelationInput | SalesReceiptOrderByWithRelationInput[]
    cursor?: SalesReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesReceiptScalarFieldEnum | SalesReceiptScalarFieldEnum[]
  }

  /**
   * CashAccount.purchasePayments
   */
  export type CashAccount$purchasePaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePayment
     */
    select?: PurchasePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePaymentInclude<ExtArgs> | null
    where?: PurchasePaymentWhereInput
    orderBy?: PurchasePaymentOrderByWithRelationInput | PurchasePaymentOrderByWithRelationInput[]
    cursor?: PurchasePaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchasePaymentScalarFieldEnum | PurchasePaymentScalarFieldEnum[]
  }

  /**
   * CashAccount.chartOfAccount
   */
  export type CashAccount$chartOfAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    where?: ChartOfAccountWhereInput
  }

  /**
   * CashAccount without action
   */
  export type CashAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashAccount
     */
    select?: CashAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashAccountInclude<ExtArgs> | null
  }


  /**
   * Model CashTransaction
   */

  export type AggregateCashTransaction = {
    _count: CashTransactionCountAggregateOutputType | null
    _avg: CashTransactionAvgAggregateOutputType | null
    _sum: CashTransactionSumAggregateOutputType | null
    _min: CashTransactionMinAggregateOutputType | null
    _max: CashTransactionMaxAggregateOutputType | null
  }

  export type CashTransactionAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type CashTransactionSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type CashTransactionMinAggregateOutputType = {
    id: string | null
    transactionNo: string | null
    cashAccountId: string | null
    glAccountId: string | null
    contraAccountId: string | null
    transactionType: string | null
    amount: Decimal | null
    description: string | null
    refType: string | null
    refId: string | null
    transactionDate: Date | null
    isReconciled: boolean | null
    reconciledAt: Date | null
    userId: string | null
    createdAt: Date | null
    reference: string | null
  }

  export type CashTransactionMaxAggregateOutputType = {
    id: string | null
    transactionNo: string | null
    cashAccountId: string | null
    glAccountId: string | null
    contraAccountId: string | null
    transactionType: string | null
    amount: Decimal | null
    description: string | null
    refType: string | null
    refId: string | null
    transactionDate: Date | null
    isReconciled: boolean | null
    reconciledAt: Date | null
    userId: string | null
    createdAt: Date | null
    reference: string | null
  }

  export type CashTransactionCountAggregateOutputType = {
    id: number
    transactionNo: number
    cashAccountId: number
    glAccountId: number
    contraAccountId: number
    transactionType: number
    amount: number
    description: number
    refType: number
    refId: number
    transactionDate: number
    isReconciled: number
    reconciledAt: number
    userId: number
    createdAt: number
    reference: number
    _all: number
  }


  export type CashTransactionAvgAggregateInputType = {
    amount?: true
  }

  export type CashTransactionSumAggregateInputType = {
    amount?: true
  }

  export type CashTransactionMinAggregateInputType = {
    id?: true
    transactionNo?: true
    cashAccountId?: true
    glAccountId?: true
    contraAccountId?: true
    transactionType?: true
    amount?: true
    description?: true
    refType?: true
    refId?: true
    transactionDate?: true
    isReconciled?: true
    reconciledAt?: true
    userId?: true
    createdAt?: true
    reference?: true
  }

  export type CashTransactionMaxAggregateInputType = {
    id?: true
    transactionNo?: true
    cashAccountId?: true
    glAccountId?: true
    contraAccountId?: true
    transactionType?: true
    amount?: true
    description?: true
    refType?: true
    refId?: true
    transactionDate?: true
    isReconciled?: true
    reconciledAt?: true
    userId?: true
    createdAt?: true
    reference?: true
  }

  export type CashTransactionCountAggregateInputType = {
    id?: true
    transactionNo?: true
    cashAccountId?: true
    glAccountId?: true
    contraAccountId?: true
    transactionType?: true
    amount?: true
    description?: true
    refType?: true
    refId?: true
    transactionDate?: true
    isReconciled?: true
    reconciledAt?: true
    userId?: true
    createdAt?: true
    reference?: true
    _all?: true
  }

  export type CashTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashTransaction to aggregate.
     */
    where?: CashTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashTransactions to fetch.
     */
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashTransactions
    **/
    _count?: true | CashTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashTransactionMaxAggregateInputType
  }

  export type GetCashTransactionAggregateType<T extends CashTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateCashTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashTransaction[P]>
      : GetScalarType<T[P], AggregateCashTransaction[P]>
  }




  export type CashTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashTransactionWhereInput
    orderBy?: CashTransactionOrderByWithAggregationInput | CashTransactionOrderByWithAggregationInput[]
    by: CashTransactionScalarFieldEnum[] | CashTransactionScalarFieldEnum
    having?: CashTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashTransactionCountAggregateInputType | true
    _avg?: CashTransactionAvgAggregateInputType
    _sum?: CashTransactionSumAggregateInputType
    _min?: CashTransactionMinAggregateInputType
    _max?: CashTransactionMaxAggregateInputType
  }

  export type CashTransactionGroupByOutputType = {
    id: string
    transactionNo: string
    cashAccountId: string
    glAccountId: string | null
    contraAccountId: string | null
    transactionType: string
    amount: Decimal
    description: string
    refType: string | null
    refId: string | null
    transactionDate: Date
    isReconciled: boolean
    reconciledAt: Date | null
    userId: string
    createdAt: Date
    reference: string
    _count: CashTransactionCountAggregateOutputType | null
    _avg: CashTransactionAvgAggregateOutputType | null
    _sum: CashTransactionSumAggregateOutputType | null
    _min: CashTransactionMinAggregateOutputType | null
    _max: CashTransactionMaxAggregateOutputType | null
  }

  type GetCashTransactionGroupByPayload<T extends CashTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], CashTransactionGroupByOutputType[P]>
        }
      >
    >


  export type CashTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionNo?: boolean
    cashAccountId?: boolean
    glAccountId?: boolean
    contraAccountId?: boolean
    transactionType?: boolean
    amount?: boolean
    description?: boolean
    refType?: boolean
    refId?: boolean
    transactionDate?: boolean
    isReconciled?: boolean
    reconciledAt?: boolean
    userId?: boolean
    createdAt?: boolean
    reference?: boolean
    cashAccount?: boolean | CashAccountDefaultArgs<ExtArgs>
    glAccount?: boolean | CashTransaction$glAccountArgs<ExtArgs>
    contraAccount?: boolean | CashTransaction$contraAccountArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashTransaction"]>

  export type CashTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionNo?: boolean
    cashAccountId?: boolean
    glAccountId?: boolean
    contraAccountId?: boolean
    transactionType?: boolean
    amount?: boolean
    description?: boolean
    refType?: boolean
    refId?: boolean
    transactionDate?: boolean
    isReconciled?: boolean
    reconciledAt?: boolean
    userId?: boolean
    createdAt?: boolean
    reference?: boolean
    cashAccount?: boolean | CashAccountDefaultArgs<ExtArgs>
    glAccount?: boolean | CashTransaction$glAccountArgs<ExtArgs>
    contraAccount?: boolean | CashTransaction$contraAccountArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashTransaction"]>

  export type CashTransactionSelectScalar = {
    id?: boolean
    transactionNo?: boolean
    cashAccountId?: boolean
    glAccountId?: boolean
    contraAccountId?: boolean
    transactionType?: boolean
    amount?: boolean
    description?: boolean
    refType?: boolean
    refId?: boolean
    transactionDate?: boolean
    isReconciled?: boolean
    reconciledAt?: boolean
    userId?: boolean
    createdAt?: boolean
    reference?: boolean
  }

  export type CashTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cashAccount?: boolean | CashAccountDefaultArgs<ExtArgs>
    glAccount?: boolean | CashTransaction$glAccountArgs<ExtArgs>
    contraAccount?: boolean | CashTransaction$contraAccountArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CashTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cashAccount?: boolean | CashAccountDefaultArgs<ExtArgs>
    glAccount?: boolean | CashTransaction$glAccountArgs<ExtArgs>
    contraAccount?: boolean | CashTransaction$contraAccountArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CashTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashTransaction"
    objects: {
      cashAccount: Prisma.$CashAccountPayload<ExtArgs>
      glAccount: Prisma.$ChartOfAccountPayload<ExtArgs> | null
      contraAccount: Prisma.$ChartOfAccountPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionNo: string
      cashAccountId: string
      glAccountId: string | null
      contraAccountId: string | null
      transactionType: string
      amount: Prisma.Decimal
      description: string
      refType: string | null
      refId: string | null
      transactionDate: Date
      isReconciled: boolean
      reconciledAt: Date | null
      userId: string
      createdAt: Date
      reference: string
    }, ExtArgs["result"]["cashTransaction"]>
    composites: {}
  }

  type CashTransactionGetPayload<S extends boolean | null | undefined | CashTransactionDefaultArgs> = $Result.GetResult<Prisma.$CashTransactionPayload, S>

  type CashTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CashTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CashTransactionCountAggregateInputType | true
    }

  export interface CashTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashTransaction'], meta: { name: 'CashTransaction' } }
    /**
     * Find zero or one CashTransaction that matches the filter.
     * @param {CashTransactionFindUniqueArgs} args - Arguments to find a CashTransaction
     * @example
     * // Get one CashTransaction
     * const cashTransaction = await prisma.cashTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashTransactionFindUniqueArgs>(args: SelectSubset<T, CashTransactionFindUniqueArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CashTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CashTransactionFindUniqueOrThrowArgs} args - Arguments to find a CashTransaction
     * @example
     * // Get one CashTransaction
     * const cashTransaction = await prisma.cashTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, CashTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CashTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionFindFirstArgs} args - Arguments to find a CashTransaction
     * @example
     * // Get one CashTransaction
     * const cashTransaction = await prisma.cashTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashTransactionFindFirstArgs>(args?: SelectSubset<T, CashTransactionFindFirstArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CashTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionFindFirstOrThrowArgs} args - Arguments to find a CashTransaction
     * @example
     * // Get one CashTransaction
     * const cashTransaction = await prisma.cashTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, CashTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CashTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashTransactions
     * const cashTransactions = await prisma.cashTransaction.findMany()
     * 
     * // Get first 10 CashTransactions
     * const cashTransactions = await prisma.cashTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashTransactionWithIdOnly = await prisma.cashTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashTransactionFindManyArgs>(args?: SelectSubset<T, CashTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CashTransaction.
     * @param {CashTransactionCreateArgs} args - Arguments to create a CashTransaction.
     * @example
     * // Create one CashTransaction
     * const CashTransaction = await prisma.cashTransaction.create({
     *   data: {
     *     // ... data to create a CashTransaction
     *   }
     * })
     * 
     */
    create<T extends CashTransactionCreateArgs>(args: SelectSubset<T, CashTransactionCreateArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CashTransactions.
     * @param {CashTransactionCreateManyArgs} args - Arguments to create many CashTransactions.
     * @example
     * // Create many CashTransactions
     * const cashTransaction = await prisma.cashTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashTransactionCreateManyArgs>(args?: SelectSubset<T, CashTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CashTransactions and returns the data saved in the database.
     * @param {CashTransactionCreateManyAndReturnArgs} args - Arguments to create many CashTransactions.
     * @example
     * // Create many CashTransactions
     * const cashTransaction = await prisma.cashTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CashTransactions and only return the `id`
     * const cashTransactionWithIdOnly = await prisma.cashTransaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CashTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, CashTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CashTransaction.
     * @param {CashTransactionDeleteArgs} args - Arguments to delete one CashTransaction.
     * @example
     * // Delete one CashTransaction
     * const CashTransaction = await prisma.cashTransaction.delete({
     *   where: {
     *     // ... filter to delete one CashTransaction
     *   }
     * })
     * 
     */
    delete<T extends CashTransactionDeleteArgs>(args: SelectSubset<T, CashTransactionDeleteArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CashTransaction.
     * @param {CashTransactionUpdateArgs} args - Arguments to update one CashTransaction.
     * @example
     * // Update one CashTransaction
     * const cashTransaction = await prisma.cashTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashTransactionUpdateArgs>(args: SelectSubset<T, CashTransactionUpdateArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CashTransactions.
     * @param {CashTransactionDeleteManyArgs} args - Arguments to filter CashTransactions to delete.
     * @example
     * // Delete a few CashTransactions
     * const { count } = await prisma.cashTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashTransactionDeleteManyArgs>(args?: SelectSubset<T, CashTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashTransactions
     * const cashTransaction = await prisma.cashTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashTransactionUpdateManyArgs>(args: SelectSubset<T, CashTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CashTransaction.
     * @param {CashTransactionUpsertArgs} args - Arguments to update or create a CashTransaction.
     * @example
     * // Update or create a CashTransaction
     * const cashTransaction = await prisma.cashTransaction.upsert({
     *   create: {
     *     // ... data to create a CashTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashTransaction we want to update
     *   }
     * })
     */
    upsert<T extends CashTransactionUpsertArgs>(args: SelectSubset<T, CashTransactionUpsertArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CashTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionCountArgs} args - Arguments to filter CashTransactions to count.
     * @example
     * // Count the number of CashTransactions
     * const count = await prisma.cashTransaction.count({
     *   where: {
     *     // ... the filter for the CashTransactions we want to count
     *   }
     * })
    **/
    count<T extends CashTransactionCountArgs>(
      args?: Subset<T, CashTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashTransactionAggregateArgs>(args: Subset<T, CashTransactionAggregateArgs>): Prisma.PrismaPromise<GetCashTransactionAggregateType<T>>

    /**
     * Group by CashTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashTransactionGroupByArgs['orderBy'] }
        : { orderBy?: CashTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashTransaction model
   */
  readonly fields: CashTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cashAccount<T extends CashAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CashAccountDefaultArgs<ExtArgs>>): Prisma__CashAccountClient<$Result.GetResult<Prisma.$CashAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    glAccount<T extends CashTransaction$glAccountArgs<ExtArgs> = {}>(args?: Subset<T, CashTransaction$glAccountArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    contraAccount<T extends CashTransaction$contraAccountArgs<ExtArgs> = {}>(args?: Subset<T, CashTransaction$contraAccountArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashTransaction model
   */ 
  interface CashTransactionFieldRefs {
    readonly id: FieldRef<"CashTransaction", 'String'>
    readonly transactionNo: FieldRef<"CashTransaction", 'String'>
    readonly cashAccountId: FieldRef<"CashTransaction", 'String'>
    readonly glAccountId: FieldRef<"CashTransaction", 'String'>
    readonly contraAccountId: FieldRef<"CashTransaction", 'String'>
    readonly transactionType: FieldRef<"CashTransaction", 'String'>
    readonly amount: FieldRef<"CashTransaction", 'Decimal'>
    readonly description: FieldRef<"CashTransaction", 'String'>
    readonly refType: FieldRef<"CashTransaction", 'String'>
    readonly refId: FieldRef<"CashTransaction", 'String'>
    readonly transactionDate: FieldRef<"CashTransaction", 'DateTime'>
    readonly isReconciled: FieldRef<"CashTransaction", 'Boolean'>
    readonly reconciledAt: FieldRef<"CashTransaction", 'DateTime'>
    readonly userId: FieldRef<"CashTransaction", 'String'>
    readonly createdAt: FieldRef<"CashTransaction", 'DateTime'>
    readonly reference: FieldRef<"CashTransaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CashTransaction findUnique
   */
  export type CashTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CashTransaction to fetch.
     */
    where: CashTransactionWhereUniqueInput
  }

  /**
   * CashTransaction findUniqueOrThrow
   */
  export type CashTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CashTransaction to fetch.
     */
    where: CashTransactionWhereUniqueInput
  }

  /**
   * CashTransaction findFirst
   */
  export type CashTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CashTransaction to fetch.
     */
    where?: CashTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashTransactions to fetch.
     */
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashTransactions.
     */
    cursor?: CashTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashTransactions.
     */
    distinct?: CashTransactionScalarFieldEnum | CashTransactionScalarFieldEnum[]
  }

  /**
   * CashTransaction findFirstOrThrow
   */
  export type CashTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CashTransaction to fetch.
     */
    where?: CashTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashTransactions to fetch.
     */
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashTransactions.
     */
    cursor?: CashTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashTransactions.
     */
    distinct?: CashTransactionScalarFieldEnum | CashTransactionScalarFieldEnum[]
  }

  /**
   * CashTransaction findMany
   */
  export type CashTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CashTransactions to fetch.
     */
    where?: CashTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashTransactions to fetch.
     */
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashTransactions.
     */
    cursor?: CashTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashTransactions.
     */
    skip?: number
    distinct?: CashTransactionScalarFieldEnum | CashTransactionScalarFieldEnum[]
  }

  /**
   * CashTransaction create
   */
  export type CashTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a CashTransaction.
     */
    data: XOR<CashTransactionCreateInput, CashTransactionUncheckedCreateInput>
  }

  /**
   * CashTransaction createMany
   */
  export type CashTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashTransactions.
     */
    data: CashTransactionCreateManyInput | CashTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashTransaction createManyAndReturn
   */
  export type CashTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CashTransactions.
     */
    data: CashTransactionCreateManyInput | CashTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashTransaction update
   */
  export type CashTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a CashTransaction.
     */
    data: XOR<CashTransactionUpdateInput, CashTransactionUncheckedUpdateInput>
    /**
     * Choose, which CashTransaction to update.
     */
    where: CashTransactionWhereUniqueInput
  }

  /**
   * CashTransaction updateMany
   */
  export type CashTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashTransactions.
     */
    data: XOR<CashTransactionUpdateManyMutationInput, CashTransactionUncheckedUpdateManyInput>
    /**
     * Filter which CashTransactions to update
     */
    where?: CashTransactionWhereInput
  }

  /**
   * CashTransaction upsert
   */
  export type CashTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the CashTransaction to update in case it exists.
     */
    where: CashTransactionWhereUniqueInput
    /**
     * In case the CashTransaction found by the `where` argument doesn't exist, create a new CashTransaction with this data.
     */
    create: XOR<CashTransactionCreateInput, CashTransactionUncheckedCreateInput>
    /**
     * In case the CashTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashTransactionUpdateInput, CashTransactionUncheckedUpdateInput>
  }

  /**
   * CashTransaction delete
   */
  export type CashTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * Filter which CashTransaction to delete.
     */
    where: CashTransactionWhereUniqueInput
  }

  /**
   * CashTransaction deleteMany
   */
  export type CashTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashTransactions to delete
     */
    where?: CashTransactionWhereInput
  }

  /**
   * CashTransaction.glAccount
   */
  export type CashTransaction$glAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    where?: ChartOfAccountWhereInput
  }

  /**
   * CashTransaction.contraAccount
   */
  export type CashTransaction$contraAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChartOfAccount
     */
    select?: ChartOfAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChartOfAccountInclude<ExtArgs> | null
    where?: ChartOfAccountWhereInput
  }

  /**
   * CashTransaction without action
   */
  export type CashTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
  }


  /**
   * Model SalesReceipt
   */

  export type AggregateSalesReceipt = {
    _count: SalesReceiptCountAggregateOutputType | null
    _avg: SalesReceiptAvgAggregateOutputType | null
    _sum: SalesReceiptSumAggregateOutputType | null
    _min: SalesReceiptMinAggregateOutputType | null
    _max: SalesReceiptMaxAggregateOutputType | null
  }

  export type SalesReceiptAvgAggregateOutputType = {
    amountReceived: Decimal | null
  }

  export type SalesReceiptSumAggregateOutputType = {
    amountReceived: Decimal | null
  }

  export type SalesReceiptMinAggregateOutputType = {
    id: string | null
    receiptNo: string | null
    saleId: string | null
    customerId: string | null
    cashAccountId: string | null
    amountReceived: Decimal | null
    receiptDate: Date | null
    reference: string | null
    notes: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type SalesReceiptMaxAggregateOutputType = {
    id: string | null
    receiptNo: string | null
    saleId: string | null
    customerId: string | null
    cashAccountId: string | null
    amountReceived: Decimal | null
    receiptDate: Date | null
    reference: string | null
    notes: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type SalesReceiptCountAggregateOutputType = {
    id: number
    receiptNo: number
    saleId: number
    customerId: number
    cashAccountId: number
    amountReceived: number
    receiptDate: number
    reference: number
    notes: number
    userId: number
    createdAt: number
    _all: number
  }


  export type SalesReceiptAvgAggregateInputType = {
    amountReceived?: true
  }

  export type SalesReceiptSumAggregateInputType = {
    amountReceived?: true
  }

  export type SalesReceiptMinAggregateInputType = {
    id?: true
    receiptNo?: true
    saleId?: true
    customerId?: true
    cashAccountId?: true
    amountReceived?: true
    receiptDate?: true
    reference?: true
    notes?: true
    userId?: true
    createdAt?: true
  }

  export type SalesReceiptMaxAggregateInputType = {
    id?: true
    receiptNo?: true
    saleId?: true
    customerId?: true
    cashAccountId?: true
    amountReceived?: true
    receiptDate?: true
    reference?: true
    notes?: true
    userId?: true
    createdAt?: true
  }

  export type SalesReceiptCountAggregateInputType = {
    id?: true
    receiptNo?: true
    saleId?: true
    customerId?: true
    cashAccountId?: true
    amountReceived?: true
    receiptDate?: true
    reference?: true
    notes?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type SalesReceiptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesReceipt to aggregate.
     */
    where?: SalesReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReceipts to fetch.
     */
    orderBy?: SalesReceiptOrderByWithRelationInput | SalesReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesReceipts
    **/
    _count?: true | SalesReceiptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesReceiptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesReceiptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesReceiptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesReceiptMaxAggregateInputType
  }

  export type GetSalesReceiptAggregateType<T extends SalesReceiptAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesReceipt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesReceipt[P]>
      : GetScalarType<T[P], AggregateSalesReceipt[P]>
  }




  export type SalesReceiptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesReceiptWhereInput
    orderBy?: SalesReceiptOrderByWithAggregationInput | SalesReceiptOrderByWithAggregationInput[]
    by: SalesReceiptScalarFieldEnum[] | SalesReceiptScalarFieldEnum
    having?: SalesReceiptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesReceiptCountAggregateInputType | true
    _avg?: SalesReceiptAvgAggregateInputType
    _sum?: SalesReceiptSumAggregateInputType
    _min?: SalesReceiptMinAggregateInputType
    _max?: SalesReceiptMaxAggregateInputType
  }

  export type SalesReceiptGroupByOutputType = {
    id: string
    receiptNo: string
    saleId: string
    customerId: string
    cashAccountId: string
    amountReceived: Decimal
    receiptDate: Date
    reference: string | null
    notes: string | null
    userId: string
    createdAt: Date
    _count: SalesReceiptCountAggregateOutputType | null
    _avg: SalesReceiptAvgAggregateOutputType | null
    _sum: SalesReceiptSumAggregateOutputType | null
    _min: SalesReceiptMinAggregateOutputType | null
    _max: SalesReceiptMaxAggregateOutputType | null
  }

  type GetSalesReceiptGroupByPayload<T extends SalesReceiptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesReceiptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesReceiptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesReceiptGroupByOutputType[P]>
            : GetScalarType<T[P], SalesReceiptGroupByOutputType[P]>
        }
      >
    >


  export type SalesReceiptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptNo?: boolean
    saleId?: boolean
    customerId?: boolean
    cashAccountId?: boolean
    amountReceived?: boolean
    receiptDate?: boolean
    reference?: boolean
    notes?: boolean
    userId?: boolean
    createdAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    cashAccount?: boolean | CashAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesReceipt"]>

  export type SalesReceiptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptNo?: boolean
    saleId?: boolean
    customerId?: boolean
    cashAccountId?: boolean
    amountReceived?: boolean
    receiptDate?: boolean
    reference?: boolean
    notes?: boolean
    userId?: boolean
    createdAt?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    cashAccount?: boolean | CashAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesReceipt"]>

  export type SalesReceiptSelectScalar = {
    id?: boolean
    receiptNo?: boolean
    saleId?: boolean
    customerId?: boolean
    cashAccountId?: boolean
    amountReceived?: boolean
    receiptDate?: boolean
    reference?: boolean
    notes?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type SalesReceiptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    cashAccount?: boolean | CashAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SalesReceiptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    cashAccount?: boolean | CashAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SalesReceiptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesReceipt"
    objects: {
      sale: Prisma.$SalePayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs>
      cashAccount: Prisma.$CashAccountPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      receiptNo: string
      saleId: string
      customerId: string
      cashAccountId: string
      amountReceived: Prisma.Decimal
      receiptDate: Date
      reference: string | null
      notes: string | null
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["salesReceipt"]>
    composites: {}
  }

  type SalesReceiptGetPayload<S extends boolean | null | undefined | SalesReceiptDefaultArgs> = $Result.GetResult<Prisma.$SalesReceiptPayload, S>

  type SalesReceiptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SalesReceiptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SalesReceiptCountAggregateInputType | true
    }

  export interface SalesReceiptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesReceipt'], meta: { name: 'SalesReceipt' } }
    /**
     * Find zero or one SalesReceipt that matches the filter.
     * @param {SalesReceiptFindUniqueArgs} args - Arguments to find a SalesReceipt
     * @example
     * // Get one SalesReceipt
     * const salesReceipt = await prisma.salesReceipt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesReceiptFindUniqueArgs>(args: SelectSubset<T, SalesReceiptFindUniqueArgs<ExtArgs>>): Prisma__SalesReceiptClient<$Result.GetResult<Prisma.$SalesReceiptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SalesReceipt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SalesReceiptFindUniqueOrThrowArgs} args - Arguments to find a SalesReceipt
     * @example
     * // Get one SalesReceipt
     * const salesReceipt = await prisma.salesReceipt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesReceiptFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesReceiptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesReceiptClient<$Result.GetResult<Prisma.$SalesReceiptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SalesReceipt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReceiptFindFirstArgs} args - Arguments to find a SalesReceipt
     * @example
     * // Get one SalesReceipt
     * const salesReceipt = await prisma.salesReceipt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesReceiptFindFirstArgs>(args?: SelectSubset<T, SalesReceiptFindFirstArgs<ExtArgs>>): Prisma__SalesReceiptClient<$Result.GetResult<Prisma.$SalesReceiptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SalesReceipt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReceiptFindFirstOrThrowArgs} args - Arguments to find a SalesReceipt
     * @example
     * // Get one SalesReceipt
     * const salesReceipt = await prisma.salesReceipt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesReceiptFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesReceiptFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesReceiptClient<$Result.GetResult<Prisma.$SalesReceiptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SalesReceipts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReceiptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesReceipts
     * const salesReceipts = await prisma.salesReceipt.findMany()
     * 
     * // Get first 10 SalesReceipts
     * const salesReceipts = await prisma.salesReceipt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesReceiptWithIdOnly = await prisma.salesReceipt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesReceiptFindManyArgs>(args?: SelectSubset<T, SalesReceiptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReceiptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SalesReceipt.
     * @param {SalesReceiptCreateArgs} args - Arguments to create a SalesReceipt.
     * @example
     * // Create one SalesReceipt
     * const SalesReceipt = await prisma.salesReceipt.create({
     *   data: {
     *     // ... data to create a SalesReceipt
     *   }
     * })
     * 
     */
    create<T extends SalesReceiptCreateArgs>(args: SelectSubset<T, SalesReceiptCreateArgs<ExtArgs>>): Prisma__SalesReceiptClient<$Result.GetResult<Prisma.$SalesReceiptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SalesReceipts.
     * @param {SalesReceiptCreateManyArgs} args - Arguments to create many SalesReceipts.
     * @example
     * // Create many SalesReceipts
     * const salesReceipt = await prisma.salesReceipt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesReceiptCreateManyArgs>(args?: SelectSubset<T, SalesReceiptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesReceipts and returns the data saved in the database.
     * @param {SalesReceiptCreateManyAndReturnArgs} args - Arguments to create many SalesReceipts.
     * @example
     * // Create many SalesReceipts
     * const salesReceipt = await prisma.salesReceipt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesReceipts and only return the `id`
     * const salesReceiptWithIdOnly = await prisma.salesReceipt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesReceiptCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesReceiptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReceiptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SalesReceipt.
     * @param {SalesReceiptDeleteArgs} args - Arguments to delete one SalesReceipt.
     * @example
     * // Delete one SalesReceipt
     * const SalesReceipt = await prisma.salesReceipt.delete({
     *   where: {
     *     // ... filter to delete one SalesReceipt
     *   }
     * })
     * 
     */
    delete<T extends SalesReceiptDeleteArgs>(args: SelectSubset<T, SalesReceiptDeleteArgs<ExtArgs>>): Prisma__SalesReceiptClient<$Result.GetResult<Prisma.$SalesReceiptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SalesReceipt.
     * @param {SalesReceiptUpdateArgs} args - Arguments to update one SalesReceipt.
     * @example
     * // Update one SalesReceipt
     * const salesReceipt = await prisma.salesReceipt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesReceiptUpdateArgs>(args: SelectSubset<T, SalesReceiptUpdateArgs<ExtArgs>>): Prisma__SalesReceiptClient<$Result.GetResult<Prisma.$SalesReceiptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SalesReceipts.
     * @param {SalesReceiptDeleteManyArgs} args - Arguments to filter SalesReceipts to delete.
     * @example
     * // Delete a few SalesReceipts
     * const { count } = await prisma.salesReceipt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesReceiptDeleteManyArgs>(args?: SelectSubset<T, SalesReceiptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReceiptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesReceipts
     * const salesReceipt = await prisma.salesReceipt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesReceiptUpdateManyArgs>(args: SelectSubset<T, SalesReceiptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SalesReceipt.
     * @param {SalesReceiptUpsertArgs} args - Arguments to update or create a SalesReceipt.
     * @example
     * // Update or create a SalesReceipt
     * const salesReceipt = await prisma.salesReceipt.upsert({
     *   create: {
     *     // ... data to create a SalesReceipt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesReceipt we want to update
     *   }
     * })
     */
    upsert<T extends SalesReceiptUpsertArgs>(args: SelectSubset<T, SalesReceiptUpsertArgs<ExtArgs>>): Prisma__SalesReceiptClient<$Result.GetResult<Prisma.$SalesReceiptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SalesReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReceiptCountArgs} args - Arguments to filter SalesReceipts to count.
     * @example
     * // Count the number of SalesReceipts
     * const count = await prisma.salesReceipt.count({
     *   where: {
     *     // ... the filter for the SalesReceipts we want to count
     *   }
     * })
    **/
    count<T extends SalesReceiptCountArgs>(
      args?: Subset<T, SalesReceiptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesReceiptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesReceipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReceiptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesReceiptAggregateArgs>(args: Subset<T, SalesReceiptAggregateArgs>): Prisma.PrismaPromise<GetSalesReceiptAggregateType<T>>

    /**
     * Group by SalesReceipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReceiptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesReceiptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesReceiptGroupByArgs['orderBy'] }
        : { orderBy?: SalesReceiptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesReceiptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesReceiptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesReceipt model
   */
  readonly fields: SalesReceiptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesReceipt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesReceiptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends SaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleDefaultArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cashAccount<T extends CashAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CashAccountDefaultArgs<ExtArgs>>): Prisma__CashAccountClient<$Result.GetResult<Prisma.$CashAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesReceipt model
   */ 
  interface SalesReceiptFieldRefs {
    readonly id: FieldRef<"SalesReceipt", 'String'>
    readonly receiptNo: FieldRef<"SalesReceipt", 'String'>
    readonly saleId: FieldRef<"SalesReceipt", 'String'>
    readonly customerId: FieldRef<"SalesReceipt", 'String'>
    readonly cashAccountId: FieldRef<"SalesReceipt", 'String'>
    readonly amountReceived: FieldRef<"SalesReceipt", 'Decimal'>
    readonly receiptDate: FieldRef<"SalesReceipt", 'DateTime'>
    readonly reference: FieldRef<"SalesReceipt", 'String'>
    readonly notes: FieldRef<"SalesReceipt", 'String'>
    readonly userId: FieldRef<"SalesReceipt", 'String'>
    readonly createdAt: FieldRef<"SalesReceipt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalesReceipt findUnique
   */
  export type SalesReceiptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReceipt
     */
    select?: SalesReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReceiptInclude<ExtArgs> | null
    /**
     * Filter, which SalesReceipt to fetch.
     */
    where: SalesReceiptWhereUniqueInput
  }

  /**
   * SalesReceipt findUniqueOrThrow
   */
  export type SalesReceiptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReceipt
     */
    select?: SalesReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReceiptInclude<ExtArgs> | null
    /**
     * Filter, which SalesReceipt to fetch.
     */
    where: SalesReceiptWhereUniqueInput
  }

  /**
   * SalesReceipt findFirst
   */
  export type SalesReceiptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReceipt
     */
    select?: SalesReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReceiptInclude<ExtArgs> | null
    /**
     * Filter, which SalesReceipt to fetch.
     */
    where?: SalesReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReceipts to fetch.
     */
    orderBy?: SalesReceiptOrderByWithRelationInput | SalesReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesReceipts.
     */
    cursor?: SalesReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesReceipts.
     */
    distinct?: SalesReceiptScalarFieldEnum | SalesReceiptScalarFieldEnum[]
  }

  /**
   * SalesReceipt findFirstOrThrow
   */
  export type SalesReceiptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReceipt
     */
    select?: SalesReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReceiptInclude<ExtArgs> | null
    /**
     * Filter, which SalesReceipt to fetch.
     */
    where?: SalesReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReceipts to fetch.
     */
    orderBy?: SalesReceiptOrderByWithRelationInput | SalesReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesReceipts.
     */
    cursor?: SalesReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesReceipts.
     */
    distinct?: SalesReceiptScalarFieldEnum | SalesReceiptScalarFieldEnum[]
  }

  /**
   * SalesReceipt findMany
   */
  export type SalesReceiptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReceipt
     */
    select?: SalesReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReceiptInclude<ExtArgs> | null
    /**
     * Filter, which SalesReceipts to fetch.
     */
    where?: SalesReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReceipts to fetch.
     */
    orderBy?: SalesReceiptOrderByWithRelationInput | SalesReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesReceipts.
     */
    cursor?: SalesReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReceipts.
     */
    skip?: number
    distinct?: SalesReceiptScalarFieldEnum | SalesReceiptScalarFieldEnum[]
  }

  /**
   * SalesReceipt create
   */
  export type SalesReceiptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReceipt
     */
    select?: SalesReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReceiptInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesReceipt.
     */
    data: XOR<SalesReceiptCreateInput, SalesReceiptUncheckedCreateInput>
  }

  /**
   * SalesReceipt createMany
   */
  export type SalesReceiptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesReceipts.
     */
    data: SalesReceiptCreateManyInput | SalesReceiptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesReceipt createManyAndReturn
   */
  export type SalesReceiptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReceipt
     */
    select?: SalesReceiptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SalesReceipts.
     */
    data: SalesReceiptCreateManyInput | SalesReceiptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReceiptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesReceipt update
   */
  export type SalesReceiptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReceipt
     */
    select?: SalesReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReceiptInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesReceipt.
     */
    data: XOR<SalesReceiptUpdateInput, SalesReceiptUncheckedUpdateInput>
    /**
     * Choose, which SalesReceipt to update.
     */
    where: SalesReceiptWhereUniqueInput
  }

  /**
   * SalesReceipt updateMany
   */
  export type SalesReceiptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesReceipts.
     */
    data: XOR<SalesReceiptUpdateManyMutationInput, SalesReceiptUncheckedUpdateManyInput>
    /**
     * Filter which SalesReceipts to update
     */
    where?: SalesReceiptWhereInput
  }

  /**
   * SalesReceipt upsert
   */
  export type SalesReceiptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReceipt
     */
    select?: SalesReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReceiptInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesReceipt to update in case it exists.
     */
    where: SalesReceiptWhereUniqueInput
    /**
     * In case the SalesReceipt found by the `where` argument doesn't exist, create a new SalesReceipt with this data.
     */
    create: XOR<SalesReceiptCreateInput, SalesReceiptUncheckedCreateInput>
    /**
     * In case the SalesReceipt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesReceiptUpdateInput, SalesReceiptUncheckedUpdateInput>
  }

  /**
   * SalesReceipt delete
   */
  export type SalesReceiptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReceipt
     */
    select?: SalesReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReceiptInclude<ExtArgs> | null
    /**
     * Filter which SalesReceipt to delete.
     */
    where: SalesReceiptWhereUniqueInput
  }

  /**
   * SalesReceipt deleteMany
   */
  export type SalesReceiptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesReceipts to delete
     */
    where?: SalesReceiptWhereInput
  }

  /**
   * SalesReceipt without action
   */
  export type SalesReceiptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReceipt
     */
    select?: SalesReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReceiptInclude<ExtArgs> | null
  }


  /**
   * Model PurchasePayment
   */

  export type AggregatePurchasePayment = {
    _count: PurchasePaymentCountAggregateOutputType | null
    _avg: PurchasePaymentAvgAggregateOutputType | null
    _sum: PurchasePaymentSumAggregateOutputType | null
    _min: PurchasePaymentMinAggregateOutputType | null
    _max: PurchasePaymentMaxAggregateOutputType | null
  }

  export type PurchasePaymentAvgAggregateOutputType = {
    amountPaid: Decimal | null
  }

  export type PurchasePaymentSumAggregateOutputType = {
    amountPaid: Decimal | null
  }

  export type PurchasePaymentMinAggregateOutputType = {
    id: string | null
    paymentNo: string | null
    purchaseId: string | null
    vendorId: string | null
    cashAccountId: string | null
    amountPaid: Decimal | null
    paymentDate: Date | null
    reference: string | null
    notes: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type PurchasePaymentMaxAggregateOutputType = {
    id: string | null
    paymentNo: string | null
    purchaseId: string | null
    vendorId: string | null
    cashAccountId: string | null
    amountPaid: Decimal | null
    paymentDate: Date | null
    reference: string | null
    notes: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type PurchasePaymentCountAggregateOutputType = {
    id: number
    paymentNo: number
    purchaseId: number
    vendorId: number
    cashAccountId: number
    amountPaid: number
    paymentDate: number
    reference: number
    notes: number
    userId: number
    createdAt: number
    _all: number
  }


  export type PurchasePaymentAvgAggregateInputType = {
    amountPaid?: true
  }

  export type PurchasePaymentSumAggregateInputType = {
    amountPaid?: true
  }

  export type PurchasePaymentMinAggregateInputType = {
    id?: true
    paymentNo?: true
    purchaseId?: true
    vendorId?: true
    cashAccountId?: true
    amountPaid?: true
    paymentDate?: true
    reference?: true
    notes?: true
    userId?: true
    createdAt?: true
  }

  export type PurchasePaymentMaxAggregateInputType = {
    id?: true
    paymentNo?: true
    purchaseId?: true
    vendorId?: true
    cashAccountId?: true
    amountPaid?: true
    paymentDate?: true
    reference?: true
    notes?: true
    userId?: true
    createdAt?: true
  }

  export type PurchasePaymentCountAggregateInputType = {
    id?: true
    paymentNo?: true
    purchaseId?: true
    vendorId?: true
    cashAccountId?: true
    amountPaid?: true
    paymentDate?: true
    reference?: true
    notes?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type PurchasePaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchasePayment to aggregate.
     */
    where?: PurchasePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePayments to fetch.
     */
    orderBy?: PurchasePaymentOrderByWithRelationInput | PurchasePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchasePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchasePayments
    **/
    _count?: true | PurchasePaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchasePaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchasePaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchasePaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchasePaymentMaxAggregateInputType
  }

  export type GetPurchasePaymentAggregateType<T extends PurchasePaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchasePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchasePayment[P]>
      : GetScalarType<T[P], AggregatePurchasePayment[P]>
  }




  export type PurchasePaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchasePaymentWhereInput
    orderBy?: PurchasePaymentOrderByWithAggregationInput | PurchasePaymentOrderByWithAggregationInput[]
    by: PurchasePaymentScalarFieldEnum[] | PurchasePaymentScalarFieldEnum
    having?: PurchasePaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchasePaymentCountAggregateInputType | true
    _avg?: PurchasePaymentAvgAggregateInputType
    _sum?: PurchasePaymentSumAggregateInputType
    _min?: PurchasePaymentMinAggregateInputType
    _max?: PurchasePaymentMaxAggregateInputType
  }

  export type PurchasePaymentGroupByOutputType = {
    id: string
    paymentNo: string
    purchaseId: string
    vendorId: string
    cashAccountId: string
    amountPaid: Decimal
    paymentDate: Date
    reference: string | null
    notes: string | null
    userId: string
    createdAt: Date
    _count: PurchasePaymentCountAggregateOutputType | null
    _avg: PurchasePaymentAvgAggregateOutputType | null
    _sum: PurchasePaymentSumAggregateOutputType | null
    _min: PurchasePaymentMinAggregateOutputType | null
    _max: PurchasePaymentMaxAggregateOutputType | null
  }

  type GetPurchasePaymentGroupByPayload<T extends PurchasePaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchasePaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchasePaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchasePaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PurchasePaymentGroupByOutputType[P]>
        }
      >
    >


  export type PurchasePaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentNo?: boolean
    purchaseId?: boolean
    vendorId?: boolean
    cashAccountId?: boolean
    amountPaid?: boolean
    paymentDate?: boolean
    reference?: boolean
    notes?: boolean
    userId?: boolean
    createdAt?: boolean
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    cashAccount?: boolean | CashAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchasePayment"]>

  export type PurchasePaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentNo?: boolean
    purchaseId?: boolean
    vendorId?: boolean
    cashAccountId?: boolean
    amountPaid?: boolean
    paymentDate?: boolean
    reference?: boolean
    notes?: boolean
    userId?: boolean
    createdAt?: boolean
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    cashAccount?: boolean | CashAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchasePayment"]>

  export type PurchasePaymentSelectScalar = {
    id?: boolean
    paymentNo?: boolean
    purchaseId?: boolean
    vendorId?: boolean
    cashAccountId?: boolean
    amountPaid?: boolean
    paymentDate?: boolean
    reference?: boolean
    notes?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type PurchasePaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    cashAccount?: boolean | CashAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PurchasePaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase?: boolean | PurchaseDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    cashAccount?: boolean | CashAccountDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PurchasePaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchasePayment"
    objects: {
      purchase: Prisma.$PurchasePayload<ExtArgs>
      vendor: Prisma.$VendorPayload<ExtArgs>
      cashAccount: Prisma.$CashAccountPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentNo: string
      purchaseId: string
      vendorId: string
      cashAccountId: string
      amountPaid: Prisma.Decimal
      paymentDate: Date
      reference: string | null
      notes: string | null
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["purchasePayment"]>
    composites: {}
  }

  type PurchasePaymentGetPayload<S extends boolean | null | undefined | PurchasePaymentDefaultArgs> = $Result.GetResult<Prisma.$PurchasePaymentPayload, S>

  type PurchasePaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchasePaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchasePaymentCountAggregateInputType | true
    }

  export interface PurchasePaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchasePayment'], meta: { name: 'PurchasePayment' } }
    /**
     * Find zero or one PurchasePayment that matches the filter.
     * @param {PurchasePaymentFindUniqueArgs} args - Arguments to find a PurchasePayment
     * @example
     * // Get one PurchasePayment
     * const purchasePayment = await prisma.purchasePayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchasePaymentFindUniqueArgs>(args: SelectSubset<T, PurchasePaymentFindUniqueArgs<ExtArgs>>): Prisma__PurchasePaymentClient<$Result.GetResult<Prisma.$PurchasePaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PurchasePayment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchasePaymentFindUniqueOrThrowArgs} args - Arguments to find a PurchasePayment
     * @example
     * // Get one PurchasePayment
     * const purchasePayment = await prisma.purchasePayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchasePaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchasePaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchasePaymentClient<$Result.GetResult<Prisma.$PurchasePaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PurchasePayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePaymentFindFirstArgs} args - Arguments to find a PurchasePayment
     * @example
     * // Get one PurchasePayment
     * const purchasePayment = await prisma.purchasePayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchasePaymentFindFirstArgs>(args?: SelectSubset<T, PurchasePaymentFindFirstArgs<ExtArgs>>): Prisma__PurchasePaymentClient<$Result.GetResult<Prisma.$PurchasePaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PurchasePayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePaymentFindFirstOrThrowArgs} args - Arguments to find a PurchasePayment
     * @example
     * // Get one PurchasePayment
     * const purchasePayment = await prisma.purchasePayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchasePaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchasePaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchasePaymentClient<$Result.GetResult<Prisma.$PurchasePaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PurchasePayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchasePayments
     * const purchasePayments = await prisma.purchasePayment.findMany()
     * 
     * // Get first 10 PurchasePayments
     * const purchasePayments = await prisma.purchasePayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchasePaymentWithIdOnly = await prisma.purchasePayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchasePaymentFindManyArgs>(args?: SelectSubset<T, PurchasePaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PurchasePayment.
     * @param {PurchasePaymentCreateArgs} args - Arguments to create a PurchasePayment.
     * @example
     * // Create one PurchasePayment
     * const PurchasePayment = await prisma.purchasePayment.create({
     *   data: {
     *     // ... data to create a PurchasePayment
     *   }
     * })
     * 
     */
    create<T extends PurchasePaymentCreateArgs>(args: SelectSubset<T, PurchasePaymentCreateArgs<ExtArgs>>): Prisma__PurchasePaymentClient<$Result.GetResult<Prisma.$PurchasePaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PurchasePayments.
     * @param {PurchasePaymentCreateManyArgs} args - Arguments to create many PurchasePayments.
     * @example
     * // Create many PurchasePayments
     * const purchasePayment = await prisma.purchasePayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchasePaymentCreateManyArgs>(args?: SelectSubset<T, PurchasePaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchasePayments and returns the data saved in the database.
     * @param {PurchasePaymentCreateManyAndReturnArgs} args - Arguments to create many PurchasePayments.
     * @example
     * // Create many PurchasePayments
     * const purchasePayment = await prisma.purchasePayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchasePayments and only return the `id`
     * const purchasePaymentWithIdOnly = await prisma.purchasePayment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchasePaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchasePaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PurchasePayment.
     * @param {PurchasePaymentDeleteArgs} args - Arguments to delete one PurchasePayment.
     * @example
     * // Delete one PurchasePayment
     * const PurchasePayment = await prisma.purchasePayment.delete({
     *   where: {
     *     // ... filter to delete one PurchasePayment
     *   }
     * })
     * 
     */
    delete<T extends PurchasePaymentDeleteArgs>(args: SelectSubset<T, PurchasePaymentDeleteArgs<ExtArgs>>): Prisma__PurchasePaymentClient<$Result.GetResult<Prisma.$PurchasePaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PurchasePayment.
     * @param {PurchasePaymentUpdateArgs} args - Arguments to update one PurchasePayment.
     * @example
     * // Update one PurchasePayment
     * const purchasePayment = await prisma.purchasePayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchasePaymentUpdateArgs>(args: SelectSubset<T, PurchasePaymentUpdateArgs<ExtArgs>>): Prisma__PurchasePaymentClient<$Result.GetResult<Prisma.$PurchasePaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PurchasePayments.
     * @param {PurchasePaymentDeleteManyArgs} args - Arguments to filter PurchasePayments to delete.
     * @example
     * // Delete a few PurchasePayments
     * const { count } = await prisma.purchasePayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchasePaymentDeleteManyArgs>(args?: SelectSubset<T, PurchasePaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchasePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchasePayments
     * const purchasePayment = await prisma.purchasePayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchasePaymentUpdateManyArgs>(args: SelectSubset<T, PurchasePaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchasePayment.
     * @param {PurchasePaymentUpsertArgs} args - Arguments to update or create a PurchasePayment.
     * @example
     * // Update or create a PurchasePayment
     * const purchasePayment = await prisma.purchasePayment.upsert({
     *   create: {
     *     // ... data to create a PurchasePayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchasePayment we want to update
     *   }
     * })
     */
    upsert<T extends PurchasePaymentUpsertArgs>(args: SelectSubset<T, PurchasePaymentUpsertArgs<ExtArgs>>): Prisma__PurchasePaymentClient<$Result.GetResult<Prisma.$PurchasePaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PurchasePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePaymentCountArgs} args - Arguments to filter PurchasePayments to count.
     * @example
     * // Count the number of PurchasePayments
     * const count = await prisma.purchasePayment.count({
     *   where: {
     *     // ... the filter for the PurchasePayments we want to count
     *   }
     * })
    **/
    count<T extends PurchasePaymentCountArgs>(
      args?: Subset<T, PurchasePaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchasePaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchasePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchasePaymentAggregateArgs>(args: Subset<T, PurchasePaymentAggregateArgs>): Prisma.PrismaPromise<GetPurchasePaymentAggregateType<T>>

    /**
     * Group by PurchasePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchasePaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchasePaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchasePaymentGroupByArgs['orderBy'] }
        : { orderBy?: PurchasePaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchasePaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchasePaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchasePayment model
   */
  readonly fields: PurchasePaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchasePayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchasePaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchase<T extends PurchaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseDefaultArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cashAccount<T extends CashAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CashAccountDefaultArgs<ExtArgs>>): Prisma__CashAccountClient<$Result.GetResult<Prisma.$CashAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchasePayment model
   */ 
  interface PurchasePaymentFieldRefs {
    readonly id: FieldRef<"PurchasePayment", 'String'>
    readonly paymentNo: FieldRef<"PurchasePayment", 'String'>
    readonly purchaseId: FieldRef<"PurchasePayment", 'String'>
    readonly vendorId: FieldRef<"PurchasePayment", 'String'>
    readonly cashAccountId: FieldRef<"PurchasePayment", 'String'>
    readonly amountPaid: FieldRef<"PurchasePayment", 'Decimal'>
    readonly paymentDate: FieldRef<"PurchasePayment", 'DateTime'>
    readonly reference: FieldRef<"PurchasePayment", 'String'>
    readonly notes: FieldRef<"PurchasePayment", 'String'>
    readonly userId: FieldRef<"PurchasePayment", 'String'>
    readonly createdAt: FieldRef<"PurchasePayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchasePayment findUnique
   */
  export type PurchasePaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePayment
     */
    select?: PurchasePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePaymentInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePayment to fetch.
     */
    where: PurchasePaymentWhereUniqueInput
  }

  /**
   * PurchasePayment findUniqueOrThrow
   */
  export type PurchasePaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePayment
     */
    select?: PurchasePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePaymentInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePayment to fetch.
     */
    where: PurchasePaymentWhereUniqueInput
  }

  /**
   * PurchasePayment findFirst
   */
  export type PurchasePaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePayment
     */
    select?: PurchasePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePaymentInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePayment to fetch.
     */
    where?: PurchasePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePayments to fetch.
     */
    orderBy?: PurchasePaymentOrderByWithRelationInput | PurchasePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasePayments.
     */
    cursor?: PurchasePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasePayments.
     */
    distinct?: PurchasePaymentScalarFieldEnum | PurchasePaymentScalarFieldEnum[]
  }

  /**
   * PurchasePayment findFirstOrThrow
   */
  export type PurchasePaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePayment
     */
    select?: PurchasePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePaymentInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePayment to fetch.
     */
    where?: PurchasePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePayments to fetch.
     */
    orderBy?: PurchasePaymentOrderByWithRelationInput | PurchasePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchasePayments.
     */
    cursor?: PurchasePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchasePayments.
     */
    distinct?: PurchasePaymentScalarFieldEnum | PurchasePaymentScalarFieldEnum[]
  }

  /**
   * PurchasePayment findMany
   */
  export type PurchasePaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePayment
     */
    select?: PurchasePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePaymentInclude<ExtArgs> | null
    /**
     * Filter, which PurchasePayments to fetch.
     */
    where?: PurchasePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchasePayments to fetch.
     */
    orderBy?: PurchasePaymentOrderByWithRelationInput | PurchasePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchasePayments.
     */
    cursor?: PurchasePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchasePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchasePayments.
     */
    skip?: number
    distinct?: PurchasePaymentScalarFieldEnum | PurchasePaymentScalarFieldEnum[]
  }

  /**
   * PurchasePayment create
   */
  export type PurchasePaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePayment
     */
    select?: PurchasePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchasePayment.
     */
    data: XOR<PurchasePaymentCreateInput, PurchasePaymentUncheckedCreateInput>
  }

  /**
   * PurchasePayment createMany
   */
  export type PurchasePaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchasePayments.
     */
    data: PurchasePaymentCreateManyInput | PurchasePaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchasePayment createManyAndReturn
   */
  export type PurchasePaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePayment
     */
    select?: PurchasePaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PurchasePayments.
     */
    data: PurchasePaymentCreateManyInput | PurchasePaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchasePayment update
   */
  export type PurchasePaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePayment
     */
    select?: PurchasePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchasePayment.
     */
    data: XOR<PurchasePaymentUpdateInput, PurchasePaymentUncheckedUpdateInput>
    /**
     * Choose, which PurchasePayment to update.
     */
    where: PurchasePaymentWhereUniqueInput
  }

  /**
   * PurchasePayment updateMany
   */
  export type PurchasePaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchasePayments.
     */
    data: XOR<PurchasePaymentUpdateManyMutationInput, PurchasePaymentUncheckedUpdateManyInput>
    /**
     * Filter which PurchasePayments to update
     */
    where?: PurchasePaymentWhereInput
  }

  /**
   * PurchasePayment upsert
   */
  export type PurchasePaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePayment
     */
    select?: PurchasePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchasePayment to update in case it exists.
     */
    where: PurchasePaymentWhereUniqueInput
    /**
     * In case the PurchasePayment found by the `where` argument doesn't exist, create a new PurchasePayment with this data.
     */
    create: XOR<PurchasePaymentCreateInput, PurchasePaymentUncheckedCreateInput>
    /**
     * In case the PurchasePayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchasePaymentUpdateInput, PurchasePaymentUncheckedUpdateInput>
  }

  /**
   * PurchasePayment delete
   */
  export type PurchasePaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePayment
     */
    select?: PurchasePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePaymentInclude<ExtArgs> | null
    /**
     * Filter which PurchasePayment to delete.
     */
    where: PurchasePaymentWhereUniqueInput
  }

  /**
   * PurchasePayment deleteMany
   */
  export type PurchasePaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchasePayments to delete
     */
    where?: PurchasePaymentWhereInput
  }

  /**
   * PurchasePayment without action
   */
  export type PurchasePaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchasePayment
     */
    select?: PurchasePaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchasePaymentInclude<ExtArgs> | null
  }


  /**
   * Model SystemSetting
   */

  export type AggregateSystemSetting = {
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  export type SystemSettingMinAggregateOutputType = {
    id: string | null
    category: string | null
    key: string | null
    value: string | null
    dataType: string | null
    description: string | null
    updatedBy: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type SystemSettingMaxAggregateOutputType = {
    id: string | null
    category: string | null
    key: string | null
    value: string | null
    dataType: string | null
    description: string | null
    updatedBy: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type SystemSettingCountAggregateOutputType = {
    id: number
    category: number
    key: number
    value: number
    dataType: number
    description: number
    updatedBy: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type SystemSettingMinAggregateInputType = {
    id?: true
    category?: true
    key?: true
    value?: true
    dataType?: true
    description?: true
    updatedBy?: true
    updatedAt?: true
    createdAt?: true
  }

  export type SystemSettingMaxAggregateInputType = {
    id?: true
    category?: true
    key?: true
    value?: true
    dataType?: true
    description?: true
    updatedBy?: true
    updatedAt?: true
    createdAt?: true
  }

  export type SystemSettingCountAggregateInputType = {
    id?: true
    category?: true
    key?: true
    value?: true
    dataType?: true
    description?: true
    updatedBy?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type SystemSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSetting to aggregate.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingMaxAggregateInputType
  }

  export type GetSystemSettingAggregateType<T extends SystemSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSetting[P]>
      : GetScalarType<T[P], AggregateSystemSetting[P]>
  }




  export type SystemSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingWhereInput
    orderBy?: SystemSettingOrderByWithAggregationInput | SystemSettingOrderByWithAggregationInput[]
    by: SystemSettingScalarFieldEnum[] | SystemSettingScalarFieldEnum
    having?: SystemSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingCountAggregateInputType | true
    _min?: SystemSettingMinAggregateInputType
    _max?: SystemSettingMaxAggregateInputType
  }

  export type SystemSettingGroupByOutputType = {
    id: string
    category: string
    key: string
    value: string | null
    dataType: string | null
    description: string | null
    updatedBy: string | null
    updatedAt: Date
    createdAt: Date
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  type GetSystemSettingGroupByPayload<T extends SystemSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    key?: boolean
    value?: boolean
    dataType?: boolean
    description?: boolean
    updatedBy?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    updatedByUser?: boolean | SystemSetting$updatedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    key?: boolean
    value?: boolean
    dataType?: boolean
    description?: boolean
    updatedBy?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    updatedByUser?: boolean | SystemSetting$updatedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectScalar = {
    id?: boolean
    category?: boolean
    key?: boolean
    value?: boolean
    dataType?: boolean
    description?: boolean
    updatedBy?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type SystemSettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    updatedByUser?: boolean | SystemSetting$updatedByUserArgs<ExtArgs>
  }
  export type SystemSettingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    updatedByUser?: boolean | SystemSetting$updatedByUserArgs<ExtArgs>
  }

  export type $SystemSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSetting"
    objects: {
      updatedByUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: string
      key: string
      value: string | null
      dataType: string | null
      description: string | null
      updatedBy: string | null
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["systemSetting"]>
    composites: {}
  }

  type SystemSettingGetPayload<S extends boolean | null | undefined | SystemSettingDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingPayload, S>

  type SystemSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemSettingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemSettingCountAggregateInputType | true
    }

  export interface SystemSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSetting'], meta: { name: 'SystemSetting' } }
    /**
     * Find zero or one SystemSetting that matches the filter.
     * @param {SystemSettingFindUniqueArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingFindUniqueArgs>(args: SelectSubset<T, SystemSettingFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemSetting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemSettingFindUniqueOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingFindFirstArgs>(args?: SelectSubset<T, SystemSettingFindFirstArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingFindManyArgs>(args?: SelectSubset<T, SystemSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemSetting.
     * @param {SystemSettingCreateArgs} args - Arguments to create a SystemSetting.
     * @example
     * // Create one SystemSetting
     * const SystemSetting = await prisma.systemSetting.create({
     *   data: {
     *     // ... data to create a SystemSetting
     *   }
     * })
     * 
     */
    create<T extends SystemSettingCreateArgs>(args: SelectSubset<T, SystemSettingCreateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingCreateManyArgs>(args?: SelectSubset<T, SystemSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemSettings and returns the data saved in the database.
     * @param {SystemSettingCreateManyAndReturnArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemSettings and only return the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SystemSetting.
     * @param {SystemSettingDeleteArgs} args - Arguments to delete one SystemSetting.
     * @example
     * // Delete one SystemSetting
     * const SystemSetting = await prisma.systemSetting.delete({
     *   where: {
     *     // ... filter to delete one SystemSetting
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingDeleteArgs>(args: SelectSubset<T, SystemSettingDeleteArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemSetting.
     * @param {SystemSettingUpdateArgs} args - Arguments to update one SystemSetting.
     * @example
     * // Update one SystemSetting
     * const systemSetting = await prisma.systemSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingUpdateArgs>(args: SelectSubset<T, SystemSettingUpdateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingDeleteManyArgs>(args?: SelectSubset<T, SystemSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingUpdateManyArgs>(args: SelectSubset<T, SystemSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemSetting.
     * @param {SystemSettingUpsertArgs} args - Arguments to update or create a SystemSetting.
     * @example
     * // Update or create a SystemSetting
     * const systemSetting = await prisma.systemSetting.upsert({
     *   create: {
     *     // ... data to create a SystemSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSetting we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingUpsertArgs>(args: SelectSubset<T, SystemSettingUpsertArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSetting.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingCountArgs>(
      args?: Subset<T, SystemSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingAggregateArgs>(args: Subset<T, SystemSettingAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingAggregateType<T>>

    /**
     * Group by SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSetting model
   */
  readonly fields: SystemSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    updatedByUser<T extends SystemSetting$updatedByUserArgs<ExtArgs> = {}>(args?: Subset<T, SystemSetting$updatedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSetting model
   */ 
  interface SystemSettingFieldRefs {
    readonly id: FieldRef<"SystemSetting", 'String'>
    readonly category: FieldRef<"SystemSetting", 'String'>
    readonly key: FieldRef<"SystemSetting", 'String'>
    readonly value: FieldRef<"SystemSetting", 'String'>
    readonly dataType: FieldRef<"SystemSetting", 'String'>
    readonly description: FieldRef<"SystemSetting", 'String'>
    readonly updatedBy: FieldRef<"SystemSetting", 'String'>
    readonly updatedAt: FieldRef<"SystemSetting", 'DateTime'>
    readonly createdAt: FieldRef<"SystemSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSetting findUnique
   */
  export type SystemSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findUniqueOrThrow
   */
  export type SystemSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findFirst
   */
  export type SystemSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findFirstOrThrow
   */
  export type SystemSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findMany
   */
  export type SystemSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting create
   */
  export type SystemSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a SystemSetting.
     */
    data: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
  }

  /**
   * SystemSetting createMany
   */
  export type SystemSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting createManyAndReturn
   */
  export type SystemSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SystemSetting update
   */
  export type SystemSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a SystemSetting.
     */
    data: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
    /**
     * Choose, which SystemSetting to update.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting updateMany
   */
  export type SystemSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
  }

  /**
   * SystemSetting upsert
   */
  export type SystemSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the SystemSetting to update in case it exists.
     */
    where: SystemSettingWhereUniqueInput
    /**
     * In case the SystemSetting found by the `where` argument doesn't exist, create a new SystemSetting with this data.
     */
    create: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
    /**
     * In case the SystemSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
  }

  /**
   * SystemSetting delete
   */
  export type SystemSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
    /**
     * Filter which SystemSetting to delete.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting deleteMany
   */
  export type SystemSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingWhereInput
  }

  /**
   * SystemSetting.updatedByUser
   */
  export type SystemSetting$updatedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SystemSetting without action
   */
  export type SystemSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemSettingInclude<ExtArgs> | null
  }


  /**
   * Model FiscalYear
   */

  export type AggregateFiscalYear = {
    _count: FiscalYearCountAggregateOutputType | null
    _avg: FiscalYearAvgAggregateOutputType | null
    _sum: FiscalYearSumAggregateOutputType | null
    _min: FiscalYearMinAggregateOutputType | null
    _max: FiscalYearMaxAggregateOutputType | null
  }

  export type FiscalYearAvgAggregateOutputType = {
    year: number | null
  }

  export type FiscalYearSumAggregateOutputType = {
    year: number | null
  }

  export type FiscalYearMinAggregateOutputType = {
    id: string | null
    year: number | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FiscalYearMaxAggregateOutputType = {
    id: string | null
    year: number | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FiscalYearCountAggregateOutputType = {
    id: number
    year: number
    startDate: number
    endDate: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FiscalYearAvgAggregateInputType = {
    year?: true
  }

  export type FiscalYearSumAggregateInputType = {
    year?: true
  }

  export type FiscalYearMinAggregateInputType = {
    id?: true
    year?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FiscalYearMaxAggregateInputType = {
    id?: true
    year?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FiscalYearCountAggregateInputType = {
    id?: true
    year?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FiscalYearAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FiscalYear to aggregate.
     */
    where?: FiscalYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiscalYears to fetch.
     */
    orderBy?: FiscalYearOrderByWithRelationInput | FiscalYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FiscalYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiscalYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiscalYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FiscalYears
    **/
    _count?: true | FiscalYearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FiscalYearAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FiscalYearSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FiscalYearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FiscalYearMaxAggregateInputType
  }

  export type GetFiscalYearAggregateType<T extends FiscalYearAggregateArgs> = {
        [P in keyof T & keyof AggregateFiscalYear]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFiscalYear[P]>
      : GetScalarType<T[P], AggregateFiscalYear[P]>
  }




  export type FiscalYearGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FiscalYearWhereInput
    orderBy?: FiscalYearOrderByWithAggregationInput | FiscalYearOrderByWithAggregationInput[]
    by: FiscalYearScalarFieldEnum[] | FiscalYearScalarFieldEnum
    having?: FiscalYearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FiscalYearCountAggregateInputType | true
    _avg?: FiscalYearAvgAggregateInputType
    _sum?: FiscalYearSumAggregateInputType
    _min?: FiscalYearMinAggregateInputType
    _max?: FiscalYearMaxAggregateInputType
  }

  export type FiscalYearGroupByOutputType = {
    id: string
    year: number
    startDate: Date
    endDate: Date
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: FiscalYearCountAggregateOutputType | null
    _avg: FiscalYearAvgAggregateOutputType | null
    _sum: FiscalYearSumAggregateOutputType | null
    _min: FiscalYearMinAggregateOutputType | null
    _max: FiscalYearMaxAggregateOutputType | null
  }

  type GetFiscalYearGroupByPayload<T extends FiscalYearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FiscalYearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FiscalYearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FiscalYearGroupByOutputType[P]>
            : GetScalarType<T[P], FiscalYearGroupByOutputType[P]>
        }
      >
    >


  export type FiscalYearSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    periods?: boolean | FiscalYear$periodsArgs<ExtArgs>
    _count?: boolean | FiscalYearCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fiscalYear"]>

  export type FiscalYearSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fiscalYear"]>

  export type FiscalYearSelectScalar = {
    id?: boolean
    year?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FiscalYearInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    periods?: boolean | FiscalYear$periodsArgs<ExtArgs>
    _count?: boolean | FiscalYearCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FiscalYearIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FiscalYearPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FiscalYear"
    objects: {
      periods: Prisma.$FiscalPeriodPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      year: number
      startDate: Date
      endDate: Date
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fiscalYear"]>
    composites: {}
  }

  type FiscalYearGetPayload<S extends boolean | null | undefined | FiscalYearDefaultArgs> = $Result.GetResult<Prisma.$FiscalYearPayload, S>

  type FiscalYearCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FiscalYearFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FiscalYearCountAggregateInputType | true
    }

  export interface FiscalYearDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FiscalYear'], meta: { name: 'FiscalYear' } }
    /**
     * Find zero or one FiscalYear that matches the filter.
     * @param {FiscalYearFindUniqueArgs} args - Arguments to find a FiscalYear
     * @example
     * // Get one FiscalYear
     * const fiscalYear = await prisma.fiscalYear.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FiscalYearFindUniqueArgs>(args: SelectSubset<T, FiscalYearFindUniqueArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FiscalYear that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FiscalYearFindUniqueOrThrowArgs} args - Arguments to find a FiscalYear
     * @example
     * // Get one FiscalYear
     * const fiscalYear = await prisma.fiscalYear.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FiscalYearFindUniqueOrThrowArgs>(args: SelectSubset<T, FiscalYearFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FiscalYear that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalYearFindFirstArgs} args - Arguments to find a FiscalYear
     * @example
     * // Get one FiscalYear
     * const fiscalYear = await prisma.fiscalYear.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FiscalYearFindFirstArgs>(args?: SelectSubset<T, FiscalYearFindFirstArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FiscalYear that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalYearFindFirstOrThrowArgs} args - Arguments to find a FiscalYear
     * @example
     * // Get one FiscalYear
     * const fiscalYear = await prisma.fiscalYear.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FiscalYearFindFirstOrThrowArgs>(args?: SelectSubset<T, FiscalYearFindFirstOrThrowArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FiscalYears that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalYearFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FiscalYears
     * const fiscalYears = await prisma.fiscalYear.findMany()
     * 
     * // Get first 10 FiscalYears
     * const fiscalYears = await prisma.fiscalYear.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fiscalYearWithIdOnly = await prisma.fiscalYear.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FiscalYearFindManyArgs>(args?: SelectSubset<T, FiscalYearFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FiscalYear.
     * @param {FiscalYearCreateArgs} args - Arguments to create a FiscalYear.
     * @example
     * // Create one FiscalYear
     * const FiscalYear = await prisma.fiscalYear.create({
     *   data: {
     *     // ... data to create a FiscalYear
     *   }
     * })
     * 
     */
    create<T extends FiscalYearCreateArgs>(args: SelectSubset<T, FiscalYearCreateArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FiscalYears.
     * @param {FiscalYearCreateManyArgs} args - Arguments to create many FiscalYears.
     * @example
     * // Create many FiscalYears
     * const fiscalYear = await prisma.fiscalYear.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FiscalYearCreateManyArgs>(args?: SelectSubset<T, FiscalYearCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FiscalYears and returns the data saved in the database.
     * @param {FiscalYearCreateManyAndReturnArgs} args - Arguments to create many FiscalYears.
     * @example
     * // Create many FiscalYears
     * const fiscalYear = await prisma.fiscalYear.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FiscalYears and only return the `id`
     * const fiscalYearWithIdOnly = await prisma.fiscalYear.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FiscalYearCreateManyAndReturnArgs>(args?: SelectSubset<T, FiscalYearCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FiscalYear.
     * @param {FiscalYearDeleteArgs} args - Arguments to delete one FiscalYear.
     * @example
     * // Delete one FiscalYear
     * const FiscalYear = await prisma.fiscalYear.delete({
     *   where: {
     *     // ... filter to delete one FiscalYear
     *   }
     * })
     * 
     */
    delete<T extends FiscalYearDeleteArgs>(args: SelectSubset<T, FiscalYearDeleteArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FiscalYear.
     * @param {FiscalYearUpdateArgs} args - Arguments to update one FiscalYear.
     * @example
     * // Update one FiscalYear
     * const fiscalYear = await prisma.fiscalYear.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FiscalYearUpdateArgs>(args: SelectSubset<T, FiscalYearUpdateArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FiscalYears.
     * @param {FiscalYearDeleteManyArgs} args - Arguments to filter FiscalYears to delete.
     * @example
     * // Delete a few FiscalYears
     * const { count } = await prisma.fiscalYear.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FiscalYearDeleteManyArgs>(args?: SelectSubset<T, FiscalYearDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FiscalYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalYearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FiscalYears
     * const fiscalYear = await prisma.fiscalYear.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FiscalYearUpdateManyArgs>(args: SelectSubset<T, FiscalYearUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FiscalYear.
     * @param {FiscalYearUpsertArgs} args - Arguments to update or create a FiscalYear.
     * @example
     * // Update or create a FiscalYear
     * const fiscalYear = await prisma.fiscalYear.upsert({
     *   create: {
     *     // ... data to create a FiscalYear
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FiscalYear we want to update
     *   }
     * })
     */
    upsert<T extends FiscalYearUpsertArgs>(args: SelectSubset<T, FiscalYearUpsertArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FiscalYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalYearCountArgs} args - Arguments to filter FiscalYears to count.
     * @example
     * // Count the number of FiscalYears
     * const count = await prisma.fiscalYear.count({
     *   where: {
     *     // ... the filter for the FiscalYears we want to count
     *   }
     * })
    **/
    count<T extends FiscalYearCountArgs>(
      args?: Subset<T, FiscalYearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FiscalYearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FiscalYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalYearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FiscalYearAggregateArgs>(args: Subset<T, FiscalYearAggregateArgs>): Prisma.PrismaPromise<GetFiscalYearAggregateType<T>>

    /**
     * Group by FiscalYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalYearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FiscalYearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FiscalYearGroupByArgs['orderBy'] }
        : { orderBy?: FiscalYearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FiscalYearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFiscalYearGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FiscalYear model
   */
  readonly fields: FiscalYearFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FiscalYear.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FiscalYearClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    periods<T extends FiscalYear$periodsArgs<ExtArgs> = {}>(args?: Subset<T, FiscalYear$periodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FiscalPeriodPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FiscalYear model
   */ 
  interface FiscalYearFieldRefs {
    readonly id: FieldRef<"FiscalYear", 'String'>
    readonly year: FieldRef<"FiscalYear", 'Int'>
    readonly startDate: FieldRef<"FiscalYear", 'DateTime'>
    readonly endDate: FieldRef<"FiscalYear", 'DateTime'>
    readonly isActive: FieldRef<"FiscalYear", 'Boolean'>
    readonly createdAt: FieldRef<"FiscalYear", 'DateTime'>
    readonly updatedAt: FieldRef<"FiscalYear", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FiscalYear findUnique
   */
  export type FiscalYearFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * Filter, which FiscalYear to fetch.
     */
    where: FiscalYearWhereUniqueInput
  }

  /**
   * FiscalYear findUniqueOrThrow
   */
  export type FiscalYearFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * Filter, which FiscalYear to fetch.
     */
    where: FiscalYearWhereUniqueInput
  }

  /**
   * FiscalYear findFirst
   */
  export type FiscalYearFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * Filter, which FiscalYear to fetch.
     */
    where?: FiscalYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiscalYears to fetch.
     */
    orderBy?: FiscalYearOrderByWithRelationInput | FiscalYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FiscalYears.
     */
    cursor?: FiscalYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiscalYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiscalYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FiscalYears.
     */
    distinct?: FiscalYearScalarFieldEnum | FiscalYearScalarFieldEnum[]
  }

  /**
   * FiscalYear findFirstOrThrow
   */
  export type FiscalYearFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * Filter, which FiscalYear to fetch.
     */
    where?: FiscalYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiscalYears to fetch.
     */
    orderBy?: FiscalYearOrderByWithRelationInput | FiscalYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FiscalYears.
     */
    cursor?: FiscalYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiscalYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiscalYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FiscalYears.
     */
    distinct?: FiscalYearScalarFieldEnum | FiscalYearScalarFieldEnum[]
  }

  /**
   * FiscalYear findMany
   */
  export type FiscalYearFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * Filter, which FiscalYears to fetch.
     */
    where?: FiscalYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiscalYears to fetch.
     */
    orderBy?: FiscalYearOrderByWithRelationInput | FiscalYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FiscalYears.
     */
    cursor?: FiscalYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiscalYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiscalYears.
     */
    skip?: number
    distinct?: FiscalYearScalarFieldEnum | FiscalYearScalarFieldEnum[]
  }

  /**
   * FiscalYear create
   */
  export type FiscalYearCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * The data needed to create a FiscalYear.
     */
    data: XOR<FiscalYearCreateInput, FiscalYearUncheckedCreateInput>
  }

  /**
   * FiscalYear createMany
   */
  export type FiscalYearCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FiscalYears.
     */
    data: FiscalYearCreateManyInput | FiscalYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FiscalYear createManyAndReturn
   */
  export type FiscalYearCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FiscalYears.
     */
    data: FiscalYearCreateManyInput | FiscalYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FiscalYear update
   */
  export type FiscalYearUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * The data needed to update a FiscalYear.
     */
    data: XOR<FiscalYearUpdateInput, FiscalYearUncheckedUpdateInput>
    /**
     * Choose, which FiscalYear to update.
     */
    where: FiscalYearWhereUniqueInput
  }

  /**
   * FiscalYear updateMany
   */
  export type FiscalYearUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FiscalYears.
     */
    data: XOR<FiscalYearUpdateManyMutationInput, FiscalYearUncheckedUpdateManyInput>
    /**
     * Filter which FiscalYears to update
     */
    where?: FiscalYearWhereInput
  }

  /**
   * FiscalYear upsert
   */
  export type FiscalYearUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * The filter to search for the FiscalYear to update in case it exists.
     */
    where: FiscalYearWhereUniqueInput
    /**
     * In case the FiscalYear found by the `where` argument doesn't exist, create a new FiscalYear with this data.
     */
    create: XOR<FiscalYearCreateInput, FiscalYearUncheckedCreateInput>
    /**
     * In case the FiscalYear was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FiscalYearUpdateInput, FiscalYearUncheckedUpdateInput>
  }

  /**
   * FiscalYear delete
   */
  export type FiscalYearDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * Filter which FiscalYear to delete.
     */
    where: FiscalYearWhereUniqueInput
  }

  /**
   * FiscalYear deleteMany
   */
  export type FiscalYearDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FiscalYears to delete
     */
    where?: FiscalYearWhereInput
  }

  /**
   * FiscalYear.periods
   */
  export type FiscalYear$periodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalPeriod
     */
    select?: FiscalPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalPeriodInclude<ExtArgs> | null
    where?: FiscalPeriodWhereInput
    orderBy?: FiscalPeriodOrderByWithRelationInput | FiscalPeriodOrderByWithRelationInput[]
    cursor?: FiscalPeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FiscalPeriodScalarFieldEnum | FiscalPeriodScalarFieldEnum[]
  }

  /**
   * FiscalYear without action
   */
  export type FiscalYearDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
  }


  /**
   * Model FiscalPeriod
   */

  export type AggregateFiscalPeriod = {
    _count: FiscalPeriodCountAggregateOutputType | null
    _avg: FiscalPeriodAvgAggregateOutputType | null
    _sum: FiscalPeriodSumAggregateOutputType | null
    _min: FiscalPeriodMinAggregateOutputType | null
    _max: FiscalPeriodMaxAggregateOutputType | null
  }

  export type FiscalPeriodAvgAggregateOutputType = {
    periodNumber: number | null
  }

  export type FiscalPeriodSumAggregateOutputType = {
    periodNumber: number | null
  }

  export type FiscalPeriodMinAggregateOutputType = {
    id: string | null
    fiscalYearId: string | null
    periodNumber: number | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    isClosed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FiscalPeriodMaxAggregateOutputType = {
    id: string | null
    fiscalYearId: string | null
    periodNumber: number | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    isClosed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FiscalPeriodCountAggregateOutputType = {
    id: number
    fiscalYearId: number
    periodNumber: number
    name: number
    startDate: number
    endDate: number
    isActive: number
    isClosed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FiscalPeriodAvgAggregateInputType = {
    periodNumber?: true
  }

  export type FiscalPeriodSumAggregateInputType = {
    periodNumber?: true
  }

  export type FiscalPeriodMinAggregateInputType = {
    id?: true
    fiscalYearId?: true
    periodNumber?: true
    name?: true
    startDate?: true
    endDate?: true
    isActive?: true
    isClosed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FiscalPeriodMaxAggregateInputType = {
    id?: true
    fiscalYearId?: true
    periodNumber?: true
    name?: true
    startDate?: true
    endDate?: true
    isActive?: true
    isClosed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FiscalPeriodCountAggregateInputType = {
    id?: true
    fiscalYearId?: true
    periodNumber?: true
    name?: true
    startDate?: true
    endDate?: true
    isActive?: true
    isClosed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FiscalPeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FiscalPeriod to aggregate.
     */
    where?: FiscalPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiscalPeriods to fetch.
     */
    orderBy?: FiscalPeriodOrderByWithRelationInput | FiscalPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FiscalPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiscalPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiscalPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FiscalPeriods
    **/
    _count?: true | FiscalPeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FiscalPeriodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FiscalPeriodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FiscalPeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FiscalPeriodMaxAggregateInputType
  }

  export type GetFiscalPeriodAggregateType<T extends FiscalPeriodAggregateArgs> = {
        [P in keyof T & keyof AggregateFiscalPeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFiscalPeriod[P]>
      : GetScalarType<T[P], AggregateFiscalPeriod[P]>
  }




  export type FiscalPeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FiscalPeriodWhereInput
    orderBy?: FiscalPeriodOrderByWithAggregationInput | FiscalPeriodOrderByWithAggregationInput[]
    by: FiscalPeriodScalarFieldEnum[] | FiscalPeriodScalarFieldEnum
    having?: FiscalPeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FiscalPeriodCountAggregateInputType | true
    _avg?: FiscalPeriodAvgAggregateInputType
    _sum?: FiscalPeriodSumAggregateInputType
    _min?: FiscalPeriodMinAggregateInputType
    _max?: FiscalPeriodMaxAggregateInputType
  }

  export type FiscalPeriodGroupByOutputType = {
    id: string
    fiscalYearId: string
    periodNumber: number
    name: string
    startDate: Date
    endDate: Date
    isActive: boolean
    isClosed: boolean
    createdAt: Date
    updatedAt: Date
    _count: FiscalPeriodCountAggregateOutputType | null
    _avg: FiscalPeriodAvgAggregateOutputType | null
    _sum: FiscalPeriodSumAggregateOutputType | null
    _min: FiscalPeriodMinAggregateOutputType | null
    _max: FiscalPeriodMaxAggregateOutputType | null
  }

  type GetFiscalPeriodGroupByPayload<T extends FiscalPeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FiscalPeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FiscalPeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FiscalPeriodGroupByOutputType[P]>
            : GetScalarType<T[P], FiscalPeriodGroupByOutputType[P]>
        }
      >
    >


  export type FiscalPeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fiscalYearId?: boolean
    periodNumber?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    isClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fiscalYear?: boolean | FiscalYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fiscalPeriod"]>

  export type FiscalPeriodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fiscalYearId?: boolean
    periodNumber?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    isClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fiscalYear?: boolean | FiscalYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fiscalPeriod"]>

  export type FiscalPeriodSelectScalar = {
    id?: boolean
    fiscalYearId?: boolean
    periodNumber?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    isClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FiscalPeriodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fiscalYear?: boolean | FiscalYearDefaultArgs<ExtArgs>
  }
  export type FiscalPeriodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fiscalYear?: boolean | FiscalYearDefaultArgs<ExtArgs>
  }

  export type $FiscalPeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FiscalPeriod"
    objects: {
      fiscalYear: Prisma.$FiscalYearPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fiscalYearId: string
      periodNumber: number
      name: string
      startDate: Date
      endDate: Date
      isActive: boolean
      isClosed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fiscalPeriod"]>
    composites: {}
  }

  type FiscalPeriodGetPayload<S extends boolean | null | undefined | FiscalPeriodDefaultArgs> = $Result.GetResult<Prisma.$FiscalPeriodPayload, S>

  type FiscalPeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FiscalPeriodFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FiscalPeriodCountAggregateInputType | true
    }

  export interface FiscalPeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FiscalPeriod'], meta: { name: 'FiscalPeriod' } }
    /**
     * Find zero or one FiscalPeriod that matches the filter.
     * @param {FiscalPeriodFindUniqueArgs} args - Arguments to find a FiscalPeriod
     * @example
     * // Get one FiscalPeriod
     * const fiscalPeriod = await prisma.fiscalPeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FiscalPeriodFindUniqueArgs>(args: SelectSubset<T, FiscalPeriodFindUniqueArgs<ExtArgs>>): Prisma__FiscalPeriodClient<$Result.GetResult<Prisma.$FiscalPeriodPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FiscalPeriod that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FiscalPeriodFindUniqueOrThrowArgs} args - Arguments to find a FiscalPeriod
     * @example
     * // Get one FiscalPeriod
     * const fiscalPeriod = await prisma.fiscalPeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FiscalPeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, FiscalPeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FiscalPeriodClient<$Result.GetResult<Prisma.$FiscalPeriodPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FiscalPeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalPeriodFindFirstArgs} args - Arguments to find a FiscalPeriod
     * @example
     * // Get one FiscalPeriod
     * const fiscalPeriod = await prisma.fiscalPeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FiscalPeriodFindFirstArgs>(args?: SelectSubset<T, FiscalPeriodFindFirstArgs<ExtArgs>>): Prisma__FiscalPeriodClient<$Result.GetResult<Prisma.$FiscalPeriodPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FiscalPeriod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalPeriodFindFirstOrThrowArgs} args - Arguments to find a FiscalPeriod
     * @example
     * // Get one FiscalPeriod
     * const fiscalPeriod = await prisma.fiscalPeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FiscalPeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, FiscalPeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__FiscalPeriodClient<$Result.GetResult<Prisma.$FiscalPeriodPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FiscalPeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalPeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FiscalPeriods
     * const fiscalPeriods = await prisma.fiscalPeriod.findMany()
     * 
     * // Get first 10 FiscalPeriods
     * const fiscalPeriods = await prisma.fiscalPeriod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fiscalPeriodWithIdOnly = await prisma.fiscalPeriod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FiscalPeriodFindManyArgs>(args?: SelectSubset<T, FiscalPeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FiscalPeriodPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FiscalPeriod.
     * @param {FiscalPeriodCreateArgs} args - Arguments to create a FiscalPeriod.
     * @example
     * // Create one FiscalPeriod
     * const FiscalPeriod = await prisma.fiscalPeriod.create({
     *   data: {
     *     // ... data to create a FiscalPeriod
     *   }
     * })
     * 
     */
    create<T extends FiscalPeriodCreateArgs>(args: SelectSubset<T, FiscalPeriodCreateArgs<ExtArgs>>): Prisma__FiscalPeriodClient<$Result.GetResult<Prisma.$FiscalPeriodPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FiscalPeriods.
     * @param {FiscalPeriodCreateManyArgs} args - Arguments to create many FiscalPeriods.
     * @example
     * // Create many FiscalPeriods
     * const fiscalPeriod = await prisma.fiscalPeriod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FiscalPeriodCreateManyArgs>(args?: SelectSubset<T, FiscalPeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FiscalPeriods and returns the data saved in the database.
     * @param {FiscalPeriodCreateManyAndReturnArgs} args - Arguments to create many FiscalPeriods.
     * @example
     * // Create many FiscalPeriods
     * const fiscalPeriod = await prisma.fiscalPeriod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FiscalPeriods and only return the `id`
     * const fiscalPeriodWithIdOnly = await prisma.fiscalPeriod.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FiscalPeriodCreateManyAndReturnArgs>(args?: SelectSubset<T, FiscalPeriodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FiscalPeriodPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FiscalPeriod.
     * @param {FiscalPeriodDeleteArgs} args - Arguments to delete one FiscalPeriod.
     * @example
     * // Delete one FiscalPeriod
     * const FiscalPeriod = await prisma.fiscalPeriod.delete({
     *   where: {
     *     // ... filter to delete one FiscalPeriod
     *   }
     * })
     * 
     */
    delete<T extends FiscalPeriodDeleteArgs>(args: SelectSubset<T, FiscalPeriodDeleteArgs<ExtArgs>>): Prisma__FiscalPeriodClient<$Result.GetResult<Prisma.$FiscalPeriodPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FiscalPeriod.
     * @param {FiscalPeriodUpdateArgs} args - Arguments to update one FiscalPeriod.
     * @example
     * // Update one FiscalPeriod
     * const fiscalPeriod = await prisma.fiscalPeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FiscalPeriodUpdateArgs>(args: SelectSubset<T, FiscalPeriodUpdateArgs<ExtArgs>>): Prisma__FiscalPeriodClient<$Result.GetResult<Prisma.$FiscalPeriodPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FiscalPeriods.
     * @param {FiscalPeriodDeleteManyArgs} args - Arguments to filter FiscalPeriods to delete.
     * @example
     * // Delete a few FiscalPeriods
     * const { count } = await prisma.fiscalPeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FiscalPeriodDeleteManyArgs>(args?: SelectSubset<T, FiscalPeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FiscalPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalPeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FiscalPeriods
     * const fiscalPeriod = await prisma.fiscalPeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FiscalPeriodUpdateManyArgs>(args: SelectSubset<T, FiscalPeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FiscalPeriod.
     * @param {FiscalPeriodUpsertArgs} args - Arguments to update or create a FiscalPeriod.
     * @example
     * // Update or create a FiscalPeriod
     * const fiscalPeriod = await prisma.fiscalPeriod.upsert({
     *   create: {
     *     // ... data to create a FiscalPeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FiscalPeriod we want to update
     *   }
     * })
     */
    upsert<T extends FiscalPeriodUpsertArgs>(args: SelectSubset<T, FiscalPeriodUpsertArgs<ExtArgs>>): Prisma__FiscalPeriodClient<$Result.GetResult<Prisma.$FiscalPeriodPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FiscalPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalPeriodCountArgs} args - Arguments to filter FiscalPeriods to count.
     * @example
     * // Count the number of FiscalPeriods
     * const count = await prisma.fiscalPeriod.count({
     *   where: {
     *     // ... the filter for the FiscalPeriods we want to count
     *   }
     * })
    **/
    count<T extends FiscalPeriodCountArgs>(
      args?: Subset<T, FiscalPeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FiscalPeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FiscalPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalPeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FiscalPeriodAggregateArgs>(args: Subset<T, FiscalPeriodAggregateArgs>): Prisma.PrismaPromise<GetFiscalPeriodAggregateType<T>>

    /**
     * Group by FiscalPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalPeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FiscalPeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FiscalPeriodGroupByArgs['orderBy'] }
        : { orderBy?: FiscalPeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FiscalPeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFiscalPeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FiscalPeriod model
   */
  readonly fields: FiscalPeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FiscalPeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FiscalPeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fiscalYear<T extends FiscalYearDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FiscalYearDefaultArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FiscalPeriod model
   */ 
  interface FiscalPeriodFieldRefs {
    readonly id: FieldRef<"FiscalPeriod", 'String'>
    readonly fiscalYearId: FieldRef<"FiscalPeriod", 'String'>
    readonly periodNumber: FieldRef<"FiscalPeriod", 'Int'>
    readonly name: FieldRef<"FiscalPeriod", 'String'>
    readonly startDate: FieldRef<"FiscalPeriod", 'DateTime'>
    readonly endDate: FieldRef<"FiscalPeriod", 'DateTime'>
    readonly isActive: FieldRef<"FiscalPeriod", 'Boolean'>
    readonly isClosed: FieldRef<"FiscalPeriod", 'Boolean'>
    readonly createdAt: FieldRef<"FiscalPeriod", 'DateTime'>
    readonly updatedAt: FieldRef<"FiscalPeriod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FiscalPeriod findUnique
   */
  export type FiscalPeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalPeriod
     */
    select?: FiscalPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalPeriodInclude<ExtArgs> | null
    /**
     * Filter, which FiscalPeriod to fetch.
     */
    where: FiscalPeriodWhereUniqueInput
  }

  /**
   * FiscalPeriod findUniqueOrThrow
   */
  export type FiscalPeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalPeriod
     */
    select?: FiscalPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalPeriodInclude<ExtArgs> | null
    /**
     * Filter, which FiscalPeriod to fetch.
     */
    where: FiscalPeriodWhereUniqueInput
  }

  /**
   * FiscalPeriod findFirst
   */
  export type FiscalPeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalPeriod
     */
    select?: FiscalPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalPeriodInclude<ExtArgs> | null
    /**
     * Filter, which FiscalPeriod to fetch.
     */
    where?: FiscalPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiscalPeriods to fetch.
     */
    orderBy?: FiscalPeriodOrderByWithRelationInput | FiscalPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FiscalPeriods.
     */
    cursor?: FiscalPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiscalPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiscalPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FiscalPeriods.
     */
    distinct?: FiscalPeriodScalarFieldEnum | FiscalPeriodScalarFieldEnum[]
  }

  /**
   * FiscalPeriod findFirstOrThrow
   */
  export type FiscalPeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalPeriod
     */
    select?: FiscalPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalPeriodInclude<ExtArgs> | null
    /**
     * Filter, which FiscalPeriod to fetch.
     */
    where?: FiscalPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiscalPeriods to fetch.
     */
    orderBy?: FiscalPeriodOrderByWithRelationInput | FiscalPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FiscalPeriods.
     */
    cursor?: FiscalPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiscalPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiscalPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FiscalPeriods.
     */
    distinct?: FiscalPeriodScalarFieldEnum | FiscalPeriodScalarFieldEnum[]
  }

  /**
   * FiscalPeriod findMany
   */
  export type FiscalPeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalPeriod
     */
    select?: FiscalPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalPeriodInclude<ExtArgs> | null
    /**
     * Filter, which FiscalPeriods to fetch.
     */
    where?: FiscalPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiscalPeriods to fetch.
     */
    orderBy?: FiscalPeriodOrderByWithRelationInput | FiscalPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FiscalPeriods.
     */
    cursor?: FiscalPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiscalPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiscalPeriods.
     */
    skip?: number
    distinct?: FiscalPeriodScalarFieldEnum | FiscalPeriodScalarFieldEnum[]
  }

  /**
   * FiscalPeriod create
   */
  export type FiscalPeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalPeriod
     */
    select?: FiscalPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalPeriodInclude<ExtArgs> | null
    /**
     * The data needed to create a FiscalPeriod.
     */
    data: XOR<FiscalPeriodCreateInput, FiscalPeriodUncheckedCreateInput>
  }

  /**
   * FiscalPeriod createMany
   */
  export type FiscalPeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FiscalPeriods.
     */
    data: FiscalPeriodCreateManyInput | FiscalPeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FiscalPeriod createManyAndReturn
   */
  export type FiscalPeriodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalPeriod
     */
    select?: FiscalPeriodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FiscalPeriods.
     */
    data: FiscalPeriodCreateManyInput | FiscalPeriodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalPeriodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FiscalPeriod update
   */
  export type FiscalPeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalPeriod
     */
    select?: FiscalPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalPeriodInclude<ExtArgs> | null
    /**
     * The data needed to update a FiscalPeriod.
     */
    data: XOR<FiscalPeriodUpdateInput, FiscalPeriodUncheckedUpdateInput>
    /**
     * Choose, which FiscalPeriod to update.
     */
    where: FiscalPeriodWhereUniqueInput
  }

  /**
   * FiscalPeriod updateMany
   */
  export type FiscalPeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FiscalPeriods.
     */
    data: XOR<FiscalPeriodUpdateManyMutationInput, FiscalPeriodUncheckedUpdateManyInput>
    /**
     * Filter which FiscalPeriods to update
     */
    where?: FiscalPeriodWhereInput
  }

  /**
   * FiscalPeriod upsert
   */
  export type FiscalPeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalPeriod
     */
    select?: FiscalPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalPeriodInclude<ExtArgs> | null
    /**
     * The filter to search for the FiscalPeriod to update in case it exists.
     */
    where: FiscalPeriodWhereUniqueInput
    /**
     * In case the FiscalPeriod found by the `where` argument doesn't exist, create a new FiscalPeriod with this data.
     */
    create: XOR<FiscalPeriodCreateInput, FiscalPeriodUncheckedCreateInput>
    /**
     * In case the FiscalPeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FiscalPeriodUpdateInput, FiscalPeriodUncheckedUpdateInput>
  }

  /**
   * FiscalPeriod delete
   */
  export type FiscalPeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalPeriod
     */
    select?: FiscalPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalPeriodInclude<ExtArgs> | null
    /**
     * Filter which FiscalPeriod to delete.
     */
    where: FiscalPeriodWhereUniqueInput
  }

  /**
   * FiscalPeriod deleteMany
   */
  export type FiscalPeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FiscalPeriods to delete
     */
    where?: FiscalPeriodWhereInput
  }

  /**
   * FiscalPeriod without action
   */
  export type FiscalPeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalPeriod
     */
    select?: FiscalPeriodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalPeriodInclude<ExtArgs> | null
  }


  /**
   * Model ApprovalWorkflow
   */

  export type AggregateApprovalWorkflow = {
    _count: ApprovalWorkflowCountAggregateOutputType | null
    _avg: ApprovalWorkflowAvgAggregateOutputType | null
    _sum: ApprovalWorkflowSumAggregateOutputType | null
    _min: ApprovalWorkflowMinAggregateOutputType | null
    _max: ApprovalWorkflowMaxAggregateOutputType | null
  }

  export type ApprovalWorkflowAvgAggregateOutputType = {
    minAmount: Decimal | null
    maxAmount: Decimal | null
  }

  export type ApprovalWorkflowSumAggregateOutputType = {
    minAmount: Decimal | null
    maxAmount: Decimal | null
  }

  export type ApprovalWorkflowMinAggregateOutputType = {
    id: string | null
    name: string | null
    entity: string | null
    minAmount: Decimal | null
    maxAmount: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApprovalWorkflowMaxAggregateOutputType = {
    id: string | null
    name: string | null
    entity: string | null
    minAmount: Decimal | null
    maxAmount: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApprovalWorkflowCountAggregateOutputType = {
    id: number
    name: number
    entity: number
    minAmount: number
    maxAmount: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApprovalWorkflowAvgAggregateInputType = {
    minAmount?: true
    maxAmount?: true
  }

  export type ApprovalWorkflowSumAggregateInputType = {
    minAmount?: true
    maxAmount?: true
  }

  export type ApprovalWorkflowMinAggregateInputType = {
    id?: true
    name?: true
    entity?: true
    minAmount?: true
    maxAmount?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApprovalWorkflowMaxAggregateInputType = {
    id?: true
    name?: true
    entity?: true
    minAmount?: true
    maxAmount?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApprovalWorkflowCountAggregateInputType = {
    id?: true
    name?: true
    entity?: true
    minAmount?: true
    maxAmount?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApprovalWorkflowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalWorkflow to aggregate.
     */
    where?: ApprovalWorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalWorkflows to fetch.
     */
    orderBy?: ApprovalWorkflowOrderByWithRelationInput | ApprovalWorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApprovalWorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalWorkflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalWorkflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApprovalWorkflows
    **/
    _count?: true | ApprovalWorkflowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApprovalWorkflowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApprovalWorkflowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApprovalWorkflowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApprovalWorkflowMaxAggregateInputType
  }

  export type GetApprovalWorkflowAggregateType<T extends ApprovalWorkflowAggregateArgs> = {
        [P in keyof T & keyof AggregateApprovalWorkflow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApprovalWorkflow[P]>
      : GetScalarType<T[P], AggregateApprovalWorkflow[P]>
  }




  export type ApprovalWorkflowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalWorkflowWhereInput
    orderBy?: ApprovalWorkflowOrderByWithAggregationInput | ApprovalWorkflowOrderByWithAggregationInput[]
    by: ApprovalWorkflowScalarFieldEnum[] | ApprovalWorkflowScalarFieldEnum
    having?: ApprovalWorkflowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApprovalWorkflowCountAggregateInputType | true
    _avg?: ApprovalWorkflowAvgAggregateInputType
    _sum?: ApprovalWorkflowSumAggregateInputType
    _min?: ApprovalWorkflowMinAggregateInputType
    _max?: ApprovalWorkflowMaxAggregateInputType
  }

  export type ApprovalWorkflowGroupByOutputType = {
    id: string
    name: string
    entity: string
    minAmount: Decimal | null
    maxAmount: Decimal | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ApprovalWorkflowCountAggregateOutputType | null
    _avg: ApprovalWorkflowAvgAggregateOutputType | null
    _sum: ApprovalWorkflowSumAggregateOutputType | null
    _min: ApprovalWorkflowMinAggregateOutputType | null
    _max: ApprovalWorkflowMaxAggregateOutputType | null
  }

  type GetApprovalWorkflowGroupByPayload<T extends ApprovalWorkflowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApprovalWorkflowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApprovalWorkflowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApprovalWorkflowGroupByOutputType[P]>
            : GetScalarType<T[P], ApprovalWorkflowGroupByOutputType[P]>
        }
      >
    >


  export type ApprovalWorkflowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    entity?: boolean
    minAmount?: boolean
    maxAmount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    steps?: boolean | ApprovalWorkflow$stepsArgs<ExtArgs>
    ApprovalRequest?: boolean | ApprovalWorkflow$ApprovalRequestArgs<ExtArgs>
    _count?: boolean | ApprovalWorkflowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approvalWorkflow"]>

  export type ApprovalWorkflowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    entity?: boolean
    minAmount?: boolean
    maxAmount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["approvalWorkflow"]>

  export type ApprovalWorkflowSelectScalar = {
    id?: boolean
    name?: boolean
    entity?: boolean
    minAmount?: boolean
    maxAmount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApprovalWorkflowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | ApprovalWorkflow$stepsArgs<ExtArgs>
    ApprovalRequest?: boolean | ApprovalWorkflow$ApprovalRequestArgs<ExtArgs>
    _count?: boolean | ApprovalWorkflowCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ApprovalWorkflowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ApprovalWorkflowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApprovalWorkflow"
    objects: {
      steps: Prisma.$ApprovalStepPayload<ExtArgs>[]
      ApprovalRequest: Prisma.$ApprovalRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      entity: string
      minAmount: Prisma.Decimal | null
      maxAmount: Prisma.Decimal | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["approvalWorkflow"]>
    composites: {}
  }

  type ApprovalWorkflowGetPayload<S extends boolean | null | undefined | ApprovalWorkflowDefaultArgs> = $Result.GetResult<Prisma.$ApprovalWorkflowPayload, S>

  type ApprovalWorkflowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApprovalWorkflowFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApprovalWorkflowCountAggregateInputType | true
    }

  export interface ApprovalWorkflowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApprovalWorkflow'], meta: { name: 'ApprovalWorkflow' } }
    /**
     * Find zero or one ApprovalWorkflow that matches the filter.
     * @param {ApprovalWorkflowFindUniqueArgs} args - Arguments to find a ApprovalWorkflow
     * @example
     * // Get one ApprovalWorkflow
     * const approvalWorkflow = await prisma.approvalWorkflow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApprovalWorkflowFindUniqueArgs>(args: SelectSubset<T, ApprovalWorkflowFindUniqueArgs<ExtArgs>>): Prisma__ApprovalWorkflowClient<$Result.GetResult<Prisma.$ApprovalWorkflowPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApprovalWorkflow that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApprovalWorkflowFindUniqueOrThrowArgs} args - Arguments to find a ApprovalWorkflow
     * @example
     * // Get one ApprovalWorkflow
     * const approvalWorkflow = await prisma.approvalWorkflow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApprovalWorkflowFindUniqueOrThrowArgs>(args: SelectSubset<T, ApprovalWorkflowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApprovalWorkflowClient<$Result.GetResult<Prisma.$ApprovalWorkflowPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApprovalWorkflow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalWorkflowFindFirstArgs} args - Arguments to find a ApprovalWorkflow
     * @example
     * // Get one ApprovalWorkflow
     * const approvalWorkflow = await prisma.approvalWorkflow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApprovalWorkflowFindFirstArgs>(args?: SelectSubset<T, ApprovalWorkflowFindFirstArgs<ExtArgs>>): Prisma__ApprovalWorkflowClient<$Result.GetResult<Prisma.$ApprovalWorkflowPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApprovalWorkflow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalWorkflowFindFirstOrThrowArgs} args - Arguments to find a ApprovalWorkflow
     * @example
     * // Get one ApprovalWorkflow
     * const approvalWorkflow = await prisma.approvalWorkflow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApprovalWorkflowFindFirstOrThrowArgs>(args?: SelectSubset<T, ApprovalWorkflowFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApprovalWorkflowClient<$Result.GetResult<Prisma.$ApprovalWorkflowPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApprovalWorkflows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalWorkflowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApprovalWorkflows
     * const approvalWorkflows = await prisma.approvalWorkflow.findMany()
     * 
     * // Get first 10 ApprovalWorkflows
     * const approvalWorkflows = await prisma.approvalWorkflow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const approvalWorkflowWithIdOnly = await prisma.approvalWorkflow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApprovalWorkflowFindManyArgs>(args?: SelectSubset<T, ApprovalWorkflowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalWorkflowPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApprovalWorkflow.
     * @param {ApprovalWorkflowCreateArgs} args - Arguments to create a ApprovalWorkflow.
     * @example
     * // Create one ApprovalWorkflow
     * const ApprovalWorkflow = await prisma.approvalWorkflow.create({
     *   data: {
     *     // ... data to create a ApprovalWorkflow
     *   }
     * })
     * 
     */
    create<T extends ApprovalWorkflowCreateArgs>(args: SelectSubset<T, ApprovalWorkflowCreateArgs<ExtArgs>>): Prisma__ApprovalWorkflowClient<$Result.GetResult<Prisma.$ApprovalWorkflowPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApprovalWorkflows.
     * @param {ApprovalWorkflowCreateManyArgs} args - Arguments to create many ApprovalWorkflows.
     * @example
     * // Create many ApprovalWorkflows
     * const approvalWorkflow = await prisma.approvalWorkflow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApprovalWorkflowCreateManyArgs>(args?: SelectSubset<T, ApprovalWorkflowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApprovalWorkflows and returns the data saved in the database.
     * @param {ApprovalWorkflowCreateManyAndReturnArgs} args - Arguments to create many ApprovalWorkflows.
     * @example
     * // Create many ApprovalWorkflows
     * const approvalWorkflow = await prisma.approvalWorkflow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApprovalWorkflows and only return the `id`
     * const approvalWorkflowWithIdOnly = await prisma.approvalWorkflow.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApprovalWorkflowCreateManyAndReturnArgs>(args?: SelectSubset<T, ApprovalWorkflowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalWorkflowPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApprovalWorkflow.
     * @param {ApprovalWorkflowDeleteArgs} args - Arguments to delete one ApprovalWorkflow.
     * @example
     * // Delete one ApprovalWorkflow
     * const ApprovalWorkflow = await prisma.approvalWorkflow.delete({
     *   where: {
     *     // ... filter to delete one ApprovalWorkflow
     *   }
     * })
     * 
     */
    delete<T extends ApprovalWorkflowDeleteArgs>(args: SelectSubset<T, ApprovalWorkflowDeleteArgs<ExtArgs>>): Prisma__ApprovalWorkflowClient<$Result.GetResult<Prisma.$ApprovalWorkflowPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApprovalWorkflow.
     * @param {ApprovalWorkflowUpdateArgs} args - Arguments to update one ApprovalWorkflow.
     * @example
     * // Update one ApprovalWorkflow
     * const approvalWorkflow = await prisma.approvalWorkflow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApprovalWorkflowUpdateArgs>(args: SelectSubset<T, ApprovalWorkflowUpdateArgs<ExtArgs>>): Prisma__ApprovalWorkflowClient<$Result.GetResult<Prisma.$ApprovalWorkflowPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApprovalWorkflows.
     * @param {ApprovalWorkflowDeleteManyArgs} args - Arguments to filter ApprovalWorkflows to delete.
     * @example
     * // Delete a few ApprovalWorkflows
     * const { count } = await prisma.approvalWorkflow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApprovalWorkflowDeleteManyArgs>(args?: SelectSubset<T, ApprovalWorkflowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApprovalWorkflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalWorkflowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApprovalWorkflows
     * const approvalWorkflow = await prisma.approvalWorkflow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApprovalWorkflowUpdateManyArgs>(args: SelectSubset<T, ApprovalWorkflowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApprovalWorkflow.
     * @param {ApprovalWorkflowUpsertArgs} args - Arguments to update or create a ApprovalWorkflow.
     * @example
     * // Update or create a ApprovalWorkflow
     * const approvalWorkflow = await prisma.approvalWorkflow.upsert({
     *   create: {
     *     // ... data to create a ApprovalWorkflow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApprovalWorkflow we want to update
     *   }
     * })
     */
    upsert<T extends ApprovalWorkflowUpsertArgs>(args: SelectSubset<T, ApprovalWorkflowUpsertArgs<ExtArgs>>): Prisma__ApprovalWorkflowClient<$Result.GetResult<Prisma.$ApprovalWorkflowPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApprovalWorkflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalWorkflowCountArgs} args - Arguments to filter ApprovalWorkflows to count.
     * @example
     * // Count the number of ApprovalWorkflows
     * const count = await prisma.approvalWorkflow.count({
     *   where: {
     *     // ... the filter for the ApprovalWorkflows we want to count
     *   }
     * })
    **/
    count<T extends ApprovalWorkflowCountArgs>(
      args?: Subset<T, ApprovalWorkflowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApprovalWorkflowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApprovalWorkflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalWorkflowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApprovalWorkflowAggregateArgs>(args: Subset<T, ApprovalWorkflowAggregateArgs>): Prisma.PrismaPromise<GetApprovalWorkflowAggregateType<T>>

    /**
     * Group by ApprovalWorkflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalWorkflowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApprovalWorkflowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApprovalWorkflowGroupByArgs['orderBy'] }
        : { orderBy?: ApprovalWorkflowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApprovalWorkflowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApprovalWorkflowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApprovalWorkflow model
   */
  readonly fields: ApprovalWorkflowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApprovalWorkflow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApprovalWorkflowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    steps<T extends ApprovalWorkflow$stepsArgs<ExtArgs> = {}>(args?: Subset<T, ApprovalWorkflow$stepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "findMany"> | Null>
    ApprovalRequest<T extends ApprovalWorkflow$ApprovalRequestArgs<ExtArgs> = {}>(args?: Subset<T, ApprovalWorkflow$ApprovalRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApprovalWorkflow model
   */ 
  interface ApprovalWorkflowFieldRefs {
    readonly id: FieldRef<"ApprovalWorkflow", 'String'>
    readonly name: FieldRef<"ApprovalWorkflow", 'String'>
    readonly entity: FieldRef<"ApprovalWorkflow", 'String'>
    readonly minAmount: FieldRef<"ApprovalWorkflow", 'Decimal'>
    readonly maxAmount: FieldRef<"ApprovalWorkflow", 'Decimal'>
    readonly isActive: FieldRef<"ApprovalWorkflow", 'Boolean'>
    readonly createdAt: FieldRef<"ApprovalWorkflow", 'DateTime'>
    readonly updatedAt: FieldRef<"ApprovalWorkflow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApprovalWorkflow findUnique
   */
  export type ApprovalWorkflowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflow
     */
    select?: ApprovalWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalWorkflow to fetch.
     */
    where: ApprovalWorkflowWhereUniqueInput
  }

  /**
   * ApprovalWorkflow findUniqueOrThrow
   */
  export type ApprovalWorkflowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflow
     */
    select?: ApprovalWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalWorkflow to fetch.
     */
    where: ApprovalWorkflowWhereUniqueInput
  }

  /**
   * ApprovalWorkflow findFirst
   */
  export type ApprovalWorkflowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflow
     */
    select?: ApprovalWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalWorkflow to fetch.
     */
    where?: ApprovalWorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalWorkflows to fetch.
     */
    orderBy?: ApprovalWorkflowOrderByWithRelationInput | ApprovalWorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalWorkflows.
     */
    cursor?: ApprovalWorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalWorkflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalWorkflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalWorkflows.
     */
    distinct?: ApprovalWorkflowScalarFieldEnum | ApprovalWorkflowScalarFieldEnum[]
  }

  /**
   * ApprovalWorkflow findFirstOrThrow
   */
  export type ApprovalWorkflowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflow
     */
    select?: ApprovalWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalWorkflow to fetch.
     */
    where?: ApprovalWorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalWorkflows to fetch.
     */
    orderBy?: ApprovalWorkflowOrderByWithRelationInput | ApprovalWorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalWorkflows.
     */
    cursor?: ApprovalWorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalWorkflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalWorkflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalWorkflows.
     */
    distinct?: ApprovalWorkflowScalarFieldEnum | ApprovalWorkflowScalarFieldEnum[]
  }

  /**
   * ApprovalWorkflow findMany
   */
  export type ApprovalWorkflowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflow
     */
    select?: ApprovalWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalWorkflows to fetch.
     */
    where?: ApprovalWorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalWorkflows to fetch.
     */
    orderBy?: ApprovalWorkflowOrderByWithRelationInput | ApprovalWorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApprovalWorkflows.
     */
    cursor?: ApprovalWorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalWorkflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalWorkflows.
     */
    skip?: number
    distinct?: ApprovalWorkflowScalarFieldEnum | ApprovalWorkflowScalarFieldEnum[]
  }

  /**
   * ApprovalWorkflow create
   */
  export type ApprovalWorkflowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflow
     */
    select?: ApprovalWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowInclude<ExtArgs> | null
    /**
     * The data needed to create a ApprovalWorkflow.
     */
    data: XOR<ApprovalWorkflowCreateInput, ApprovalWorkflowUncheckedCreateInput>
  }

  /**
   * ApprovalWorkflow createMany
   */
  export type ApprovalWorkflowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApprovalWorkflows.
     */
    data: ApprovalWorkflowCreateManyInput | ApprovalWorkflowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApprovalWorkflow createManyAndReturn
   */
  export type ApprovalWorkflowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflow
     */
    select?: ApprovalWorkflowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApprovalWorkflows.
     */
    data: ApprovalWorkflowCreateManyInput | ApprovalWorkflowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApprovalWorkflow update
   */
  export type ApprovalWorkflowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflow
     */
    select?: ApprovalWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowInclude<ExtArgs> | null
    /**
     * The data needed to update a ApprovalWorkflow.
     */
    data: XOR<ApprovalWorkflowUpdateInput, ApprovalWorkflowUncheckedUpdateInput>
    /**
     * Choose, which ApprovalWorkflow to update.
     */
    where: ApprovalWorkflowWhereUniqueInput
  }

  /**
   * ApprovalWorkflow updateMany
   */
  export type ApprovalWorkflowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApprovalWorkflows.
     */
    data: XOR<ApprovalWorkflowUpdateManyMutationInput, ApprovalWorkflowUncheckedUpdateManyInput>
    /**
     * Filter which ApprovalWorkflows to update
     */
    where?: ApprovalWorkflowWhereInput
  }

  /**
   * ApprovalWorkflow upsert
   */
  export type ApprovalWorkflowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflow
     */
    select?: ApprovalWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowInclude<ExtArgs> | null
    /**
     * The filter to search for the ApprovalWorkflow to update in case it exists.
     */
    where: ApprovalWorkflowWhereUniqueInput
    /**
     * In case the ApprovalWorkflow found by the `where` argument doesn't exist, create a new ApprovalWorkflow with this data.
     */
    create: XOR<ApprovalWorkflowCreateInput, ApprovalWorkflowUncheckedCreateInput>
    /**
     * In case the ApprovalWorkflow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApprovalWorkflowUpdateInput, ApprovalWorkflowUncheckedUpdateInput>
  }

  /**
   * ApprovalWorkflow delete
   */
  export type ApprovalWorkflowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflow
     */
    select?: ApprovalWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowInclude<ExtArgs> | null
    /**
     * Filter which ApprovalWorkflow to delete.
     */
    where: ApprovalWorkflowWhereUniqueInput
  }

  /**
   * ApprovalWorkflow deleteMany
   */
  export type ApprovalWorkflowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalWorkflows to delete
     */
    where?: ApprovalWorkflowWhereInput
  }

  /**
   * ApprovalWorkflow.steps
   */
  export type ApprovalWorkflow$stepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepInclude<ExtArgs> | null
    where?: ApprovalStepWhereInput
    orderBy?: ApprovalStepOrderByWithRelationInput | ApprovalStepOrderByWithRelationInput[]
    cursor?: ApprovalStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalStepScalarFieldEnum | ApprovalStepScalarFieldEnum[]
  }

  /**
   * ApprovalWorkflow.ApprovalRequest
   */
  export type ApprovalWorkflow$ApprovalRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    where?: ApprovalRequestWhereInput
    orderBy?: ApprovalRequestOrderByWithRelationInput | ApprovalRequestOrderByWithRelationInput[]
    cursor?: ApprovalRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalRequestScalarFieldEnum | ApprovalRequestScalarFieldEnum[]
  }

  /**
   * ApprovalWorkflow without action
   */
  export type ApprovalWorkflowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflow
     */
    select?: ApprovalWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowInclude<ExtArgs> | null
  }


  /**
   * Model ApprovalStep
   */

  export type AggregateApprovalStep = {
    _count: ApprovalStepCountAggregateOutputType | null
    _avg: ApprovalStepAvgAggregateOutputType | null
    _sum: ApprovalStepSumAggregateOutputType | null
    _min: ApprovalStepMinAggregateOutputType | null
    _max: ApprovalStepMaxAggregateOutputType | null
  }

  export type ApprovalStepAvgAggregateOutputType = {
    stepOrder: number | null
  }

  export type ApprovalStepSumAggregateOutputType = {
    stepOrder: number | null
  }

  export type ApprovalStepMinAggregateOutputType = {
    id: string | null
    workflowId: string | null
    stepOrder: number | null
    name: string | null
    roleId: string | null
    isRequired: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApprovalStepMaxAggregateOutputType = {
    id: string | null
    workflowId: string | null
    stepOrder: number | null
    name: string | null
    roleId: string | null
    isRequired: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApprovalStepCountAggregateOutputType = {
    id: number
    workflowId: number
    stepOrder: number
    name: number
    roleId: number
    isRequired: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApprovalStepAvgAggregateInputType = {
    stepOrder?: true
  }

  export type ApprovalStepSumAggregateInputType = {
    stepOrder?: true
  }

  export type ApprovalStepMinAggregateInputType = {
    id?: true
    workflowId?: true
    stepOrder?: true
    name?: true
    roleId?: true
    isRequired?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApprovalStepMaxAggregateInputType = {
    id?: true
    workflowId?: true
    stepOrder?: true
    name?: true
    roleId?: true
    isRequired?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApprovalStepCountAggregateInputType = {
    id?: true
    workflowId?: true
    stepOrder?: true
    name?: true
    roleId?: true
    isRequired?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApprovalStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalStep to aggregate.
     */
    where?: ApprovalStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalSteps to fetch.
     */
    orderBy?: ApprovalStepOrderByWithRelationInput | ApprovalStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApprovalStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApprovalSteps
    **/
    _count?: true | ApprovalStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApprovalStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApprovalStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApprovalStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApprovalStepMaxAggregateInputType
  }

  export type GetApprovalStepAggregateType<T extends ApprovalStepAggregateArgs> = {
        [P in keyof T & keyof AggregateApprovalStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApprovalStep[P]>
      : GetScalarType<T[P], AggregateApprovalStep[P]>
  }




  export type ApprovalStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalStepWhereInput
    orderBy?: ApprovalStepOrderByWithAggregationInput | ApprovalStepOrderByWithAggregationInput[]
    by: ApprovalStepScalarFieldEnum[] | ApprovalStepScalarFieldEnum
    having?: ApprovalStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApprovalStepCountAggregateInputType | true
    _avg?: ApprovalStepAvgAggregateInputType
    _sum?: ApprovalStepSumAggregateInputType
    _min?: ApprovalStepMinAggregateInputType
    _max?: ApprovalStepMaxAggregateInputType
  }

  export type ApprovalStepGroupByOutputType = {
    id: string
    workflowId: string
    stepOrder: number
    name: string
    roleId: string
    isRequired: boolean
    createdAt: Date
    updatedAt: Date
    _count: ApprovalStepCountAggregateOutputType | null
    _avg: ApprovalStepAvgAggregateOutputType | null
    _sum: ApprovalStepSumAggregateOutputType | null
    _min: ApprovalStepMinAggregateOutputType | null
    _max: ApprovalStepMaxAggregateOutputType | null
  }

  type GetApprovalStepGroupByPayload<T extends ApprovalStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApprovalStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApprovalStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApprovalStepGroupByOutputType[P]>
            : GetScalarType<T[P], ApprovalStepGroupByOutputType[P]>
        }
      >
    >


  export type ApprovalStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    stepOrder?: boolean
    name?: boolean
    roleId?: boolean
    isRequired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflow?: boolean | ApprovalWorkflowDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    ApprovalRequest?: boolean | ApprovalStep$ApprovalRequestArgs<ExtArgs>
    ApprovalAction?: boolean | ApprovalStep$ApprovalActionArgs<ExtArgs>
    _count?: boolean | ApprovalStepCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approvalStep"]>

  export type ApprovalStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    stepOrder?: boolean
    name?: boolean
    roleId?: boolean
    isRequired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflow?: boolean | ApprovalWorkflowDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approvalStep"]>

  export type ApprovalStepSelectScalar = {
    id?: boolean
    workflowId?: boolean
    stepOrder?: boolean
    name?: boolean
    roleId?: boolean
    isRequired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApprovalStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | ApprovalWorkflowDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    ApprovalRequest?: boolean | ApprovalStep$ApprovalRequestArgs<ExtArgs>
    ApprovalAction?: boolean | ApprovalStep$ApprovalActionArgs<ExtArgs>
    _count?: boolean | ApprovalStepCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ApprovalStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | ApprovalWorkflowDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $ApprovalStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApprovalStep"
    objects: {
      workflow: Prisma.$ApprovalWorkflowPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
      ApprovalRequest: Prisma.$ApprovalRequestPayload<ExtArgs>[]
      ApprovalAction: Prisma.$ApprovalActionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workflowId: string
      stepOrder: number
      name: string
      roleId: string
      isRequired: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["approvalStep"]>
    composites: {}
  }

  type ApprovalStepGetPayload<S extends boolean | null | undefined | ApprovalStepDefaultArgs> = $Result.GetResult<Prisma.$ApprovalStepPayload, S>

  type ApprovalStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApprovalStepFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApprovalStepCountAggregateInputType | true
    }

  export interface ApprovalStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApprovalStep'], meta: { name: 'ApprovalStep' } }
    /**
     * Find zero or one ApprovalStep that matches the filter.
     * @param {ApprovalStepFindUniqueArgs} args - Arguments to find a ApprovalStep
     * @example
     * // Get one ApprovalStep
     * const approvalStep = await prisma.approvalStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApprovalStepFindUniqueArgs>(args: SelectSubset<T, ApprovalStepFindUniqueArgs<ExtArgs>>): Prisma__ApprovalStepClient<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApprovalStep that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApprovalStepFindUniqueOrThrowArgs} args - Arguments to find a ApprovalStep
     * @example
     * // Get one ApprovalStep
     * const approvalStep = await prisma.approvalStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApprovalStepFindUniqueOrThrowArgs>(args: SelectSubset<T, ApprovalStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApprovalStepClient<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApprovalStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalStepFindFirstArgs} args - Arguments to find a ApprovalStep
     * @example
     * // Get one ApprovalStep
     * const approvalStep = await prisma.approvalStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApprovalStepFindFirstArgs>(args?: SelectSubset<T, ApprovalStepFindFirstArgs<ExtArgs>>): Prisma__ApprovalStepClient<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApprovalStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalStepFindFirstOrThrowArgs} args - Arguments to find a ApprovalStep
     * @example
     * // Get one ApprovalStep
     * const approvalStep = await prisma.approvalStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApprovalStepFindFirstOrThrowArgs>(args?: SelectSubset<T, ApprovalStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApprovalStepClient<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApprovalSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApprovalSteps
     * const approvalSteps = await prisma.approvalStep.findMany()
     * 
     * // Get first 10 ApprovalSteps
     * const approvalSteps = await prisma.approvalStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const approvalStepWithIdOnly = await prisma.approvalStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApprovalStepFindManyArgs>(args?: SelectSubset<T, ApprovalStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApprovalStep.
     * @param {ApprovalStepCreateArgs} args - Arguments to create a ApprovalStep.
     * @example
     * // Create one ApprovalStep
     * const ApprovalStep = await prisma.approvalStep.create({
     *   data: {
     *     // ... data to create a ApprovalStep
     *   }
     * })
     * 
     */
    create<T extends ApprovalStepCreateArgs>(args: SelectSubset<T, ApprovalStepCreateArgs<ExtArgs>>): Prisma__ApprovalStepClient<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApprovalSteps.
     * @param {ApprovalStepCreateManyArgs} args - Arguments to create many ApprovalSteps.
     * @example
     * // Create many ApprovalSteps
     * const approvalStep = await prisma.approvalStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApprovalStepCreateManyArgs>(args?: SelectSubset<T, ApprovalStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApprovalSteps and returns the data saved in the database.
     * @param {ApprovalStepCreateManyAndReturnArgs} args - Arguments to create many ApprovalSteps.
     * @example
     * // Create many ApprovalSteps
     * const approvalStep = await prisma.approvalStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApprovalSteps and only return the `id`
     * const approvalStepWithIdOnly = await prisma.approvalStep.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApprovalStepCreateManyAndReturnArgs>(args?: SelectSubset<T, ApprovalStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApprovalStep.
     * @param {ApprovalStepDeleteArgs} args - Arguments to delete one ApprovalStep.
     * @example
     * // Delete one ApprovalStep
     * const ApprovalStep = await prisma.approvalStep.delete({
     *   where: {
     *     // ... filter to delete one ApprovalStep
     *   }
     * })
     * 
     */
    delete<T extends ApprovalStepDeleteArgs>(args: SelectSubset<T, ApprovalStepDeleteArgs<ExtArgs>>): Prisma__ApprovalStepClient<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApprovalStep.
     * @param {ApprovalStepUpdateArgs} args - Arguments to update one ApprovalStep.
     * @example
     * // Update one ApprovalStep
     * const approvalStep = await prisma.approvalStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApprovalStepUpdateArgs>(args: SelectSubset<T, ApprovalStepUpdateArgs<ExtArgs>>): Prisma__ApprovalStepClient<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApprovalSteps.
     * @param {ApprovalStepDeleteManyArgs} args - Arguments to filter ApprovalSteps to delete.
     * @example
     * // Delete a few ApprovalSteps
     * const { count } = await prisma.approvalStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApprovalStepDeleteManyArgs>(args?: SelectSubset<T, ApprovalStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApprovalSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApprovalSteps
     * const approvalStep = await prisma.approvalStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApprovalStepUpdateManyArgs>(args: SelectSubset<T, ApprovalStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApprovalStep.
     * @param {ApprovalStepUpsertArgs} args - Arguments to update or create a ApprovalStep.
     * @example
     * // Update or create a ApprovalStep
     * const approvalStep = await prisma.approvalStep.upsert({
     *   create: {
     *     // ... data to create a ApprovalStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApprovalStep we want to update
     *   }
     * })
     */
    upsert<T extends ApprovalStepUpsertArgs>(args: SelectSubset<T, ApprovalStepUpsertArgs<ExtArgs>>): Prisma__ApprovalStepClient<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApprovalSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalStepCountArgs} args - Arguments to filter ApprovalSteps to count.
     * @example
     * // Count the number of ApprovalSteps
     * const count = await prisma.approvalStep.count({
     *   where: {
     *     // ... the filter for the ApprovalSteps we want to count
     *   }
     * })
    **/
    count<T extends ApprovalStepCountArgs>(
      args?: Subset<T, ApprovalStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApprovalStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApprovalStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApprovalStepAggregateArgs>(args: Subset<T, ApprovalStepAggregateArgs>): Prisma.PrismaPromise<GetApprovalStepAggregateType<T>>

    /**
     * Group by ApprovalStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApprovalStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApprovalStepGroupByArgs['orderBy'] }
        : { orderBy?: ApprovalStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApprovalStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApprovalStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApprovalStep model
   */
  readonly fields: ApprovalStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApprovalStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApprovalStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workflow<T extends ApprovalWorkflowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApprovalWorkflowDefaultArgs<ExtArgs>>): Prisma__ApprovalWorkflowClient<$Result.GetResult<Prisma.$ApprovalWorkflowPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ApprovalRequest<T extends ApprovalStep$ApprovalRequestArgs<ExtArgs> = {}>(args?: Subset<T, ApprovalStep$ApprovalRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findMany"> | Null>
    ApprovalAction<T extends ApprovalStep$ApprovalActionArgs<ExtArgs> = {}>(args?: Subset<T, ApprovalStep$ApprovalActionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApprovalStep model
   */ 
  interface ApprovalStepFieldRefs {
    readonly id: FieldRef<"ApprovalStep", 'String'>
    readonly workflowId: FieldRef<"ApprovalStep", 'String'>
    readonly stepOrder: FieldRef<"ApprovalStep", 'Int'>
    readonly name: FieldRef<"ApprovalStep", 'String'>
    readonly roleId: FieldRef<"ApprovalStep", 'String'>
    readonly isRequired: FieldRef<"ApprovalStep", 'Boolean'>
    readonly createdAt: FieldRef<"ApprovalStep", 'DateTime'>
    readonly updatedAt: FieldRef<"ApprovalStep", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApprovalStep findUnique
   */
  export type ApprovalStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalStep to fetch.
     */
    where: ApprovalStepWhereUniqueInput
  }

  /**
   * ApprovalStep findUniqueOrThrow
   */
  export type ApprovalStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalStep to fetch.
     */
    where: ApprovalStepWhereUniqueInput
  }

  /**
   * ApprovalStep findFirst
   */
  export type ApprovalStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalStep to fetch.
     */
    where?: ApprovalStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalSteps to fetch.
     */
    orderBy?: ApprovalStepOrderByWithRelationInput | ApprovalStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalSteps.
     */
    cursor?: ApprovalStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalSteps.
     */
    distinct?: ApprovalStepScalarFieldEnum | ApprovalStepScalarFieldEnum[]
  }

  /**
   * ApprovalStep findFirstOrThrow
   */
  export type ApprovalStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalStep to fetch.
     */
    where?: ApprovalStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalSteps to fetch.
     */
    orderBy?: ApprovalStepOrderByWithRelationInput | ApprovalStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalSteps.
     */
    cursor?: ApprovalStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalSteps.
     */
    distinct?: ApprovalStepScalarFieldEnum | ApprovalStepScalarFieldEnum[]
  }

  /**
   * ApprovalStep findMany
   */
  export type ApprovalStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalSteps to fetch.
     */
    where?: ApprovalStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalSteps to fetch.
     */
    orderBy?: ApprovalStepOrderByWithRelationInput | ApprovalStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApprovalSteps.
     */
    cursor?: ApprovalStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalSteps.
     */
    skip?: number
    distinct?: ApprovalStepScalarFieldEnum | ApprovalStepScalarFieldEnum[]
  }

  /**
   * ApprovalStep create
   */
  export type ApprovalStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepInclude<ExtArgs> | null
    /**
     * The data needed to create a ApprovalStep.
     */
    data: XOR<ApprovalStepCreateInput, ApprovalStepUncheckedCreateInput>
  }

  /**
   * ApprovalStep createMany
   */
  export type ApprovalStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApprovalSteps.
     */
    data: ApprovalStepCreateManyInput | ApprovalStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApprovalStep createManyAndReturn
   */
  export type ApprovalStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApprovalSteps.
     */
    data: ApprovalStepCreateManyInput | ApprovalStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApprovalStep update
   */
  export type ApprovalStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepInclude<ExtArgs> | null
    /**
     * The data needed to update a ApprovalStep.
     */
    data: XOR<ApprovalStepUpdateInput, ApprovalStepUncheckedUpdateInput>
    /**
     * Choose, which ApprovalStep to update.
     */
    where: ApprovalStepWhereUniqueInput
  }

  /**
   * ApprovalStep updateMany
   */
  export type ApprovalStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApprovalSteps.
     */
    data: XOR<ApprovalStepUpdateManyMutationInput, ApprovalStepUncheckedUpdateManyInput>
    /**
     * Filter which ApprovalSteps to update
     */
    where?: ApprovalStepWhereInput
  }

  /**
   * ApprovalStep upsert
   */
  export type ApprovalStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepInclude<ExtArgs> | null
    /**
     * The filter to search for the ApprovalStep to update in case it exists.
     */
    where: ApprovalStepWhereUniqueInput
    /**
     * In case the ApprovalStep found by the `where` argument doesn't exist, create a new ApprovalStep with this data.
     */
    create: XOR<ApprovalStepCreateInput, ApprovalStepUncheckedCreateInput>
    /**
     * In case the ApprovalStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApprovalStepUpdateInput, ApprovalStepUncheckedUpdateInput>
  }

  /**
   * ApprovalStep delete
   */
  export type ApprovalStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepInclude<ExtArgs> | null
    /**
     * Filter which ApprovalStep to delete.
     */
    where: ApprovalStepWhereUniqueInput
  }

  /**
   * ApprovalStep deleteMany
   */
  export type ApprovalStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalSteps to delete
     */
    where?: ApprovalStepWhereInput
  }

  /**
   * ApprovalStep.ApprovalRequest
   */
  export type ApprovalStep$ApprovalRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    where?: ApprovalRequestWhereInput
    orderBy?: ApprovalRequestOrderByWithRelationInput | ApprovalRequestOrderByWithRelationInput[]
    cursor?: ApprovalRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalRequestScalarFieldEnum | ApprovalRequestScalarFieldEnum[]
  }

  /**
   * ApprovalStep.ApprovalAction
   */
  export type ApprovalStep$ApprovalActionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
    where?: ApprovalActionWhereInput
    orderBy?: ApprovalActionOrderByWithRelationInput | ApprovalActionOrderByWithRelationInput[]
    cursor?: ApprovalActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalActionScalarFieldEnum | ApprovalActionScalarFieldEnum[]
  }

  /**
   * ApprovalStep without action
   */
  export type ApprovalStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepInclude<ExtArgs> | null
  }


  /**
   * Model ApprovalRequest
   */

  export type AggregateApprovalRequest = {
    _count: ApprovalRequestCountAggregateOutputType | null
    _min: ApprovalRequestMinAggregateOutputType | null
    _max: ApprovalRequestMaxAggregateOutputType | null
  }

  export type ApprovalRequestMinAggregateOutputType = {
    id: string | null
    workflowId: string | null
    entityType: string | null
    entityId: string | null
    requestedBy: string | null
    currentStepId: string | null
    status: string | null
    requestedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApprovalRequestMaxAggregateOutputType = {
    id: string | null
    workflowId: string | null
    entityType: string | null
    entityId: string | null
    requestedBy: string | null
    currentStepId: string | null
    status: string | null
    requestedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApprovalRequestCountAggregateOutputType = {
    id: number
    workflowId: number
    entityType: number
    entityId: number
    requestedBy: number
    currentStepId: number
    status: number
    requestedAt: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApprovalRequestMinAggregateInputType = {
    id?: true
    workflowId?: true
    entityType?: true
    entityId?: true
    requestedBy?: true
    currentStepId?: true
    status?: true
    requestedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApprovalRequestMaxAggregateInputType = {
    id?: true
    workflowId?: true
    entityType?: true
    entityId?: true
    requestedBy?: true
    currentStepId?: true
    status?: true
    requestedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApprovalRequestCountAggregateInputType = {
    id?: true
    workflowId?: true
    entityType?: true
    entityId?: true
    requestedBy?: true
    currentStepId?: true
    status?: true
    requestedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApprovalRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalRequest to aggregate.
     */
    where?: ApprovalRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalRequests to fetch.
     */
    orderBy?: ApprovalRequestOrderByWithRelationInput | ApprovalRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApprovalRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApprovalRequests
    **/
    _count?: true | ApprovalRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApprovalRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApprovalRequestMaxAggregateInputType
  }

  export type GetApprovalRequestAggregateType<T extends ApprovalRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateApprovalRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApprovalRequest[P]>
      : GetScalarType<T[P], AggregateApprovalRequest[P]>
  }




  export type ApprovalRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalRequestWhereInput
    orderBy?: ApprovalRequestOrderByWithAggregationInput | ApprovalRequestOrderByWithAggregationInput[]
    by: ApprovalRequestScalarFieldEnum[] | ApprovalRequestScalarFieldEnum
    having?: ApprovalRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApprovalRequestCountAggregateInputType | true
    _min?: ApprovalRequestMinAggregateInputType
    _max?: ApprovalRequestMaxAggregateInputType
  }

  export type ApprovalRequestGroupByOutputType = {
    id: string
    workflowId: string
    entityType: string
    entityId: string
    requestedBy: string
    currentStepId: string | null
    status: string
    requestedAt: Date
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ApprovalRequestCountAggregateOutputType | null
    _min: ApprovalRequestMinAggregateOutputType | null
    _max: ApprovalRequestMaxAggregateOutputType | null
  }

  type GetApprovalRequestGroupByPayload<T extends ApprovalRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApprovalRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApprovalRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApprovalRequestGroupByOutputType[P]>
            : GetScalarType<T[P], ApprovalRequestGroupByOutputType[P]>
        }
      >
    >


  export type ApprovalRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    entityType?: boolean
    entityId?: boolean
    requestedBy?: boolean
    currentStepId?: boolean
    status?: boolean
    requestedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflow?: boolean | ApprovalWorkflowDefaultArgs<ExtArgs>
    requestedByUser?: boolean | UserDefaultArgs<ExtArgs>
    currentStep?: boolean | ApprovalRequest$currentStepArgs<ExtArgs>
    actions?: boolean | ApprovalRequest$actionsArgs<ExtArgs>
    _count?: boolean | ApprovalRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approvalRequest"]>

  export type ApprovalRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    entityType?: boolean
    entityId?: boolean
    requestedBy?: boolean
    currentStepId?: boolean
    status?: boolean
    requestedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflow?: boolean | ApprovalWorkflowDefaultArgs<ExtArgs>
    requestedByUser?: boolean | UserDefaultArgs<ExtArgs>
    currentStep?: boolean | ApprovalRequest$currentStepArgs<ExtArgs>
  }, ExtArgs["result"]["approvalRequest"]>

  export type ApprovalRequestSelectScalar = {
    id?: boolean
    workflowId?: boolean
    entityType?: boolean
    entityId?: boolean
    requestedBy?: boolean
    currentStepId?: boolean
    status?: boolean
    requestedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApprovalRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | ApprovalWorkflowDefaultArgs<ExtArgs>
    requestedByUser?: boolean | UserDefaultArgs<ExtArgs>
    currentStep?: boolean | ApprovalRequest$currentStepArgs<ExtArgs>
    actions?: boolean | ApprovalRequest$actionsArgs<ExtArgs>
    _count?: boolean | ApprovalRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ApprovalRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | ApprovalWorkflowDefaultArgs<ExtArgs>
    requestedByUser?: boolean | UserDefaultArgs<ExtArgs>
    currentStep?: boolean | ApprovalRequest$currentStepArgs<ExtArgs>
  }

  export type $ApprovalRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApprovalRequest"
    objects: {
      workflow: Prisma.$ApprovalWorkflowPayload<ExtArgs>
      requestedByUser: Prisma.$UserPayload<ExtArgs>
      currentStep: Prisma.$ApprovalStepPayload<ExtArgs> | null
      actions: Prisma.$ApprovalActionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workflowId: string
      entityType: string
      entityId: string
      requestedBy: string
      currentStepId: string | null
      status: string
      requestedAt: Date
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["approvalRequest"]>
    composites: {}
  }

  type ApprovalRequestGetPayload<S extends boolean | null | undefined | ApprovalRequestDefaultArgs> = $Result.GetResult<Prisma.$ApprovalRequestPayload, S>

  type ApprovalRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApprovalRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApprovalRequestCountAggregateInputType | true
    }

  export interface ApprovalRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApprovalRequest'], meta: { name: 'ApprovalRequest' } }
    /**
     * Find zero or one ApprovalRequest that matches the filter.
     * @param {ApprovalRequestFindUniqueArgs} args - Arguments to find a ApprovalRequest
     * @example
     * // Get one ApprovalRequest
     * const approvalRequest = await prisma.approvalRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApprovalRequestFindUniqueArgs>(args: SelectSubset<T, ApprovalRequestFindUniqueArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApprovalRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApprovalRequestFindUniqueOrThrowArgs} args - Arguments to find a ApprovalRequest
     * @example
     * // Get one ApprovalRequest
     * const approvalRequest = await prisma.approvalRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApprovalRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, ApprovalRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApprovalRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalRequestFindFirstArgs} args - Arguments to find a ApprovalRequest
     * @example
     * // Get one ApprovalRequest
     * const approvalRequest = await prisma.approvalRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApprovalRequestFindFirstArgs>(args?: SelectSubset<T, ApprovalRequestFindFirstArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApprovalRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalRequestFindFirstOrThrowArgs} args - Arguments to find a ApprovalRequest
     * @example
     * // Get one ApprovalRequest
     * const approvalRequest = await prisma.approvalRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApprovalRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, ApprovalRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApprovalRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApprovalRequests
     * const approvalRequests = await prisma.approvalRequest.findMany()
     * 
     * // Get first 10 ApprovalRequests
     * const approvalRequests = await prisma.approvalRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const approvalRequestWithIdOnly = await prisma.approvalRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApprovalRequestFindManyArgs>(args?: SelectSubset<T, ApprovalRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApprovalRequest.
     * @param {ApprovalRequestCreateArgs} args - Arguments to create a ApprovalRequest.
     * @example
     * // Create one ApprovalRequest
     * const ApprovalRequest = await prisma.approvalRequest.create({
     *   data: {
     *     // ... data to create a ApprovalRequest
     *   }
     * })
     * 
     */
    create<T extends ApprovalRequestCreateArgs>(args: SelectSubset<T, ApprovalRequestCreateArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApprovalRequests.
     * @param {ApprovalRequestCreateManyArgs} args - Arguments to create many ApprovalRequests.
     * @example
     * // Create many ApprovalRequests
     * const approvalRequest = await prisma.approvalRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApprovalRequestCreateManyArgs>(args?: SelectSubset<T, ApprovalRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApprovalRequests and returns the data saved in the database.
     * @param {ApprovalRequestCreateManyAndReturnArgs} args - Arguments to create many ApprovalRequests.
     * @example
     * // Create many ApprovalRequests
     * const approvalRequest = await prisma.approvalRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApprovalRequests and only return the `id`
     * const approvalRequestWithIdOnly = await prisma.approvalRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApprovalRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, ApprovalRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApprovalRequest.
     * @param {ApprovalRequestDeleteArgs} args - Arguments to delete one ApprovalRequest.
     * @example
     * // Delete one ApprovalRequest
     * const ApprovalRequest = await prisma.approvalRequest.delete({
     *   where: {
     *     // ... filter to delete one ApprovalRequest
     *   }
     * })
     * 
     */
    delete<T extends ApprovalRequestDeleteArgs>(args: SelectSubset<T, ApprovalRequestDeleteArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApprovalRequest.
     * @param {ApprovalRequestUpdateArgs} args - Arguments to update one ApprovalRequest.
     * @example
     * // Update one ApprovalRequest
     * const approvalRequest = await prisma.approvalRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApprovalRequestUpdateArgs>(args: SelectSubset<T, ApprovalRequestUpdateArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApprovalRequests.
     * @param {ApprovalRequestDeleteManyArgs} args - Arguments to filter ApprovalRequests to delete.
     * @example
     * // Delete a few ApprovalRequests
     * const { count } = await prisma.approvalRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApprovalRequestDeleteManyArgs>(args?: SelectSubset<T, ApprovalRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApprovalRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApprovalRequests
     * const approvalRequest = await prisma.approvalRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApprovalRequestUpdateManyArgs>(args: SelectSubset<T, ApprovalRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApprovalRequest.
     * @param {ApprovalRequestUpsertArgs} args - Arguments to update or create a ApprovalRequest.
     * @example
     * // Update or create a ApprovalRequest
     * const approvalRequest = await prisma.approvalRequest.upsert({
     *   create: {
     *     // ... data to create a ApprovalRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApprovalRequest we want to update
     *   }
     * })
     */
    upsert<T extends ApprovalRequestUpsertArgs>(args: SelectSubset<T, ApprovalRequestUpsertArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApprovalRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalRequestCountArgs} args - Arguments to filter ApprovalRequests to count.
     * @example
     * // Count the number of ApprovalRequests
     * const count = await prisma.approvalRequest.count({
     *   where: {
     *     // ... the filter for the ApprovalRequests we want to count
     *   }
     * })
    **/
    count<T extends ApprovalRequestCountArgs>(
      args?: Subset<T, ApprovalRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApprovalRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApprovalRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApprovalRequestAggregateArgs>(args: Subset<T, ApprovalRequestAggregateArgs>): Prisma.PrismaPromise<GetApprovalRequestAggregateType<T>>

    /**
     * Group by ApprovalRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApprovalRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApprovalRequestGroupByArgs['orderBy'] }
        : { orderBy?: ApprovalRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApprovalRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApprovalRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApprovalRequest model
   */
  readonly fields: ApprovalRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApprovalRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApprovalRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workflow<T extends ApprovalWorkflowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApprovalWorkflowDefaultArgs<ExtArgs>>): Prisma__ApprovalWorkflowClient<$Result.GetResult<Prisma.$ApprovalWorkflowPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    requestedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    currentStep<T extends ApprovalRequest$currentStepArgs<ExtArgs> = {}>(args?: Subset<T, ApprovalRequest$currentStepArgs<ExtArgs>>): Prisma__ApprovalStepClient<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    actions<T extends ApprovalRequest$actionsArgs<ExtArgs> = {}>(args?: Subset<T, ApprovalRequest$actionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApprovalRequest model
   */ 
  interface ApprovalRequestFieldRefs {
    readonly id: FieldRef<"ApprovalRequest", 'String'>
    readonly workflowId: FieldRef<"ApprovalRequest", 'String'>
    readonly entityType: FieldRef<"ApprovalRequest", 'String'>
    readonly entityId: FieldRef<"ApprovalRequest", 'String'>
    readonly requestedBy: FieldRef<"ApprovalRequest", 'String'>
    readonly currentStepId: FieldRef<"ApprovalRequest", 'String'>
    readonly status: FieldRef<"ApprovalRequest", 'String'>
    readonly requestedAt: FieldRef<"ApprovalRequest", 'DateTime'>
    readonly completedAt: FieldRef<"ApprovalRequest", 'DateTime'>
    readonly createdAt: FieldRef<"ApprovalRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"ApprovalRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApprovalRequest findUnique
   */
  export type ApprovalRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalRequest to fetch.
     */
    where: ApprovalRequestWhereUniqueInput
  }

  /**
   * ApprovalRequest findUniqueOrThrow
   */
  export type ApprovalRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalRequest to fetch.
     */
    where: ApprovalRequestWhereUniqueInput
  }

  /**
   * ApprovalRequest findFirst
   */
  export type ApprovalRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalRequest to fetch.
     */
    where?: ApprovalRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalRequests to fetch.
     */
    orderBy?: ApprovalRequestOrderByWithRelationInput | ApprovalRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalRequests.
     */
    cursor?: ApprovalRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalRequests.
     */
    distinct?: ApprovalRequestScalarFieldEnum | ApprovalRequestScalarFieldEnum[]
  }

  /**
   * ApprovalRequest findFirstOrThrow
   */
  export type ApprovalRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalRequest to fetch.
     */
    where?: ApprovalRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalRequests to fetch.
     */
    orderBy?: ApprovalRequestOrderByWithRelationInput | ApprovalRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalRequests.
     */
    cursor?: ApprovalRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalRequests.
     */
    distinct?: ApprovalRequestScalarFieldEnum | ApprovalRequestScalarFieldEnum[]
  }

  /**
   * ApprovalRequest findMany
   */
  export type ApprovalRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalRequests to fetch.
     */
    where?: ApprovalRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalRequests to fetch.
     */
    orderBy?: ApprovalRequestOrderByWithRelationInput | ApprovalRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApprovalRequests.
     */
    cursor?: ApprovalRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalRequests.
     */
    skip?: number
    distinct?: ApprovalRequestScalarFieldEnum | ApprovalRequestScalarFieldEnum[]
  }

  /**
   * ApprovalRequest create
   */
  export type ApprovalRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a ApprovalRequest.
     */
    data: XOR<ApprovalRequestCreateInput, ApprovalRequestUncheckedCreateInput>
  }

  /**
   * ApprovalRequest createMany
   */
  export type ApprovalRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApprovalRequests.
     */
    data: ApprovalRequestCreateManyInput | ApprovalRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApprovalRequest createManyAndReturn
   */
  export type ApprovalRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApprovalRequests.
     */
    data: ApprovalRequestCreateManyInput | ApprovalRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApprovalRequest update
   */
  export type ApprovalRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a ApprovalRequest.
     */
    data: XOR<ApprovalRequestUpdateInput, ApprovalRequestUncheckedUpdateInput>
    /**
     * Choose, which ApprovalRequest to update.
     */
    where: ApprovalRequestWhereUniqueInput
  }

  /**
   * ApprovalRequest updateMany
   */
  export type ApprovalRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApprovalRequests.
     */
    data: XOR<ApprovalRequestUpdateManyMutationInput, ApprovalRequestUncheckedUpdateManyInput>
    /**
     * Filter which ApprovalRequests to update
     */
    where?: ApprovalRequestWhereInput
  }

  /**
   * ApprovalRequest upsert
   */
  export type ApprovalRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the ApprovalRequest to update in case it exists.
     */
    where: ApprovalRequestWhereUniqueInput
    /**
     * In case the ApprovalRequest found by the `where` argument doesn't exist, create a new ApprovalRequest with this data.
     */
    create: XOR<ApprovalRequestCreateInput, ApprovalRequestUncheckedCreateInput>
    /**
     * In case the ApprovalRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApprovalRequestUpdateInput, ApprovalRequestUncheckedUpdateInput>
  }

  /**
   * ApprovalRequest delete
   */
  export type ApprovalRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
    /**
     * Filter which ApprovalRequest to delete.
     */
    where: ApprovalRequestWhereUniqueInput
  }

  /**
   * ApprovalRequest deleteMany
   */
  export type ApprovalRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalRequests to delete
     */
    where?: ApprovalRequestWhereInput
  }

  /**
   * ApprovalRequest.currentStep
   */
  export type ApprovalRequest$currentStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepInclude<ExtArgs> | null
    where?: ApprovalStepWhereInput
  }

  /**
   * ApprovalRequest.actions
   */
  export type ApprovalRequest$actionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
    where?: ApprovalActionWhereInput
    orderBy?: ApprovalActionOrderByWithRelationInput | ApprovalActionOrderByWithRelationInput[]
    cursor?: ApprovalActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalActionScalarFieldEnum | ApprovalActionScalarFieldEnum[]
  }

  /**
   * ApprovalRequest without action
   */
  export type ApprovalRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalRequest
     */
    select?: ApprovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalRequestInclude<ExtArgs> | null
  }


  /**
   * Model ApprovalAction
   */

  export type AggregateApprovalAction = {
    _count: ApprovalActionCountAggregateOutputType | null
    _min: ApprovalActionMinAggregateOutputType | null
    _max: ApprovalActionMaxAggregateOutputType | null
  }

  export type ApprovalActionMinAggregateOutputType = {
    id: string | null
    requestId: string | null
    stepId: string | null
    userId: string | null
    action: string | null
    comments: string | null
    actionDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApprovalActionMaxAggregateOutputType = {
    id: string | null
    requestId: string | null
    stepId: string | null
    userId: string | null
    action: string | null
    comments: string | null
    actionDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApprovalActionCountAggregateOutputType = {
    id: number
    requestId: number
    stepId: number
    userId: number
    action: number
    comments: number
    actionDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApprovalActionMinAggregateInputType = {
    id?: true
    requestId?: true
    stepId?: true
    userId?: true
    action?: true
    comments?: true
    actionDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApprovalActionMaxAggregateInputType = {
    id?: true
    requestId?: true
    stepId?: true
    userId?: true
    action?: true
    comments?: true
    actionDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApprovalActionCountAggregateInputType = {
    id?: true
    requestId?: true
    stepId?: true
    userId?: true
    action?: true
    comments?: true
    actionDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApprovalActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalAction to aggregate.
     */
    where?: ApprovalActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalActions to fetch.
     */
    orderBy?: ApprovalActionOrderByWithRelationInput | ApprovalActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApprovalActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApprovalActions
    **/
    _count?: true | ApprovalActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApprovalActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApprovalActionMaxAggregateInputType
  }

  export type GetApprovalActionAggregateType<T extends ApprovalActionAggregateArgs> = {
        [P in keyof T & keyof AggregateApprovalAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApprovalAction[P]>
      : GetScalarType<T[P], AggregateApprovalAction[P]>
  }




  export type ApprovalActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalActionWhereInput
    orderBy?: ApprovalActionOrderByWithAggregationInput | ApprovalActionOrderByWithAggregationInput[]
    by: ApprovalActionScalarFieldEnum[] | ApprovalActionScalarFieldEnum
    having?: ApprovalActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApprovalActionCountAggregateInputType | true
    _min?: ApprovalActionMinAggregateInputType
    _max?: ApprovalActionMaxAggregateInputType
  }

  export type ApprovalActionGroupByOutputType = {
    id: string
    requestId: string
    stepId: string
    userId: string
    action: string
    comments: string | null
    actionDate: Date
    createdAt: Date
    updatedAt: Date
    _count: ApprovalActionCountAggregateOutputType | null
    _min: ApprovalActionMinAggregateOutputType | null
    _max: ApprovalActionMaxAggregateOutputType | null
  }

  type GetApprovalActionGroupByPayload<T extends ApprovalActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApprovalActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApprovalActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApprovalActionGroupByOutputType[P]>
            : GetScalarType<T[P], ApprovalActionGroupByOutputType[P]>
        }
      >
    >


  export type ApprovalActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    stepId?: boolean
    userId?: boolean
    action?: boolean
    comments?: boolean
    actionDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    request?: boolean | ApprovalRequestDefaultArgs<ExtArgs>
    step?: boolean | ApprovalStepDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approvalAction"]>

  export type ApprovalActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestId?: boolean
    stepId?: boolean
    userId?: boolean
    action?: boolean
    comments?: boolean
    actionDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    request?: boolean | ApprovalRequestDefaultArgs<ExtArgs>
    step?: boolean | ApprovalStepDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approvalAction"]>

  export type ApprovalActionSelectScalar = {
    id?: boolean
    requestId?: boolean
    stepId?: boolean
    userId?: boolean
    action?: boolean
    comments?: boolean
    actionDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApprovalActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | ApprovalRequestDefaultArgs<ExtArgs>
    step?: boolean | ApprovalStepDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ApprovalActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | ApprovalRequestDefaultArgs<ExtArgs>
    step?: boolean | ApprovalStepDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ApprovalActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApprovalAction"
    objects: {
      request: Prisma.$ApprovalRequestPayload<ExtArgs>
      step: Prisma.$ApprovalStepPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requestId: string
      stepId: string
      userId: string
      action: string
      comments: string | null
      actionDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["approvalAction"]>
    composites: {}
  }

  type ApprovalActionGetPayload<S extends boolean | null | undefined | ApprovalActionDefaultArgs> = $Result.GetResult<Prisma.$ApprovalActionPayload, S>

  type ApprovalActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApprovalActionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApprovalActionCountAggregateInputType | true
    }

  export interface ApprovalActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApprovalAction'], meta: { name: 'ApprovalAction' } }
    /**
     * Find zero or one ApprovalAction that matches the filter.
     * @param {ApprovalActionFindUniqueArgs} args - Arguments to find a ApprovalAction
     * @example
     * // Get one ApprovalAction
     * const approvalAction = await prisma.approvalAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApprovalActionFindUniqueArgs>(args: SelectSubset<T, ApprovalActionFindUniqueArgs<ExtArgs>>): Prisma__ApprovalActionClient<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApprovalAction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApprovalActionFindUniqueOrThrowArgs} args - Arguments to find a ApprovalAction
     * @example
     * // Get one ApprovalAction
     * const approvalAction = await prisma.approvalAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApprovalActionFindUniqueOrThrowArgs>(args: SelectSubset<T, ApprovalActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApprovalActionClient<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApprovalAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalActionFindFirstArgs} args - Arguments to find a ApprovalAction
     * @example
     * // Get one ApprovalAction
     * const approvalAction = await prisma.approvalAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApprovalActionFindFirstArgs>(args?: SelectSubset<T, ApprovalActionFindFirstArgs<ExtArgs>>): Prisma__ApprovalActionClient<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApprovalAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalActionFindFirstOrThrowArgs} args - Arguments to find a ApprovalAction
     * @example
     * // Get one ApprovalAction
     * const approvalAction = await prisma.approvalAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApprovalActionFindFirstOrThrowArgs>(args?: SelectSubset<T, ApprovalActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApprovalActionClient<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApprovalActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApprovalActions
     * const approvalActions = await prisma.approvalAction.findMany()
     * 
     * // Get first 10 ApprovalActions
     * const approvalActions = await prisma.approvalAction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const approvalActionWithIdOnly = await prisma.approvalAction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApprovalActionFindManyArgs>(args?: SelectSubset<T, ApprovalActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApprovalAction.
     * @param {ApprovalActionCreateArgs} args - Arguments to create a ApprovalAction.
     * @example
     * // Create one ApprovalAction
     * const ApprovalAction = await prisma.approvalAction.create({
     *   data: {
     *     // ... data to create a ApprovalAction
     *   }
     * })
     * 
     */
    create<T extends ApprovalActionCreateArgs>(args: SelectSubset<T, ApprovalActionCreateArgs<ExtArgs>>): Prisma__ApprovalActionClient<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApprovalActions.
     * @param {ApprovalActionCreateManyArgs} args - Arguments to create many ApprovalActions.
     * @example
     * // Create many ApprovalActions
     * const approvalAction = await prisma.approvalAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApprovalActionCreateManyArgs>(args?: SelectSubset<T, ApprovalActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApprovalActions and returns the data saved in the database.
     * @param {ApprovalActionCreateManyAndReturnArgs} args - Arguments to create many ApprovalActions.
     * @example
     * // Create many ApprovalActions
     * const approvalAction = await prisma.approvalAction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApprovalActions and only return the `id`
     * const approvalActionWithIdOnly = await prisma.approvalAction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApprovalActionCreateManyAndReturnArgs>(args?: SelectSubset<T, ApprovalActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApprovalAction.
     * @param {ApprovalActionDeleteArgs} args - Arguments to delete one ApprovalAction.
     * @example
     * // Delete one ApprovalAction
     * const ApprovalAction = await prisma.approvalAction.delete({
     *   where: {
     *     // ... filter to delete one ApprovalAction
     *   }
     * })
     * 
     */
    delete<T extends ApprovalActionDeleteArgs>(args: SelectSubset<T, ApprovalActionDeleteArgs<ExtArgs>>): Prisma__ApprovalActionClient<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApprovalAction.
     * @param {ApprovalActionUpdateArgs} args - Arguments to update one ApprovalAction.
     * @example
     * // Update one ApprovalAction
     * const approvalAction = await prisma.approvalAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApprovalActionUpdateArgs>(args: SelectSubset<T, ApprovalActionUpdateArgs<ExtArgs>>): Prisma__ApprovalActionClient<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApprovalActions.
     * @param {ApprovalActionDeleteManyArgs} args - Arguments to filter ApprovalActions to delete.
     * @example
     * // Delete a few ApprovalActions
     * const { count } = await prisma.approvalAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApprovalActionDeleteManyArgs>(args?: SelectSubset<T, ApprovalActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApprovalActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApprovalActions
     * const approvalAction = await prisma.approvalAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApprovalActionUpdateManyArgs>(args: SelectSubset<T, ApprovalActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApprovalAction.
     * @param {ApprovalActionUpsertArgs} args - Arguments to update or create a ApprovalAction.
     * @example
     * // Update or create a ApprovalAction
     * const approvalAction = await prisma.approvalAction.upsert({
     *   create: {
     *     // ... data to create a ApprovalAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApprovalAction we want to update
     *   }
     * })
     */
    upsert<T extends ApprovalActionUpsertArgs>(args: SelectSubset<T, ApprovalActionUpsertArgs<ExtArgs>>): Prisma__ApprovalActionClient<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApprovalActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalActionCountArgs} args - Arguments to filter ApprovalActions to count.
     * @example
     * // Count the number of ApprovalActions
     * const count = await prisma.approvalAction.count({
     *   where: {
     *     // ... the filter for the ApprovalActions we want to count
     *   }
     * })
    **/
    count<T extends ApprovalActionCountArgs>(
      args?: Subset<T, ApprovalActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApprovalActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApprovalAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApprovalActionAggregateArgs>(args: Subset<T, ApprovalActionAggregateArgs>): Prisma.PrismaPromise<GetApprovalActionAggregateType<T>>

    /**
     * Group by ApprovalAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApprovalActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApprovalActionGroupByArgs['orderBy'] }
        : { orderBy?: ApprovalActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApprovalActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApprovalActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApprovalAction model
   */
  readonly fields: ApprovalActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApprovalAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApprovalActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    request<T extends ApprovalRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApprovalRequestDefaultArgs<ExtArgs>>): Prisma__ApprovalRequestClient<$Result.GetResult<Prisma.$ApprovalRequestPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    step<T extends ApprovalStepDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApprovalStepDefaultArgs<ExtArgs>>): Prisma__ApprovalStepClient<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApprovalAction model
   */ 
  interface ApprovalActionFieldRefs {
    readonly id: FieldRef<"ApprovalAction", 'String'>
    readonly requestId: FieldRef<"ApprovalAction", 'String'>
    readonly stepId: FieldRef<"ApprovalAction", 'String'>
    readonly userId: FieldRef<"ApprovalAction", 'String'>
    readonly action: FieldRef<"ApprovalAction", 'String'>
    readonly comments: FieldRef<"ApprovalAction", 'String'>
    readonly actionDate: FieldRef<"ApprovalAction", 'DateTime'>
    readonly createdAt: FieldRef<"ApprovalAction", 'DateTime'>
    readonly updatedAt: FieldRef<"ApprovalAction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApprovalAction findUnique
   */
  export type ApprovalActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalAction to fetch.
     */
    where: ApprovalActionWhereUniqueInput
  }

  /**
   * ApprovalAction findUniqueOrThrow
   */
  export type ApprovalActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalAction to fetch.
     */
    where: ApprovalActionWhereUniqueInput
  }

  /**
   * ApprovalAction findFirst
   */
  export type ApprovalActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalAction to fetch.
     */
    where?: ApprovalActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalActions to fetch.
     */
    orderBy?: ApprovalActionOrderByWithRelationInput | ApprovalActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalActions.
     */
    cursor?: ApprovalActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalActions.
     */
    distinct?: ApprovalActionScalarFieldEnum | ApprovalActionScalarFieldEnum[]
  }

  /**
   * ApprovalAction findFirstOrThrow
   */
  export type ApprovalActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalAction to fetch.
     */
    where?: ApprovalActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalActions to fetch.
     */
    orderBy?: ApprovalActionOrderByWithRelationInput | ApprovalActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalActions.
     */
    cursor?: ApprovalActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalActions.
     */
    distinct?: ApprovalActionScalarFieldEnum | ApprovalActionScalarFieldEnum[]
  }

  /**
   * ApprovalAction findMany
   */
  export type ApprovalActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalActions to fetch.
     */
    where?: ApprovalActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalActions to fetch.
     */
    orderBy?: ApprovalActionOrderByWithRelationInput | ApprovalActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApprovalActions.
     */
    cursor?: ApprovalActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalActions.
     */
    skip?: number
    distinct?: ApprovalActionScalarFieldEnum | ApprovalActionScalarFieldEnum[]
  }

  /**
   * ApprovalAction create
   */
  export type ApprovalActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
    /**
     * The data needed to create a ApprovalAction.
     */
    data: XOR<ApprovalActionCreateInput, ApprovalActionUncheckedCreateInput>
  }

  /**
   * ApprovalAction createMany
   */
  export type ApprovalActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApprovalActions.
     */
    data: ApprovalActionCreateManyInput | ApprovalActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApprovalAction createManyAndReturn
   */
  export type ApprovalActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApprovalActions.
     */
    data: ApprovalActionCreateManyInput | ApprovalActionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApprovalAction update
   */
  export type ApprovalActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
    /**
     * The data needed to update a ApprovalAction.
     */
    data: XOR<ApprovalActionUpdateInput, ApprovalActionUncheckedUpdateInput>
    /**
     * Choose, which ApprovalAction to update.
     */
    where: ApprovalActionWhereUniqueInput
  }

  /**
   * ApprovalAction updateMany
   */
  export type ApprovalActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApprovalActions.
     */
    data: XOR<ApprovalActionUpdateManyMutationInput, ApprovalActionUncheckedUpdateManyInput>
    /**
     * Filter which ApprovalActions to update
     */
    where?: ApprovalActionWhereInput
  }

  /**
   * ApprovalAction upsert
   */
  export type ApprovalActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
    /**
     * The filter to search for the ApprovalAction to update in case it exists.
     */
    where: ApprovalActionWhereUniqueInput
    /**
     * In case the ApprovalAction found by the `where` argument doesn't exist, create a new ApprovalAction with this data.
     */
    create: XOR<ApprovalActionCreateInput, ApprovalActionUncheckedCreateInput>
    /**
     * In case the ApprovalAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApprovalActionUpdateInput, ApprovalActionUncheckedUpdateInput>
  }

  /**
   * ApprovalAction delete
   */
  export type ApprovalActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
    /**
     * Filter which ApprovalAction to delete.
     */
    where: ApprovalActionWhereUniqueInput
  }

  /**
   * ApprovalAction deleteMany
   */
  export type ApprovalActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalActions to delete
     */
    where?: ApprovalActionWhereInput
  }

  /**
   * ApprovalAction without action
   */
  export type ApprovalActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
  }


  /**
   * Model AssetCategory
   */

  export type AggregateAssetCategory = {
    _count: AssetCategoryCountAggregateOutputType | null
    _avg: AssetCategoryAvgAggregateOutputType | null
    _sum: AssetCategorySumAggregateOutputType | null
    _min: AssetCategoryMinAggregateOutputType | null
    _max: AssetCategoryMaxAggregateOutputType | null
  }

  export type AssetCategoryAvgAggregateOutputType = {
    usefulLife: number | null
    residualValue: Decimal | null
  }

  export type AssetCategorySumAggregateOutputType = {
    usefulLife: number | null
    residualValue: Decimal | null
  }

  export type AssetCategoryMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    depreciationMethod: string | null
    usefulLife: number | null
    residualValue: Decimal | null
    glAssetAccountId: string | null
    glDepreciationAccountId: string | null
    glAccumulatedDepreciationAccountId: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type AssetCategoryMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    depreciationMethod: string | null
    usefulLife: number | null
    residualValue: Decimal | null
    glAssetAccountId: string | null
    glDepreciationAccountId: string | null
    glAccumulatedDepreciationAccountId: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type AssetCategoryCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    depreciationMethod: number
    usefulLife: number
    residualValue: number
    glAssetAccountId: number
    glDepreciationAccountId: number
    glAccumulatedDepreciationAccountId: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type AssetCategoryAvgAggregateInputType = {
    usefulLife?: true
    residualValue?: true
  }

  export type AssetCategorySumAggregateInputType = {
    usefulLife?: true
    residualValue?: true
  }

  export type AssetCategoryMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    depreciationMethod?: true
    usefulLife?: true
    residualValue?: true
    glAssetAccountId?: true
    glDepreciationAccountId?: true
    glAccumulatedDepreciationAccountId?: true
    isActive?: true
    createdAt?: true
  }

  export type AssetCategoryMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    depreciationMethod?: true
    usefulLife?: true
    residualValue?: true
    glAssetAccountId?: true
    glDepreciationAccountId?: true
    glAccumulatedDepreciationAccountId?: true
    isActive?: true
    createdAt?: true
  }

  export type AssetCategoryCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    depreciationMethod?: true
    usefulLife?: true
    residualValue?: true
    glAssetAccountId?: true
    glDepreciationAccountId?: true
    glAccumulatedDepreciationAccountId?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type AssetCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetCategory to aggregate.
     */
    where?: AssetCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetCategories to fetch.
     */
    orderBy?: AssetCategoryOrderByWithRelationInput | AssetCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssetCategories
    **/
    _count?: true | AssetCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetCategoryMaxAggregateInputType
  }

  export type GetAssetCategoryAggregateType<T extends AssetCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateAssetCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssetCategory[P]>
      : GetScalarType<T[P], AggregateAssetCategory[P]>
  }




  export type AssetCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetCategoryWhereInput
    orderBy?: AssetCategoryOrderByWithAggregationInput | AssetCategoryOrderByWithAggregationInput[]
    by: AssetCategoryScalarFieldEnum[] | AssetCategoryScalarFieldEnum
    having?: AssetCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetCategoryCountAggregateInputType | true
    _avg?: AssetCategoryAvgAggregateInputType
    _sum?: AssetCategorySumAggregateInputType
    _min?: AssetCategoryMinAggregateInputType
    _max?: AssetCategoryMaxAggregateInputType
  }

  export type AssetCategoryGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    depreciationMethod: string
    usefulLife: number
    residualValue: Decimal
    glAssetAccountId: string
    glDepreciationAccountId: string
    glAccumulatedDepreciationAccountId: string
    isActive: boolean
    createdAt: Date
    _count: AssetCategoryCountAggregateOutputType | null
    _avg: AssetCategoryAvgAggregateOutputType | null
    _sum: AssetCategorySumAggregateOutputType | null
    _min: AssetCategoryMinAggregateOutputType | null
    _max: AssetCategoryMaxAggregateOutputType | null
  }

  type GetAssetCategoryGroupByPayload<T extends AssetCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], AssetCategoryGroupByOutputType[P]>
        }
      >
    >


  export type AssetCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    depreciationMethod?: boolean
    usefulLife?: boolean
    residualValue?: boolean
    glAssetAccountId?: boolean
    glDepreciationAccountId?: boolean
    glAccumulatedDepreciationAccountId?: boolean
    isActive?: boolean
    createdAt?: boolean
    assets?: boolean | AssetCategory$assetsArgs<ExtArgs>
    glAssetAccount?: boolean | ChartOfAccountDefaultArgs<ExtArgs>
    glDepreciationAccount?: boolean | ChartOfAccountDefaultArgs<ExtArgs>
    glAccumulatedDepreciationAccount?: boolean | ChartOfAccountDefaultArgs<ExtArgs>
    _count?: boolean | AssetCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetCategory"]>

  export type AssetCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    depreciationMethod?: boolean
    usefulLife?: boolean
    residualValue?: boolean
    glAssetAccountId?: boolean
    glDepreciationAccountId?: boolean
    glAccumulatedDepreciationAccountId?: boolean
    isActive?: boolean
    createdAt?: boolean
    glAssetAccount?: boolean | ChartOfAccountDefaultArgs<ExtArgs>
    glDepreciationAccount?: boolean | ChartOfAccountDefaultArgs<ExtArgs>
    glAccumulatedDepreciationAccount?: boolean | ChartOfAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetCategory"]>

  export type AssetCategorySelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    depreciationMethod?: boolean
    usefulLife?: boolean
    residualValue?: boolean
    glAssetAccountId?: boolean
    glDepreciationAccountId?: boolean
    glAccumulatedDepreciationAccountId?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type AssetCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assets?: boolean | AssetCategory$assetsArgs<ExtArgs>
    glAssetAccount?: boolean | ChartOfAccountDefaultArgs<ExtArgs>
    glDepreciationAccount?: boolean | ChartOfAccountDefaultArgs<ExtArgs>
    glAccumulatedDepreciationAccount?: boolean | ChartOfAccountDefaultArgs<ExtArgs>
    _count?: boolean | AssetCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AssetCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    glAssetAccount?: boolean | ChartOfAccountDefaultArgs<ExtArgs>
    glDepreciationAccount?: boolean | ChartOfAccountDefaultArgs<ExtArgs>
    glAccumulatedDepreciationAccount?: boolean | ChartOfAccountDefaultArgs<ExtArgs>
  }

  export type $AssetCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssetCategory"
    objects: {
      assets: Prisma.$AssetPayload<ExtArgs>[]
      glAssetAccount: Prisma.$ChartOfAccountPayload<ExtArgs>
      glDepreciationAccount: Prisma.$ChartOfAccountPayload<ExtArgs>
      glAccumulatedDepreciationAccount: Prisma.$ChartOfAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      depreciationMethod: string
      usefulLife: number
      residualValue: Prisma.Decimal
      glAssetAccountId: string
      glDepreciationAccountId: string
      glAccumulatedDepreciationAccountId: string
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["assetCategory"]>
    composites: {}
  }

  type AssetCategoryGetPayload<S extends boolean | null | undefined | AssetCategoryDefaultArgs> = $Result.GetResult<Prisma.$AssetCategoryPayload, S>

  type AssetCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssetCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssetCategoryCountAggregateInputType | true
    }

  export interface AssetCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssetCategory'], meta: { name: 'AssetCategory' } }
    /**
     * Find zero or one AssetCategory that matches the filter.
     * @param {AssetCategoryFindUniqueArgs} args - Arguments to find a AssetCategory
     * @example
     * // Get one AssetCategory
     * const assetCategory = await prisma.assetCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetCategoryFindUniqueArgs>(args: SelectSubset<T, AssetCategoryFindUniqueArgs<ExtArgs>>): Prisma__AssetCategoryClient<$Result.GetResult<Prisma.$AssetCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AssetCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssetCategoryFindUniqueOrThrowArgs} args - Arguments to find a AssetCategory
     * @example
     * // Get one AssetCategory
     * const assetCategory = await prisma.assetCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetCategoryClient<$Result.GetResult<Prisma.$AssetCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AssetCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCategoryFindFirstArgs} args - Arguments to find a AssetCategory
     * @example
     * // Get one AssetCategory
     * const assetCategory = await prisma.assetCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetCategoryFindFirstArgs>(args?: SelectSubset<T, AssetCategoryFindFirstArgs<ExtArgs>>): Prisma__AssetCategoryClient<$Result.GetResult<Prisma.$AssetCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AssetCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCategoryFindFirstOrThrowArgs} args - Arguments to find a AssetCategory
     * @example
     * // Get one AssetCategory
     * const assetCategory = await prisma.assetCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetCategoryClient<$Result.GetResult<Prisma.$AssetCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AssetCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssetCategories
     * const assetCategories = await prisma.assetCategory.findMany()
     * 
     * // Get first 10 AssetCategories
     * const assetCategories = await prisma.assetCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetCategoryWithIdOnly = await prisma.assetCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetCategoryFindManyArgs>(args?: SelectSubset<T, AssetCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AssetCategory.
     * @param {AssetCategoryCreateArgs} args - Arguments to create a AssetCategory.
     * @example
     * // Create one AssetCategory
     * const AssetCategory = await prisma.assetCategory.create({
     *   data: {
     *     // ... data to create a AssetCategory
     *   }
     * })
     * 
     */
    create<T extends AssetCategoryCreateArgs>(args: SelectSubset<T, AssetCategoryCreateArgs<ExtArgs>>): Prisma__AssetCategoryClient<$Result.GetResult<Prisma.$AssetCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AssetCategories.
     * @param {AssetCategoryCreateManyArgs} args - Arguments to create many AssetCategories.
     * @example
     * // Create many AssetCategories
     * const assetCategory = await prisma.assetCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetCategoryCreateManyArgs>(args?: SelectSubset<T, AssetCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssetCategories and returns the data saved in the database.
     * @param {AssetCategoryCreateManyAndReturnArgs} args - Arguments to create many AssetCategories.
     * @example
     * // Create many AssetCategories
     * const assetCategory = await prisma.assetCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssetCategories and only return the `id`
     * const assetCategoryWithIdOnly = await prisma.assetCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AssetCategory.
     * @param {AssetCategoryDeleteArgs} args - Arguments to delete one AssetCategory.
     * @example
     * // Delete one AssetCategory
     * const AssetCategory = await prisma.assetCategory.delete({
     *   where: {
     *     // ... filter to delete one AssetCategory
     *   }
     * })
     * 
     */
    delete<T extends AssetCategoryDeleteArgs>(args: SelectSubset<T, AssetCategoryDeleteArgs<ExtArgs>>): Prisma__AssetCategoryClient<$Result.GetResult<Prisma.$AssetCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AssetCategory.
     * @param {AssetCategoryUpdateArgs} args - Arguments to update one AssetCategory.
     * @example
     * // Update one AssetCategory
     * const assetCategory = await prisma.assetCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetCategoryUpdateArgs>(args: SelectSubset<T, AssetCategoryUpdateArgs<ExtArgs>>): Prisma__AssetCategoryClient<$Result.GetResult<Prisma.$AssetCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AssetCategories.
     * @param {AssetCategoryDeleteManyArgs} args - Arguments to filter AssetCategories to delete.
     * @example
     * // Delete a few AssetCategories
     * const { count } = await prisma.assetCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetCategoryDeleteManyArgs>(args?: SelectSubset<T, AssetCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssetCategories
     * const assetCategory = await prisma.assetCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetCategoryUpdateManyArgs>(args: SelectSubset<T, AssetCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AssetCategory.
     * @param {AssetCategoryUpsertArgs} args - Arguments to update or create a AssetCategory.
     * @example
     * // Update or create a AssetCategory
     * const assetCategory = await prisma.assetCategory.upsert({
     *   create: {
     *     // ... data to create a AssetCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssetCategory we want to update
     *   }
     * })
     */
    upsert<T extends AssetCategoryUpsertArgs>(args: SelectSubset<T, AssetCategoryUpsertArgs<ExtArgs>>): Prisma__AssetCategoryClient<$Result.GetResult<Prisma.$AssetCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AssetCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCategoryCountArgs} args - Arguments to filter AssetCategories to count.
     * @example
     * // Count the number of AssetCategories
     * const count = await prisma.assetCategory.count({
     *   where: {
     *     // ... the filter for the AssetCategories we want to count
     *   }
     * })
    **/
    count<T extends AssetCategoryCountArgs>(
      args?: Subset<T, AssetCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssetCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetCategoryAggregateArgs>(args: Subset<T, AssetCategoryAggregateArgs>): Prisma.PrismaPromise<GetAssetCategoryAggregateType<T>>

    /**
     * Group by AssetCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetCategoryGroupByArgs['orderBy'] }
        : { orderBy?: AssetCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssetCategory model
   */
  readonly fields: AssetCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssetCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assets<T extends AssetCategory$assetsArgs<ExtArgs> = {}>(args?: Subset<T, AssetCategory$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany"> | Null>
    glAssetAccount<T extends ChartOfAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChartOfAccountDefaultArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    glDepreciationAccount<T extends ChartOfAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChartOfAccountDefaultArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    glAccumulatedDepreciationAccount<T extends ChartOfAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChartOfAccountDefaultArgs<ExtArgs>>): Prisma__ChartOfAccountClient<$Result.GetResult<Prisma.$ChartOfAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssetCategory model
   */ 
  interface AssetCategoryFieldRefs {
    readonly id: FieldRef<"AssetCategory", 'String'>
    readonly code: FieldRef<"AssetCategory", 'String'>
    readonly name: FieldRef<"AssetCategory", 'String'>
    readonly description: FieldRef<"AssetCategory", 'String'>
    readonly depreciationMethod: FieldRef<"AssetCategory", 'String'>
    readonly usefulLife: FieldRef<"AssetCategory", 'Int'>
    readonly residualValue: FieldRef<"AssetCategory", 'Decimal'>
    readonly glAssetAccountId: FieldRef<"AssetCategory", 'String'>
    readonly glDepreciationAccountId: FieldRef<"AssetCategory", 'String'>
    readonly glAccumulatedDepreciationAccountId: FieldRef<"AssetCategory", 'String'>
    readonly isActive: FieldRef<"AssetCategory", 'Boolean'>
    readonly createdAt: FieldRef<"AssetCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AssetCategory findUnique
   */
  export type AssetCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetCategory
     */
    select?: AssetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetCategory to fetch.
     */
    where: AssetCategoryWhereUniqueInput
  }

  /**
   * AssetCategory findUniqueOrThrow
   */
  export type AssetCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetCategory
     */
    select?: AssetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetCategory to fetch.
     */
    where: AssetCategoryWhereUniqueInput
  }

  /**
   * AssetCategory findFirst
   */
  export type AssetCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetCategory
     */
    select?: AssetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetCategory to fetch.
     */
    where?: AssetCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetCategories to fetch.
     */
    orderBy?: AssetCategoryOrderByWithRelationInput | AssetCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetCategories.
     */
    cursor?: AssetCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetCategories.
     */
    distinct?: AssetCategoryScalarFieldEnum | AssetCategoryScalarFieldEnum[]
  }

  /**
   * AssetCategory findFirstOrThrow
   */
  export type AssetCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetCategory
     */
    select?: AssetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetCategory to fetch.
     */
    where?: AssetCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetCategories to fetch.
     */
    orderBy?: AssetCategoryOrderByWithRelationInput | AssetCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetCategories.
     */
    cursor?: AssetCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetCategories.
     */
    distinct?: AssetCategoryScalarFieldEnum | AssetCategoryScalarFieldEnum[]
  }

  /**
   * AssetCategory findMany
   */
  export type AssetCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetCategory
     */
    select?: AssetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which AssetCategories to fetch.
     */
    where?: AssetCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetCategories to fetch.
     */
    orderBy?: AssetCategoryOrderByWithRelationInput | AssetCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssetCategories.
     */
    cursor?: AssetCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetCategories.
     */
    skip?: number
    distinct?: AssetCategoryScalarFieldEnum | AssetCategoryScalarFieldEnum[]
  }

  /**
   * AssetCategory create
   */
  export type AssetCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetCategory
     */
    select?: AssetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a AssetCategory.
     */
    data: XOR<AssetCategoryCreateInput, AssetCategoryUncheckedCreateInput>
  }

  /**
   * AssetCategory createMany
   */
  export type AssetCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssetCategories.
     */
    data: AssetCategoryCreateManyInput | AssetCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssetCategory createManyAndReturn
   */
  export type AssetCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetCategory
     */
    select?: AssetCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AssetCategories.
     */
    data: AssetCategoryCreateManyInput | AssetCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetCategory update
   */
  export type AssetCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetCategory
     */
    select?: AssetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a AssetCategory.
     */
    data: XOR<AssetCategoryUpdateInput, AssetCategoryUncheckedUpdateInput>
    /**
     * Choose, which AssetCategory to update.
     */
    where: AssetCategoryWhereUniqueInput
  }

  /**
   * AssetCategory updateMany
   */
  export type AssetCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssetCategories.
     */
    data: XOR<AssetCategoryUpdateManyMutationInput, AssetCategoryUncheckedUpdateManyInput>
    /**
     * Filter which AssetCategories to update
     */
    where?: AssetCategoryWhereInput
  }

  /**
   * AssetCategory upsert
   */
  export type AssetCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetCategory
     */
    select?: AssetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the AssetCategory to update in case it exists.
     */
    where: AssetCategoryWhereUniqueInput
    /**
     * In case the AssetCategory found by the `where` argument doesn't exist, create a new AssetCategory with this data.
     */
    create: XOR<AssetCategoryCreateInput, AssetCategoryUncheckedCreateInput>
    /**
     * In case the AssetCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetCategoryUpdateInput, AssetCategoryUncheckedUpdateInput>
  }

  /**
   * AssetCategory delete
   */
  export type AssetCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetCategory
     */
    select?: AssetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCategoryInclude<ExtArgs> | null
    /**
     * Filter which AssetCategory to delete.
     */
    where: AssetCategoryWhereUniqueInput
  }

  /**
   * AssetCategory deleteMany
   */
  export type AssetCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetCategories to delete
     */
    where?: AssetCategoryWhereInput
  }

  /**
   * AssetCategory.assets
   */
  export type AssetCategory$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * AssetCategory without action
   */
  export type AssetCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetCategory
     */
    select?: AssetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Asset
   */

  export type AggregateAsset = {
    _count: AssetCountAggregateOutputType | null
    _avg: AssetAvgAggregateOutputType | null
    _sum: AssetSumAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  export type AssetAvgAggregateOutputType = {
    acquisitionCost: Decimal | null
    residualValue: Decimal | null
    usefulLife: number | null
    disposalAmount: Decimal | null
  }

  export type AssetSumAggregateOutputType = {
    acquisitionCost: Decimal | null
    residualValue: Decimal | null
    usefulLife: number | null
    disposalAmount: Decimal | null
  }

  export type AssetMinAggregateOutputType = {
    id: string | null
    assetNo: string | null
    name: string | null
    description: string | null
    categoryId: string | null
    acquisitionDate: Date | null
    acquisitionCost: Decimal | null
    residualValue: Decimal | null
    usefulLife: number | null
    depreciationMethod: string | null
    locationId: string | null
    serialNumber: string | null
    supplier: string | null
    purchaseOrderId: string | null
    status: string | null
    disposalDate: Date | null
    disposalAmount: Decimal | null
    disposalMethod: string | null
    createdBy: string | null
    createdAt: Date | null
    vendorId: string | null
  }

  export type AssetMaxAggregateOutputType = {
    id: string | null
    assetNo: string | null
    name: string | null
    description: string | null
    categoryId: string | null
    acquisitionDate: Date | null
    acquisitionCost: Decimal | null
    residualValue: Decimal | null
    usefulLife: number | null
    depreciationMethod: string | null
    locationId: string | null
    serialNumber: string | null
    supplier: string | null
    purchaseOrderId: string | null
    status: string | null
    disposalDate: Date | null
    disposalAmount: Decimal | null
    disposalMethod: string | null
    createdBy: string | null
    createdAt: Date | null
    vendorId: string | null
  }

  export type AssetCountAggregateOutputType = {
    id: number
    assetNo: number
    name: number
    description: number
    categoryId: number
    acquisitionDate: number
    acquisitionCost: number
    residualValue: number
    usefulLife: number
    depreciationMethod: number
    locationId: number
    serialNumber: number
    supplier: number
    purchaseOrderId: number
    status: number
    disposalDate: number
    disposalAmount: number
    disposalMethod: number
    createdBy: number
    createdAt: number
    vendorId: number
    _all: number
  }


  export type AssetAvgAggregateInputType = {
    acquisitionCost?: true
    residualValue?: true
    usefulLife?: true
    disposalAmount?: true
  }

  export type AssetSumAggregateInputType = {
    acquisitionCost?: true
    residualValue?: true
    usefulLife?: true
    disposalAmount?: true
  }

  export type AssetMinAggregateInputType = {
    id?: true
    assetNo?: true
    name?: true
    description?: true
    categoryId?: true
    acquisitionDate?: true
    acquisitionCost?: true
    residualValue?: true
    usefulLife?: true
    depreciationMethod?: true
    locationId?: true
    serialNumber?: true
    supplier?: true
    purchaseOrderId?: true
    status?: true
    disposalDate?: true
    disposalAmount?: true
    disposalMethod?: true
    createdBy?: true
    createdAt?: true
    vendorId?: true
  }

  export type AssetMaxAggregateInputType = {
    id?: true
    assetNo?: true
    name?: true
    description?: true
    categoryId?: true
    acquisitionDate?: true
    acquisitionCost?: true
    residualValue?: true
    usefulLife?: true
    depreciationMethod?: true
    locationId?: true
    serialNumber?: true
    supplier?: true
    purchaseOrderId?: true
    status?: true
    disposalDate?: true
    disposalAmount?: true
    disposalMethod?: true
    createdBy?: true
    createdAt?: true
    vendorId?: true
  }

  export type AssetCountAggregateInputType = {
    id?: true
    assetNo?: true
    name?: true
    description?: true
    categoryId?: true
    acquisitionDate?: true
    acquisitionCost?: true
    residualValue?: true
    usefulLife?: true
    depreciationMethod?: true
    locationId?: true
    serialNumber?: true
    supplier?: true
    purchaseOrderId?: true
    status?: true
    disposalDate?: true
    disposalAmount?: true
    disposalMethod?: true
    createdBy?: true
    createdAt?: true
    vendorId?: true
    _all?: true
  }

  export type AssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Asset to aggregate.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assets
    **/
    _count?: true | AssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetMaxAggregateInputType
  }

  export type GetAssetAggregateType<T extends AssetAggregateArgs> = {
        [P in keyof T & keyof AggregateAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsset[P]>
      : GetScalarType<T[P], AggregateAsset[P]>
  }




  export type AssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithAggregationInput | AssetOrderByWithAggregationInput[]
    by: AssetScalarFieldEnum[] | AssetScalarFieldEnum
    having?: AssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetCountAggregateInputType | true
    _avg?: AssetAvgAggregateInputType
    _sum?: AssetSumAggregateInputType
    _min?: AssetMinAggregateInputType
    _max?: AssetMaxAggregateInputType
  }

  export type AssetGroupByOutputType = {
    id: string
    assetNo: string
    name: string
    description: string | null
    categoryId: string
    acquisitionDate: Date
    acquisitionCost: Decimal
    residualValue: Decimal
    usefulLife: number
    depreciationMethod: string
    locationId: string | null
    serialNumber: string | null
    supplier: string | null
    purchaseOrderId: string | null
    status: string
    disposalDate: Date | null
    disposalAmount: Decimal | null
    disposalMethod: string | null
    createdBy: string
    createdAt: Date
    vendorId: string | null
    _count: AssetCountAggregateOutputType | null
    _avg: AssetAvgAggregateOutputType | null
    _sum: AssetSumAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  type GetAssetGroupByPayload<T extends AssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetGroupByOutputType[P]>
            : GetScalarType<T[P], AssetGroupByOutputType[P]>
        }
      >
    >


  export type AssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetNo?: boolean
    name?: boolean
    description?: boolean
    categoryId?: boolean
    acquisitionDate?: boolean
    acquisitionCost?: boolean
    residualValue?: boolean
    usefulLife?: boolean
    depreciationMethod?: boolean
    locationId?: boolean
    serialNumber?: boolean
    supplier?: boolean
    purchaseOrderId?: boolean
    status?: boolean
    disposalDate?: boolean
    disposalAmount?: boolean
    disposalMethod?: boolean
    createdBy?: boolean
    createdAt?: boolean
    vendorId?: boolean
    category?: boolean | AssetCategoryDefaultArgs<ExtArgs>
    location?: boolean | Asset$locationArgs<ExtArgs>
    purchaseOrder?: boolean | Asset$purchaseOrderArgs<ExtArgs>
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
    depreciationEntries?: boolean | Asset$depreciationEntriesArgs<ExtArgs>
    disposals?: boolean | Asset$disposalsArgs<ExtArgs>
    Vendor?: boolean | Asset$VendorArgs<ExtArgs>
    _count?: boolean | AssetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetNo?: boolean
    name?: boolean
    description?: boolean
    categoryId?: boolean
    acquisitionDate?: boolean
    acquisitionCost?: boolean
    residualValue?: boolean
    usefulLife?: boolean
    depreciationMethod?: boolean
    locationId?: boolean
    serialNumber?: boolean
    supplier?: boolean
    purchaseOrderId?: boolean
    status?: boolean
    disposalDate?: boolean
    disposalAmount?: boolean
    disposalMethod?: boolean
    createdBy?: boolean
    createdAt?: boolean
    vendorId?: boolean
    category?: boolean | AssetCategoryDefaultArgs<ExtArgs>
    location?: boolean | Asset$locationArgs<ExtArgs>
    purchaseOrder?: boolean | Asset$purchaseOrderArgs<ExtArgs>
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
    Vendor?: boolean | Asset$VendorArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectScalar = {
    id?: boolean
    assetNo?: boolean
    name?: boolean
    description?: boolean
    categoryId?: boolean
    acquisitionDate?: boolean
    acquisitionCost?: boolean
    residualValue?: boolean
    usefulLife?: boolean
    depreciationMethod?: boolean
    locationId?: boolean
    serialNumber?: boolean
    supplier?: boolean
    purchaseOrderId?: boolean
    status?: boolean
    disposalDate?: boolean
    disposalAmount?: boolean
    disposalMethod?: boolean
    createdBy?: boolean
    createdAt?: boolean
    vendorId?: boolean
  }

  export type AssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | AssetCategoryDefaultArgs<ExtArgs>
    location?: boolean | Asset$locationArgs<ExtArgs>
    purchaseOrder?: boolean | Asset$purchaseOrderArgs<ExtArgs>
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
    depreciationEntries?: boolean | Asset$depreciationEntriesArgs<ExtArgs>
    disposals?: boolean | Asset$disposalsArgs<ExtArgs>
    Vendor?: boolean | Asset$VendorArgs<ExtArgs>
    _count?: boolean | AssetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AssetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | AssetCategoryDefaultArgs<ExtArgs>
    location?: boolean | Asset$locationArgs<ExtArgs>
    purchaseOrder?: boolean | Asset$purchaseOrderArgs<ExtArgs>
    createdByUser?: boolean | UserDefaultArgs<ExtArgs>
    Vendor?: boolean | Asset$VendorArgs<ExtArgs>
  }

  export type $AssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Asset"
    objects: {
      category: Prisma.$AssetCategoryPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs> | null
      purchaseOrder: Prisma.$PurchasePayload<ExtArgs> | null
      createdByUser: Prisma.$UserPayload<ExtArgs>
      depreciationEntries: Prisma.$AssetDepreciationPayload<ExtArgs>[]
      disposals: Prisma.$AssetDisposalPayload<ExtArgs>[]
      Vendor: Prisma.$VendorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      assetNo: string
      name: string
      description: string | null
      categoryId: string
      acquisitionDate: Date
      acquisitionCost: Prisma.Decimal
      residualValue: Prisma.Decimal
      usefulLife: number
      depreciationMethod: string
      locationId: string | null
      serialNumber: string | null
      supplier: string | null
      purchaseOrderId: string | null
      status: string
      disposalDate: Date | null
      disposalAmount: Prisma.Decimal | null
      disposalMethod: string | null
      createdBy: string
      createdAt: Date
      vendorId: string | null
    }, ExtArgs["result"]["asset"]>
    composites: {}
  }

  type AssetGetPayload<S extends boolean | null | undefined | AssetDefaultArgs> = $Result.GetResult<Prisma.$AssetPayload, S>

  type AssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssetCountAggregateInputType | true
    }

  export interface AssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Asset'], meta: { name: 'Asset' } }
    /**
     * Find zero or one Asset that matches the filter.
     * @param {AssetFindUniqueArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetFindUniqueArgs>(args: SelectSubset<T, AssetFindUniqueArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Asset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssetFindUniqueOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Asset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetFindFirstArgs>(args?: SelectSubset<T, AssetFindFirstArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Asset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assets
     * const assets = await prisma.asset.findMany()
     * 
     * // Get first 10 Assets
     * const assets = await prisma.asset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetWithIdOnly = await prisma.asset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetFindManyArgs>(args?: SelectSubset<T, AssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Asset.
     * @param {AssetCreateArgs} args - Arguments to create a Asset.
     * @example
     * // Create one Asset
     * const Asset = await prisma.asset.create({
     *   data: {
     *     // ... data to create a Asset
     *   }
     * })
     * 
     */
    create<T extends AssetCreateArgs>(args: SelectSubset<T, AssetCreateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Assets.
     * @param {AssetCreateManyArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetCreateManyArgs>(args?: SelectSubset<T, AssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assets and returns the data saved in the database.
     * @param {AssetCreateManyAndReturnArgs} args - Arguments to create many Assets.
     * @example
     * // Create many Assets
     * const asset = await prisma.asset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assets and only return the `id`
     * const assetWithIdOnly = await prisma.asset.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Asset.
     * @param {AssetDeleteArgs} args - Arguments to delete one Asset.
     * @example
     * // Delete one Asset
     * const Asset = await prisma.asset.delete({
     *   where: {
     *     // ... filter to delete one Asset
     *   }
     * })
     * 
     */
    delete<T extends AssetDeleteArgs>(args: SelectSubset<T, AssetDeleteArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Asset.
     * @param {AssetUpdateArgs} args - Arguments to update one Asset.
     * @example
     * // Update one Asset
     * const asset = await prisma.asset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetUpdateArgs>(args: SelectSubset<T, AssetUpdateArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Assets.
     * @param {AssetDeleteManyArgs} args - Arguments to filter Assets to delete.
     * @example
     * // Delete a few Assets
     * const { count } = await prisma.asset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetDeleteManyArgs>(args?: SelectSubset<T, AssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetUpdateManyArgs>(args: SelectSubset<T, AssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Asset.
     * @param {AssetUpsertArgs} args - Arguments to update or create a Asset.
     * @example
     * // Update or create a Asset
     * const asset = await prisma.asset.upsert({
     *   create: {
     *     // ... data to create a Asset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Asset we want to update
     *   }
     * })
     */
    upsert<T extends AssetUpsertArgs>(args: SelectSubset<T, AssetUpsertArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCountArgs} args - Arguments to filter Assets to count.
     * @example
     * // Count the number of Assets
     * const count = await prisma.asset.count({
     *   where: {
     *     // ... the filter for the Assets we want to count
     *   }
     * })
    **/
    count<T extends AssetCountArgs>(
      args?: Subset<T, AssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetAggregateArgs>(args: Subset<T, AssetAggregateArgs>): Prisma.PrismaPromise<GetAssetAggregateType<T>>

    /**
     * Group by Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetGroupByArgs['orderBy'] }
        : { orderBy?: AssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Asset model
   */
  readonly fields: AssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Asset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends AssetCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssetCategoryDefaultArgs<ExtArgs>>): Prisma__AssetCategoryClient<$Result.GetResult<Prisma.$AssetCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    location<T extends Asset$locationArgs<ExtArgs> = {}>(args?: Subset<T, Asset$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    purchaseOrder<T extends Asset$purchaseOrderArgs<ExtArgs> = {}>(args?: Subset<T, Asset$purchaseOrderArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    createdByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    depreciationEntries<T extends Asset$depreciationEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Asset$depreciationEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetDepreciationPayload<ExtArgs>, T, "findMany"> | Null>
    disposals<T extends Asset$disposalsArgs<ExtArgs> = {}>(args?: Subset<T, Asset$disposalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetDisposalPayload<ExtArgs>, T, "findMany"> | Null>
    Vendor<T extends Asset$VendorArgs<ExtArgs> = {}>(args?: Subset<T, Asset$VendorArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Asset model
   */ 
  interface AssetFieldRefs {
    readonly id: FieldRef<"Asset", 'String'>
    readonly assetNo: FieldRef<"Asset", 'String'>
    readonly name: FieldRef<"Asset", 'String'>
    readonly description: FieldRef<"Asset", 'String'>
    readonly categoryId: FieldRef<"Asset", 'String'>
    readonly acquisitionDate: FieldRef<"Asset", 'DateTime'>
    readonly acquisitionCost: FieldRef<"Asset", 'Decimal'>
    readonly residualValue: FieldRef<"Asset", 'Decimal'>
    readonly usefulLife: FieldRef<"Asset", 'Int'>
    readonly depreciationMethod: FieldRef<"Asset", 'String'>
    readonly locationId: FieldRef<"Asset", 'String'>
    readonly serialNumber: FieldRef<"Asset", 'String'>
    readonly supplier: FieldRef<"Asset", 'String'>
    readonly purchaseOrderId: FieldRef<"Asset", 'String'>
    readonly status: FieldRef<"Asset", 'String'>
    readonly disposalDate: FieldRef<"Asset", 'DateTime'>
    readonly disposalAmount: FieldRef<"Asset", 'Decimal'>
    readonly disposalMethod: FieldRef<"Asset", 'String'>
    readonly createdBy: FieldRef<"Asset", 'String'>
    readonly createdAt: FieldRef<"Asset", 'DateTime'>
    readonly vendorId: FieldRef<"Asset", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Asset findUnique
   */
  export type AssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findUniqueOrThrow
   */
  export type AssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset findFirst
   */
  export type AssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findFirstOrThrow
   */
  export type AssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset findMany
   */
  export type AssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Assets to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }

  /**
   * Asset create
   */
  export type AssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to create a Asset.
     */
    data: XOR<AssetCreateInput, AssetUncheckedCreateInput>
  }

  /**
   * Asset createMany
   */
  export type AssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Asset createManyAndReturn
   */
  export type AssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Asset update
   */
  export type AssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to update a Asset.
     */
    data: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
    /**
     * Choose, which Asset to update.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset updateMany
   */
  export type AssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput
  }

  /**
   * Asset upsert
   */
  export type AssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The filter to search for the Asset to update in case it exists.
     */
    where: AssetWhereUniqueInput
    /**
     * In case the Asset found by the `where` argument doesn't exist, create a new Asset with this data.
     */
    create: XOR<AssetCreateInput, AssetUncheckedCreateInput>
    /**
     * In case the Asset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
  }

  /**
   * Asset delete
   */
  export type AssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter which Asset to delete.
     */
    where: AssetWhereUniqueInput
  }

  /**
   * Asset deleteMany
   */
  export type AssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assets to delete
     */
    where?: AssetWhereInput
  }

  /**
   * Asset.location
   */
  export type Asset$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Asset.purchaseOrder
   */
  export type Asset$purchaseOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
  }

  /**
   * Asset.depreciationEntries
   */
  export type Asset$depreciationEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDepreciation
     */
    select?: AssetDepreciationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDepreciationInclude<ExtArgs> | null
    where?: AssetDepreciationWhereInput
    orderBy?: AssetDepreciationOrderByWithRelationInput | AssetDepreciationOrderByWithRelationInput[]
    cursor?: AssetDepreciationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetDepreciationScalarFieldEnum | AssetDepreciationScalarFieldEnum[]
  }

  /**
   * Asset.disposals
   */
  export type Asset$disposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDisposal
     */
    select?: AssetDisposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDisposalInclude<ExtArgs> | null
    where?: AssetDisposalWhereInput
    orderBy?: AssetDisposalOrderByWithRelationInput | AssetDisposalOrderByWithRelationInput[]
    cursor?: AssetDisposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetDisposalScalarFieldEnum | AssetDisposalScalarFieldEnum[]
  }

  /**
   * Asset.Vendor
   */
  export type Asset$VendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
  }

  /**
   * Asset without action
   */
  export type AssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetInclude<ExtArgs> | null
  }


  /**
   * Model AssetDepreciation
   */

  export type AggregateAssetDepreciation = {
    _count: AssetDepreciationCountAggregateOutputType | null
    _avg: AssetDepreciationAvgAggregateOutputType | null
    _sum: AssetDepreciationSumAggregateOutputType | null
    _min: AssetDepreciationMinAggregateOutputType | null
    _max: AssetDepreciationMaxAggregateOutputType | null
  }

  export type AssetDepreciationAvgAggregateOutputType = {
    periodYear: number | null
    periodMonth: number | null
    depreciationAmount: Decimal | null
    accumulatedDepreciation: Decimal | null
    netBookValue: Decimal | null
  }

  export type AssetDepreciationSumAggregateOutputType = {
    periodYear: number | null
    periodMonth: number | null
    depreciationAmount: Decimal | null
    accumulatedDepreciation: Decimal | null
    netBookValue: Decimal | null
  }

  export type AssetDepreciationMinAggregateOutputType = {
    id: string | null
    assetId: string | null
    periodYear: number | null
    periodMonth: number | null
    depreciationAmount: Decimal | null
    accumulatedDepreciation: Decimal | null
    netBookValue: Decimal | null
    isPosted: boolean | null
    postedAt: Date | null
    journalId: string | null
    createdAt: Date | null
  }

  export type AssetDepreciationMaxAggregateOutputType = {
    id: string | null
    assetId: string | null
    periodYear: number | null
    periodMonth: number | null
    depreciationAmount: Decimal | null
    accumulatedDepreciation: Decimal | null
    netBookValue: Decimal | null
    isPosted: boolean | null
    postedAt: Date | null
    journalId: string | null
    createdAt: Date | null
  }

  export type AssetDepreciationCountAggregateOutputType = {
    id: number
    assetId: number
    periodYear: number
    periodMonth: number
    depreciationAmount: number
    accumulatedDepreciation: number
    netBookValue: number
    isPosted: number
    postedAt: number
    journalId: number
    createdAt: number
    _all: number
  }


  export type AssetDepreciationAvgAggregateInputType = {
    periodYear?: true
    periodMonth?: true
    depreciationAmount?: true
    accumulatedDepreciation?: true
    netBookValue?: true
  }

  export type AssetDepreciationSumAggregateInputType = {
    periodYear?: true
    periodMonth?: true
    depreciationAmount?: true
    accumulatedDepreciation?: true
    netBookValue?: true
  }

  export type AssetDepreciationMinAggregateInputType = {
    id?: true
    assetId?: true
    periodYear?: true
    periodMonth?: true
    depreciationAmount?: true
    accumulatedDepreciation?: true
    netBookValue?: true
    isPosted?: true
    postedAt?: true
    journalId?: true
    createdAt?: true
  }

  export type AssetDepreciationMaxAggregateInputType = {
    id?: true
    assetId?: true
    periodYear?: true
    periodMonth?: true
    depreciationAmount?: true
    accumulatedDepreciation?: true
    netBookValue?: true
    isPosted?: true
    postedAt?: true
    journalId?: true
    createdAt?: true
  }

  export type AssetDepreciationCountAggregateInputType = {
    id?: true
    assetId?: true
    periodYear?: true
    periodMonth?: true
    depreciationAmount?: true
    accumulatedDepreciation?: true
    netBookValue?: true
    isPosted?: true
    postedAt?: true
    journalId?: true
    createdAt?: true
    _all?: true
  }

  export type AssetDepreciationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetDepreciation to aggregate.
     */
    where?: AssetDepreciationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetDepreciations to fetch.
     */
    orderBy?: AssetDepreciationOrderByWithRelationInput | AssetDepreciationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetDepreciationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetDepreciations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetDepreciations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssetDepreciations
    **/
    _count?: true | AssetDepreciationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetDepreciationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetDepreciationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetDepreciationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetDepreciationMaxAggregateInputType
  }

  export type GetAssetDepreciationAggregateType<T extends AssetDepreciationAggregateArgs> = {
        [P in keyof T & keyof AggregateAssetDepreciation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssetDepreciation[P]>
      : GetScalarType<T[P], AggregateAssetDepreciation[P]>
  }




  export type AssetDepreciationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetDepreciationWhereInput
    orderBy?: AssetDepreciationOrderByWithAggregationInput | AssetDepreciationOrderByWithAggregationInput[]
    by: AssetDepreciationScalarFieldEnum[] | AssetDepreciationScalarFieldEnum
    having?: AssetDepreciationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetDepreciationCountAggregateInputType | true
    _avg?: AssetDepreciationAvgAggregateInputType
    _sum?: AssetDepreciationSumAggregateInputType
    _min?: AssetDepreciationMinAggregateInputType
    _max?: AssetDepreciationMaxAggregateInputType
  }

  export type AssetDepreciationGroupByOutputType = {
    id: string
    assetId: string
    periodYear: number
    periodMonth: number
    depreciationAmount: Decimal
    accumulatedDepreciation: Decimal
    netBookValue: Decimal
    isPosted: boolean
    postedAt: Date | null
    journalId: string | null
    createdAt: Date
    _count: AssetDepreciationCountAggregateOutputType | null
    _avg: AssetDepreciationAvgAggregateOutputType | null
    _sum: AssetDepreciationSumAggregateOutputType | null
    _min: AssetDepreciationMinAggregateOutputType | null
    _max: AssetDepreciationMaxAggregateOutputType | null
  }

  type GetAssetDepreciationGroupByPayload<T extends AssetDepreciationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetDepreciationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetDepreciationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetDepreciationGroupByOutputType[P]>
            : GetScalarType<T[P], AssetDepreciationGroupByOutputType[P]>
        }
      >
    >


  export type AssetDepreciationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetId?: boolean
    periodYear?: boolean
    periodMonth?: boolean
    depreciationAmount?: boolean
    accumulatedDepreciation?: boolean
    netBookValue?: boolean
    isPosted?: boolean
    postedAt?: boolean
    journalId?: boolean
    createdAt?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    journal?: boolean | AssetDepreciation$journalArgs<ExtArgs>
  }, ExtArgs["result"]["assetDepreciation"]>

  export type AssetDepreciationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetId?: boolean
    periodYear?: boolean
    periodMonth?: boolean
    depreciationAmount?: boolean
    accumulatedDepreciation?: boolean
    netBookValue?: boolean
    isPosted?: boolean
    postedAt?: boolean
    journalId?: boolean
    createdAt?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    journal?: boolean | AssetDepreciation$journalArgs<ExtArgs>
  }, ExtArgs["result"]["assetDepreciation"]>

  export type AssetDepreciationSelectScalar = {
    id?: boolean
    assetId?: boolean
    periodYear?: boolean
    periodMonth?: boolean
    depreciationAmount?: boolean
    accumulatedDepreciation?: boolean
    netBookValue?: boolean
    isPosted?: boolean
    postedAt?: boolean
    journalId?: boolean
    createdAt?: boolean
  }

  export type AssetDepreciationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    journal?: boolean | AssetDepreciation$journalArgs<ExtArgs>
  }
  export type AssetDepreciationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    journal?: boolean | AssetDepreciation$journalArgs<ExtArgs>
  }

  export type $AssetDepreciationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssetDepreciation"
    objects: {
      asset: Prisma.$AssetPayload<ExtArgs>
      journal: Prisma.$JournalPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      assetId: string
      periodYear: number
      periodMonth: number
      depreciationAmount: Prisma.Decimal
      accumulatedDepreciation: Prisma.Decimal
      netBookValue: Prisma.Decimal
      isPosted: boolean
      postedAt: Date | null
      journalId: string | null
      createdAt: Date
    }, ExtArgs["result"]["assetDepreciation"]>
    composites: {}
  }

  type AssetDepreciationGetPayload<S extends boolean | null | undefined | AssetDepreciationDefaultArgs> = $Result.GetResult<Prisma.$AssetDepreciationPayload, S>

  type AssetDepreciationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssetDepreciationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssetDepreciationCountAggregateInputType | true
    }

  export interface AssetDepreciationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssetDepreciation'], meta: { name: 'AssetDepreciation' } }
    /**
     * Find zero or one AssetDepreciation that matches the filter.
     * @param {AssetDepreciationFindUniqueArgs} args - Arguments to find a AssetDepreciation
     * @example
     * // Get one AssetDepreciation
     * const assetDepreciation = await prisma.assetDepreciation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetDepreciationFindUniqueArgs>(args: SelectSubset<T, AssetDepreciationFindUniqueArgs<ExtArgs>>): Prisma__AssetDepreciationClient<$Result.GetResult<Prisma.$AssetDepreciationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AssetDepreciation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssetDepreciationFindUniqueOrThrowArgs} args - Arguments to find a AssetDepreciation
     * @example
     * // Get one AssetDepreciation
     * const assetDepreciation = await prisma.assetDepreciation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetDepreciationFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetDepreciationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetDepreciationClient<$Result.GetResult<Prisma.$AssetDepreciationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AssetDepreciation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetDepreciationFindFirstArgs} args - Arguments to find a AssetDepreciation
     * @example
     * // Get one AssetDepreciation
     * const assetDepreciation = await prisma.assetDepreciation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetDepreciationFindFirstArgs>(args?: SelectSubset<T, AssetDepreciationFindFirstArgs<ExtArgs>>): Prisma__AssetDepreciationClient<$Result.GetResult<Prisma.$AssetDepreciationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AssetDepreciation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetDepreciationFindFirstOrThrowArgs} args - Arguments to find a AssetDepreciation
     * @example
     * // Get one AssetDepreciation
     * const assetDepreciation = await prisma.assetDepreciation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetDepreciationFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetDepreciationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetDepreciationClient<$Result.GetResult<Prisma.$AssetDepreciationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AssetDepreciations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetDepreciationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssetDepreciations
     * const assetDepreciations = await prisma.assetDepreciation.findMany()
     * 
     * // Get first 10 AssetDepreciations
     * const assetDepreciations = await prisma.assetDepreciation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetDepreciationWithIdOnly = await prisma.assetDepreciation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetDepreciationFindManyArgs>(args?: SelectSubset<T, AssetDepreciationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetDepreciationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AssetDepreciation.
     * @param {AssetDepreciationCreateArgs} args - Arguments to create a AssetDepreciation.
     * @example
     * // Create one AssetDepreciation
     * const AssetDepreciation = await prisma.assetDepreciation.create({
     *   data: {
     *     // ... data to create a AssetDepreciation
     *   }
     * })
     * 
     */
    create<T extends AssetDepreciationCreateArgs>(args: SelectSubset<T, AssetDepreciationCreateArgs<ExtArgs>>): Prisma__AssetDepreciationClient<$Result.GetResult<Prisma.$AssetDepreciationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AssetDepreciations.
     * @param {AssetDepreciationCreateManyArgs} args - Arguments to create many AssetDepreciations.
     * @example
     * // Create many AssetDepreciations
     * const assetDepreciation = await prisma.assetDepreciation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetDepreciationCreateManyArgs>(args?: SelectSubset<T, AssetDepreciationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssetDepreciations and returns the data saved in the database.
     * @param {AssetDepreciationCreateManyAndReturnArgs} args - Arguments to create many AssetDepreciations.
     * @example
     * // Create many AssetDepreciations
     * const assetDepreciation = await prisma.assetDepreciation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssetDepreciations and only return the `id`
     * const assetDepreciationWithIdOnly = await prisma.assetDepreciation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetDepreciationCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetDepreciationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetDepreciationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AssetDepreciation.
     * @param {AssetDepreciationDeleteArgs} args - Arguments to delete one AssetDepreciation.
     * @example
     * // Delete one AssetDepreciation
     * const AssetDepreciation = await prisma.assetDepreciation.delete({
     *   where: {
     *     // ... filter to delete one AssetDepreciation
     *   }
     * })
     * 
     */
    delete<T extends AssetDepreciationDeleteArgs>(args: SelectSubset<T, AssetDepreciationDeleteArgs<ExtArgs>>): Prisma__AssetDepreciationClient<$Result.GetResult<Prisma.$AssetDepreciationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AssetDepreciation.
     * @param {AssetDepreciationUpdateArgs} args - Arguments to update one AssetDepreciation.
     * @example
     * // Update one AssetDepreciation
     * const assetDepreciation = await prisma.assetDepreciation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetDepreciationUpdateArgs>(args: SelectSubset<T, AssetDepreciationUpdateArgs<ExtArgs>>): Prisma__AssetDepreciationClient<$Result.GetResult<Prisma.$AssetDepreciationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AssetDepreciations.
     * @param {AssetDepreciationDeleteManyArgs} args - Arguments to filter AssetDepreciations to delete.
     * @example
     * // Delete a few AssetDepreciations
     * const { count } = await prisma.assetDepreciation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetDepreciationDeleteManyArgs>(args?: SelectSubset<T, AssetDepreciationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetDepreciations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetDepreciationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssetDepreciations
     * const assetDepreciation = await prisma.assetDepreciation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetDepreciationUpdateManyArgs>(args: SelectSubset<T, AssetDepreciationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AssetDepreciation.
     * @param {AssetDepreciationUpsertArgs} args - Arguments to update or create a AssetDepreciation.
     * @example
     * // Update or create a AssetDepreciation
     * const assetDepreciation = await prisma.assetDepreciation.upsert({
     *   create: {
     *     // ... data to create a AssetDepreciation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssetDepreciation we want to update
     *   }
     * })
     */
    upsert<T extends AssetDepreciationUpsertArgs>(args: SelectSubset<T, AssetDepreciationUpsertArgs<ExtArgs>>): Prisma__AssetDepreciationClient<$Result.GetResult<Prisma.$AssetDepreciationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AssetDepreciations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetDepreciationCountArgs} args - Arguments to filter AssetDepreciations to count.
     * @example
     * // Count the number of AssetDepreciations
     * const count = await prisma.assetDepreciation.count({
     *   where: {
     *     // ... the filter for the AssetDepreciations we want to count
     *   }
     * })
    **/
    count<T extends AssetDepreciationCountArgs>(
      args?: Subset<T, AssetDepreciationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetDepreciationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssetDepreciation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetDepreciationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetDepreciationAggregateArgs>(args: Subset<T, AssetDepreciationAggregateArgs>): Prisma.PrismaPromise<GetAssetDepreciationAggregateType<T>>

    /**
     * Group by AssetDepreciation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetDepreciationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetDepreciationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetDepreciationGroupByArgs['orderBy'] }
        : { orderBy?: AssetDepreciationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetDepreciationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetDepreciationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssetDepreciation model
   */
  readonly fields: AssetDepreciationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssetDepreciation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetDepreciationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    asset<T extends AssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssetDefaultArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    journal<T extends AssetDepreciation$journalArgs<ExtArgs> = {}>(args?: Subset<T, AssetDepreciation$journalArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssetDepreciation model
   */ 
  interface AssetDepreciationFieldRefs {
    readonly id: FieldRef<"AssetDepreciation", 'String'>
    readonly assetId: FieldRef<"AssetDepreciation", 'String'>
    readonly periodYear: FieldRef<"AssetDepreciation", 'Int'>
    readonly periodMonth: FieldRef<"AssetDepreciation", 'Int'>
    readonly depreciationAmount: FieldRef<"AssetDepreciation", 'Decimal'>
    readonly accumulatedDepreciation: FieldRef<"AssetDepreciation", 'Decimal'>
    readonly netBookValue: FieldRef<"AssetDepreciation", 'Decimal'>
    readonly isPosted: FieldRef<"AssetDepreciation", 'Boolean'>
    readonly postedAt: FieldRef<"AssetDepreciation", 'DateTime'>
    readonly journalId: FieldRef<"AssetDepreciation", 'String'>
    readonly createdAt: FieldRef<"AssetDepreciation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AssetDepreciation findUnique
   */
  export type AssetDepreciationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDepreciation
     */
    select?: AssetDepreciationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDepreciationInclude<ExtArgs> | null
    /**
     * Filter, which AssetDepreciation to fetch.
     */
    where: AssetDepreciationWhereUniqueInput
  }

  /**
   * AssetDepreciation findUniqueOrThrow
   */
  export type AssetDepreciationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDepreciation
     */
    select?: AssetDepreciationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDepreciationInclude<ExtArgs> | null
    /**
     * Filter, which AssetDepreciation to fetch.
     */
    where: AssetDepreciationWhereUniqueInput
  }

  /**
   * AssetDepreciation findFirst
   */
  export type AssetDepreciationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDepreciation
     */
    select?: AssetDepreciationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDepreciationInclude<ExtArgs> | null
    /**
     * Filter, which AssetDepreciation to fetch.
     */
    where?: AssetDepreciationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetDepreciations to fetch.
     */
    orderBy?: AssetDepreciationOrderByWithRelationInput | AssetDepreciationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetDepreciations.
     */
    cursor?: AssetDepreciationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetDepreciations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetDepreciations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetDepreciations.
     */
    distinct?: AssetDepreciationScalarFieldEnum | AssetDepreciationScalarFieldEnum[]
  }

  /**
   * AssetDepreciation findFirstOrThrow
   */
  export type AssetDepreciationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDepreciation
     */
    select?: AssetDepreciationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDepreciationInclude<ExtArgs> | null
    /**
     * Filter, which AssetDepreciation to fetch.
     */
    where?: AssetDepreciationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetDepreciations to fetch.
     */
    orderBy?: AssetDepreciationOrderByWithRelationInput | AssetDepreciationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetDepreciations.
     */
    cursor?: AssetDepreciationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetDepreciations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetDepreciations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetDepreciations.
     */
    distinct?: AssetDepreciationScalarFieldEnum | AssetDepreciationScalarFieldEnum[]
  }

  /**
   * AssetDepreciation findMany
   */
  export type AssetDepreciationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDepreciation
     */
    select?: AssetDepreciationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDepreciationInclude<ExtArgs> | null
    /**
     * Filter, which AssetDepreciations to fetch.
     */
    where?: AssetDepreciationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetDepreciations to fetch.
     */
    orderBy?: AssetDepreciationOrderByWithRelationInput | AssetDepreciationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssetDepreciations.
     */
    cursor?: AssetDepreciationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetDepreciations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetDepreciations.
     */
    skip?: number
    distinct?: AssetDepreciationScalarFieldEnum | AssetDepreciationScalarFieldEnum[]
  }

  /**
   * AssetDepreciation create
   */
  export type AssetDepreciationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDepreciation
     */
    select?: AssetDepreciationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDepreciationInclude<ExtArgs> | null
    /**
     * The data needed to create a AssetDepreciation.
     */
    data: XOR<AssetDepreciationCreateInput, AssetDepreciationUncheckedCreateInput>
  }

  /**
   * AssetDepreciation createMany
   */
  export type AssetDepreciationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssetDepreciations.
     */
    data: AssetDepreciationCreateManyInput | AssetDepreciationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssetDepreciation createManyAndReturn
   */
  export type AssetDepreciationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDepreciation
     */
    select?: AssetDepreciationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AssetDepreciations.
     */
    data: AssetDepreciationCreateManyInput | AssetDepreciationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDepreciationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetDepreciation update
   */
  export type AssetDepreciationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDepreciation
     */
    select?: AssetDepreciationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDepreciationInclude<ExtArgs> | null
    /**
     * The data needed to update a AssetDepreciation.
     */
    data: XOR<AssetDepreciationUpdateInput, AssetDepreciationUncheckedUpdateInput>
    /**
     * Choose, which AssetDepreciation to update.
     */
    where: AssetDepreciationWhereUniqueInput
  }

  /**
   * AssetDepreciation updateMany
   */
  export type AssetDepreciationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssetDepreciations.
     */
    data: XOR<AssetDepreciationUpdateManyMutationInput, AssetDepreciationUncheckedUpdateManyInput>
    /**
     * Filter which AssetDepreciations to update
     */
    where?: AssetDepreciationWhereInput
  }

  /**
   * AssetDepreciation upsert
   */
  export type AssetDepreciationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDepreciation
     */
    select?: AssetDepreciationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDepreciationInclude<ExtArgs> | null
    /**
     * The filter to search for the AssetDepreciation to update in case it exists.
     */
    where: AssetDepreciationWhereUniqueInput
    /**
     * In case the AssetDepreciation found by the `where` argument doesn't exist, create a new AssetDepreciation with this data.
     */
    create: XOR<AssetDepreciationCreateInput, AssetDepreciationUncheckedCreateInput>
    /**
     * In case the AssetDepreciation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetDepreciationUpdateInput, AssetDepreciationUncheckedUpdateInput>
  }

  /**
   * AssetDepreciation delete
   */
  export type AssetDepreciationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDepreciation
     */
    select?: AssetDepreciationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDepreciationInclude<ExtArgs> | null
    /**
     * Filter which AssetDepreciation to delete.
     */
    where: AssetDepreciationWhereUniqueInput
  }

  /**
   * AssetDepreciation deleteMany
   */
  export type AssetDepreciationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetDepreciations to delete
     */
    where?: AssetDepreciationWhereInput
  }

  /**
   * AssetDepreciation.journal
   */
  export type AssetDepreciation$journalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    where?: JournalWhereInput
  }

  /**
   * AssetDepreciation without action
   */
  export type AssetDepreciationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDepreciation
     */
    select?: AssetDepreciationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDepreciationInclude<ExtArgs> | null
  }


  /**
   * Model AssetDisposal
   */

  export type AggregateAssetDisposal = {
    _count: AssetDisposalCountAggregateOutputType | null
    _avg: AssetDisposalAvgAggregateOutputType | null
    _sum: AssetDisposalSumAggregateOutputType | null
    _min: AssetDisposalMinAggregateOutputType | null
    _max: AssetDisposalMaxAggregateOutputType | null
  }

  export type AssetDisposalAvgAggregateOutputType = {
    disposalAmount: Decimal | null
    gainLoss: Decimal | null
  }

  export type AssetDisposalSumAggregateOutputType = {
    disposalAmount: Decimal | null
    gainLoss: Decimal | null
  }

  export type AssetDisposalMinAggregateOutputType = {
    id: string | null
    assetId: string | null
    disposalDate: Date | null
    disposalAmount: Decimal | null
    disposalMethod: string | null
    buyerDetails: string | null
    gainLoss: Decimal | null
    notes: string | null
    journalId: string | null
    disposedBy: string | null
    createdAt: Date | null
  }

  export type AssetDisposalMaxAggregateOutputType = {
    id: string | null
    assetId: string | null
    disposalDate: Date | null
    disposalAmount: Decimal | null
    disposalMethod: string | null
    buyerDetails: string | null
    gainLoss: Decimal | null
    notes: string | null
    journalId: string | null
    disposedBy: string | null
    createdAt: Date | null
  }

  export type AssetDisposalCountAggregateOutputType = {
    id: number
    assetId: number
    disposalDate: number
    disposalAmount: number
    disposalMethod: number
    buyerDetails: number
    gainLoss: number
    notes: number
    journalId: number
    disposedBy: number
    createdAt: number
    _all: number
  }


  export type AssetDisposalAvgAggregateInputType = {
    disposalAmount?: true
    gainLoss?: true
  }

  export type AssetDisposalSumAggregateInputType = {
    disposalAmount?: true
    gainLoss?: true
  }

  export type AssetDisposalMinAggregateInputType = {
    id?: true
    assetId?: true
    disposalDate?: true
    disposalAmount?: true
    disposalMethod?: true
    buyerDetails?: true
    gainLoss?: true
    notes?: true
    journalId?: true
    disposedBy?: true
    createdAt?: true
  }

  export type AssetDisposalMaxAggregateInputType = {
    id?: true
    assetId?: true
    disposalDate?: true
    disposalAmount?: true
    disposalMethod?: true
    buyerDetails?: true
    gainLoss?: true
    notes?: true
    journalId?: true
    disposedBy?: true
    createdAt?: true
  }

  export type AssetDisposalCountAggregateInputType = {
    id?: true
    assetId?: true
    disposalDate?: true
    disposalAmount?: true
    disposalMethod?: true
    buyerDetails?: true
    gainLoss?: true
    notes?: true
    journalId?: true
    disposedBy?: true
    createdAt?: true
    _all?: true
  }

  export type AssetDisposalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetDisposal to aggregate.
     */
    where?: AssetDisposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetDisposals to fetch.
     */
    orderBy?: AssetDisposalOrderByWithRelationInput | AssetDisposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetDisposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetDisposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetDisposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssetDisposals
    **/
    _count?: true | AssetDisposalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetDisposalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetDisposalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetDisposalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetDisposalMaxAggregateInputType
  }

  export type GetAssetDisposalAggregateType<T extends AssetDisposalAggregateArgs> = {
        [P in keyof T & keyof AggregateAssetDisposal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssetDisposal[P]>
      : GetScalarType<T[P], AggregateAssetDisposal[P]>
  }




  export type AssetDisposalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetDisposalWhereInput
    orderBy?: AssetDisposalOrderByWithAggregationInput | AssetDisposalOrderByWithAggregationInput[]
    by: AssetDisposalScalarFieldEnum[] | AssetDisposalScalarFieldEnum
    having?: AssetDisposalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetDisposalCountAggregateInputType | true
    _avg?: AssetDisposalAvgAggregateInputType
    _sum?: AssetDisposalSumAggregateInputType
    _min?: AssetDisposalMinAggregateInputType
    _max?: AssetDisposalMaxAggregateInputType
  }

  export type AssetDisposalGroupByOutputType = {
    id: string
    assetId: string
    disposalDate: Date
    disposalAmount: Decimal
    disposalMethod: string
    buyerDetails: string | null
    gainLoss: Decimal
    notes: string | null
    journalId: string | null
    disposedBy: string
    createdAt: Date
    _count: AssetDisposalCountAggregateOutputType | null
    _avg: AssetDisposalAvgAggregateOutputType | null
    _sum: AssetDisposalSumAggregateOutputType | null
    _min: AssetDisposalMinAggregateOutputType | null
    _max: AssetDisposalMaxAggregateOutputType | null
  }

  type GetAssetDisposalGroupByPayload<T extends AssetDisposalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetDisposalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetDisposalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetDisposalGroupByOutputType[P]>
            : GetScalarType<T[P], AssetDisposalGroupByOutputType[P]>
        }
      >
    >


  export type AssetDisposalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetId?: boolean
    disposalDate?: boolean
    disposalAmount?: boolean
    disposalMethod?: boolean
    buyerDetails?: boolean
    gainLoss?: boolean
    notes?: boolean
    journalId?: boolean
    disposedBy?: boolean
    createdAt?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    journal?: boolean | AssetDisposal$journalArgs<ExtArgs>
    disposedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetDisposal"]>

  export type AssetDisposalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assetId?: boolean
    disposalDate?: boolean
    disposalAmount?: boolean
    disposalMethod?: boolean
    buyerDetails?: boolean
    gainLoss?: boolean
    notes?: boolean
    journalId?: boolean
    disposedBy?: boolean
    createdAt?: boolean
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    journal?: boolean | AssetDisposal$journalArgs<ExtArgs>
    disposedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assetDisposal"]>

  export type AssetDisposalSelectScalar = {
    id?: boolean
    assetId?: boolean
    disposalDate?: boolean
    disposalAmount?: boolean
    disposalMethod?: boolean
    buyerDetails?: boolean
    gainLoss?: boolean
    notes?: boolean
    journalId?: boolean
    disposedBy?: boolean
    createdAt?: boolean
  }

  export type AssetDisposalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    journal?: boolean | AssetDisposal$journalArgs<ExtArgs>
    disposedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AssetDisposalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asset?: boolean | AssetDefaultArgs<ExtArgs>
    journal?: boolean | AssetDisposal$journalArgs<ExtArgs>
    disposedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AssetDisposalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssetDisposal"
    objects: {
      asset: Prisma.$AssetPayload<ExtArgs>
      journal: Prisma.$JournalPayload<ExtArgs> | null
      disposedByUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      assetId: string
      disposalDate: Date
      disposalAmount: Prisma.Decimal
      disposalMethod: string
      buyerDetails: string | null
      gainLoss: Prisma.Decimal
      notes: string | null
      journalId: string | null
      disposedBy: string
      createdAt: Date
    }, ExtArgs["result"]["assetDisposal"]>
    composites: {}
  }

  type AssetDisposalGetPayload<S extends boolean | null | undefined | AssetDisposalDefaultArgs> = $Result.GetResult<Prisma.$AssetDisposalPayload, S>

  type AssetDisposalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssetDisposalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssetDisposalCountAggregateInputType | true
    }

  export interface AssetDisposalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssetDisposal'], meta: { name: 'AssetDisposal' } }
    /**
     * Find zero or one AssetDisposal that matches the filter.
     * @param {AssetDisposalFindUniqueArgs} args - Arguments to find a AssetDisposal
     * @example
     * // Get one AssetDisposal
     * const assetDisposal = await prisma.assetDisposal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetDisposalFindUniqueArgs>(args: SelectSubset<T, AssetDisposalFindUniqueArgs<ExtArgs>>): Prisma__AssetDisposalClient<$Result.GetResult<Prisma.$AssetDisposalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AssetDisposal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssetDisposalFindUniqueOrThrowArgs} args - Arguments to find a AssetDisposal
     * @example
     * // Get one AssetDisposal
     * const assetDisposal = await prisma.assetDisposal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetDisposalFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetDisposalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetDisposalClient<$Result.GetResult<Prisma.$AssetDisposalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AssetDisposal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetDisposalFindFirstArgs} args - Arguments to find a AssetDisposal
     * @example
     * // Get one AssetDisposal
     * const assetDisposal = await prisma.assetDisposal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetDisposalFindFirstArgs>(args?: SelectSubset<T, AssetDisposalFindFirstArgs<ExtArgs>>): Prisma__AssetDisposalClient<$Result.GetResult<Prisma.$AssetDisposalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AssetDisposal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetDisposalFindFirstOrThrowArgs} args - Arguments to find a AssetDisposal
     * @example
     * // Get one AssetDisposal
     * const assetDisposal = await prisma.assetDisposal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetDisposalFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetDisposalFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetDisposalClient<$Result.GetResult<Prisma.$AssetDisposalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AssetDisposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetDisposalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssetDisposals
     * const assetDisposals = await prisma.assetDisposal.findMany()
     * 
     * // Get first 10 AssetDisposals
     * const assetDisposals = await prisma.assetDisposal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetDisposalWithIdOnly = await prisma.assetDisposal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetDisposalFindManyArgs>(args?: SelectSubset<T, AssetDisposalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetDisposalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AssetDisposal.
     * @param {AssetDisposalCreateArgs} args - Arguments to create a AssetDisposal.
     * @example
     * // Create one AssetDisposal
     * const AssetDisposal = await prisma.assetDisposal.create({
     *   data: {
     *     // ... data to create a AssetDisposal
     *   }
     * })
     * 
     */
    create<T extends AssetDisposalCreateArgs>(args: SelectSubset<T, AssetDisposalCreateArgs<ExtArgs>>): Prisma__AssetDisposalClient<$Result.GetResult<Prisma.$AssetDisposalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AssetDisposals.
     * @param {AssetDisposalCreateManyArgs} args - Arguments to create many AssetDisposals.
     * @example
     * // Create many AssetDisposals
     * const assetDisposal = await prisma.assetDisposal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetDisposalCreateManyArgs>(args?: SelectSubset<T, AssetDisposalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssetDisposals and returns the data saved in the database.
     * @param {AssetDisposalCreateManyAndReturnArgs} args - Arguments to create many AssetDisposals.
     * @example
     * // Create many AssetDisposals
     * const assetDisposal = await prisma.assetDisposal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssetDisposals and only return the `id`
     * const assetDisposalWithIdOnly = await prisma.assetDisposal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetDisposalCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetDisposalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetDisposalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AssetDisposal.
     * @param {AssetDisposalDeleteArgs} args - Arguments to delete one AssetDisposal.
     * @example
     * // Delete one AssetDisposal
     * const AssetDisposal = await prisma.assetDisposal.delete({
     *   where: {
     *     // ... filter to delete one AssetDisposal
     *   }
     * })
     * 
     */
    delete<T extends AssetDisposalDeleteArgs>(args: SelectSubset<T, AssetDisposalDeleteArgs<ExtArgs>>): Prisma__AssetDisposalClient<$Result.GetResult<Prisma.$AssetDisposalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AssetDisposal.
     * @param {AssetDisposalUpdateArgs} args - Arguments to update one AssetDisposal.
     * @example
     * // Update one AssetDisposal
     * const assetDisposal = await prisma.assetDisposal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetDisposalUpdateArgs>(args: SelectSubset<T, AssetDisposalUpdateArgs<ExtArgs>>): Prisma__AssetDisposalClient<$Result.GetResult<Prisma.$AssetDisposalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AssetDisposals.
     * @param {AssetDisposalDeleteManyArgs} args - Arguments to filter AssetDisposals to delete.
     * @example
     * // Delete a few AssetDisposals
     * const { count } = await prisma.assetDisposal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetDisposalDeleteManyArgs>(args?: SelectSubset<T, AssetDisposalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetDisposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetDisposalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssetDisposals
     * const assetDisposal = await prisma.assetDisposal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetDisposalUpdateManyArgs>(args: SelectSubset<T, AssetDisposalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AssetDisposal.
     * @param {AssetDisposalUpsertArgs} args - Arguments to update or create a AssetDisposal.
     * @example
     * // Update or create a AssetDisposal
     * const assetDisposal = await prisma.assetDisposal.upsert({
     *   create: {
     *     // ... data to create a AssetDisposal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssetDisposal we want to update
     *   }
     * })
     */
    upsert<T extends AssetDisposalUpsertArgs>(args: SelectSubset<T, AssetDisposalUpsertArgs<ExtArgs>>): Prisma__AssetDisposalClient<$Result.GetResult<Prisma.$AssetDisposalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AssetDisposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetDisposalCountArgs} args - Arguments to filter AssetDisposals to count.
     * @example
     * // Count the number of AssetDisposals
     * const count = await prisma.assetDisposal.count({
     *   where: {
     *     // ... the filter for the AssetDisposals we want to count
     *   }
     * })
    **/
    count<T extends AssetDisposalCountArgs>(
      args?: Subset<T, AssetDisposalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetDisposalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssetDisposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetDisposalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetDisposalAggregateArgs>(args: Subset<T, AssetDisposalAggregateArgs>): Prisma.PrismaPromise<GetAssetDisposalAggregateType<T>>

    /**
     * Group by AssetDisposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetDisposalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetDisposalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetDisposalGroupByArgs['orderBy'] }
        : { orderBy?: AssetDisposalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetDisposalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetDisposalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssetDisposal model
   */
  readonly fields: AssetDisposalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssetDisposal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetDisposalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    asset<T extends AssetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssetDefaultArgs<ExtArgs>>): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    journal<T extends AssetDisposal$journalArgs<ExtArgs> = {}>(args?: Subset<T, AssetDisposal$journalArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    disposedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssetDisposal model
   */ 
  interface AssetDisposalFieldRefs {
    readonly id: FieldRef<"AssetDisposal", 'String'>
    readonly assetId: FieldRef<"AssetDisposal", 'String'>
    readonly disposalDate: FieldRef<"AssetDisposal", 'DateTime'>
    readonly disposalAmount: FieldRef<"AssetDisposal", 'Decimal'>
    readonly disposalMethod: FieldRef<"AssetDisposal", 'String'>
    readonly buyerDetails: FieldRef<"AssetDisposal", 'String'>
    readonly gainLoss: FieldRef<"AssetDisposal", 'Decimal'>
    readonly notes: FieldRef<"AssetDisposal", 'String'>
    readonly journalId: FieldRef<"AssetDisposal", 'String'>
    readonly disposedBy: FieldRef<"AssetDisposal", 'String'>
    readonly createdAt: FieldRef<"AssetDisposal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AssetDisposal findUnique
   */
  export type AssetDisposalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDisposal
     */
    select?: AssetDisposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDisposalInclude<ExtArgs> | null
    /**
     * Filter, which AssetDisposal to fetch.
     */
    where: AssetDisposalWhereUniqueInput
  }

  /**
   * AssetDisposal findUniqueOrThrow
   */
  export type AssetDisposalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDisposal
     */
    select?: AssetDisposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDisposalInclude<ExtArgs> | null
    /**
     * Filter, which AssetDisposal to fetch.
     */
    where: AssetDisposalWhereUniqueInput
  }

  /**
   * AssetDisposal findFirst
   */
  export type AssetDisposalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDisposal
     */
    select?: AssetDisposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDisposalInclude<ExtArgs> | null
    /**
     * Filter, which AssetDisposal to fetch.
     */
    where?: AssetDisposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetDisposals to fetch.
     */
    orderBy?: AssetDisposalOrderByWithRelationInput | AssetDisposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetDisposals.
     */
    cursor?: AssetDisposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetDisposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetDisposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetDisposals.
     */
    distinct?: AssetDisposalScalarFieldEnum | AssetDisposalScalarFieldEnum[]
  }

  /**
   * AssetDisposal findFirstOrThrow
   */
  export type AssetDisposalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDisposal
     */
    select?: AssetDisposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDisposalInclude<ExtArgs> | null
    /**
     * Filter, which AssetDisposal to fetch.
     */
    where?: AssetDisposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetDisposals to fetch.
     */
    orderBy?: AssetDisposalOrderByWithRelationInput | AssetDisposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetDisposals.
     */
    cursor?: AssetDisposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetDisposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetDisposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetDisposals.
     */
    distinct?: AssetDisposalScalarFieldEnum | AssetDisposalScalarFieldEnum[]
  }

  /**
   * AssetDisposal findMany
   */
  export type AssetDisposalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDisposal
     */
    select?: AssetDisposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDisposalInclude<ExtArgs> | null
    /**
     * Filter, which AssetDisposals to fetch.
     */
    where?: AssetDisposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetDisposals to fetch.
     */
    orderBy?: AssetDisposalOrderByWithRelationInput | AssetDisposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssetDisposals.
     */
    cursor?: AssetDisposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetDisposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetDisposals.
     */
    skip?: number
    distinct?: AssetDisposalScalarFieldEnum | AssetDisposalScalarFieldEnum[]
  }

  /**
   * AssetDisposal create
   */
  export type AssetDisposalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDisposal
     */
    select?: AssetDisposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDisposalInclude<ExtArgs> | null
    /**
     * The data needed to create a AssetDisposal.
     */
    data: XOR<AssetDisposalCreateInput, AssetDisposalUncheckedCreateInput>
  }

  /**
   * AssetDisposal createMany
   */
  export type AssetDisposalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssetDisposals.
     */
    data: AssetDisposalCreateManyInput | AssetDisposalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssetDisposal createManyAndReturn
   */
  export type AssetDisposalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDisposal
     */
    select?: AssetDisposalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AssetDisposals.
     */
    data: AssetDisposalCreateManyInput | AssetDisposalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDisposalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetDisposal update
   */
  export type AssetDisposalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDisposal
     */
    select?: AssetDisposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDisposalInclude<ExtArgs> | null
    /**
     * The data needed to update a AssetDisposal.
     */
    data: XOR<AssetDisposalUpdateInput, AssetDisposalUncheckedUpdateInput>
    /**
     * Choose, which AssetDisposal to update.
     */
    where: AssetDisposalWhereUniqueInput
  }

  /**
   * AssetDisposal updateMany
   */
  export type AssetDisposalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssetDisposals.
     */
    data: XOR<AssetDisposalUpdateManyMutationInput, AssetDisposalUncheckedUpdateManyInput>
    /**
     * Filter which AssetDisposals to update
     */
    where?: AssetDisposalWhereInput
  }

  /**
   * AssetDisposal upsert
   */
  export type AssetDisposalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDisposal
     */
    select?: AssetDisposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDisposalInclude<ExtArgs> | null
    /**
     * The filter to search for the AssetDisposal to update in case it exists.
     */
    where: AssetDisposalWhereUniqueInput
    /**
     * In case the AssetDisposal found by the `where` argument doesn't exist, create a new AssetDisposal with this data.
     */
    create: XOR<AssetDisposalCreateInput, AssetDisposalUncheckedCreateInput>
    /**
     * In case the AssetDisposal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetDisposalUpdateInput, AssetDisposalUncheckedUpdateInput>
  }

  /**
   * AssetDisposal delete
   */
  export type AssetDisposalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDisposal
     */
    select?: AssetDisposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDisposalInclude<ExtArgs> | null
    /**
     * Filter which AssetDisposal to delete.
     */
    where: AssetDisposalWhereUniqueInput
  }

  /**
   * AssetDisposal deleteMany
   */
  export type AssetDisposalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetDisposals to delete
     */
    where?: AssetDisposalWhereInput
  }

  /**
   * AssetDisposal.journal
   */
  export type AssetDisposal$journalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    where?: JournalWhereInput
  }

  /**
   * AssetDisposal without action
   */
  export type AssetDisposalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetDisposal
     */
    select?: AssetDisposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetDisposalInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    status: 'status',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    resource: 'resource',
    action: 'action',
    description: 'description'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleId: 'roleId'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    permissionId: 'permissionId'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    baseCurrency: 'baseCurrency',
    timezone: 'timezone',
    address: 'address',
    phone: 'phone',
    email: 'email',
    createdAt: 'createdAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    address: 'address',
    city: 'city',
    state: 'state',
    country: 'country',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const WarehouseScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    locationId: 'locationId',
    address: 'address',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type WarehouseScalarFieldEnum = (typeof WarehouseScalarFieldEnum)[keyof typeof WarehouseScalarFieldEnum]


  export const BinScalarFieldEnum: {
    id: 'id',
    warehouseId: 'warehouseId',
    code: 'code',
    name: 'name'
  };

  export type BinScalarFieldEnum = (typeof BinScalarFieldEnum)[keyof typeof BinScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    name: 'name',
    description: 'description',
    type: 'type',
    uom: 'uom',
    costingMethod: 'costingMethod',
    standardCost: 'standardCost',
    sellingPriceOrdinary: 'sellingPriceOrdinary',
    sellingPriceBulk: 'sellingPriceBulk',
    sellingPriceWIC: 'sellingPriceWIC',
    taxCode: 'taxCode',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const BomScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    version: 'version',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BomScalarFieldEnum = (typeof BomScalarFieldEnum)[keyof typeof BomScalarFieldEnum]


  export const BomLineScalarFieldEnum: {
    id: 'id',
    bomId: 'bomId',
    componentItemId: 'componentItemId',
    qtyPer: 'qtyPer',
    scrapPercent: 'scrapPercent'
  };

  export type BomLineScalarFieldEnum = (typeof BomLineScalarFieldEnum)[keyof typeof BomLineScalarFieldEnum]


  export const InventoryBatchScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    warehouseId: 'warehouseId',
    binId: 'binId',
    qtyOnHand: 'qtyOnHand',
    unitCost: 'unitCost',
    receivedAt: 'receivedAt'
  };

  export type InventoryBatchScalarFieldEnum = (typeof InventoryBatchScalarFieldEnum)[keyof typeof InventoryBatchScalarFieldEnum]


  export const InventoryLedgerScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    warehouseId: 'warehouseId',
    refType: 'refType',
    refId: 'refId',
    direction: 'direction',
    qty: 'qty',
    unitCost: 'unitCost',
    value: 'value',
    runningQty: 'runningQty',
    runningValue: 'runningValue',
    runningAvgCost: 'runningAvgCost',
    batchId: 'batchId',
    userId: 'userId',
    postedAt: 'postedAt'
  };

  export type InventoryLedgerScalarFieldEnum = (typeof InventoryLedgerScalarFieldEnum)[keyof typeof InventoryLedgerScalarFieldEnum]


  export const ProductionOrderScalarFieldEnum: {
    id: 'id',
    orderNo: 'orderNo',
    itemId: 'itemId',
    qtyTarget: 'qtyTarget',
    qtyProduced: 'qtyProduced',
    status: 'status',
    warehouseId: 'warehouseId',
    bomId: 'bomId',
    approvalStatus: 'approvalStatus',
    approvalRequestId: 'approvalRequestId',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    startedAt: 'startedAt',
    finishedAt: 'finishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductionOrderScalarFieldEnum = (typeof ProductionOrderScalarFieldEnum)[keyof typeof ProductionOrderScalarFieldEnum]


  export const WipLedgerScalarFieldEnum: {
    id: 'id',
    productionOrderId: 'productionOrderId',
    type: 'type',
    amount: 'amount',
    note: 'note',
    postedAt: 'postedAt'
  };

  export type WipLedgerScalarFieldEnum = (typeof WipLedgerScalarFieldEnum)[keyof typeof WipLedgerScalarFieldEnum]


  export const LaborTimeScalarFieldEnum: {
    id: 'id',
    productionOrderId: 'productionOrderId',
    hours: 'hours',
    rate: 'rate',
    amount: 'amount',
    employeeName: 'employeeName'
  };

  export type LaborTimeScalarFieldEnum = (typeof LaborTimeScalarFieldEnum)[keyof typeof LaborTimeScalarFieldEnum]


  export const VendorScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    address: 'address',
    phone: 'phone',
    email: 'email',
    paymentTerms: 'paymentTerms',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    address: 'address',
    phone: 'phone',
    email: 'email',
    creditLimit: 'creditLimit',
    CustomerGroup: 'CustomerGroup',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const PurchaseScalarFieldEnum: {
    id: 'id',
    orderNo: 'orderNo',
    vendorId: 'vendorId',
    orderDate: 'orderDate',
    status: 'status',
    totalAmount: 'totalAmount',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseScalarFieldEnum = (typeof PurchaseScalarFieldEnum)[keyof typeof PurchaseScalarFieldEnum]


  export const PurchaseLineScalarFieldEnum: {
    id: 'id',
    purchaseId: 'purchaseId',
    itemId: 'itemId',
    qty: 'qty',
    unitPrice: 'unitPrice',
    lineTotal: 'lineTotal'
  };

  export type PurchaseLineScalarFieldEnum = (typeof PurchaseLineScalarFieldEnum)[keyof typeof PurchaseLineScalarFieldEnum]


  export const SaleScalarFieldEnum: {
    id: 'id',
    orderNo: 'orderNo',
    customerId: 'customerId',
    orderDate: 'orderDate',
    status: 'status',
    totalAmount: 'totalAmount',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SaleScalarFieldEnum = (typeof SaleScalarFieldEnum)[keyof typeof SaleScalarFieldEnum]


  export const SaleLineScalarFieldEnum: {
    id: 'id',
    saleId: 'saleId',
    itemId: 'itemId',
    qty: 'qty',
    unitPrice: 'unitPrice',
    lineTotal: 'lineTotal'
  };

  export type SaleLineScalarFieldEnum = (typeof SaleLineScalarFieldEnum)[keyof typeof SaleLineScalarFieldEnum]


  export const ChartOfAccountScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    accountType: 'accountType',
    parentId: 'parentId',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type ChartOfAccountScalarFieldEnum = (typeof ChartOfAccountScalarFieldEnum)[keyof typeof ChartOfAccountScalarFieldEnum]


  export const JournalScalarFieldEnum: {
    id: 'id',
    journalNo: 'journalNo',
    date: 'date',
    memo: 'memo',
    postedBy: 'postedBy',
    postedAt: 'postedAt'
  };

  export type JournalScalarFieldEnum = (typeof JournalScalarFieldEnum)[keyof typeof JournalScalarFieldEnum]


  export const JournalLineScalarFieldEnum: {
    id: 'id',
    journalId: 'journalId',
    accountId: 'accountId',
    debit: 'debit',
    credit: 'credit',
    refType: 'refType',
    refId: 'refId'
  };

  export type JournalLineScalarFieldEnum = (typeof JournalLineScalarFieldEnum)[keyof typeof JournalLineScalarFieldEnum]


  export const PolicyScalarFieldEnum: {
    id: 'id',
    key: 'key',
    valueJson: 'valueJson',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PolicyScalarFieldEnum = (typeof PolicyScalarFieldEnum)[keyof typeof PolicyScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    beforeJson: 'beforeJson',
    afterJson: 'afterJson',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const CashAccountScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    accountType: 'accountType',
    accountNumber: 'accountNumber',
    glAccountId: 'glAccountId',
    bankName: 'bankName',
    balance: 'balance',
    isActive: 'isActive',
    createdAt: 'createdAt',
    chartOfAccountId: 'chartOfAccountId'
  };

  export type CashAccountScalarFieldEnum = (typeof CashAccountScalarFieldEnum)[keyof typeof CashAccountScalarFieldEnum]


  export const CashTransactionScalarFieldEnum: {
    id: 'id',
    transactionNo: 'transactionNo',
    cashAccountId: 'cashAccountId',
    glAccountId: 'glAccountId',
    contraAccountId: 'contraAccountId',
    transactionType: 'transactionType',
    amount: 'amount',
    description: 'description',
    refType: 'refType',
    refId: 'refId',
    transactionDate: 'transactionDate',
    isReconciled: 'isReconciled',
    reconciledAt: 'reconciledAt',
    userId: 'userId',
    createdAt: 'createdAt',
    reference: 'reference'
  };

  export type CashTransactionScalarFieldEnum = (typeof CashTransactionScalarFieldEnum)[keyof typeof CashTransactionScalarFieldEnum]


  export const SalesReceiptScalarFieldEnum: {
    id: 'id',
    receiptNo: 'receiptNo',
    saleId: 'saleId',
    customerId: 'customerId',
    cashAccountId: 'cashAccountId',
    amountReceived: 'amountReceived',
    receiptDate: 'receiptDate',
    reference: 'reference',
    notes: 'notes',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type SalesReceiptScalarFieldEnum = (typeof SalesReceiptScalarFieldEnum)[keyof typeof SalesReceiptScalarFieldEnum]


  export const PurchasePaymentScalarFieldEnum: {
    id: 'id',
    paymentNo: 'paymentNo',
    purchaseId: 'purchaseId',
    vendorId: 'vendorId',
    cashAccountId: 'cashAccountId',
    amountPaid: 'amountPaid',
    paymentDate: 'paymentDate',
    reference: 'reference',
    notes: 'notes',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type PurchasePaymentScalarFieldEnum = (typeof PurchasePaymentScalarFieldEnum)[keyof typeof PurchasePaymentScalarFieldEnum]


  export const SystemSettingScalarFieldEnum: {
    id: 'id',
    category: 'category',
    key: 'key',
    value: 'value',
    dataType: 'dataType',
    description: 'description',
    updatedBy: 'updatedBy',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type SystemSettingScalarFieldEnum = (typeof SystemSettingScalarFieldEnum)[keyof typeof SystemSettingScalarFieldEnum]


  export const FiscalYearScalarFieldEnum: {
    id: 'id',
    year: 'year',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FiscalYearScalarFieldEnum = (typeof FiscalYearScalarFieldEnum)[keyof typeof FiscalYearScalarFieldEnum]


  export const FiscalPeriodScalarFieldEnum: {
    id: 'id',
    fiscalYearId: 'fiscalYearId',
    periodNumber: 'periodNumber',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    isClosed: 'isClosed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FiscalPeriodScalarFieldEnum = (typeof FiscalPeriodScalarFieldEnum)[keyof typeof FiscalPeriodScalarFieldEnum]


  export const ApprovalWorkflowScalarFieldEnum: {
    id: 'id',
    name: 'name',
    entity: 'entity',
    minAmount: 'minAmount',
    maxAmount: 'maxAmount',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApprovalWorkflowScalarFieldEnum = (typeof ApprovalWorkflowScalarFieldEnum)[keyof typeof ApprovalWorkflowScalarFieldEnum]


  export const ApprovalStepScalarFieldEnum: {
    id: 'id',
    workflowId: 'workflowId',
    stepOrder: 'stepOrder',
    name: 'name',
    roleId: 'roleId',
    isRequired: 'isRequired',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApprovalStepScalarFieldEnum = (typeof ApprovalStepScalarFieldEnum)[keyof typeof ApprovalStepScalarFieldEnum]


  export const ApprovalRequestScalarFieldEnum: {
    id: 'id',
    workflowId: 'workflowId',
    entityType: 'entityType',
    entityId: 'entityId',
    requestedBy: 'requestedBy',
    currentStepId: 'currentStepId',
    status: 'status',
    requestedAt: 'requestedAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApprovalRequestScalarFieldEnum = (typeof ApprovalRequestScalarFieldEnum)[keyof typeof ApprovalRequestScalarFieldEnum]


  export const ApprovalActionScalarFieldEnum: {
    id: 'id',
    requestId: 'requestId',
    stepId: 'stepId',
    userId: 'userId',
    action: 'action',
    comments: 'comments',
    actionDate: 'actionDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApprovalActionScalarFieldEnum = (typeof ApprovalActionScalarFieldEnum)[keyof typeof ApprovalActionScalarFieldEnum]


  export const AssetCategoryScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    depreciationMethod: 'depreciationMethod',
    usefulLife: 'usefulLife',
    residualValue: 'residualValue',
    glAssetAccountId: 'glAssetAccountId',
    glDepreciationAccountId: 'glDepreciationAccountId',
    glAccumulatedDepreciationAccountId: 'glAccumulatedDepreciationAccountId',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type AssetCategoryScalarFieldEnum = (typeof AssetCategoryScalarFieldEnum)[keyof typeof AssetCategoryScalarFieldEnum]


  export const AssetScalarFieldEnum: {
    id: 'id',
    assetNo: 'assetNo',
    name: 'name',
    description: 'description',
    categoryId: 'categoryId',
    acquisitionDate: 'acquisitionDate',
    acquisitionCost: 'acquisitionCost',
    residualValue: 'residualValue',
    usefulLife: 'usefulLife',
    depreciationMethod: 'depreciationMethod',
    locationId: 'locationId',
    serialNumber: 'serialNumber',
    supplier: 'supplier',
    purchaseOrderId: 'purchaseOrderId',
    status: 'status',
    disposalDate: 'disposalDate',
    disposalAmount: 'disposalAmount',
    disposalMethod: 'disposalMethod',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    vendorId: 'vendorId'
  };

  export type AssetScalarFieldEnum = (typeof AssetScalarFieldEnum)[keyof typeof AssetScalarFieldEnum]


  export const AssetDepreciationScalarFieldEnum: {
    id: 'id',
    assetId: 'assetId',
    periodYear: 'periodYear',
    periodMonth: 'periodMonth',
    depreciationAmount: 'depreciationAmount',
    accumulatedDepreciation: 'accumulatedDepreciation',
    netBookValue: 'netBookValue',
    isPosted: 'isPosted',
    postedAt: 'postedAt',
    journalId: 'journalId',
    createdAt: 'createdAt'
  };

  export type AssetDepreciationScalarFieldEnum = (typeof AssetDepreciationScalarFieldEnum)[keyof typeof AssetDepreciationScalarFieldEnum]


  export const AssetDisposalScalarFieldEnum: {
    id: 'id',
    assetId: 'assetId',
    disposalDate: 'disposalDate',
    disposalAmount: 'disposalAmount',
    disposalMethod: 'disposalMethod',
    buyerDetails: 'buyerDetails',
    gainLoss: 'gainLoss',
    notes: 'notes',
    journalId: 'journalId',
    disposedBy: 'disposedBy',
    createdAt: 'createdAt'
  };

  export type AssetDisposalScalarFieldEnum = (typeof AssetDisposalScalarFieldEnum)[keyof typeof AssetDisposalScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ItemType'
   */
  export type EnumItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemType'>
    


  /**
   * Reference to a field of type 'ItemType[]'
   */
  export type ListEnumItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemType[]'>
    


  /**
   * Reference to a field of type 'CostingMethod'
   */
  export type EnumCostingMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CostingMethod'>
    


  /**
   * Reference to a field of type 'CostingMethod[]'
   */
  export type ListEnumCostingMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CostingMethod[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'LedgerDirection'
   */
  export type EnumLedgerDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerDirection'>
    


  /**
   * Reference to a field of type 'LedgerDirection[]'
   */
  export type ListEnumLedgerDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerDirection[]'>
    


  /**
   * Reference to a field of type 'ProductionOrderStatus'
   */
  export type EnumProductionOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductionOrderStatus'>
    


  /**
   * Reference to a field of type 'ProductionOrderStatus[]'
   */
  export type ListEnumProductionOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductionOrderStatus[]'>
    


  /**
   * Reference to a field of type 'WipLedgerType'
   */
  export type EnumWipLedgerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WipLedgerType'>
    


  /**
   * Reference to a field of type 'WipLedgerType[]'
   */
  export type ListEnumWipLedgerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WipLedgerType[]'>
    


  /**
   * Reference to a field of type 'PurchaseStatus'
   */
  export type EnumPurchaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseStatus'>
    


  /**
   * Reference to a field of type 'PurchaseStatus[]'
   */
  export type ListEnumPurchaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseStatus[]'>
    


  /**
   * Reference to a field of type 'SaleStatus'
   */
  export type EnumSaleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SaleStatus'>
    


  /**
   * Reference to a field of type 'SaleStatus[]'
   */
  export type ListEnumSaleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SaleStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    status?: StringFilter<"User"> | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    userRoles?: UserRoleListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    journals?: JournalListRelationFilter
    inventoryLedger?: InventoryLedgerListRelationFilter
    cashTransactions?: CashTransactionListRelationFilter
    salesReceipts?: SalesReceiptListRelationFilter
    purchasePayments?: PurchasePaymentListRelationFilter
    SystemSetting?: SystemSettingListRelationFilter
    ApprovalRequest?: ApprovalRequestListRelationFilter
    ApprovalAction?: ApprovalActionListRelationFilter
    assetsCreated?: AssetListRelationFilter
    assetDisposals?: AssetDisposalListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    status?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userRoles?: UserRoleOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    journals?: JournalOrderByRelationAggregateInput
    inventoryLedger?: InventoryLedgerOrderByRelationAggregateInput
    cashTransactions?: CashTransactionOrderByRelationAggregateInput
    salesReceipts?: SalesReceiptOrderByRelationAggregateInput
    purchasePayments?: PurchasePaymentOrderByRelationAggregateInput
    SystemSetting?: SystemSettingOrderByRelationAggregateInput
    ApprovalRequest?: ApprovalRequestOrderByRelationAggregateInput
    ApprovalAction?: ApprovalActionOrderByRelationAggregateInput
    assetsCreated?: AssetOrderByRelationAggregateInput
    assetDisposals?: AssetDisposalOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    status?: StringFilter<"User"> | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    userRoles?: UserRoleListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    journals?: JournalListRelationFilter
    inventoryLedger?: InventoryLedgerListRelationFilter
    cashTransactions?: CashTransactionListRelationFilter
    salesReceipts?: SalesReceiptListRelationFilter
    purchasePayments?: PurchasePaymentListRelationFilter
    SystemSetting?: SystemSettingListRelationFilter
    ApprovalRequest?: ApprovalRequestListRelationFilter
    ApprovalAction?: ApprovalActionListRelationFilter
    assetsCreated?: AssetListRelationFilter
    assetDisposals?: AssetDisposalListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    status?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    status?: StringWithAggregatesFilter<"User"> | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    rolePermissions?: RolePermissionListRelationFilter
    userRoles?: UserRoleListRelationFilter
    ApprovalStep?: ApprovalStepListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    rolePermissions?: RolePermissionOrderByRelationAggregateInput
    userRoles?: UserRoleOrderByRelationAggregateInput
    ApprovalStep?: ApprovalStepOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    rolePermissions?: RolePermissionListRelationFilter
    userRoles?: UserRoleListRelationFilter
    ApprovalStep?: ApprovalStepListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    name?: StringFilter<"Permission"> | string
    resource?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    rolePermissions?: RolePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    description?: SortOrderInput | SortOrder
    rolePermissions?: RolePermissionOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    resource?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    rolePermissions?: RolePermissionListRelationFilter
  }, "id" | "name">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permission"> | string
    name?: StringWithAggregatesFilter<"Permission"> | string
    resource?: StringWithAggregatesFilter<"Permission"> | string
    action?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    id?: StringFilter<"UserRole"> | string
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    user?: UserOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_roleId?: UserRoleUserIdRoleIdCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }, "id" | "userId_roleId">

  export type UserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserRole"> | string
    userId?: StringWithAggregatesFilter<"UserRole"> | string
    roleId?: StringWithAggregatesFilter<"UserRole"> | string
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    id?: StringFilter<"RolePermission"> | string
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionRelationFilter, PermissionWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    role?: RoleOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roleId_permissionId?: RolePermissionRoleIdPermissionIdCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionRelationFilter, PermissionWhereInput>
  }, "id" | "roleId_permissionId">

  export type RolePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RolePermission"> | string
    roleId?: StringWithAggregatesFilter<"RolePermission"> | string
    permissionId?: StringWithAggregatesFilter<"RolePermission"> | string
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    baseCurrency?: StringFilter<"Company"> | string
    timezone?: StringFilter<"Company"> | string
    address?: StringNullableFilter<"Company"> | string | null
    phone?: StringNullableFilter<"Company"> | string | null
    email?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    baseCurrency?: SortOrder
    timezone?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    baseCurrency?: StringFilter<"Company"> | string
    timezone?: StringFilter<"Company"> | string
    address?: StringNullableFilter<"Company"> | string | null
    phone?: StringNullableFilter<"Company"> | string | null
    email?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
  }, "id">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    baseCurrency?: SortOrder
    timezone?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    baseCurrency?: StringWithAggregatesFilter<"Company"> | string
    timezone?: StringWithAggregatesFilter<"Company"> | string
    address?: StringNullableWithAggregatesFilter<"Company"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Company"> | string | null
    email?: StringNullableWithAggregatesFilter<"Company"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    code?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    address?: StringNullableFilter<"Location"> | string | null
    city?: StringNullableFilter<"Location"> | string | null
    state?: StringNullableFilter<"Location"> | string | null
    country?: StringFilter<"Location"> | string
    isActive?: BoolFilter<"Location"> | boolean
    createdAt?: DateTimeFilter<"Location"> | Date | string
    warehouses?: WarehouseListRelationFilter
    assets?: AssetListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    warehouses?: WarehouseOrderByRelationAggregateInput
    assets?: AssetOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    name?: StringFilter<"Location"> | string
    address?: StringNullableFilter<"Location"> | string | null
    city?: StringNullableFilter<"Location"> | string | null
    state?: StringNullableFilter<"Location"> | string | null
    country?: StringFilter<"Location"> | string
    isActive?: BoolFilter<"Location"> | boolean
    createdAt?: DateTimeFilter<"Location"> | Date | string
    warehouses?: WarehouseListRelationFilter
    assets?: AssetListRelationFilter
  }, "id" | "code">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    code?: StringWithAggregatesFilter<"Location"> | string
    name?: StringWithAggregatesFilter<"Location"> | string
    address?: StringNullableWithAggregatesFilter<"Location"> | string | null
    city?: StringNullableWithAggregatesFilter<"Location"> | string | null
    state?: StringNullableWithAggregatesFilter<"Location"> | string | null
    country?: StringWithAggregatesFilter<"Location"> | string
    isActive?: BoolWithAggregatesFilter<"Location"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
  }

  export type WarehouseWhereInput = {
    AND?: WarehouseWhereInput | WarehouseWhereInput[]
    OR?: WarehouseWhereInput[]
    NOT?: WarehouseWhereInput | WarehouseWhereInput[]
    id?: StringFilter<"Warehouse"> | string
    code?: StringFilter<"Warehouse"> | string
    name?: StringFilter<"Warehouse"> | string
    locationId?: StringFilter<"Warehouse"> | string
    address?: StringNullableFilter<"Warehouse"> | string | null
    isActive?: BoolFilter<"Warehouse"> | boolean
    createdAt?: DateTimeFilter<"Warehouse"> | Date | string
    location?: XOR<LocationRelationFilter, LocationWhereInput>
    bins?: BinListRelationFilter
    inventoryBatches?: InventoryBatchListRelationFilter
    inventoryLedger?: InventoryLedgerListRelationFilter
    productionOrders?: ProductionOrderListRelationFilter
  }

  export type WarehouseOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    locationId?: SortOrder
    address?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    location?: LocationOrderByWithRelationInput
    bins?: BinOrderByRelationAggregateInput
    inventoryBatches?: InventoryBatchOrderByRelationAggregateInput
    inventoryLedger?: InventoryLedgerOrderByRelationAggregateInput
    productionOrders?: ProductionOrderOrderByRelationAggregateInput
  }

  export type WarehouseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: WarehouseWhereInput | WarehouseWhereInput[]
    OR?: WarehouseWhereInput[]
    NOT?: WarehouseWhereInput | WarehouseWhereInput[]
    name?: StringFilter<"Warehouse"> | string
    locationId?: StringFilter<"Warehouse"> | string
    address?: StringNullableFilter<"Warehouse"> | string | null
    isActive?: BoolFilter<"Warehouse"> | boolean
    createdAt?: DateTimeFilter<"Warehouse"> | Date | string
    location?: XOR<LocationRelationFilter, LocationWhereInput>
    bins?: BinListRelationFilter
    inventoryBatches?: InventoryBatchListRelationFilter
    inventoryLedger?: InventoryLedgerListRelationFilter
    productionOrders?: ProductionOrderListRelationFilter
  }, "id" | "code">

  export type WarehouseOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    locationId?: SortOrder
    address?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: WarehouseCountOrderByAggregateInput
    _max?: WarehouseMaxOrderByAggregateInput
    _min?: WarehouseMinOrderByAggregateInput
  }

  export type WarehouseScalarWhereWithAggregatesInput = {
    AND?: WarehouseScalarWhereWithAggregatesInput | WarehouseScalarWhereWithAggregatesInput[]
    OR?: WarehouseScalarWhereWithAggregatesInput[]
    NOT?: WarehouseScalarWhereWithAggregatesInput | WarehouseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Warehouse"> | string
    code?: StringWithAggregatesFilter<"Warehouse"> | string
    name?: StringWithAggregatesFilter<"Warehouse"> | string
    locationId?: StringWithAggregatesFilter<"Warehouse"> | string
    address?: StringNullableWithAggregatesFilter<"Warehouse"> | string | null
    isActive?: BoolWithAggregatesFilter<"Warehouse"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Warehouse"> | Date | string
  }

  export type BinWhereInput = {
    AND?: BinWhereInput | BinWhereInput[]
    OR?: BinWhereInput[]
    NOT?: BinWhereInput | BinWhereInput[]
    id?: StringFilter<"Bin"> | string
    warehouseId?: StringFilter<"Bin"> | string
    code?: StringFilter<"Bin"> | string
    name?: StringNullableFilter<"Bin"> | string | null
    warehouse?: XOR<WarehouseRelationFilter, WarehouseWhereInput>
    inventoryBatches?: InventoryBatchListRelationFilter
  }

  export type BinOrderByWithRelationInput = {
    id?: SortOrder
    warehouseId?: SortOrder
    code?: SortOrder
    name?: SortOrderInput | SortOrder
    warehouse?: WarehouseOrderByWithRelationInput
    inventoryBatches?: InventoryBatchOrderByRelationAggregateInput
  }

  export type BinWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    warehouseId_code?: BinWarehouseIdCodeCompoundUniqueInput
    AND?: BinWhereInput | BinWhereInput[]
    OR?: BinWhereInput[]
    NOT?: BinWhereInput | BinWhereInput[]
    warehouseId?: StringFilter<"Bin"> | string
    code?: StringFilter<"Bin"> | string
    name?: StringNullableFilter<"Bin"> | string | null
    warehouse?: XOR<WarehouseRelationFilter, WarehouseWhereInput>
    inventoryBatches?: InventoryBatchListRelationFilter
  }, "id" | "warehouseId_code">

  export type BinOrderByWithAggregationInput = {
    id?: SortOrder
    warehouseId?: SortOrder
    code?: SortOrder
    name?: SortOrderInput | SortOrder
    _count?: BinCountOrderByAggregateInput
    _max?: BinMaxOrderByAggregateInput
    _min?: BinMinOrderByAggregateInput
  }

  export type BinScalarWhereWithAggregatesInput = {
    AND?: BinScalarWhereWithAggregatesInput | BinScalarWhereWithAggregatesInput[]
    OR?: BinScalarWhereWithAggregatesInput[]
    NOT?: BinScalarWhereWithAggregatesInput | BinScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bin"> | string
    warehouseId?: StringWithAggregatesFilter<"Bin"> | string
    code?: StringWithAggregatesFilter<"Bin"> | string
    name?: StringNullableWithAggregatesFilter<"Bin"> | string | null
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    id?: StringFilter<"Item"> | string
    sku?: StringFilter<"Item"> | string
    name?: StringFilter<"Item"> | string
    description?: StringNullableFilter<"Item"> | string | null
    type?: EnumItemTypeFilter<"Item"> | $Enums.ItemType
    uom?: StringFilter<"Item"> | string
    costingMethod?: EnumCostingMethodFilter<"Item"> | $Enums.CostingMethod
    standardCost?: DecimalNullableFilter<"Item"> | Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: DecimalNullableFilter<"Item"> | Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: DecimalNullableFilter<"Item"> | Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: DecimalNullableFilter<"Item"> | Decimal | DecimalJsLike | number | string | null
    taxCode?: StringNullableFilter<"Item"> | string | null
    isActive?: BoolFilter<"Item"> | boolean
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    boms?: BomListRelationFilter
    bomLines?: BomLineListRelationFilter
    inventoryBatches?: InventoryBatchListRelationFilter
    inventoryLedger?: InventoryLedgerListRelationFilter
    productionOrders?: ProductionOrderListRelationFilter
    purchaseLines?: PurchaseLineListRelationFilter
    saleLines?: SaleLineListRelationFilter
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    uom?: SortOrder
    costingMethod?: SortOrder
    standardCost?: SortOrderInput | SortOrder
    sellingPriceOrdinary?: SortOrderInput | SortOrder
    sellingPriceBulk?: SortOrderInput | SortOrder
    sellingPriceWIC?: SortOrderInput | SortOrder
    taxCode?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    boms?: BomOrderByRelationAggregateInput
    bomLines?: BomLineOrderByRelationAggregateInput
    inventoryBatches?: InventoryBatchOrderByRelationAggregateInput
    inventoryLedger?: InventoryLedgerOrderByRelationAggregateInput
    productionOrders?: ProductionOrderOrderByRelationAggregateInput
    purchaseLines?: PurchaseLineOrderByRelationAggregateInput
    saleLines?: SaleLineOrderByRelationAggregateInput
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    name?: StringFilter<"Item"> | string
    description?: StringNullableFilter<"Item"> | string | null
    type?: EnumItemTypeFilter<"Item"> | $Enums.ItemType
    uom?: StringFilter<"Item"> | string
    costingMethod?: EnumCostingMethodFilter<"Item"> | $Enums.CostingMethod
    standardCost?: DecimalNullableFilter<"Item"> | Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: DecimalNullableFilter<"Item"> | Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: DecimalNullableFilter<"Item"> | Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: DecimalNullableFilter<"Item"> | Decimal | DecimalJsLike | number | string | null
    taxCode?: StringNullableFilter<"Item"> | string | null
    isActive?: BoolFilter<"Item"> | boolean
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    boms?: BomListRelationFilter
    bomLines?: BomLineListRelationFilter
    inventoryBatches?: InventoryBatchListRelationFilter
    inventoryLedger?: InventoryLedgerListRelationFilter
    productionOrders?: ProductionOrderListRelationFilter
    purchaseLines?: PurchaseLineListRelationFilter
    saleLines?: SaleLineListRelationFilter
  }, "id" | "sku">

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    uom?: SortOrder
    costingMethod?: SortOrder
    standardCost?: SortOrderInput | SortOrder
    sellingPriceOrdinary?: SortOrderInput | SortOrder
    sellingPriceBulk?: SortOrderInput | SortOrder
    sellingPriceWIC?: SortOrderInput | SortOrder
    taxCode?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Item"> | string
    sku?: StringWithAggregatesFilter<"Item"> | string
    name?: StringWithAggregatesFilter<"Item"> | string
    description?: StringNullableWithAggregatesFilter<"Item"> | string | null
    type?: EnumItemTypeWithAggregatesFilter<"Item"> | $Enums.ItemType
    uom?: StringWithAggregatesFilter<"Item"> | string
    costingMethod?: EnumCostingMethodWithAggregatesFilter<"Item"> | $Enums.CostingMethod
    standardCost?: DecimalNullableWithAggregatesFilter<"Item"> | Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: DecimalNullableWithAggregatesFilter<"Item"> | Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: DecimalNullableWithAggregatesFilter<"Item"> | Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: DecimalNullableWithAggregatesFilter<"Item"> | Decimal | DecimalJsLike | number | string | null
    taxCode?: StringNullableWithAggregatesFilter<"Item"> | string | null
    isActive?: BoolWithAggregatesFilter<"Item"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
  }

  export type BomWhereInput = {
    AND?: BomWhereInput | BomWhereInput[]
    OR?: BomWhereInput[]
    NOT?: BomWhereInput | BomWhereInput[]
    id?: StringFilter<"Bom"> | string
    itemId?: StringFilter<"Bom"> | string
    version?: StringFilter<"Bom"> | string
    isActive?: BoolFilter<"Bom"> | boolean
    createdAt?: DateTimeFilter<"Bom"> | Date | string
    updatedAt?: DateTimeFilter<"Bom"> | Date | string
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    bomLines?: BomLineListRelationFilter
    productionOrders?: ProductionOrderListRelationFilter
  }

  export type BomOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    item?: ItemOrderByWithRelationInput
    bomLines?: BomLineOrderByRelationAggregateInput
    productionOrders?: ProductionOrderOrderByRelationAggregateInput
  }

  export type BomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    itemId_version?: BomItemIdVersionCompoundUniqueInput
    AND?: BomWhereInput | BomWhereInput[]
    OR?: BomWhereInput[]
    NOT?: BomWhereInput | BomWhereInput[]
    itemId?: StringFilter<"Bom"> | string
    version?: StringFilter<"Bom"> | string
    isActive?: BoolFilter<"Bom"> | boolean
    createdAt?: DateTimeFilter<"Bom"> | Date | string
    updatedAt?: DateTimeFilter<"Bom"> | Date | string
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    bomLines?: BomLineListRelationFilter
    productionOrders?: ProductionOrderListRelationFilter
  }, "id" | "itemId_version">

  export type BomOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BomCountOrderByAggregateInput
    _max?: BomMaxOrderByAggregateInput
    _min?: BomMinOrderByAggregateInput
  }

  export type BomScalarWhereWithAggregatesInput = {
    AND?: BomScalarWhereWithAggregatesInput | BomScalarWhereWithAggregatesInput[]
    OR?: BomScalarWhereWithAggregatesInput[]
    NOT?: BomScalarWhereWithAggregatesInput | BomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bom"> | string
    itemId?: StringWithAggregatesFilter<"Bom"> | string
    version?: StringWithAggregatesFilter<"Bom"> | string
    isActive?: BoolWithAggregatesFilter<"Bom"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Bom"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bom"> | Date | string
  }

  export type BomLineWhereInput = {
    AND?: BomLineWhereInput | BomLineWhereInput[]
    OR?: BomLineWhereInput[]
    NOT?: BomLineWhereInput | BomLineWhereInput[]
    id?: StringFilter<"BomLine"> | string
    bomId?: StringFilter<"BomLine"> | string
    componentItemId?: StringFilter<"BomLine"> | string
    qtyPer?: DecimalFilter<"BomLine"> | Decimal | DecimalJsLike | number | string
    scrapPercent?: DecimalFilter<"BomLine"> | Decimal | DecimalJsLike | number | string
    bom?: XOR<BomRelationFilter, BomWhereInput>
    componentItem?: XOR<ItemRelationFilter, ItemWhereInput>
  }

  export type BomLineOrderByWithRelationInput = {
    id?: SortOrder
    bomId?: SortOrder
    componentItemId?: SortOrder
    qtyPer?: SortOrder
    scrapPercent?: SortOrder
    bom?: BomOrderByWithRelationInput
    componentItem?: ItemOrderByWithRelationInput
  }

  export type BomLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BomLineWhereInput | BomLineWhereInput[]
    OR?: BomLineWhereInput[]
    NOT?: BomLineWhereInput | BomLineWhereInput[]
    bomId?: StringFilter<"BomLine"> | string
    componentItemId?: StringFilter<"BomLine"> | string
    qtyPer?: DecimalFilter<"BomLine"> | Decimal | DecimalJsLike | number | string
    scrapPercent?: DecimalFilter<"BomLine"> | Decimal | DecimalJsLike | number | string
    bom?: XOR<BomRelationFilter, BomWhereInput>
    componentItem?: XOR<ItemRelationFilter, ItemWhereInput>
  }, "id">

  export type BomLineOrderByWithAggregationInput = {
    id?: SortOrder
    bomId?: SortOrder
    componentItemId?: SortOrder
    qtyPer?: SortOrder
    scrapPercent?: SortOrder
    _count?: BomLineCountOrderByAggregateInput
    _avg?: BomLineAvgOrderByAggregateInput
    _max?: BomLineMaxOrderByAggregateInput
    _min?: BomLineMinOrderByAggregateInput
    _sum?: BomLineSumOrderByAggregateInput
  }

  export type BomLineScalarWhereWithAggregatesInput = {
    AND?: BomLineScalarWhereWithAggregatesInput | BomLineScalarWhereWithAggregatesInput[]
    OR?: BomLineScalarWhereWithAggregatesInput[]
    NOT?: BomLineScalarWhereWithAggregatesInput | BomLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BomLine"> | string
    bomId?: StringWithAggregatesFilter<"BomLine"> | string
    componentItemId?: StringWithAggregatesFilter<"BomLine"> | string
    qtyPer?: DecimalWithAggregatesFilter<"BomLine"> | Decimal | DecimalJsLike | number | string
    scrapPercent?: DecimalWithAggregatesFilter<"BomLine"> | Decimal | DecimalJsLike | number | string
  }

  export type InventoryBatchWhereInput = {
    AND?: InventoryBatchWhereInput | InventoryBatchWhereInput[]
    OR?: InventoryBatchWhereInput[]
    NOT?: InventoryBatchWhereInput | InventoryBatchWhereInput[]
    id?: StringFilter<"InventoryBatch"> | string
    itemId?: StringFilter<"InventoryBatch"> | string
    warehouseId?: StringFilter<"InventoryBatch"> | string
    binId?: StringNullableFilter<"InventoryBatch"> | string | null
    qtyOnHand?: DecimalFilter<"InventoryBatch"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFilter<"InventoryBatch"> | Decimal | DecimalJsLike | number | string
    receivedAt?: DateTimeFilter<"InventoryBatch"> | Date | string
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    warehouse?: XOR<WarehouseRelationFilter, WarehouseWhereInput>
    bin?: XOR<BinNullableRelationFilter, BinWhereInput> | null
    inventoryLedger?: InventoryLedgerListRelationFilter
  }

  export type InventoryBatchOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    warehouseId?: SortOrder
    binId?: SortOrderInput | SortOrder
    qtyOnHand?: SortOrder
    unitCost?: SortOrder
    receivedAt?: SortOrder
    item?: ItemOrderByWithRelationInput
    warehouse?: WarehouseOrderByWithRelationInput
    bin?: BinOrderByWithRelationInput
    inventoryLedger?: InventoryLedgerOrderByRelationAggregateInput
  }

  export type InventoryBatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryBatchWhereInput | InventoryBatchWhereInput[]
    OR?: InventoryBatchWhereInput[]
    NOT?: InventoryBatchWhereInput | InventoryBatchWhereInput[]
    itemId?: StringFilter<"InventoryBatch"> | string
    warehouseId?: StringFilter<"InventoryBatch"> | string
    binId?: StringNullableFilter<"InventoryBatch"> | string | null
    qtyOnHand?: DecimalFilter<"InventoryBatch"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFilter<"InventoryBatch"> | Decimal | DecimalJsLike | number | string
    receivedAt?: DateTimeFilter<"InventoryBatch"> | Date | string
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    warehouse?: XOR<WarehouseRelationFilter, WarehouseWhereInput>
    bin?: XOR<BinNullableRelationFilter, BinWhereInput> | null
    inventoryLedger?: InventoryLedgerListRelationFilter
  }, "id">

  export type InventoryBatchOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    warehouseId?: SortOrder
    binId?: SortOrderInput | SortOrder
    qtyOnHand?: SortOrder
    unitCost?: SortOrder
    receivedAt?: SortOrder
    _count?: InventoryBatchCountOrderByAggregateInput
    _avg?: InventoryBatchAvgOrderByAggregateInput
    _max?: InventoryBatchMaxOrderByAggregateInput
    _min?: InventoryBatchMinOrderByAggregateInput
    _sum?: InventoryBatchSumOrderByAggregateInput
  }

  export type InventoryBatchScalarWhereWithAggregatesInput = {
    AND?: InventoryBatchScalarWhereWithAggregatesInput | InventoryBatchScalarWhereWithAggregatesInput[]
    OR?: InventoryBatchScalarWhereWithAggregatesInput[]
    NOT?: InventoryBatchScalarWhereWithAggregatesInput | InventoryBatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryBatch"> | string
    itemId?: StringWithAggregatesFilter<"InventoryBatch"> | string
    warehouseId?: StringWithAggregatesFilter<"InventoryBatch"> | string
    binId?: StringNullableWithAggregatesFilter<"InventoryBatch"> | string | null
    qtyOnHand?: DecimalWithAggregatesFilter<"InventoryBatch"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalWithAggregatesFilter<"InventoryBatch"> | Decimal | DecimalJsLike | number | string
    receivedAt?: DateTimeWithAggregatesFilter<"InventoryBatch"> | Date | string
  }

  export type InventoryLedgerWhereInput = {
    AND?: InventoryLedgerWhereInput | InventoryLedgerWhereInput[]
    OR?: InventoryLedgerWhereInput[]
    NOT?: InventoryLedgerWhereInput | InventoryLedgerWhereInput[]
    id?: StringFilter<"InventoryLedger"> | string
    itemId?: StringFilter<"InventoryLedger"> | string
    warehouseId?: StringFilter<"InventoryLedger"> | string
    refType?: StringFilter<"InventoryLedger"> | string
    refId?: StringFilter<"InventoryLedger"> | string
    direction?: EnumLedgerDirectionFilter<"InventoryLedger"> | $Enums.LedgerDirection
    qty?: DecimalFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    value?: DecimalFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    runningQty?: DecimalFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    runningValue?: DecimalFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    runningAvgCost?: DecimalFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    batchId?: StringNullableFilter<"InventoryLedger"> | string | null
    userId?: StringNullableFilter<"InventoryLedger"> | string | null
    postedAt?: DateTimeFilter<"InventoryLedger"> | Date | string
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    warehouse?: XOR<WarehouseRelationFilter, WarehouseWhereInput>
    batch?: XOR<InventoryBatchNullableRelationFilter, InventoryBatchWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type InventoryLedgerOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    warehouseId?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    direction?: SortOrder
    qty?: SortOrder
    unitCost?: SortOrder
    value?: SortOrder
    runningQty?: SortOrder
    runningValue?: SortOrder
    runningAvgCost?: SortOrder
    batchId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    postedAt?: SortOrder
    item?: ItemOrderByWithRelationInput
    warehouse?: WarehouseOrderByWithRelationInput
    batch?: InventoryBatchOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type InventoryLedgerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryLedgerWhereInput | InventoryLedgerWhereInput[]
    OR?: InventoryLedgerWhereInput[]
    NOT?: InventoryLedgerWhereInput | InventoryLedgerWhereInput[]
    itemId?: StringFilter<"InventoryLedger"> | string
    warehouseId?: StringFilter<"InventoryLedger"> | string
    refType?: StringFilter<"InventoryLedger"> | string
    refId?: StringFilter<"InventoryLedger"> | string
    direction?: EnumLedgerDirectionFilter<"InventoryLedger"> | $Enums.LedgerDirection
    qty?: DecimalFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    value?: DecimalFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    runningQty?: DecimalFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    runningValue?: DecimalFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    runningAvgCost?: DecimalFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    batchId?: StringNullableFilter<"InventoryLedger"> | string | null
    userId?: StringNullableFilter<"InventoryLedger"> | string | null
    postedAt?: DateTimeFilter<"InventoryLedger"> | Date | string
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    warehouse?: XOR<WarehouseRelationFilter, WarehouseWhereInput>
    batch?: XOR<InventoryBatchNullableRelationFilter, InventoryBatchWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type InventoryLedgerOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    warehouseId?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    direction?: SortOrder
    qty?: SortOrder
    unitCost?: SortOrder
    value?: SortOrder
    runningQty?: SortOrder
    runningValue?: SortOrder
    runningAvgCost?: SortOrder
    batchId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    postedAt?: SortOrder
    _count?: InventoryLedgerCountOrderByAggregateInput
    _avg?: InventoryLedgerAvgOrderByAggregateInput
    _max?: InventoryLedgerMaxOrderByAggregateInput
    _min?: InventoryLedgerMinOrderByAggregateInput
    _sum?: InventoryLedgerSumOrderByAggregateInput
  }

  export type InventoryLedgerScalarWhereWithAggregatesInput = {
    AND?: InventoryLedgerScalarWhereWithAggregatesInput | InventoryLedgerScalarWhereWithAggregatesInput[]
    OR?: InventoryLedgerScalarWhereWithAggregatesInput[]
    NOT?: InventoryLedgerScalarWhereWithAggregatesInput | InventoryLedgerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryLedger"> | string
    itemId?: StringWithAggregatesFilter<"InventoryLedger"> | string
    warehouseId?: StringWithAggregatesFilter<"InventoryLedger"> | string
    refType?: StringWithAggregatesFilter<"InventoryLedger"> | string
    refId?: StringWithAggregatesFilter<"InventoryLedger"> | string
    direction?: EnumLedgerDirectionWithAggregatesFilter<"InventoryLedger"> | $Enums.LedgerDirection
    qty?: DecimalWithAggregatesFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalWithAggregatesFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    value?: DecimalWithAggregatesFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    runningQty?: DecimalWithAggregatesFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    runningValue?: DecimalWithAggregatesFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    runningAvgCost?: DecimalWithAggregatesFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    batchId?: StringNullableWithAggregatesFilter<"InventoryLedger"> | string | null
    userId?: StringNullableWithAggregatesFilter<"InventoryLedger"> | string | null
    postedAt?: DateTimeWithAggregatesFilter<"InventoryLedger"> | Date | string
  }

  export type ProductionOrderWhereInput = {
    AND?: ProductionOrderWhereInput | ProductionOrderWhereInput[]
    OR?: ProductionOrderWhereInput[]
    NOT?: ProductionOrderWhereInput | ProductionOrderWhereInput[]
    id?: StringFilter<"ProductionOrder"> | string
    orderNo?: StringFilter<"ProductionOrder"> | string
    itemId?: StringFilter<"ProductionOrder"> | string
    qtyTarget?: DecimalFilter<"ProductionOrder"> | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalFilter<"ProductionOrder"> | Decimal | DecimalJsLike | number | string
    status?: EnumProductionOrderStatusFilter<"ProductionOrder"> | $Enums.ProductionOrderStatus
    warehouseId?: StringFilter<"ProductionOrder"> | string
    bomId?: StringNullableFilter<"ProductionOrder"> | string | null
    approvalStatus?: StringNullableFilter<"ProductionOrder"> | string | null
    approvalRequestId?: StringNullableFilter<"ProductionOrder"> | string | null
    approvedBy?: StringNullableFilter<"ProductionOrder"> | string | null
    approvedAt?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductionOrder"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionOrder"> | Date | string
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    warehouse?: XOR<WarehouseRelationFilter, WarehouseWhereInput>
    bom?: XOR<BomNullableRelationFilter, BomWhereInput> | null
    wipLedger?: WipLedgerListRelationFilter
    laborTimes?: LaborTimeListRelationFilter
  }

  export type ProductionOrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNo?: SortOrder
    itemId?: SortOrder
    qtyTarget?: SortOrder
    qtyProduced?: SortOrder
    status?: SortOrder
    warehouseId?: SortOrder
    bomId?: SortOrderInput | SortOrder
    approvalStatus?: SortOrderInput | SortOrder
    approvalRequestId?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    finishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    item?: ItemOrderByWithRelationInput
    warehouse?: WarehouseOrderByWithRelationInput
    bom?: BomOrderByWithRelationInput
    wipLedger?: WipLedgerOrderByRelationAggregateInput
    laborTimes?: LaborTimeOrderByRelationAggregateInput
  }

  export type ProductionOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNo?: string
    AND?: ProductionOrderWhereInput | ProductionOrderWhereInput[]
    OR?: ProductionOrderWhereInput[]
    NOT?: ProductionOrderWhereInput | ProductionOrderWhereInput[]
    itemId?: StringFilter<"ProductionOrder"> | string
    qtyTarget?: DecimalFilter<"ProductionOrder"> | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalFilter<"ProductionOrder"> | Decimal | DecimalJsLike | number | string
    status?: EnumProductionOrderStatusFilter<"ProductionOrder"> | $Enums.ProductionOrderStatus
    warehouseId?: StringFilter<"ProductionOrder"> | string
    bomId?: StringNullableFilter<"ProductionOrder"> | string | null
    approvalStatus?: StringNullableFilter<"ProductionOrder"> | string | null
    approvalRequestId?: StringNullableFilter<"ProductionOrder"> | string | null
    approvedBy?: StringNullableFilter<"ProductionOrder"> | string | null
    approvedAt?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductionOrder"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionOrder"> | Date | string
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    warehouse?: XOR<WarehouseRelationFilter, WarehouseWhereInput>
    bom?: XOR<BomNullableRelationFilter, BomWhereInput> | null
    wipLedger?: WipLedgerListRelationFilter
    laborTimes?: LaborTimeListRelationFilter
  }, "id" | "orderNo">

  export type ProductionOrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNo?: SortOrder
    itemId?: SortOrder
    qtyTarget?: SortOrder
    qtyProduced?: SortOrder
    status?: SortOrder
    warehouseId?: SortOrder
    bomId?: SortOrderInput | SortOrder
    approvalStatus?: SortOrderInput | SortOrder
    approvalRequestId?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    finishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductionOrderCountOrderByAggregateInput
    _avg?: ProductionOrderAvgOrderByAggregateInput
    _max?: ProductionOrderMaxOrderByAggregateInput
    _min?: ProductionOrderMinOrderByAggregateInput
    _sum?: ProductionOrderSumOrderByAggregateInput
  }

  export type ProductionOrderScalarWhereWithAggregatesInput = {
    AND?: ProductionOrderScalarWhereWithAggregatesInput | ProductionOrderScalarWhereWithAggregatesInput[]
    OR?: ProductionOrderScalarWhereWithAggregatesInput[]
    NOT?: ProductionOrderScalarWhereWithAggregatesInput | ProductionOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductionOrder"> | string
    orderNo?: StringWithAggregatesFilter<"ProductionOrder"> | string
    itemId?: StringWithAggregatesFilter<"ProductionOrder"> | string
    qtyTarget?: DecimalWithAggregatesFilter<"ProductionOrder"> | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalWithAggregatesFilter<"ProductionOrder"> | Decimal | DecimalJsLike | number | string
    status?: EnumProductionOrderStatusWithAggregatesFilter<"ProductionOrder"> | $Enums.ProductionOrderStatus
    warehouseId?: StringWithAggregatesFilter<"ProductionOrder"> | string
    bomId?: StringNullableWithAggregatesFilter<"ProductionOrder"> | string | null
    approvalStatus?: StringNullableWithAggregatesFilter<"ProductionOrder"> | string | null
    approvalRequestId?: StringNullableWithAggregatesFilter<"ProductionOrder"> | string | null
    approvedBy?: StringNullableWithAggregatesFilter<"ProductionOrder"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"ProductionOrder"> | Date | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"ProductionOrder"> | Date | string | null
    finishedAt?: DateTimeNullableWithAggregatesFilter<"ProductionOrder"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductionOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductionOrder"> | Date | string
  }

  export type WipLedgerWhereInput = {
    AND?: WipLedgerWhereInput | WipLedgerWhereInput[]
    OR?: WipLedgerWhereInput[]
    NOT?: WipLedgerWhereInput | WipLedgerWhereInput[]
    id?: StringFilter<"WipLedger"> | string
    productionOrderId?: StringFilter<"WipLedger"> | string
    type?: EnumWipLedgerTypeFilter<"WipLedger"> | $Enums.WipLedgerType
    amount?: DecimalFilter<"WipLedger"> | Decimal | DecimalJsLike | number | string
    note?: StringNullableFilter<"WipLedger"> | string | null
    postedAt?: DateTimeFilter<"WipLedger"> | Date | string
    productionOrder?: XOR<ProductionOrderRelationFilter, ProductionOrderWhereInput>
  }

  export type WipLedgerOrderByWithRelationInput = {
    id?: SortOrder
    productionOrderId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    note?: SortOrderInput | SortOrder
    postedAt?: SortOrder
    productionOrder?: ProductionOrderOrderByWithRelationInput
  }

  export type WipLedgerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WipLedgerWhereInput | WipLedgerWhereInput[]
    OR?: WipLedgerWhereInput[]
    NOT?: WipLedgerWhereInput | WipLedgerWhereInput[]
    productionOrderId?: StringFilter<"WipLedger"> | string
    type?: EnumWipLedgerTypeFilter<"WipLedger"> | $Enums.WipLedgerType
    amount?: DecimalFilter<"WipLedger"> | Decimal | DecimalJsLike | number | string
    note?: StringNullableFilter<"WipLedger"> | string | null
    postedAt?: DateTimeFilter<"WipLedger"> | Date | string
    productionOrder?: XOR<ProductionOrderRelationFilter, ProductionOrderWhereInput>
  }, "id">

  export type WipLedgerOrderByWithAggregationInput = {
    id?: SortOrder
    productionOrderId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    note?: SortOrderInput | SortOrder
    postedAt?: SortOrder
    _count?: WipLedgerCountOrderByAggregateInput
    _avg?: WipLedgerAvgOrderByAggregateInput
    _max?: WipLedgerMaxOrderByAggregateInput
    _min?: WipLedgerMinOrderByAggregateInput
    _sum?: WipLedgerSumOrderByAggregateInput
  }

  export type WipLedgerScalarWhereWithAggregatesInput = {
    AND?: WipLedgerScalarWhereWithAggregatesInput | WipLedgerScalarWhereWithAggregatesInput[]
    OR?: WipLedgerScalarWhereWithAggregatesInput[]
    NOT?: WipLedgerScalarWhereWithAggregatesInput | WipLedgerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WipLedger"> | string
    productionOrderId?: StringWithAggregatesFilter<"WipLedger"> | string
    type?: EnumWipLedgerTypeWithAggregatesFilter<"WipLedger"> | $Enums.WipLedgerType
    amount?: DecimalWithAggregatesFilter<"WipLedger"> | Decimal | DecimalJsLike | number | string
    note?: StringNullableWithAggregatesFilter<"WipLedger"> | string | null
    postedAt?: DateTimeWithAggregatesFilter<"WipLedger"> | Date | string
  }

  export type LaborTimeWhereInput = {
    AND?: LaborTimeWhereInput | LaborTimeWhereInput[]
    OR?: LaborTimeWhereInput[]
    NOT?: LaborTimeWhereInput | LaborTimeWhereInput[]
    id?: StringFilter<"LaborTime"> | string
    productionOrderId?: StringFilter<"LaborTime"> | string
    hours?: DecimalFilter<"LaborTime"> | Decimal | DecimalJsLike | number | string
    rate?: DecimalFilter<"LaborTime"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalFilter<"LaborTime"> | Decimal | DecimalJsLike | number | string
    employeeName?: StringNullableFilter<"LaborTime"> | string | null
    productionOrder?: XOR<ProductionOrderRelationFilter, ProductionOrderWhereInput>
  }

  export type LaborTimeOrderByWithRelationInput = {
    id?: SortOrder
    productionOrderId?: SortOrder
    hours?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    employeeName?: SortOrderInput | SortOrder
    productionOrder?: ProductionOrderOrderByWithRelationInput
  }

  export type LaborTimeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LaborTimeWhereInput | LaborTimeWhereInput[]
    OR?: LaborTimeWhereInput[]
    NOT?: LaborTimeWhereInput | LaborTimeWhereInput[]
    productionOrderId?: StringFilter<"LaborTime"> | string
    hours?: DecimalFilter<"LaborTime"> | Decimal | DecimalJsLike | number | string
    rate?: DecimalFilter<"LaborTime"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalFilter<"LaborTime"> | Decimal | DecimalJsLike | number | string
    employeeName?: StringNullableFilter<"LaborTime"> | string | null
    productionOrder?: XOR<ProductionOrderRelationFilter, ProductionOrderWhereInput>
  }, "id">

  export type LaborTimeOrderByWithAggregationInput = {
    id?: SortOrder
    productionOrderId?: SortOrder
    hours?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    employeeName?: SortOrderInput | SortOrder
    _count?: LaborTimeCountOrderByAggregateInput
    _avg?: LaborTimeAvgOrderByAggregateInput
    _max?: LaborTimeMaxOrderByAggregateInput
    _min?: LaborTimeMinOrderByAggregateInput
    _sum?: LaborTimeSumOrderByAggregateInput
  }

  export type LaborTimeScalarWhereWithAggregatesInput = {
    AND?: LaborTimeScalarWhereWithAggregatesInput | LaborTimeScalarWhereWithAggregatesInput[]
    OR?: LaborTimeScalarWhereWithAggregatesInput[]
    NOT?: LaborTimeScalarWhereWithAggregatesInput | LaborTimeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LaborTime"> | string
    productionOrderId?: StringWithAggregatesFilter<"LaborTime"> | string
    hours?: DecimalWithAggregatesFilter<"LaborTime"> | Decimal | DecimalJsLike | number | string
    rate?: DecimalWithAggregatesFilter<"LaborTime"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalWithAggregatesFilter<"LaborTime"> | Decimal | DecimalJsLike | number | string
    employeeName?: StringNullableWithAggregatesFilter<"LaborTime"> | string | null
  }

  export type VendorWhereInput = {
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    id?: StringFilter<"Vendor"> | string
    code?: StringFilter<"Vendor"> | string
    name?: StringFilter<"Vendor"> | string
    address?: StringNullableFilter<"Vendor"> | string | null
    phone?: StringNullableFilter<"Vendor"> | string | null
    email?: StringNullableFilter<"Vendor"> | string | null
    paymentTerms?: StringNullableFilter<"Vendor"> | string | null
    isActive?: BoolFilter<"Vendor"> | boolean
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    purchases?: PurchaseListRelationFilter
    purchasePayments?: PurchasePaymentListRelationFilter
    assets?: AssetListRelationFilter
  }

  export type VendorOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    purchases?: PurchaseOrderByRelationAggregateInput
    purchasePayments?: PurchasePaymentOrderByRelationAggregateInput
    assets?: AssetOrderByRelationAggregateInput
  }

  export type VendorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    name?: StringFilter<"Vendor"> | string
    address?: StringNullableFilter<"Vendor"> | string | null
    phone?: StringNullableFilter<"Vendor"> | string | null
    email?: StringNullableFilter<"Vendor"> | string | null
    paymentTerms?: StringNullableFilter<"Vendor"> | string | null
    isActive?: BoolFilter<"Vendor"> | boolean
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    purchases?: PurchaseListRelationFilter
    purchasePayments?: PurchasePaymentListRelationFilter
    assets?: AssetListRelationFilter
  }, "id" | "code">

  export type VendorOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: VendorCountOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    OR?: VendorScalarWhereWithAggregatesInput[]
    NOT?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vendor"> | string
    code?: StringWithAggregatesFilter<"Vendor"> | string
    name?: StringWithAggregatesFilter<"Vendor"> | string
    address?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    email?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    paymentTerms?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    isActive?: BoolWithAggregatesFilter<"Vendor"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    code?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    address?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    creditLimit?: DecimalNullableFilter<"Customer"> | Decimal | DecimalJsLike | number | string | null
    CustomerGroup?: StringFilter<"Customer"> | string
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    sales?: SaleListRelationFilter
    salesReceipts?: SalesReceiptListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    creditLimit?: SortOrderInput | SortOrder
    CustomerGroup?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    sales?: SaleOrderByRelationAggregateInput
    salesReceipts?: SalesReceiptOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringFilter<"Customer"> | string
    address?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    creditLimit?: DecimalNullableFilter<"Customer"> | Decimal | DecimalJsLike | number | string | null
    CustomerGroup?: StringFilter<"Customer"> | string
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    sales?: SaleListRelationFilter
    salesReceipts?: SalesReceiptListRelationFilter
  }, "id" | "code">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    creditLimit?: SortOrderInput | SortOrder
    CustomerGroup?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    code?: StringWithAggregatesFilter<"Customer"> | string
    name?: StringWithAggregatesFilter<"Customer"> | string
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    creditLimit?: DecimalNullableWithAggregatesFilter<"Customer"> | Decimal | DecimalJsLike | number | string | null
    CustomerGroup?: StringWithAggregatesFilter<"Customer"> | string
    isActive?: BoolWithAggregatesFilter<"Customer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type PurchaseWhereInput = {
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    id?: StringFilter<"Purchase"> | string
    orderNo?: StringFilter<"Purchase"> | string
    vendorId?: StringFilter<"Purchase"> | string
    orderDate?: DateTimeFilter<"Purchase"> | Date | string
    status?: EnumPurchaseStatusFilter<"Purchase"> | $Enums.PurchaseStatus
    totalAmount?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Purchase"> | string | null
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    purchaseLines?: PurchaseLineListRelationFilter
    purchasePayments?: PurchasePaymentListRelationFilter
    assets?: AssetListRelationFilter
  }

  export type PurchaseOrderByWithRelationInput = {
    id?: SortOrder
    orderNo?: SortOrder
    vendorId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    purchaseLines?: PurchaseLineOrderByRelationAggregateInput
    purchasePayments?: PurchasePaymentOrderByRelationAggregateInput
    assets?: AssetOrderByRelationAggregateInput
  }

  export type PurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNo?: string
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    vendorId?: StringFilter<"Purchase"> | string
    orderDate?: DateTimeFilter<"Purchase"> | Date | string
    status?: EnumPurchaseStatusFilter<"Purchase"> | $Enums.PurchaseStatus
    totalAmount?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Purchase"> | string | null
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    purchaseLines?: PurchaseLineListRelationFilter
    purchasePayments?: PurchasePaymentListRelationFilter
    assets?: AssetListRelationFilter
  }, "id" | "orderNo">

  export type PurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    orderNo?: SortOrder
    vendorId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseCountOrderByAggregateInput
    _avg?: PurchaseAvgOrderByAggregateInput
    _max?: PurchaseMaxOrderByAggregateInput
    _min?: PurchaseMinOrderByAggregateInput
    _sum?: PurchaseSumOrderByAggregateInput
  }

  export type PurchaseScalarWhereWithAggregatesInput = {
    AND?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    OR?: PurchaseScalarWhereWithAggregatesInput[]
    NOT?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Purchase"> | string
    orderNo?: StringWithAggregatesFilter<"Purchase"> | string
    vendorId?: StringWithAggregatesFilter<"Purchase"> | string
    orderDate?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
    status?: EnumPurchaseStatusWithAggregatesFilter<"Purchase"> | $Enums.PurchaseStatus
    totalAmount?: DecimalWithAggregatesFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"Purchase"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
  }

  export type PurchaseLineWhereInput = {
    AND?: PurchaseLineWhereInput | PurchaseLineWhereInput[]
    OR?: PurchaseLineWhereInput[]
    NOT?: PurchaseLineWhereInput | PurchaseLineWhereInput[]
    id?: StringFilter<"PurchaseLine"> | string
    purchaseId?: StringFilter<"PurchaseLine"> | string
    itemId?: StringFilter<"PurchaseLine"> | string
    qty?: DecimalFilter<"PurchaseLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"PurchaseLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"PurchaseLine"> | Decimal | DecimalJsLike | number | string
    purchase?: XOR<PurchaseRelationFilter, PurchaseWhereInput>
    item?: XOR<ItemRelationFilter, ItemWhereInput>
  }

  export type PurchaseLineOrderByWithRelationInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
    purchase?: PurchaseOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type PurchaseLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseLineWhereInput | PurchaseLineWhereInput[]
    OR?: PurchaseLineWhereInput[]
    NOT?: PurchaseLineWhereInput | PurchaseLineWhereInput[]
    purchaseId?: StringFilter<"PurchaseLine"> | string
    itemId?: StringFilter<"PurchaseLine"> | string
    qty?: DecimalFilter<"PurchaseLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"PurchaseLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"PurchaseLine"> | Decimal | DecimalJsLike | number | string
    purchase?: XOR<PurchaseRelationFilter, PurchaseWhereInput>
    item?: XOR<ItemRelationFilter, ItemWhereInput>
  }, "id">

  export type PurchaseLineOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
    _count?: PurchaseLineCountOrderByAggregateInput
    _avg?: PurchaseLineAvgOrderByAggregateInput
    _max?: PurchaseLineMaxOrderByAggregateInput
    _min?: PurchaseLineMinOrderByAggregateInput
    _sum?: PurchaseLineSumOrderByAggregateInput
  }

  export type PurchaseLineScalarWhereWithAggregatesInput = {
    AND?: PurchaseLineScalarWhereWithAggregatesInput | PurchaseLineScalarWhereWithAggregatesInput[]
    OR?: PurchaseLineScalarWhereWithAggregatesInput[]
    NOT?: PurchaseLineScalarWhereWithAggregatesInput | PurchaseLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseLine"> | string
    purchaseId?: StringWithAggregatesFilter<"PurchaseLine"> | string
    itemId?: StringWithAggregatesFilter<"PurchaseLine"> | string
    qty?: DecimalWithAggregatesFilter<"PurchaseLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalWithAggregatesFilter<"PurchaseLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalWithAggregatesFilter<"PurchaseLine"> | Decimal | DecimalJsLike | number | string
  }

  export type SaleWhereInput = {
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    id?: StringFilter<"Sale"> | string
    orderNo?: StringFilter<"Sale"> | string
    customerId?: StringFilter<"Sale"> | string
    orderDate?: DateTimeFilter<"Sale"> | Date | string
    status?: EnumSaleStatusFilter<"Sale"> | $Enums.SaleStatus
    totalAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Sale"> | string | null
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    updatedAt?: DateTimeFilter<"Sale"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    saleLines?: SaleLineListRelationFilter
    salesReceipts?: SalesReceiptListRelationFilter
  }

  export type SaleOrderByWithRelationInput = {
    id?: SortOrder
    orderNo?: SortOrder
    customerId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    saleLines?: SaleLineOrderByRelationAggregateInput
    salesReceipts?: SalesReceiptOrderByRelationAggregateInput
  }

  export type SaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNo?: string
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    customerId?: StringFilter<"Sale"> | string
    orderDate?: DateTimeFilter<"Sale"> | Date | string
    status?: EnumSaleStatusFilter<"Sale"> | $Enums.SaleStatus
    totalAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Sale"> | string | null
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    updatedAt?: DateTimeFilter<"Sale"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    saleLines?: SaleLineListRelationFilter
    salesReceipts?: SalesReceiptListRelationFilter
  }, "id" | "orderNo">

  export type SaleOrderByWithAggregationInput = {
    id?: SortOrder
    orderNo?: SortOrder
    customerId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SaleCountOrderByAggregateInput
    _avg?: SaleAvgOrderByAggregateInput
    _max?: SaleMaxOrderByAggregateInput
    _min?: SaleMinOrderByAggregateInput
    _sum?: SaleSumOrderByAggregateInput
  }

  export type SaleScalarWhereWithAggregatesInput = {
    AND?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    OR?: SaleScalarWhereWithAggregatesInput[]
    NOT?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sale"> | string
    orderNo?: StringWithAggregatesFilter<"Sale"> | string
    customerId?: StringWithAggregatesFilter<"Sale"> | string
    orderDate?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
    status?: EnumSaleStatusWithAggregatesFilter<"Sale"> | $Enums.SaleStatus
    totalAmount?: DecimalWithAggregatesFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"Sale"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
  }

  export type SaleLineWhereInput = {
    AND?: SaleLineWhereInput | SaleLineWhereInput[]
    OR?: SaleLineWhereInput[]
    NOT?: SaleLineWhereInput | SaleLineWhereInput[]
    id?: StringFilter<"SaleLine"> | string
    saleId?: StringFilter<"SaleLine"> | string
    itemId?: StringFilter<"SaleLine"> | string
    qty?: DecimalFilter<"SaleLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"SaleLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"SaleLine"> | Decimal | DecimalJsLike | number | string
    sale?: XOR<SaleRelationFilter, SaleWhereInput>
    item?: XOR<ItemRelationFilter, ItemWhereInput>
  }

  export type SaleLineOrderByWithRelationInput = {
    id?: SortOrder
    saleId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
    sale?: SaleOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type SaleLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaleLineWhereInput | SaleLineWhereInput[]
    OR?: SaleLineWhereInput[]
    NOT?: SaleLineWhereInput | SaleLineWhereInput[]
    saleId?: StringFilter<"SaleLine"> | string
    itemId?: StringFilter<"SaleLine"> | string
    qty?: DecimalFilter<"SaleLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"SaleLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"SaleLine"> | Decimal | DecimalJsLike | number | string
    sale?: XOR<SaleRelationFilter, SaleWhereInput>
    item?: XOR<ItemRelationFilter, ItemWhereInput>
  }, "id">

  export type SaleLineOrderByWithAggregationInput = {
    id?: SortOrder
    saleId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
    _count?: SaleLineCountOrderByAggregateInput
    _avg?: SaleLineAvgOrderByAggregateInput
    _max?: SaleLineMaxOrderByAggregateInput
    _min?: SaleLineMinOrderByAggregateInput
    _sum?: SaleLineSumOrderByAggregateInput
  }

  export type SaleLineScalarWhereWithAggregatesInput = {
    AND?: SaleLineScalarWhereWithAggregatesInput | SaleLineScalarWhereWithAggregatesInput[]
    OR?: SaleLineScalarWhereWithAggregatesInput[]
    NOT?: SaleLineScalarWhereWithAggregatesInput | SaleLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SaleLine"> | string
    saleId?: StringWithAggregatesFilter<"SaleLine"> | string
    itemId?: StringWithAggregatesFilter<"SaleLine"> | string
    qty?: DecimalWithAggregatesFilter<"SaleLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalWithAggregatesFilter<"SaleLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalWithAggregatesFilter<"SaleLine"> | Decimal | DecimalJsLike | number | string
  }

  export type ChartOfAccountWhereInput = {
    AND?: ChartOfAccountWhereInput | ChartOfAccountWhereInput[]
    OR?: ChartOfAccountWhereInput[]
    NOT?: ChartOfAccountWhereInput | ChartOfAccountWhereInput[]
    id?: StringFilter<"ChartOfAccount"> | string
    code?: StringFilter<"ChartOfAccount"> | string
    name?: StringFilter<"ChartOfAccount"> | string
    description?: StringNullableFilter<"ChartOfAccount"> | string | null
    accountType?: StringFilter<"ChartOfAccount"> | string
    parentId?: StringNullableFilter<"ChartOfAccount"> | string | null
    isActive?: BoolFilter<"ChartOfAccount"> | boolean
    createdAt?: DateTimeFilter<"ChartOfAccount"> | Date | string
    parent?: XOR<ChartOfAccountNullableRelationFilter, ChartOfAccountWhereInput> | null
    children?: ChartOfAccountListRelationFilter
    journalLines?: JournalLineListRelationFilter
    cashTransactionsGL?: CashTransactionListRelationFilter
    cashTransactionsContra?: CashTransactionListRelationFilter
    cashAccounts?: CashAccountListRelationFilter
    assetCategoriesAsset?: AssetCategoryListRelationFilter
    assetCategoriesDepreciation?: AssetCategoryListRelationFilter
    assetCategoriesAccumulated?: AssetCategoryListRelationFilter
  }

  export type ChartOfAccountOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    accountType?: SortOrder
    parentId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    parent?: ChartOfAccountOrderByWithRelationInput
    children?: ChartOfAccountOrderByRelationAggregateInput
    journalLines?: JournalLineOrderByRelationAggregateInput
    cashTransactionsGL?: CashTransactionOrderByRelationAggregateInput
    cashTransactionsContra?: CashTransactionOrderByRelationAggregateInput
    cashAccounts?: CashAccountOrderByRelationAggregateInput
    assetCategoriesAsset?: AssetCategoryOrderByRelationAggregateInput
    assetCategoriesDepreciation?: AssetCategoryOrderByRelationAggregateInput
    assetCategoriesAccumulated?: AssetCategoryOrderByRelationAggregateInput
  }

  export type ChartOfAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ChartOfAccountWhereInput | ChartOfAccountWhereInput[]
    OR?: ChartOfAccountWhereInput[]
    NOT?: ChartOfAccountWhereInput | ChartOfAccountWhereInput[]
    name?: StringFilter<"ChartOfAccount"> | string
    description?: StringNullableFilter<"ChartOfAccount"> | string | null
    accountType?: StringFilter<"ChartOfAccount"> | string
    parentId?: StringNullableFilter<"ChartOfAccount"> | string | null
    isActive?: BoolFilter<"ChartOfAccount"> | boolean
    createdAt?: DateTimeFilter<"ChartOfAccount"> | Date | string
    parent?: XOR<ChartOfAccountNullableRelationFilter, ChartOfAccountWhereInput> | null
    children?: ChartOfAccountListRelationFilter
    journalLines?: JournalLineListRelationFilter
    cashTransactionsGL?: CashTransactionListRelationFilter
    cashTransactionsContra?: CashTransactionListRelationFilter
    cashAccounts?: CashAccountListRelationFilter
    assetCategoriesAsset?: AssetCategoryListRelationFilter
    assetCategoriesDepreciation?: AssetCategoryListRelationFilter
    assetCategoriesAccumulated?: AssetCategoryListRelationFilter
  }, "id" | "code">

  export type ChartOfAccountOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    accountType?: SortOrder
    parentId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: ChartOfAccountCountOrderByAggregateInput
    _max?: ChartOfAccountMaxOrderByAggregateInput
    _min?: ChartOfAccountMinOrderByAggregateInput
  }

  export type ChartOfAccountScalarWhereWithAggregatesInput = {
    AND?: ChartOfAccountScalarWhereWithAggregatesInput | ChartOfAccountScalarWhereWithAggregatesInput[]
    OR?: ChartOfAccountScalarWhereWithAggregatesInput[]
    NOT?: ChartOfAccountScalarWhereWithAggregatesInput | ChartOfAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChartOfAccount"> | string
    code?: StringWithAggregatesFilter<"ChartOfAccount"> | string
    name?: StringWithAggregatesFilter<"ChartOfAccount"> | string
    description?: StringNullableWithAggregatesFilter<"ChartOfAccount"> | string | null
    accountType?: StringWithAggregatesFilter<"ChartOfAccount"> | string
    parentId?: StringNullableWithAggregatesFilter<"ChartOfAccount"> | string | null
    isActive?: BoolWithAggregatesFilter<"ChartOfAccount"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ChartOfAccount"> | Date | string
  }

  export type JournalWhereInput = {
    AND?: JournalWhereInput | JournalWhereInput[]
    OR?: JournalWhereInput[]
    NOT?: JournalWhereInput | JournalWhereInput[]
    id?: StringFilter<"Journal"> | string
    journalNo?: StringFilter<"Journal"> | string
    date?: DateTimeFilter<"Journal"> | Date | string
    memo?: StringNullableFilter<"Journal"> | string | null
    postedBy?: StringFilter<"Journal"> | string
    postedAt?: DateTimeFilter<"Journal"> | Date | string
    postedByUser?: XOR<UserRelationFilter, UserWhereInput>
    journalLines?: JournalLineListRelationFilter
    assetDepreciation?: AssetDepreciationListRelationFilter
    assetDisposals?: AssetDisposalListRelationFilter
  }

  export type JournalOrderByWithRelationInput = {
    id?: SortOrder
    journalNo?: SortOrder
    date?: SortOrder
    memo?: SortOrderInput | SortOrder
    postedBy?: SortOrder
    postedAt?: SortOrder
    postedByUser?: UserOrderByWithRelationInput
    journalLines?: JournalLineOrderByRelationAggregateInput
    assetDepreciation?: AssetDepreciationOrderByRelationAggregateInput
    assetDisposals?: AssetDisposalOrderByRelationAggregateInput
  }

  export type JournalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    journalNo?: string
    AND?: JournalWhereInput | JournalWhereInput[]
    OR?: JournalWhereInput[]
    NOT?: JournalWhereInput | JournalWhereInput[]
    date?: DateTimeFilter<"Journal"> | Date | string
    memo?: StringNullableFilter<"Journal"> | string | null
    postedBy?: StringFilter<"Journal"> | string
    postedAt?: DateTimeFilter<"Journal"> | Date | string
    postedByUser?: XOR<UserRelationFilter, UserWhereInput>
    journalLines?: JournalLineListRelationFilter
    assetDepreciation?: AssetDepreciationListRelationFilter
    assetDisposals?: AssetDisposalListRelationFilter
  }, "id" | "journalNo">

  export type JournalOrderByWithAggregationInput = {
    id?: SortOrder
    journalNo?: SortOrder
    date?: SortOrder
    memo?: SortOrderInput | SortOrder
    postedBy?: SortOrder
    postedAt?: SortOrder
    _count?: JournalCountOrderByAggregateInput
    _max?: JournalMaxOrderByAggregateInput
    _min?: JournalMinOrderByAggregateInput
  }

  export type JournalScalarWhereWithAggregatesInput = {
    AND?: JournalScalarWhereWithAggregatesInput | JournalScalarWhereWithAggregatesInput[]
    OR?: JournalScalarWhereWithAggregatesInput[]
    NOT?: JournalScalarWhereWithAggregatesInput | JournalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Journal"> | string
    journalNo?: StringWithAggregatesFilter<"Journal"> | string
    date?: DateTimeWithAggregatesFilter<"Journal"> | Date | string
    memo?: StringNullableWithAggregatesFilter<"Journal"> | string | null
    postedBy?: StringWithAggregatesFilter<"Journal"> | string
    postedAt?: DateTimeWithAggregatesFilter<"Journal"> | Date | string
  }

  export type JournalLineWhereInput = {
    AND?: JournalLineWhereInput | JournalLineWhereInput[]
    OR?: JournalLineWhereInput[]
    NOT?: JournalLineWhereInput | JournalLineWhereInput[]
    id?: StringFilter<"JournalLine"> | string
    journalId?: StringFilter<"JournalLine"> | string
    accountId?: StringFilter<"JournalLine"> | string
    debit?: DecimalFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string
    refType?: StringNullableFilter<"JournalLine"> | string | null
    refId?: StringNullableFilter<"JournalLine"> | string | null
    journal?: XOR<JournalRelationFilter, JournalWhereInput>
    account?: XOR<ChartOfAccountRelationFilter, ChartOfAccountWhereInput>
  }

  export type JournalLineOrderByWithRelationInput = {
    id?: SortOrder
    journalId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    refType?: SortOrderInput | SortOrder
    refId?: SortOrderInput | SortOrder
    journal?: JournalOrderByWithRelationInput
    account?: ChartOfAccountOrderByWithRelationInput
  }

  export type JournalLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalLineWhereInput | JournalLineWhereInput[]
    OR?: JournalLineWhereInput[]
    NOT?: JournalLineWhereInput | JournalLineWhereInput[]
    journalId?: StringFilter<"JournalLine"> | string
    accountId?: StringFilter<"JournalLine"> | string
    debit?: DecimalFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string
    refType?: StringNullableFilter<"JournalLine"> | string | null
    refId?: StringNullableFilter<"JournalLine"> | string | null
    journal?: XOR<JournalRelationFilter, JournalWhereInput>
    account?: XOR<ChartOfAccountRelationFilter, ChartOfAccountWhereInput>
  }, "id">

  export type JournalLineOrderByWithAggregationInput = {
    id?: SortOrder
    journalId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    refType?: SortOrderInput | SortOrder
    refId?: SortOrderInput | SortOrder
    _count?: JournalLineCountOrderByAggregateInput
    _avg?: JournalLineAvgOrderByAggregateInput
    _max?: JournalLineMaxOrderByAggregateInput
    _min?: JournalLineMinOrderByAggregateInput
    _sum?: JournalLineSumOrderByAggregateInput
  }

  export type JournalLineScalarWhereWithAggregatesInput = {
    AND?: JournalLineScalarWhereWithAggregatesInput | JournalLineScalarWhereWithAggregatesInput[]
    OR?: JournalLineScalarWhereWithAggregatesInput[]
    NOT?: JournalLineScalarWhereWithAggregatesInput | JournalLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JournalLine"> | string
    journalId?: StringWithAggregatesFilter<"JournalLine"> | string
    accountId?: StringWithAggregatesFilter<"JournalLine"> | string
    debit?: DecimalWithAggregatesFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalWithAggregatesFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string
    refType?: StringNullableWithAggregatesFilter<"JournalLine"> | string | null
    refId?: StringNullableWithAggregatesFilter<"JournalLine"> | string | null
  }

  export type PolicyWhereInput = {
    AND?: PolicyWhereInput | PolicyWhereInput[]
    OR?: PolicyWhereInput[]
    NOT?: PolicyWhereInput | PolicyWhereInput[]
    id?: StringFilter<"Policy"> | string
    key?: StringFilter<"Policy"> | string
    valueJson?: JsonFilter<"Policy">
    createdAt?: DateTimeFilter<"Policy"> | Date | string
    updatedAt?: DateTimeFilter<"Policy"> | Date | string
  }

  export type PolicyOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    valueJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: PolicyWhereInput | PolicyWhereInput[]
    OR?: PolicyWhereInput[]
    NOT?: PolicyWhereInput | PolicyWhereInput[]
    valueJson?: JsonFilter<"Policy">
    createdAt?: DateTimeFilter<"Policy"> | Date | string
    updatedAt?: DateTimeFilter<"Policy"> | Date | string
  }, "id" | "key">

  export type PolicyOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    valueJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PolicyCountOrderByAggregateInput
    _max?: PolicyMaxOrderByAggregateInput
    _min?: PolicyMinOrderByAggregateInput
  }

  export type PolicyScalarWhereWithAggregatesInput = {
    AND?: PolicyScalarWhereWithAggregatesInput | PolicyScalarWhereWithAggregatesInput[]
    OR?: PolicyScalarWhereWithAggregatesInput[]
    NOT?: PolicyScalarWhereWithAggregatesInput | PolicyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Policy"> | string
    key?: StringWithAggregatesFilter<"Policy"> | string
    valueJson?: JsonWithAggregatesFilter<"Policy">
    createdAt?: DateTimeWithAggregatesFilter<"Policy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Policy"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    beforeJson?: JsonNullableFilter<"AuditLog">
    afterJson?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    beforeJson?: SortOrderInput | SortOrder
    afterJson?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    beforeJson?: JsonNullableFilter<"AuditLog">
    afterJson?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    beforeJson?: SortOrderInput | SortOrder
    afterJson?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    beforeJson?: JsonNullableWithAggregatesFilter<"AuditLog">
    afterJson?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type CashAccountWhereInput = {
    AND?: CashAccountWhereInput | CashAccountWhereInput[]
    OR?: CashAccountWhereInput[]
    NOT?: CashAccountWhereInput | CashAccountWhereInput[]
    id?: StringFilter<"CashAccount"> | string
    code?: StringFilter<"CashAccount"> | string
    name?: StringFilter<"CashAccount"> | string
    accountType?: StringFilter<"CashAccount"> | string
    accountNumber?: StringNullableFilter<"CashAccount"> | string | null
    glAccountId?: StringNullableFilter<"CashAccount"> | string | null
    bankName?: StringNullableFilter<"CashAccount"> | string | null
    balance?: DecimalFilter<"CashAccount"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"CashAccount"> | boolean
    createdAt?: DateTimeFilter<"CashAccount"> | Date | string
    chartOfAccountId?: StringNullableFilter<"CashAccount"> | string | null
    cashTransactions?: CashTransactionListRelationFilter
    salesReceipts?: SalesReceiptListRelationFilter
    purchasePayments?: PurchasePaymentListRelationFilter
    chartOfAccount?: XOR<ChartOfAccountNullableRelationFilter, ChartOfAccountWhereInput> | null
  }

  export type CashAccountOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    accountType?: SortOrder
    accountNumber?: SortOrderInput | SortOrder
    glAccountId?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    balance?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    chartOfAccountId?: SortOrderInput | SortOrder
    cashTransactions?: CashTransactionOrderByRelationAggregateInput
    salesReceipts?: SalesReceiptOrderByRelationAggregateInput
    purchasePayments?: PurchasePaymentOrderByRelationAggregateInput
    chartOfAccount?: ChartOfAccountOrderByWithRelationInput
  }

  export type CashAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CashAccountWhereInput | CashAccountWhereInput[]
    OR?: CashAccountWhereInput[]
    NOT?: CashAccountWhereInput | CashAccountWhereInput[]
    name?: StringFilter<"CashAccount"> | string
    accountType?: StringFilter<"CashAccount"> | string
    accountNumber?: StringNullableFilter<"CashAccount"> | string | null
    glAccountId?: StringNullableFilter<"CashAccount"> | string | null
    bankName?: StringNullableFilter<"CashAccount"> | string | null
    balance?: DecimalFilter<"CashAccount"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"CashAccount"> | boolean
    createdAt?: DateTimeFilter<"CashAccount"> | Date | string
    chartOfAccountId?: StringNullableFilter<"CashAccount"> | string | null
    cashTransactions?: CashTransactionListRelationFilter
    salesReceipts?: SalesReceiptListRelationFilter
    purchasePayments?: PurchasePaymentListRelationFilter
    chartOfAccount?: XOR<ChartOfAccountNullableRelationFilter, ChartOfAccountWhereInput> | null
  }, "id" | "code">

  export type CashAccountOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    accountType?: SortOrder
    accountNumber?: SortOrderInput | SortOrder
    glAccountId?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    balance?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    chartOfAccountId?: SortOrderInput | SortOrder
    _count?: CashAccountCountOrderByAggregateInput
    _avg?: CashAccountAvgOrderByAggregateInput
    _max?: CashAccountMaxOrderByAggregateInput
    _min?: CashAccountMinOrderByAggregateInput
    _sum?: CashAccountSumOrderByAggregateInput
  }

  export type CashAccountScalarWhereWithAggregatesInput = {
    AND?: CashAccountScalarWhereWithAggregatesInput | CashAccountScalarWhereWithAggregatesInput[]
    OR?: CashAccountScalarWhereWithAggregatesInput[]
    NOT?: CashAccountScalarWhereWithAggregatesInput | CashAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CashAccount"> | string
    code?: StringWithAggregatesFilter<"CashAccount"> | string
    name?: StringWithAggregatesFilter<"CashAccount"> | string
    accountType?: StringWithAggregatesFilter<"CashAccount"> | string
    accountNumber?: StringNullableWithAggregatesFilter<"CashAccount"> | string | null
    glAccountId?: StringNullableWithAggregatesFilter<"CashAccount"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"CashAccount"> | string | null
    balance?: DecimalWithAggregatesFilter<"CashAccount"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolWithAggregatesFilter<"CashAccount"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CashAccount"> | Date | string
    chartOfAccountId?: StringNullableWithAggregatesFilter<"CashAccount"> | string | null
  }

  export type CashTransactionWhereInput = {
    AND?: CashTransactionWhereInput | CashTransactionWhereInput[]
    OR?: CashTransactionWhereInput[]
    NOT?: CashTransactionWhereInput | CashTransactionWhereInput[]
    id?: StringFilter<"CashTransaction"> | string
    transactionNo?: StringFilter<"CashTransaction"> | string
    cashAccountId?: StringFilter<"CashTransaction"> | string
    glAccountId?: StringNullableFilter<"CashTransaction"> | string | null
    contraAccountId?: StringNullableFilter<"CashTransaction"> | string | null
    transactionType?: StringFilter<"CashTransaction"> | string
    amount?: DecimalFilter<"CashTransaction"> | Decimal | DecimalJsLike | number | string
    description?: StringFilter<"CashTransaction"> | string
    refType?: StringNullableFilter<"CashTransaction"> | string | null
    refId?: StringNullableFilter<"CashTransaction"> | string | null
    transactionDate?: DateTimeFilter<"CashTransaction"> | Date | string
    isReconciled?: BoolFilter<"CashTransaction"> | boolean
    reconciledAt?: DateTimeNullableFilter<"CashTransaction"> | Date | string | null
    userId?: StringFilter<"CashTransaction"> | string
    createdAt?: DateTimeFilter<"CashTransaction"> | Date | string
    reference?: StringFilter<"CashTransaction"> | string
    cashAccount?: XOR<CashAccountRelationFilter, CashAccountWhereInput>
    glAccount?: XOR<ChartOfAccountNullableRelationFilter, ChartOfAccountWhereInput> | null
    contraAccount?: XOR<ChartOfAccountNullableRelationFilter, ChartOfAccountWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CashTransactionOrderByWithRelationInput = {
    id?: SortOrder
    transactionNo?: SortOrder
    cashAccountId?: SortOrder
    glAccountId?: SortOrderInput | SortOrder
    contraAccountId?: SortOrderInput | SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    refType?: SortOrderInput | SortOrder
    refId?: SortOrderInput | SortOrder
    transactionDate?: SortOrder
    isReconciled?: SortOrder
    reconciledAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    reference?: SortOrder
    cashAccount?: CashAccountOrderByWithRelationInput
    glAccount?: ChartOfAccountOrderByWithRelationInput
    contraAccount?: ChartOfAccountOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CashTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionNo?: string
    AND?: CashTransactionWhereInput | CashTransactionWhereInput[]
    OR?: CashTransactionWhereInput[]
    NOT?: CashTransactionWhereInput | CashTransactionWhereInput[]
    cashAccountId?: StringFilter<"CashTransaction"> | string
    glAccountId?: StringNullableFilter<"CashTransaction"> | string | null
    contraAccountId?: StringNullableFilter<"CashTransaction"> | string | null
    transactionType?: StringFilter<"CashTransaction"> | string
    amount?: DecimalFilter<"CashTransaction"> | Decimal | DecimalJsLike | number | string
    description?: StringFilter<"CashTransaction"> | string
    refType?: StringNullableFilter<"CashTransaction"> | string | null
    refId?: StringNullableFilter<"CashTransaction"> | string | null
    transactionDate?: DateTimeFilter<"CashTransaction"> | Date | string
    isReconciled?: BoolFilter<"CashTransaction"> | boolean
    reconciledAt?: DateTimeNullableFilter<"CashTransaction"> | Date | string | null
    userId?: StringFilter<"CashTransaction"> | string
    createdAt?: DateTimeFilter<"CashTransaction"> | Date | string
    reference?: StringFilter<"CashTransaction"> | string
    cashAccount?: XOR<CashAccountRelationFilter, CashAccountWhereInput>
    glAccount?: XOR<ChartOfAccountNullableRelationFilter, ChartOfAccountWhereInput> | null
    contraAccount?: XOR<ChartOfAccountNullableRelationFilter, ChartOfAccountWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "transactionNo">

  export type CashTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    transactionNo?: SortOrder
    cashAccountId?: SortOrder
    glAccountId?: SortOrderInput | SortOrder
    contraAccountId?: SortOrderInput | SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    refType?: SortOrderInput | SortOrder
    refId?: SortOrderInput | SortOrder
    transactionDate?: SortOrder
    isReconciled?: SortOrder
    reconciledAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    reference?: SortOrder
    _count?: CashTransactionCountOrderByAggregateInput
    _avg?: CashTransactionAvgOrderByAggregateInput
    _max?: CashTransactionMaxOrderByAggregateInput
    _min?: CashTransactionMinOrderByAggregateInput
    _sum?: CashTransactionSumOrderByAggregateInput
  }

  export type CashTransactionScalarWhereWithAggregatesInput = {
    AND?: CashTransactionScalarWhereWithAggregatesInput | CashTransactionScalarWhereWithAggregatesInput[]
    OR?: CashTransactionScalarWhereWithAggregatesInput[]
    NOT?: CashTransactionScalarWhereWithAggregatesInput | CashTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CashTransaction"> | string
    transactionNo?: StringWithAggregatesFilter<"CashTransaction"> | string
    cashAccountId?: StringWithAggregatesFilter<"CashTransaction"> | string
    glAccountId?: StringNullableWithAggregatesFilter<"CashTransaction"> | string | null
    contraAccountId?: StringNullableWithAggregatesFilter<"CashTransaction"> | string | null
    transactionType?: StringWithAggregatesFilter<"CashTransaction"> | string
    amount?: DecimalWithAggregatesFilter<"CashTransaction"> | Decimal | DecimalJsLike | number | string
    description?: StringWithAggregatesFilter<"CashTransaction"> | string
    refType?: StringNullableWithAggregatesFilter<"CashTransaction"> | string | null
    refId?: StringNullableWithAggregatesFilter<"CashTransaction"> | string | null
    transactionDate?: DateTimeWithAggregatesFilter<"CashTransaction"> | Date | string
    isReconciled?: BoolWithAggregatesFilter<"CashTransaction"> | boolean
    reconciledAt?: DateTimeNullableWithAggregatesFilter<"CashTransaction"> | Date | string | null
    userId?: StringWithAggregatesFilter<"CashTransaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CashTransaction"> | Date | string
    reference?: StringWithAggregatesFilter<"CashTransaction"> | string
  }

  export type SalesReceiptWhereInput = {
    AND?: SalesReceiptWhereInput | SalesReceiptWhereInput[]
    OR?: SalesReceiptWhereInput[]
    NOT?: SalesReceiptWhereInput | SalesReceiptWhereInput[]
    id?: StringFilter<"SalesReceipt"> | string
    receiptNo?: StringFilter<"SalesReceipt"> | string
    saleId?: StringFilter<"SalesReceipt"> | string
    customerId?: StringFilter<"SalesReceipt"> | string
    cashAccountId?: StringFilter<"SalesReceipt"> | string
    amountReceived?: DecimalFilter<"SalesReceipt"> | Decimal | DecimalJsLike | number | string
    receiptDate?: DateTimeFilter<"SalesReceipt"> | Date | string
    reference?: StringNullableFilter<"SalesReceipt"> | string | null
    notes?: StringNullableFilter<"SalesReceipt"> | string | null
    userId?: StringFilter<"SalesReceipt"> | string
    createdAt?: DateTimeFilter<"SalesReceipt"> | Date | string
    sale?: XOR<SaleRelationFilter, SaleWhereInput>
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    cashAccount?: XOR<CashAccountRelationFilter, CashAccountWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SalesReceiptOrderByWithRelationInput = {
    id?: SortOrder
    receiptNo?: SortOrder
    saleId?: SortOrder
    customerId?: SortOrder
    cashAccountId?: SortOrder
    amountReceived?: SortOrder
    receiptDate?: SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    sale?: SaleOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    cashAccount?: CashAccountOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type SalesReceiptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    receiptNo?: string
    AND?: SalesReceiptWhereInput | SalesReceiptWhereInput[]
    OR?: SalesReceiptWhereInput[]
    NOT?: SalesReceiptWhereInput | SalesReceiptWhereInput[]
    saleId?: StringFilter<"SalesReceipt"> | string
    customerId?: StringFilter<"SalesReceipt"> | string
    cashAccountId?: StringFilter<"SalesReceipt"> | string
    amountReceived?: DecimalFilter<"SalesReceipt"> | Decimal | DecimalJsLike | number | string
    receiptDate?: DateTimeFilter<"SalesReceipt"> | Date | string
    reference?: StringNullableFilter<"SalesReceipt"> | string | null
    notes?: StringNullableFilter<"SalesReceipt"> | string | null
    userId?: StringFilter<"SalesReceipt"> | string
    createdAt?: DateTimeFilter<"SalesReceipt"> | Date | string
    sale?: XOR<SaleRelationFilter, SaleWhereInput>
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    cashAccount?: XOR<CashAccountRelationFilter, CashAccountWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "receiptNo">

  export type SalesReceiptOrderByWithAggregationInput = {
    id?: SortOrder
    receiptNo?: SortOrder
    saleId?: SortOrder
    customerId?: SortOrder
    cashAccountId?: SortOrder
    amountReceived?: SortOrder
    receiptDate?: SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: SalesReceiptCountOrderByAggregateInput
    _avg?: SalesReceiptAvgOrderByAggregateInput
    _max?: SalesReceiptMaxOrderByAggregateInput
    _min?: SalesReceiptMinOrderByAggregateInput
    _sum?: SalesReceiptSumOrderByAggregateInput
  }

  export type SalesReceiptScalarWhereWithAggregatesInput = {
    AND?: SalesReceiptScalarWhereWithAggregatesInput | SalesReceiptScalarWhereWithAggregatesInput[]
    OR?: SalesReceiptScalarWhereWithAggregatesInput[]
    NOT?: SalesReceiptScalarWhereWithAggregatesInput | SalesReceiptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalesReceipt"> | string
    receiptNo?: StringWithAggregatesFilter<"SalesReceipt"> | string
    saleId?: StringWithAggregatesFilter<"SalesReceipt"> | string
    customerId?: StringWithAggregatesFilter<"SalesReceipt"> | string
    cashAccountId?: StringWithAggregatesFilter<"SalesReceipt"> | string
    amountReceived?: DecimalWithAggregatesFilter<"SalesReceipt"> | Decimal | DecimalJsLike | number | string
    receiptDate?: DateTimeWithAggregatesFilter<"SalesReceipt"> | Date | string
    reference?: StringNullableWithAggregatesFilter<"SalesReceipt"> | string | null
    notes?: StringNullableWithAggregatesFilter<"SalesReceipt"> | string | null
    userId?: StringWithAggregatesFilter<"SalesReceipt"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SalesReceipt"> | Date | string
  }

  export type PurchasePaymentWhereInput = {
    AND?: PurchasePaymentWhereInput | PurchasePaymentWhereInput[]
    OR?: PurchasePaymentWhereInput[]
    NOT?: PurchasePaymentWhereInput | PurchasePaymentWhereInput[]
    id?: StringFilter<"PurchasePayment"> | string
    paymentNo?: StringFilter<"PurchasePayment"> | string
    purchaseId?: StringFilter<"PurchasePayment"> | string
    vendorId?: StringFilter<"PurchasePayment"> | string
    cashAccountId?: StringFilter<"PurchasePayment"> | string
    amountPaid?: DecimalFilter<"PurchasePayment"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFilter<"PurchasePayment"> | Date | string
    reference?: StringNullableFilter<"PurchasePayment"> | string | null
    notes?: StringNullableFilter<"PurchasePayment"> | string | null
    userId?: StringFilter<"PurchasePayment"> | string
    createdAt?: DateTimeFilter<"PurchasePayment"> | Date | string
    purchase?: XOR<PurchaseRelationFilter, PurchaseWhereInput>
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    cashAccount?: XOR<CashAccountRelationFilter, CashAccountWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PurchasePaymentOrderByWithRelationInput = {
    id?: SortOrder
    paymentNo?: SortOrder
    purchaseId?: SortOrder
    vendorId?: SortOrder
    cashAccountId?: SortOrder
    amountPaid?: SortOrder
    paymentDate?: SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    purchase?: PurchaseOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
    cashAccount?: CashAccountOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PurchasePaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    paymentNo?: string
    AND?: PurchasePaymentWhereInput | PurchasePaymentWhereInput[]
    OR?: PurchasePaymentWhereInput[]
    NOT?: PurchasePaymentWhereInput | PurchasePaymentWhereInput[]
    purchaseId?: StringFilter<"PurchasePayment"> | string
    vendorId?: StringFilter<"PurchasePayment"> | string
    cashAccountId?: StringFilter<"PurchasePayment"> | string
    amountPaid?: DecimalFilter<"PurchasePayment"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFilter<"PurchasePayment"> | Date | string
    reference?: StringNullableFilter<"PurchasePayment"> | string | null
    notes?: StringNullableFilter<"PurchasePayment"> | string | null
    userId?: StringFilter<"PurchasePayment"> | string
    createdAt?: DateTimeFilter<"PurchasePayment"> | Date | string
    purchase?: XOR<PurchaseRelationFilter, PurchaseWhereInput>
    vendor?: XOR<VendorRelationFilter, VendorWhereInput>
    cashAccount?: XOR<CashAccountRelationFilter, CashAccountWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "paymentNo">

  export type PurchasePaymentOrderByWithAggregationInput = {
    id?: SortOrder
    paymentNo?: SortOrder
    purchaseId?: SortOrder
    vendorId?: SortOrder
    cashAccountId?: SortOrder
    amountPaid?: SortOrder
    paymentDate?: SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: PurchasePaymentCountOrderByAggregateInput
    _avg?: PurchasePaymentAvgOrderByAggregateInput
    _max?: PurchasePaymentMaxOrderByAggregateInput
    _min?: PurchasePaymentMinOrderByAggregateInput
    _sum?: PurchasePaymentSumOrderByAggregateInput
  }

  export type PurchasePaymentScalarWhereWithAggregatesInput = {
    AND?: PurchasePaymentScalarWhereWithAggregatesInput | PurchasePaymentScalarWhereWithAggregatesInput[]
    OR?: PurchasePaymentScalarWhereWithAggregatesInput[]
    NOT?: PurchasePaymentScalarWhereWithAggregatesInput | PurchasePaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchasePayment"> | string
    paymentNo?: StringWithAggregatesFilter<"PurchasePayment"> | string
    purchaseId?: StringWithAggregatesFilter<"PurchasePayment"> | string
    vendorId?: StringWithAggregatesFilter<"PurchasePayment"> | string
    cashAccountId?: StringWithAggregatesFilter<"PurchasePayment"> | string
    amountPaid?: DecimalWithAggregatesFilter<"PurchasePayment"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeWithAggregatesFilter<"PurchasePayment"> | Date | string
    reference?: StringNullableWithAggregatesFilter<"PurchasePayment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"PurchasePayment"> | string | null
    userId?: StringWithAggregatesFilter<"PurchasePayment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PurchasePayment"> | Date | string
  }

  export type SystemSettingWhereInput = {
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    id?: StringFilter<"SystemSetting"> | string
    category?: StringFilter<"SystemSetting"> | string
    key?: StringFilter<"SystemSetting"> | string
    value?: StringNullableFilter<"SystemSetting"> | string | null
    dataType?: StringNullableFilter<"SystemSetting"> | string | null
    description?: StringNullableFilter<"SystemSetting"> | string | null
    updatedBy?: StringNullableFilter<"SystemSetting"> | string | null
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
    createdAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type SystemSettingOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    key?: SortOrder
    value?: SortOrderInput | SortOrder
    dataType?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    updatedByUser?: UserOrderByWithRelationInput
  }

  export type SystemSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    category_key?: SystemSettingCategory_keyCompoundUniqueInput
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    category?: StringFilter<"SystemSetting"> | string
    key?: StringFilter<"SystemSetting"> | string
    value?: StringNullableFilter<"SystemSetting"> | string | null
    dataType?: StringNullableFilter<"SystemSetting"> | string | null
    description?: StringNullableFilter<"SystemSetting"> | string | null
    updatedBy?: StringNullableFilter<"SystemSetting"> | string | null
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
    createdAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedByUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "category_key">

  export type SystemSettingOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    key?: SortOrder
    value?: SortOrderInput | SortOrder
    dataType?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: SystemSettingCountOrderByAggregateInput
    _max?: SystemSettingMaxOrderByAggregateInput
    _min?: SystemSettingMinOrderByAggregateInput
  }

  export type SystemSettingScalarWhereWithAggregatesInput = {
    AND?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    OR?: SystemSettingScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemSetting"> | string
    category?: StringWithAggregatesFilter<"SystemSetting"> | string
    key?: StringWithAggregatesFilter<"SystemSetting"> | string
    value?: StringNullableWithAggregatesFilter<"SystemSetting"> | string | null
    dataType?: StringNullableWithAggregatesFilter<"SystemSetting"> | string | null
    description?: StringNullableWithAggregatesFilter<"SystemSetting"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"SystemSetting"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
  }

  export type FiscalYearWhereInput = {
    AND?: FiscalYearWhereInput | FiscalYearWhereInput[]
    OR?: FiscalYearWhereInput[]
    NOT?: FiscalYearWhereInput | FiscalYearWhereInput[]
    id?: StringFilter<"FiscalYear"> | string
    year?: IntFilter<"FiscalYear"> | number
    startDate?: DateTimeFilter<"FiscalYear"> | Date | string
    endDate?: DateTimeFilter<"FiscalYear"> | Date | string
    isActive?: BoolFilter<"FiscalYear"> | boolean
    createdAt?: DateTimeFilter<"FiscalYear"> | Date | string
    updatedAt?: DateTimeFilter<"FiscalYear"> | Date | string
    periods?: FiscalPeriodListRelationFilter
  }

  export type FiscalYearOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    periods?: FiscalPeriodOrderByRelationAggregateInput
  }

  export type FiscalYearWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FiscalYearWhereInput | FiscalYearWhereInput[]
    OR?: FiscalYearWhereInput[]
    NOT?: FiscalYearWhereInput | FiscalYearWhereInput[]
    year?: IntFilter<"FiscalYear"> | number
    startDate?: DateTimeFilter<"FiscalYear"> | Date | string
    endDate?: DateTimeFilter<"FiscalYear"> | Date | string
    isActive?: BoolFilter<"FiscalYear"> | boolean
    createdAt?: DateTimeFilter<"FiscalYear"> | Date | string
    updatedAt?: DateTimeFilter<"FiscalYear"> | Date | string
    periods?: FiscalPeriodListRelationFilter
  }, "id">

  export type FiscalYearOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FiscalYearCountOrderByAggregateInput
    _avg?: FiscalYearAvgOrderByAggregateInput
    _max?: FiscalYearMaxOrderByAggregateInput
    _min?: FiscalYearMinOrderByAggregateInput
    _sum?: FiscalYearSumOrderByAggregateInput
  }

  export type FiscalYearScalarWhereWithAggregatesInput = {
    AND?: FiscalYearScalarWhereWithAggregatesInput | FiscalYearScalarWhereWithAggregatesInput[]
    OR?: FiscalYearScalarWhereWithAggregatesInput[]
    NOT?: FiscalYearScalarWhereWithAggregatesInput | FiscalYearScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FiscalYear"> | string
    year?: IntWithAggregatesFilter<"FiscalYear"> | number
    startDate?: DateTimeWithAggregatesFilter<"FiscalYear"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"FiscalYear"> | Date | string
    isActive?: BoolWithAggregatesFilter<"FiscalYear"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FiscalYear"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FiscalYear"> | Date | string
  }

  export type FiscalPeriodWhereInput = {
    AND?: FiscalPeriodWhereInput | FiscalPeriodWhereInput[]
    OR?: FiscalPeriodWhereInput[]
    NOT?: FiscalPeriodWhereInput | FiscalPeriodWhereInput[]
    id?: StringFilter<"FiscalPeriod"> | string
    fiscalYearId?: StringFilter<"FiscalPeriod"> | string
    periodNumber?: IntFilter<"FiscalPeriod"> | number
    name?: StringFilter<"FiscalPeriod"> | string
    startDate?: DateTimeFilter<"FiscalPeriod"> | Date | string
    endDate?: DateTimeFilter<"FiscalPeriod"> | Date | string
    isActive?: BoolFilter<"FiscalPeriod"> | boolean
    isClosed?: BoolFilter<"FiscalPeriod"> | boolean
    createdAt?: DateTimeFilter<"FiscalPeriod"> | Date | string
    updatedAt?: DateTimeFilter<"FiscalPeriod"> | Date | string
    fiscalYear?: XOR<FiscalYearRelationFilter, FiscalYearWhereInput>
  }

  export type FiscalPeriodOrderByWithRelationInput = {
    id?: SortOrder
    fiscalYearId?: SortOrder
    periodNumber?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fiscalYear?: FiscalYearOrderByWithRelationInput
  }

  export type FiscalPeriodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FiscalPeriodWhereInput | FiscalPeriodWhereInput[]
    OR?: FiscalPeriodWhereInput[]
    NOT?: FiscalPeriodWhereInput | FiscalPeriodWhereInput[]
    fiscalYearId?: StringFilter<"FiscalPeriod"> | string
    periodNumber?: IntFilter<"FiscalPeriod"> | number
    name?: StringFilter<"FiscalPeriod"> | string
    startDate?: DateTimeFilter<"FiscalPeriod"> | Date | string
    endDate?: DateTimeFilter<"FiscalPeriod"> | Date | string
    isActive?: BoolFilter<"FiscalPeriod"> | boolean
    isClosed?: BoolFilter<"FiscalPeriod"> | boolean
    createdAt?: DateTimeFilter<"FiscalPeriod"> | Date | string
    updatedAt?: DateTimeFilter<"FiscalPeriod"> | Date | string
    fiscalYear?: XOR<FiscalYearRelationFilter, FiscalYearWhereInput>
  }, "id">

  export type FiscalPeriodOrderByWithAggregationInput = {
    id?: SortOrder
    fiscalYearId?: SortOrder
    periodNumber?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FiscalPeriodCountOrderByAggregateInput
    _avg?: FiscalPeriodAvgOrderByAggregateInput
    _max?: FiscalPeriodMaxOrderByAggregateInput
    _min?: FiscalPeriodMinOrderByAggregateInput
    _sum?: FiscalPeriodSumOrderByAggregateInput
  }

  export type FiscalPeriodScalarWhereWithAggregatesInput = {
    AND?: FiscalPeriodScalarWhereWithAggregatesInput | FiscalPeriodScalarWhereWithAggregatesInput[]
    OR?: FiscalPeriodScalarWhereWithAggregatesInput[]
    NOT?: FiscalPeriodScalarWhereWithAggregatesInput | FiscalPeriodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FiscalPeriod"> | string
    fiscalYearId?: StringWithAggregatesFilter<"FiscalPeriod"> | string
    periodNumber?: IntWithAggregatesFilter<"FiscalPeriod"> | number
    name?: StringWithAggregatesFilter<"FiscalPeriod"> | string
    startDate?: DateTimeWithAggregatesFilter<"FiscalPeriod"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"FiscalPeriod"> | Date | string
    isActive?: BoolWithAggregatesFilter<"FiscalPeriod"> | boolean
    isClosed?: BoolWithAggregatesFilter<"FiscalPeriod"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FiscalPeriod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FiscalPeriod"> | Date | string
  }

  export type ApprovalWorkflowWhereInput = {
    AND?: ApprovalWorkflowWhereInput | ApprovalWorkflowWhereInput[]
    OR?: ApprovalWorkflowWhereInput[]
    NOT?: ApprovalWorkflowWhereInput | ApprovalWorkflowWhereInput[]
    id?: StringFilter<"ApprovalWorkflow"> | string
    name?: StringFilter<"ApprovalWorkflow"> | string
    entity?: StringFilter<"ApprovalWorkflow"> | string
    minAmount?: DecimalNullableFilter<"ApprovalWorkflow"> | Decimal | DecimalJsLike | number | string | null
    maxAmount?: DecimalNullableFilter<"ApprovalWorkflow"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"ApprovalWorkflow"> | boolean
    createdAt?: DateTimeFilter<"ApprovalWorkflow"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalWorkflow"> | Date | string
    steps?: ApprovalStepListRelationFilter
    ApprovalRequest?: ApprovalRequestListRelationFilter
  }

  export type ApprovalWorkflowOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    entity?: SortOrder
    minAmount?: SortOrderInput | SortOrder
    maxAmount?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    steps?: ApprovalStepOrderByRelationAggregateInput
    ApprovalRequest?: ApprovalRequestOrderByRelationAggregateInput
  }

  export type ApprovalWorkflowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApprovalWorkflowWhereInput | ApprovalWorkflowWhereInput[]
    OR?: ApprovalWorkflowWhereInput[]
    NOT?: ApprovalWorkflowWhereInput | ApprovalWorkflowWhereInput[]
    name?: StringFilter<"ApprovalWorkflow"> | string
    entity?: StringFilter<"ApprovalWorkflow"> | string
    minAmount?: DecimalNullableFilter<"ApprovalWorkflow"> | Decimal | DecimalJsLike | number | string | null
    maxAmount?: DecimalNullableFilter<"ApprovalWorkflow"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"ApprovalWorkflow"> | boolean
    createdAt?: DateTimeFilter<"ApprovalWorkflow"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalWorkflow"> | Date | string
    steps?: ApprovalStepListRelationFilter
    ApprovalRequest?: ApprovalRequestListRelationFilter
  }, "id">

  export type ApprovalWorkflowOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    entity?: SortOrder
    minAmount?: SortOrderInput | SortOrder
    maxAmount?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApprovalWorkflowCountOrderByAggregateInput
    _avg?: ApprovalWorkflowAvgOrderByAggregateInput
    _max?: ApprovalWorkflowMaxOrderByAggregateInput
    _min?: ApprovalWorkflowMinOrderByAggregateInput
    _sum?: ApprovalWorkflowSumOrderByAggregateInput
  }

  export type ApprovalWorkflowScalarWhereWithAggregatesInput = {
    AND?: ApprovalWorkflowScalarWhereWithAggregatesInput | ApprovalWorkflowScalarWhereWithAggregatesInput[]
    OR?: ApprovalWorkflowScalarWhereWithAggregatesInput[]
    NOT?: ApprovalWorkflowScalarWhereWithAggregatesInput | ApprovalWorkflowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApprovalWorkflow"> | string
    name?: StringWithAggregatesFilter<"ApprovalWorkflow"> | string
    entity?: StringWithAggregatesFilter<"ApprovalWorkflow"> | string
    minAmount?: DecimalNullableWithAggregatesFilter<"ApprovalWorkflow"> | Decimal | DecimalJsLike | number | string | null
    maxAmount?: DecimalNullableWithAggregatesFilter<"ApprovalWorkflow"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolWithAggregatesFilter<"ApprovalWorkflow"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ApprovalWorkflow"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApprovalWorkflow"> | Date | string
  }

  export type ApprovalStepWhereInput = {
    AND?: ApprovalStepWhereInput | ApprovalStepWhereInput[]
    OR?: ApprovalStepWhereInput[]
    NOT?: ApprovalStepWhereInput | ApprovalStepWhereInput[]
    id?: StringFilter<"ApprovalStep"> | string
    workflowId?: StringFilter<"ApprovalStep"> | string
    stepOrder?: IntFilter<"ApprovalStep"> | number
    name?: StringFilter<"ApprovalStep"> | string
    roleId?: StringFilter<"ApprovalStep"> | string
    isRequired?: BoolFilter<"ApprovalStep"> | boolean
    createdAt?: DateTimeFilter<"ApprovalStep"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalStep"> | Date | string
    workflow?: XOR<ApprovalWorkflowRelationFilter, ApprovalWorkflowWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    ApprovalRequest?: ApprovalRequestListRelationFilter
    ApprovalAction?: ApprovalActionListRelationFilter
  }

  export type ApprovalStepOrderByWithRelationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    stepOrder?: SortOrder
    name?: SortOrder
    roleId?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workflow?: ApprovalWorkflowOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
    ApprovalRequest?: ApprovalRequestOrderByRelationAggregateInput
    ApprovalAction?: ApprovalActionOrderByRelationAggregateInput
  }

  export type ApprovalStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApprovalStepWhereInput | ApprovalStepWhereInput[]
    OR?: ApprovalStepWhereInput[]
    NOT?: ApprovalStepWhereInput | ApprovalStepWhereInput[]
    workflowId?: StringFilter<"ApprovalStep"> | string
    stepOrder?: IntFilter<"ApprovalStep"> | number
    name?: StringFilter<"ApprovalStep"> | string
    roleId?: StringFilter<"ApprovalStep"> | string
    isRequired?: BoolFilter<"ApprovalStep"> | boolean
    createdAt?: DateTimeFilter<"ApprovalStep"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalStep"> | Date | string
    workflow?: XOR<ApprovalWorkflowRelationFilter, ApprovalWorkflowWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    ApprovalRequest?: ApprovalRequestListRelationFilter
    ApprovalAction?: ApprovalActionListRelationFilter
  }, "id">

  export type ApprovalStepOrderByWithAggregationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    stepOrder?: SortOrder
    name?: SortOrder
    roleId?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApprovalStepCountOrderByAggregateInput
    _avg?: ApprovalStepAvgOrderByAggregateInput
    _max?: ApprovalStepMaxOrderByAggregateInput
    _min?: ApprovalStepMinOrderByAggregateInput
    _sum?: ApprovalStepSumOrderByAggregateInput
  }

  export type ApprovalStepScalarWhereWithAggregatesInput = {
    AND?: ApprovalStepScalarWhereWithAggregatesInput | ApprovalStepScalarWhereWithAggregatesInput[]
    OR?: ApprovalStepScalarWhereWithAggregatesInput[]
    NOT?: ApprovalStepScalarWhereWithAggregatesInput | ApprovalStepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApprovalStep"> | string
    workflowId?: StringWithAggregatesFilter<"ApprovalStep"> | string
    stepOrder?: IntWithAggregatesFilter<"ApprovalStep"> | number
    name?: StringWithAggregatesFilter<"ApprovalStep"> | string
    roleId?: StringWithAggregatesFilter<"ApprovalStep"> | string
    isRequired?: BoolWithAggregatesFilter<"ApprovalStep"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ApprovalStep"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApprovalStep"> | Date | string
  }

  export type ApprovalRequestWhereInput = {
    AND?: ApprovalRequestWhereInput | ApprovalRequestWhereInput[]
    OR?: ApprovalRequestWhereInput[]
    NOT?: ApprovalRequestWhereInput | ApprovalRequestWhereInput[]
    id?: StringFilter<"ApprovalRequest"> | string
    workflowId?: StringFilter<"ApprovalRequest"> | string
    entityType?: StringFilter<"ApprovalRequest"> | string
    entityId?: StringFilter<"ApprovalRequest"> | string
    requestedBy?: StringFilter<"ApprovalRequest"> | string
    currentStepId?: StringNullableFilter<"ApprovalRequest"> | string | null
    status?: StringFilter<"ApprovalRequest"> | string
    requestedAt?: DateTimeFilter<"ApprovalRequest"> | Date | string
    completedAt?: DateTimeNullableFilter<"ApprovalRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"ApprovalRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalRequest"> | Date | string
    workflow?: XOR<ApprovalWorkflowRelationFilter, ApprovalWorkflowWhereInput>
    requestedByUser?: XOR<UserRelationFilter, UserWhereInput>
    currentStep?: XOR<ApprovalStepNullableRelationFilter, ApprovalStepWhereInput> | null
    actions?: ApprovalActionListRelationFilter
  }

  export type ApprovalRequestOrderByWithRelationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    requestedBy?: SortOrder
    currentStepId?: SortOrderInput | SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workflow?: ApprovalWorkflowOrderByWithRelationInput
    requestedByUser?: UserOrderByWithRelationInput
    currentStep?: ApprovalStepOrderByWithRelationInput
    actions?: ApprovalActionOrderByRelationAggregateInput
  }

  export type ApprovalRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApprovalRequestWhereInput | ApprovalRequestWhereInput[]
    OR?: ApprovalRequestWhereInput[]
    NOT?: ApprovalRequestWhereInput | ApprovalRequestWhereInput[]
    workflowId?: StringFilter<"ApprovalRequest"> | string
    entityType?: StringFilter<"ApprovalRequest"> | string
    entityId?: StringFilter<"ApprovalRequest"> | string
    requestedBy?: StringFilter<"ApprovalRequest"> | string
    currentStepId?: StringNullableFilter<"ApprovalRequest"> | string | null
    status?: StringFilter<"ApprovalRequest"> | string
    requestedAt?: DateTimeFilter<"ApprovalRequest"> | Date | string
    completedAt?: DateTimeNullableFilter<"ApprovalRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"ApprovalRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalRequest"> | Date | string
    workflow?: XOR<ApprovalWorkflowRelationFilter, ApprovalWorkflowWhereInput>
    requestedByUser?: XOR<UserRelationFilter, UserWhereInput>
    currentStep?: XOR<ApprovalStepNullableRelationFilter, ApprovalStepWhereInput> | null
    actions?: ApprovalActionListRelationFilter
  }, "id">

  export type ApprovalRequestOrderByWithAggregationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    requestedBy?: SortOrder
    currentStepId?: SortOrderInput | SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApprovalRequestCountOrderByAggregateInput
    _max?: ApprovalRequestMaxOrderByAggregateInput
    _min?: ApprovalRequestMinOrderByAggregateInput
  }

  export type ApprovalRequestScalarWhereWithAggregatesInput = {
    AND?: ApprovalRequestScalarWhereWithAggregatesInput | ApprovalRequestScalarWhereWithAggregatesInput[]
    OR?: ApprovalRequestScalarWhereWithAggregatesInput[]
    NOT?: ApprovalRequestScalarWhereWithAggregatesInput | ApprovalRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApprovalRequest"> | string
    workflowId?: StringWithAggregatesFilter<"ApprovalRequest"> | string
    entityType?: StringWithAggregatesFilter<"ApprovalRequest"> | string
    entityId?: StringWithAggregatesFilter<"ApprovalRequest"> | string
    requestedBy?: StringWithAggregatesFilter<"ApprovalRequest"> | string
    currentStepId?: StringNullableWithAggregatesFilter<"ApprovalRequest"> | string | null
    status?: StringWithAggregatesFilter<"ApprovalRequest"> | string
    requestedAt?: DateTimeWithAggregatesFilter<"ApprovalRequest"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"ApprovalRequest"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ApprovalRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApprovalRequest"> | Date | string
  }

  export type ApprovalActionWhereInput = {
    AND?: ApprovalActionWhereInput | ApprovalActionWhereInput[]
    OR?: ApprovalActionWhereInput[]
    NOT?: ApprovalActionWhereInput | ApprovalActionWhereInput[]
    id?: StringFilter<"ApprovalAction"> | string
    requestId?: StringFilter<"ApprovalAction"> | string
    stepId?: StringFilter<"ApprovalAction"> | string
    userId?: StringFilter<"ApprovalAction"> | string
    action?: StringFilter<"ApprovalAction"> | string
    comments?: StringNullableFilter<"ApprovalAction"> | string | null
    actionDate?: DateTimeFilter<"ApprovalAction"> | Date | string
    createdAt?: DateTimeFilter<"ApprovalAction"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalAction"> | Date | string
    request?: XOR<ApprovalRequestRelationFilter, ApprovalRequestWhereInput>
    step?: XOR<ApprovalStepRelationFilter, ApprovalStepWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ApprovalActionOrderByWithRelationInput = {
    id?: SortOrder
    requestId?: SortOrder
    stepId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    comments?: SortOrderInput | SortOrder
    actionDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    request?: ApprovalRequestOrderByWithRelationInput
    step?: ApprovalStepOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ApprovalActionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApprovalActionWhereInput | ApprovalActionWhereInput[]
    OR?: ApprovalActionWhereInput[]
    NOT?: ApprovalActionWhereInput | ApprovalActionWhereInput[]
    requestId?: StringFilter<"ApprovalAction"> | string
    stepId?: StringFilter<"ApprovalAction"> | string
    userId?: StringFilter<"ApprovalAction"> | string
    action?: StringFilter<"ApprovalAction"> | string
    comments?: StringNullableFilter<"ApprovalAction"> | string | null
    actionDate?: DateTimeFilter<"ApprovalAction"> | Date | string
    createdAt?: DateTimeFilter<"ApprovalAction"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalAction"> | Date | string
    request?: XOR<ApprovalRequestRelationFilter, ApprovalRequestWhereInput>
    step?: XOR<ApprovalStepRelationFilter, ApprovalStepWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ApprovalActionOrderByWithAggregationInput = {
    id?: SortOrder
    requestId?: SortOrder
    stepId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    comments?: SortOrderInput | SortOrder
    actionDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApprovalActionCountOrderByAggregateInput
    _max?: ApprovalActionMaxOrderByAggregateInput
    _min?: ApprovalActionMinOrderByAggregateInput
  }

  export type ApprovalActionScalarWhereWithAggregatesInput = {
    AND?: ApprovalActionScalarWhereWithAggregatesInput | ApprovalActionScalarWhereWithAggregatesInput[]
    OR?: ApprovalActionScalarWhereWithAggregatesInput[]
    NOT?: ApprovalActionScalarWhereWithAggregatesInput | ApprovalActionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApprovalAction"> | string
    requestId?: StringWithAggregatesFilter<"ApprovalAction"> | string
    stepId?: StringWithAggregatesFilter<"ApprovalAction"> | string
    userId?: StringWithAggregatesFilter<"ApprovalAction"> | string
    action?: StringWithAggregatesFilter<"ApprovalAction"> | string
    comments?: StringNullableWithAggregatesFilter<"ApprovalAction"> | string | null
    actionDate?: DateTimeWithAggregatesFilter<"ApprovalAction"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ApprovalAction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApprovalAction"> | Date | string
  }

  export type AssetCategoryWhereInput = {
    AND?: AssetCategoryWhereInput | AssetCategoryWhereInput[]
    OR?: AssetCategoryWhereInput[]
    NOT?: AssetCategoryWhereInput | AssetCategoryWhereInput[]
    id?: StringFilter<"AssetCategory"> | string
    code?: StringFilter<"AssetCategory"> | string
    name?: StringFilter<"AssetCategory"> | string
    description?: StringNullableFilter<"AssetCategory"> | string | null
    depreciationMethod?: StringFilter<"AssetCategory"> | string
    usefulLife?: IntFilter<"AssetCategory"> | number
    residualValue?: DecimalFilter<"AssetCategory"> | Decimal | DecimalJsLike | number | string
    glAssetAccountId?: StringFilter<"AssetCategory"> | string
    glDepreciationAccountId?: StringFilter<"AssetCategory"> | string
    glAccumulatedDepreciationAccountId?: StringFilter<"AssetCategory"> | string
    isActive?: BoolFilter<"AssetCategory"> | boolean
    createdAt?: DateTimeFilter<"AssetCategory"> | Date | string
    assets?: AssetListRelationFilter
    glAssetAccount?: XOR<ChartOfAccountRelationFilter, ChartOfAccountWhereInput>
    glDepreciationAccount?: XOR<ChartOfAccountRelationFilter, ChartOfAccountWhereInput>
    glAccumulatedDepreciationAccount?: XOR<ChartOfAccountRelationFilter, ChartOfAccountWhereInput>
  }

  export type AssetCategoryOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    depreciationMethod?: SortOrder
    usefulLife?: SortOrder
    residualValue?: SortOrder
    glAssetAccountId?: SortOrder
    glDepreciationAccountId?: SortOrder
    glAccumulatedDepreciationAccountId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    assets?: AssetOrderByRelationAggregateInput
    glAssetAccount?: ChartOfAccountOrderByWithRelationInput
    glDepreciationAccount?: ChartOfAccountOrderByWithRelationInput
    glAccumulatedDepreciationAccount?: ChartOfAccountOrderByWithRelationInput
  }

  export type AssetCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: AssetCategoryWhereInput | AssetCategoryWhereInput[]
    OR?: AssetCategoryWhereInput[]
    NOT?: AssetCategoryWhereInput | AssetCategoryWhereInput[]
    name?: StringFilter<"AssetCategory"> | string
    description?: StringNullableFilter<"AssetCategory"> | string | null
    depreciationMethod?: StringFilter<"AssetCategory"> | string
    usefulLife?: IntFilter<"AssetCategory"> | number
    residualValue?: DecimalFilter<"AssetCategory"> | Decimal | DecimalJsLike | number | string
    glAssetAccountId?: StringFilter<"AssetCategory"> | string
    glDepreciationAccountId?: StringFilter<"AssetCategory"> | string
    glAccumulatedDepreciationAccountId?: StringFilter<"AssetCategory"> | string
    isActive?: BoolFilter<"AssetCategory"> | boolean
    createdAt?: DateTimeFilter<"AssetCategory"> | Date | string
    assets?: AssetListRelationFilter
    glAssetAccount?: XOR<ChartOfAccountRelationFilter, ChartOfAccountWhereInput>
    glDepreciationAccount?: XOR<ChartOfAccountRelationFilter, ChartOfAccountWhereInput>
    glAccumulatedDepreciationAccount?: XOR<ChartOfAccountRelationFilter, ChartOfAccountWhereInput>
  }, "id" | "code">

  export type AssetCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    depreciationMethod?: SortOrder
    usefulLife?: SortOrder
    residualValue?: SortOrder
    glAssetAccountId?: SortOrder
    glDepreciationAccountId?: SortOrder
    glAccumulatedDepreciationAccountId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: AssetCategoryCountOrderByAggregateInput
    _avg?: AssetCategoryAvgOrderByAggregateInput
    _max?: AssetCategoryMaxOrderByAggregateInput
    _min?: AssetCategoryMinOrderByAggregateInput
    _sum?: AssetCategorySumOrderByAggregateInput
  }

  export type AssetCategoryScalarWhereWithAggregatesInput = {
    AND?: AssetCategoryScalarWhereWithAggregatesInput | AssetCategoryScalarWhereWithAggregatesInput[]
    OR?: AssetCategoryScalarWhereWithAggregatesInput[]
    NOT?: AssetCategoryScalarWhereWithAggregatesInput | AssetCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AssetCategory"> | string
    code?: StringWithAggregatesFilter<"AssetCategory"> | string
    name?: StringWithAggregatesFilter<"AssetCategory"> | string
    description?: StringNullableWithAggregatesFilter<"AssetCategory"> | string | null
    depreciationMethod?: StringWithAggregatesFilter<"AssetCategory"> | string
    usefulLife?: IntWithAggregatesFilter<"AssetCategory"> | number
    residualValue?: DecimalWithAggregatesFilter<"AssetCategory"> | Decimal | DecimalJsLike | number | string
    glAssetAccountId?: StringWithAggregatesFilter<"AssetCategory"> | string
    glDepreciationAccountId?: StringWithAggregatesFilter<"AssetCategory"> | string
    glAccumulatedDepreciationAccountId?: StringWithAggregatesFilter<"AssetCategory"> | string
    isActive?: BoolWithAggregatesFilter<"AssetCategory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AssetCategory"> | Date | string
  }

  export type AssetWhereInput = {
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    id?: StringFilter<"Asset"> | string
    assetNo?: StringFilter<"Asset"> | string
    name?: StringFilter<"Asset"> | string
    description?: StringNullableFilter<"Asset"> | string | null
    categoryId?: StringFilter<"Asset"> | string
    acquisitionDate?: DateTimeFilter<"Asset"> | Date | string
    acquisitionCost?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFilter<"Asset"> | number
    depreciationMethod?: StringFilter<"Asset"> | string
    locationId?: StringNullableFilter<"Asset"> | string | null
    serialNumber?: StringNullableFilter<"Asset"> | string | null
    supplier?: StringNullableFilter<"Asset"> | string | null
    purchaseOrderId?: StringNullableFilter<"Asset"> | string | null
    status?: StringFilter<"Asset"> | string
    disposalDate?: DateTimeNullableFilter<"Asset"> | Date | string | null
    disposalAmount?: DecimalNullableFilter<"Asset"> | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: StringNullableFilter<"Asset"> | string | null
    createdBy?: StringFilter<"Asset"> | string
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    vendorId?: StringNullableFilter<"Asset"> | string | null
    category?: XOR<AssetCategoryRelationFilter, AssetCategoryWhereInput>
    location?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
    purchaseOrder?: XOR<PurchaseNullableRelationFilter, PurchaseWhereInput> | null
    createdByUser?: XOR<UserRelationFilter, UserWhereInput>
    depreciationEntries?: AssetDepreciationListRelationFilter
    disposals?: AssetDisposalListRelationFilter
    Vendor?: XOR<VendorNullableRelationFilter, VendorWhereInput> | null
  }

  export type AssetOrderByWithRelationInput = {
    id?: SortOrder
    assetNo?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    acquisitionDate?: SortOrder
    acquisitionCost?: SortOrder
    residualValue?: SortOrder
    usefulLife?: SortOrder
    depreciationMethod?: SortOrder
    locationId?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    supplier?: SortOrderInput | SortOrder
    purchaseOrderId?: SortOrderInput | SortOrder
    status?: SortOrder
    disposalDate?: SortOrderInput | SortOrder
    disposalAmount?: SortOrderInput | SortOrder
    disposalMethod?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    vendorId?: SortOrderInput | SortOrder
    category?: AssetCategoryOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    purchaseOrder?: PurchaseOrderByWithRelationInput
    createdByUser?: UserOrderByWithRelationInput
    depreciationEntries?: AssetDepreciationOrderByRelationAggregateInput
    disposals?: AssetDisposalOrderByRelationAggregateInput
    Vendor?: VendorOrderByWithRelationInput
  }

  export type AssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    assetNo?: string
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    name?: StringFilter<"Asset"> | string
    description?: StringNullableFilter<"Asset"> | string | null
    categoryId?: StringFilter<"Asset"> | string
    acquisitionDate?: DateTimeFilter<"Asset"> | Date | string
    acquisitionCost?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFilter<"Asset"> | number
    depreciationMethod?: StringFilter<"Asset"> | string
    locationId?: StringNullableFilter<"Asset"> | string | null
    serialNumber?: StringNullableFilter<"Asset"> | string | null
    supplier?: StringNullableFilter<"Asset"> | string | null
    purchaseOrderId?: StringNullableFilter<"Asset"> | string | null
    status?: StringFilter<"Asset"> | string
    disposalDate?: DateTimeNullableFilter<"Asset"> | Date | string | null
    disposalAmount?: DecimalNullableFilter<"Asset"> | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: StringNullableFilter<"Asset"> | string | null
    createdBy?: StringFilter<"Asset"> | string
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    vendorId?: StringNullableFilter<"Asset"> | string | null
    category?: XOR<AssetCategoryRelationFilter, AssetCategoryWhereInput>
    location?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
    purchaseOrder?: XOR<PurchaseNullableRelationFilter, PurchaseWhereInput> | null
    createdByUser?: XOR<UserRelationFilter, UserWhereInput>
    depreciationEntries?: AssetDepreciationListRelationFilter
    disposals?: AssetDisposalListRelationFilter
    Vendor?: XOR<VendorNullableRelationFilter, VendorWhereInput> | null
  }, "id" | "assetNo">

  export type AssetOrderByWithAggregationInput = {
    id?: SortOrder
    assetNo?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    acquisitionDate?: SortOrder
    acquisitionCost?: SortOrder
    residualValue?: SortOrder
    usefulLife?: SortOrder
    depreciationMethod?: SortOrder
    locationId?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    supplier?: SortOrderInput | SortOrder
    purchaseOrderId?: SortOrderInput | SortOrder
    status?: SortOrder
    disposalDate?: SortOrderInput | SortOrder
    disposalAmount?: SortOrderInput | SortOrder
    disposalMethod?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    vendorId?: SortOrderInput | SortOrder
    _count?: AssetCountOrderByAggregateInput
    _avg?: AssetAvgOrderByAggregateInput
    _max?: AssetMaxOrderByAggregateInput
    _min?: AssetMinOrderByAggregateInput
    _sum?: AssetSumOrderByAggregateInput
  }

  export type AssetScalarWhereWithAggregatesInput = {
    AND?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    OR?: AssetScalarWhereWithAggregatesInput[]
    NOT?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Asset"> | string
    assetNo?: StringWithAggregatesFilter<"Asset"> | string
    name?: StringWithAggregatesFilter<"Asset"> | string
    description?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    categoryId?: StringWithAggregatesFilter<"Asset"> | string
    acquisitionDate?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
    acquisitionCost?: DecimalWithAggregatesFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalWithAggregatesFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    usefulLife?: IntWithAggregatesFilter<"Asset"> | number
    depreciationMethod?: StringWithAggregatesFilter<"Asset"> | string
    locationId?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    serialNumber?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    supplier?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    purchaseOrderId?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    status?: StringWithAggregatesFilter<"Asset"> | string
    disposalDate?: DateTimeNullableWithAggregatesFilter<"Asset"> | Date | string | null
    disposalAmount?: DecimalNullableWithAggregatesFilter<"Asset"> | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: StringNullableWithAggregatesFilter<"Asset"> | string | null
    createdBy?: StringWithAggregatesFilter<"Asset"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
    vendorId?: StringNullableWithAggregatesFilter<"Asset"> | string | null
  }

  export type AssetDepreciationWhereInput = {
    AND?: AssetDepreciationWhereInput | AssetDepreciationWhereInput[]
    OR?: AssetDepreciationWhereInput[]
    NOT?: AssetDepreciationWhereInput | AssetDepreciationWhereInput[]
    id?: StringFilter<"AssetDepreciation"> | string
    assetId?: StringFilter<"AssetDepreciation"> | string
    periodYear?: IntFilter<"AssetDepreciation"> | number
    periodMonth?: IntFilter<"AssetDepreciation"> | number
    depreciationAmount?: DecimalFilter<"AssetDepreciation"> | Decimal | DecimalJsLike | number | string
    accumulatedDepreciation?: DecimalFilter<"AssetDepreciation"> | Decimal | DecimalJsLike | number | string
    netBookValue?: DecimalFilter<"AssetDepreciation"> | Decimal | DecimalJsLike | number | string
    isPosted?: BoolFilter<"AssetDepreciation"> | boolean
    postedAt?: DateTimeNullableFilter<"AssetDepreciation"> | Date | string | null
    journalId?: StringNullableFilter<"AssetDepreciation"> | string | null
    createdAt?: DateTimeFilter<"AssetDepreciation"> | Date | string
    asset?: XOR<AssetRelationFilter, AssetWhereInput>
    journal?: XOR<JournalNullableRelationFilter, JournalWhereInput> | null
  }

  export type AssetDepreciationOrderByWithRelationInput = {
    id?: SortOrder
    assetId?: SortOrder
    periodYear?: SortOrder
    periodMonth?: SortOrder
    depreciationAmount?: SortOrder
    accumulatedDepreciation?: SortOrder
    netBookValue?: SortOrder
    isPosted?: SortOrder
    postedAt?: SortOrderInput | SortOrder
    journalId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    asset?: AssetOrderByWithRelationInput
    journal?: JournalOrderByWithRelationInput
  }

  export type AssetDepreciationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    assetId_periodYear_periodMonth?: AssetDepreciationAssetIdPeriodYearPeriodMonthCompoundUniqueInput
    AND?: AssetDepreciationWhereInput | AssetDepreciationWhereInput[]
    OR?: AssetDepreciationWhereInput[]
    NOT?: AssetDepreciationWhereInput | AssetDepreciationWhereInput[]
    assetId?: StringFilter<"AssetDepreciation"> | string
    periodYear?: IntFilter<"AssetDepreciation"> | number
    periodMonth?: IntFilter<"AssetDepreciation"> | number
    depreciationAmount?: DecimalFilter<"AssetDepreciation"> | Decimal | DecimalJsLike | number | string
    accumulatedDepreciation?: DecimalFilter<"AssetDepreciation"> | Decimal | DecimalJsLike | number | string
    netBookValue?: DecimalFilter<"AssetDepreciation"> | Decimal | DecimalJsLike | number | string
    isPosted?: BoolFilter<"AssetDepreciation"> | boolean
    postedAt?: DateTimeNullableFilter<"AssetDepreciation"> | Date | string | null
    journalId?: StringNullableFilter<"AssetDepreciation"> | string | null
    createdAt?: DateTimeFilter<"AssetDepreciation"> | Date | string
    asset?: XOR<AssetRelationFilter, AssetWhereInput>
    journal?: XOR<JournalNullableRelationFilter, JournalWhereInput> | null
  }, "id" | "assetId_periodYear_periodMonth">

  export type AssetDepreciationOrderByWithAggregationInput = {
    id?: SortOrder
    assetId?: SortOrder
    periodYear?: SortOrder
    periodMonth?: SortOrder
    depreciationAmount?: SortOrder
    accumulatedDepreciation?: SortOrder
    netBookValue?: SortOrder
    isPosted?: SortOrder
    postedAt?: SortOrderInput | SortOrder
    journalId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AssetDepreciationCountOrderByAggregateInput
    _avg?: AssetDepreciationAvgOrderByAggregateInput
    _max?: AssetDepreciationMaxOrderByAggregateInput
    _min?: AssetDepreciationMinOrderByAggregateInput
    _sum?: AssetDepreciationSumOrderByAggregateInput
  }

  export type AssetDepreciationScalarWhereWithAggregatesInput = {
    AND?: AssetDepreciationScalarWhereWithAggregatesInput | AssetDepreciationScalarWhereWithAggregatesInput[]
    OR?: AssetDepreciationScalarWhereWithAggregatesInput[]
    NOT?: AssetDepreciationScalarWhereWithAggregatesInput | AssetDepreciationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AssetDepreciation"> | string
    assetId?: StringWithAggregatesFilter<"AssetDepreciation"> | string
    periodYear?: IntWithAggregatesFilter<"AssetDepreciation"> | number
    periodMonth?: IntWithAggregatesFilter<"AssetDepreciation"> | number
    depreciationAmount?: DecimalWithAggregatesFilter<"AssetDepreciation"> | Decimal | DecimalJsLike | number | string
    accumulatedDepreciation?: DecimalWithAggregatesFilter<"AssetDepreciation"> | Decimal | DecimalJsLike | number | string
    netBookValue?: DecimalWithAggregatesFilter<"AssetDepreciation"> | Decimal | DecimalJsLike | number | string
    isPosted?: BoolWithAggregatesFilter<"AssetDepreciation"> | boolean
    postedAt?: DateTimeNullableWithAggregatesFilter<"AssetDepreciation"> | Date | string | null
    journalId?: StringNullableWithAggregatesFilter<"AssetDepreciation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AssetDepreciation"> | Date | string
  }

  export type AssetDisposalWhereInput = {
    AND?: AssetDisposalWhereInput | AssetDisposalWhereInput[]
    OR?: AssetDisposalWhereInput[]
    NOT?: AssetDisposalWhereInput | AssetDisposalWhereInput[]
    id?: StringFilter<"AssetDisposal"> | string
    assetId?: StringFilter<"AssetDisposal"> | string
    disposalDate?: DateTimeFilter<"AssetDisposal"> | Date | string
    disposalAmount?: DecimalFilter<"AssetDisposal"> | Decimal | DecimalJsLike | number | string
    disposalMethod?: StringFilter<"AssetDisposal"> | string
    buyerDetails?: StringNullableFilter<"AssetDisposal"> | string | null
    gainLoss?: DecimalFilter<"AssetDisposal"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"AssetDisposal"> | string | null
    journalId?: StringNullableFilter<"AssetDisposal"> | string | null
    disposedBy?: StringFilter<"AssetDisposal"> | string
    createdAt?: DateTimeFilter<"AssetDisposal"> | Date | string
    asset?: XOR<AssetRelationFilter, AssetWhereInput>
    journal?: XOR<JournalNullableRelationFilter, JournalWhereInput> | null
    disposedByUser?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AssetDisposalOrderByWithRelationInput = {
    id?: SortOrder
    assetId?: SortOrder
    disposalDate?: SortOrder
    disposalAmount?: SortOrder
    disposalMethod?: SortOrder
    buyerDetails?: SortOrderInput | SortOrder
    gainLoss?: SortOrder
    notes?: SortOrderInput | SortOrder
    journalId?: SortOrderInput | SortOrder
    disposedBy?: SortOrder
    createdAt?: SortOrder
    asset?: AssetOrderByWithRelationInput
    journal?: JournalOrderByWithRelationInput
    disposedByUser?: UserOrderByWithRelationInput
  }

  export type AssetDisposalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssetDisposalWhereInput | AssetDisposalWhereInput[]
    OR?: AssetDisposalWhereInput[]
    NOT?: AssetDisposalWhereInput | AssetDisposalWhereInput[]
    assetId?: StringFilter<"AssetDisposal"> | string
    disposalDate?: DateTimeFilter<"AssetDisposal"> | Date | string
    disposalAmount?: DecimalFilter<"AssetDisposal"> | Decimal | DecimalJsLike | number | string
    disposalMethod?: StringFilter<"AssetDisposal"> | string
    buyerDetails?: StringNullableFilter<"AssetDisposal"> | string | null
    gainLoss?: DecimalFilter<"AssetDisposal"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"AssetDisposal"> | string | null
    journalId?: StringNullableFilter<"AssetDisposal"> | string | null
    disposedBy?: StringFilter<"AssetDisposal"> | string
    createdAt?: DateTimeFilter<"AssetDisposal"> | Date | string
    asset?: XOR<AssetRelationFilter, AssetWhereInput>
    journal?: XOR<JournalNullableRelationFilter, JournalWhereInput> | null
    disposedByUser?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AssetDisposalOrderByWithAggregationInput = {
    id?: SortOrder
    assetId?: SortOrder
    disposalDate?: SortOrder
    disposalAmount?: SortOrder
    disposalMethod?: SortOrder
    buyerDetails?: SortOrderInput | SortOrder
    gainLoss?: SortOrder
    notes?: SortOrderInput | SortOrder
    journalId?: SortOrderInput | SortOrder
    disposedBy?: SortOrder
    createdAt?: SortOrder
    _count?: AssetDisposalCountOrderByAggregateInput
    _avg?: AssetDisposalAvgOrderByAggregateInput
    _max?: AssetDisposalMaxOrderByAggregateInput
    _min?: AssetDisposalMinOrderByAggregateInput
    _sum?: AssetDisposalSumOrderByAggregateInput
  }

  export type AssetDisposalScalarWhereWithAggregatesInput = {
    AND?: AssetDisposalScalarWhereWithAggregatesInput | AssetDisposalScalarWhereWithAggregatesInput[]
    OR?: AssetDisposalScalarWhereWithAggregatesInput[]
    NOT?: AssetDisposalScalarWhereWithAggregatesInput | AssetDisposalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AssetDisposal"> | string
    assetId?: StringWithAggregatesFilter<"AssetDisposal"> | string
    disposalDate?: DateTimeWithAggregatesFilter<"AssetDisposal"> | Date | string
    disposalAmount?: DecimalWithAggregatesFilter<"AssetDisposal"> | Decimal | DecimalJsLike | number | string
    disposalMethod?: StringWithAggregatesFilter<"AssetDisposal"> | string
    buyerDetails?: StringNullableWithAggregatesFilter<"AssetDisposal"> | string | null
    gainLoss?: DecimalWithAggregatesFilter<"AssetDisposal"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"AssetDisposal"> | string | null
    journalId?: StringNullableWithAggregatesFilter<"AssetDisposal"> | string | null
    disposedBy?: StringWithAggregatesFilter<"AssetDisposal"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AssetDisposal"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    journals?: JournalCreateNestedManyWithoutPostedByUserInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutUserInput
    salesReceipts?: SalesReceiptCreateNestedManyWithoutUserInput
    purchasePayments?: PurchasePaymentCreateNestedManyWithoutUserInput
    SystemSetting?: SystemSettingCreateNestedManyWithoutUpdatedByUserInput
    ApprovalRequest?: ApprovalRequestCreateNestedManyWithoutRequestedByUserInput
    ApprovalAction?: ApprovalActionCreateNestedManyWithoutUserInput
    assetsCreated?: AssetCreateNestedManyWithoutCreatedByUserInput
    assetDisposals?: AssetDisposalCreateNestedManyWithoutDisposedByUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    journals?: JournalUncheckedCreateNestedManyWithoutPostedByUserInput
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutUserInput
    salesReceipts?: SalesReceiptUncheckedCreateNestedManyWithoutUserInput
    purchasePayments?: PurchasePaymentUncheckedCreateNestedManyWithoutUserInput
    SystemSetting?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    ApprovalRequest?: ApprovalRequestUncheckedCreateNestedManyWithoutRequestedByUserInput
    ApprovalAction?: ApprovalActionUncheckedCreateNestedManyWithoutUserInput
    assetsCreated?: AssetUncheckedCreateNestedManyWithoutCreatedByUserInput
    assetDisposals?: AssetDisposalUncheckedCreateNestedManyWithoutDisposedByUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    journals?: JournalUpdateManyWithoutPostedByUserNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutUserNestedInput
    salesReceipts?: SalesReceiptUpdateManyWithoutUserNestedInput
    purchasePayments?: PurchasePaymentUpdateManyWithoutUserNestedInput
    SystemSetting?: SystemSettingUpdateManyWithoutUpdatedByUserNestedInput
    ApprovalRequest?: ApprovalRequestUpdateManyWithoutRequestedByUserNestedInput
    ApprovalAction?: ApprovalActionUpdateManyWithoutUserNestedInput
    assetsCreated?: AssetUpdateManyWithoutCreatedByUserNestedInput
    assetDisposals?: AssetDisposalUpdateManyWithoutDisposedByUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    journals?: JournalUncheckedUpdateManyWithoutPostedByUserNestedInput
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutUserNestedInput
    salesReceipts?: SalesReceiptUncheckedUpdateManyWithoutUserNestedInput
    purchasePayments?: PurchasePaymentUncheckedUpdateManyWithoutUserNestedInput
    SystemSetting?: SystemSettingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    ApprovalRequest?: ApprovalRequestUncheckedUpdateManyWithoutRequestedByUserNestedInput
    ApprovalAction?: ApprovalActionUncheckedUpdateManyWithoutUserNestedInput
    assetsCreated?: AssetUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assetDisposals?: AssetDisposalUncheckedUpdateManyWithoutDisposedByUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    rolePermissions?: RolePermissionCreateNestedManyWithoutRoleInput
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput
    ApprovalStep?: ApprovalStepCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
    ApprovalStep?: ApprovalStepUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUpdateManyWithoutRoleNestedInput
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput
    ApprovalStep?: ApprovalStepUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
    ApprovalStep?: ApprovalStepUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateInput = {
    id?: string
    name: string
    resource: string
    action: string
    description?: string | null
    rolePermissions?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    name: string
    resource: string
    action: string
    description?: string | null
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rolePermissions?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: string
    name: string
    resource: string
    action: string
    description?: string | null
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutUserRolesInput
    role: RoleCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateInput = {
    id?: string
    userId: string
    roleId: string
  }

  export type UserRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleCreateManyInput = {
    id?: string
    userId: string
    roleId: string
  }

  export type UserRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionCreateInput = {
    id?: string
    role: RoleCreateNestedOneWithoutRolePermissionsInput
    permission: PermissionCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateInput = {
    id?: string
    roleId: string
    permissionId: string
  }

  export type RolePermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: RoleUpdateOneRequiredWithoutRolePermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionCreateManyInput = {
    id?: string
    roleId: string
    permissionId: string
  }

  export type RolePermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    baseCurrency?: string
    timezone?: string
    address?: string | null
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    baseCurrency?: string
    timezone?: string
    address?: string | null
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    baseCurrency?: string
    timezone?: string
    address?: string | null
    phone?: string | null
    email?: string | null
    createdAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    baseCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string
    isActive?: boolean
    createdAt?: Date | string
    warehouses?: WarehouseCreateNestedManyWithoutLocationInput
    assets?: AssetCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string
    isActive?: boolean
    createdAt?: Date | string
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutLocationInput
    assets?: AssetUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouses?: WarehouseUpdateManyWithoutLocationNestedInput
    assets?: AssetUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouses?: WarehouseUncheckedUpdateManyWithoutLocationNestedInput
    assets?: AssetUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseCreateInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    location: LocationCreateNestedOneWithoutWarehousesInput
    bins?: BinCreateNestedManyWithoutWarehouseInput
    inventoryBatches?: InventoryBatchCreateNestedManyWithoutWarehouseInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutWarehouseInput
    productionOrders?: ProductionOrderCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    locationId: string
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    bins?: BinUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryBatches?: InventoryBatchUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutWarehouseInput
    productionOrders?: ProductionOrderUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutWarehousesNestedInput
    bins?: BinUpdateManyWithoutWarehouseNestedInput
    inventoryBatches?: InventoryBatchUpdateManyWithoutWarehouseNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutWarehouseNestedInput
    productionOrders?: ProductionOrderUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bins?: BinUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryBatches?: InventoryBatchUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutWarehouseNestedInput
    productionOrders?: ProductionOrderUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseCreateManyInput = {
    id?: string
    code: string
    name: string
    locationId: string
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type WarehouseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BinCreateInput = {
    id?: string
    code: string
    name?: string | null
    warehouse: WarehouseCreateNestedOneWithoutBinsInput
    inventoryBatches?: InventoryBatchCreateNestedManyWithoutBinInput
  }

  export type BinUncheckedCreateInput = {
    id?: string
    warehouseId: string
    code: string
    name?: string | null
    inventoryBatches?: InventoryBatchUncheckedCreateNestedManyWithoutBinInput
  }

  export type BinUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    warehouse?: WarehouseUpdateOneRequiredWithoutBinsNestedInput
    inventoryBatches?: InventoryBatchUpdateManyWithoutBinNestedInput
  }

  export type BinUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryBatches?: InventoryBatchUncheckedUpdateManyWithoutBinNestedInput
  }

  export type BinCreateManyInput = {
    id?: string
    warehouseId: string
    code: string
    name?: string | null
  }

  export type BinUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BinUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemCreateInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ItemType
    uom?: string
    costingMethod?: $Enums.CostingMethod
    standardCost?: Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: Decimal | DecimalJsLike | number | string | null
    taxCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    boms?: BomCreateNestedManyWithoutItemInput
    bomLines?: BomLineCreateNestedManyWithoutComponentItemInput
    inventoryBatches?: InventoryBatchCreateNestedManyWithoutItemInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutItemInput
    productionOrders?: ProductionOrderCreateNestedManyWithoutItemInput
    purchaseLines?: PurchaseLineCreateNestedManyWithoutItemInput
    saleLines?: SaleLineCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ItemType
    uom?: string
    costingMethod?: $Enums.CostingMethod
    standardCost?: Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: Decimal | DecimalJsLike | number | string | null
    taxCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    boms?: BomUncheckedCreateNestedManyWithoutItemInput
    bomLines?: BomLineUncheckedCreateNestedManyWithoutComponentItemInput
    inventoryBatches?: InventoryBatchUncheckedCreateNestedManyWithoutItemInput
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutItemInput
    productionOrders?: ProductionOrderUncheckedCreateNestedManyWithoutItemInput
    purchaseLines?: PurchaseLineUncheckedCreateNestedManyWithoutItemInput
    saleLines?: SaleLineUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    uom?: StringFieldUpdateOperationsInput | string
    costingMethod?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boms?: BomUpdateManyWithoutItemNestedInput
    bomLines?: BomLineUpdateManyWithoutComponentItemNestedInput
    inventoryBatches?: InventoryBatchUpdateManyWithoutItemNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutItemNestedInput
    productionOrders?: ProductionOrderUpdateManyWithoutItemNestedInput
    purchaseLines?: PurchaseLineUpdateManyWithoutItemNestedInput
    saleLines?: SaleLineUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    uom?: StringFieldUpdateOperationsInput | string
    costingMethod?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boms?: BomUncheckedUpdateManyWithoutItemNestedInput
    bomLines?: BomLineUncheckedUpdateManyWithoutComponentItemNestedInput
    inventoryBatches?: InventoryBatchUncheckedUpdateManyWithoutItemNestedInput
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutItemNestedInput
    productionOrders?: ProductionOrderUncheckedUpdateManyWithoutItemNestedInput
    purchaseLines?: PurchaseLineUncheckedUpdateManyWithoutItemNestedInput
    saleLines?: SaleLineUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateManyInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ItemType
    uom?: string
    costingMethod?: $Enums.CostingMethod
    standardCost?: Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: Decimal | DecimalJsLike | number | string | null
    taxCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    uom?: StringFieldUpdateOperationsInput | string
    costingMethod?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    uom?: StringFieldUpdateOperationsInput | string
    costingMethod?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BomCreateInput = {
    id?: string
    version?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    item: ItemCreateNestedOneWithoutBomsInput
    bomLines?: BomLineCreateNestedManyWithoutBomInput
    productionOrders?: ProductionOrderCreateNestedManyWithoutBomInput
  }

  export type BomUncheckedCreateInput = {
    id?: string
    itemId: string
    version?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bomLines?: BomLineUncheckedCreateNestedManyWithoutBomInput
    productionOrders?: ProductionOrderUncheckedCreateNestedManyWithoutBomInput
  }

  export type BomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutBomsNestedInput
    bomLines?: BomLineUpdateManyWithoutBomNestedInput
    productionOrders?: ProductionOrderUpdateManyWithoutBomNestedInput
  }

  export type BomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bomLines?: BomLineUncheckedUpdateManyWithoutBomNestedInput
    productionOrders?: ProductionOrderUncheckedUpdateManyWithoutBomNestedInput
  }

  export type BomCreateManyInput = {
    id?: string
    itemId: string
    version?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BomLineCreateInput = {
    id?: string
    qtyPer: Decimal | DecimalJsLike | number | string
    scrapPercent?: Decimal | DecimalJsLike | number | string
    bom: BomCreateNestedOneWithoutBomLinesInput
    componentItem: ItemCreateNestedOneWithoutBomLinesInput
  }

  export type BomLineUncheckedCreateInput = {
    id?: string
    bomId: string
    componentItemId: string
    qtyPer: Decimal | DecimalJsLike | number | string
    scrapPercent?: Decimal | DecimalJsLike | number | string
  }

  export type BomLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qtyPer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bom?: BomUpdateOneRequiredWithoutBomLinesNestedInput
    componentItem?: ItemUpdateOneRequiredWithoutBomLinesNestedInput
  }

  export type BomLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bomId?: StringFieldUpdateOperationsInput | string
    componentItemId?: StringFieldUpdateOperationsInput | string
    qtyPer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BomLineCreateManyInput = {
    id?: string
    bomId: string
    componentItemId: string
    qtyPer: Decimal | DecimalJsLike | number | string
    scrapPercent?: Decimal | DecimalJsLike | number | string
  }

  export type BomLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qtyPer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BomLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bomId?: StringFieldUpdateOperationsInput | string
    componentItemId?: StringFieldUpdateOperationsInput | string
    qtyPer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InventoryBatchCreateInput = {
    id?: string
    qtyOnHand: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    receivedAt: Date | string
    item: ItemCreateNestedOneWithoutInventoryBatchesInput
    warehouse: WarehouseCreateNestedOneWithoutInventoryBatchesInput
    bin?: BinCreateNestedOneWithoutInventoryBatchesInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutBatchInput
  }

  export type InventoryBatchUncheckedCreateInput = {
    id?: string
    itemId: string
    warehouseId: string
    binId?: string | null
    qtyOnHand: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    receivedAt: Date | string
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutBatchInput
  }

  export type InventoryBatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutInventoryBatchesNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutInventoryBatchesNestedInput
    bin?: BinUpdateOneWithoutInventoryBatchesNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutBatchNestedInput
  }

  export type InventoryBatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type InventoryBatchCreateManyInput = {
    id?: string
    itemId: string
    warehouseId: string
    binId?: string | null
    qtyOnHand: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    receivedAt: Date | string
  }

  export type InventoryBatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryBatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryLedgerCreateInput = {
    id?: string
    refType: string
    refId: string
    direction: $Enums.LedgerDirection
    qty: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    value: Decimal | DecimalJsLike | number | string
    runningQty: Decimal | DecimalJsLike | number | string
    runningValue: Decimal | DecimalJsLike | number | string
    runningAvgCost: Decimal | DecimalJsLike | number | string
    postedAt?: Date | string
    item: ItemCreateNestedOneWithoutInventoryLedgerInput
    warehouse: WarehouseCreateNestedOneWithoutInventoryLedgerInput
    batch?: InventoryBatchCreateNestedOneWithoutInventoryLedgerInput
    user?: UserCreateNestedOneWithoutInventoryLedgerInput
  }

  export type InventoryLedgerUncheckedCreateInput = {
    id?: string
    itemId: string
    warehouseId: string
    refType: string
    refId: string
    direction: $Enums.LedgerDirection
    qty: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    value: Decimal | DecimalJsLike | number | string
    runningQty: Decimal | DecimalJsLike | number | string
    runningValue: Decimal | DecimalJsLike | number | string
    runningAvgCost: Decimal | DecimalJsLike | number | string
    batchId?: string | null
    userId?: string | null
    postedAt?: Date | string
  }

  export type InventoryLedgerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningAvgCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutInventoryLedgerNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutInventoryLedgerNestedInput
    batch?: InventoryBatchUpdateOneWithoutInventoryLedgerNestedInput
    user?: UserUpdateOneWithoutInventoryLedgerNestedInput
  }

  export type InventoryLedgerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningAvgCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryLedgerCreateManyInput = {
    id?: string
    itemId: string
    warehouseId: string
    refType: string
    refId: string
    direction: $Enums.LedgerDirection
    qty: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    value: Decimal | DecimalJsLike | number | string
    runningQty: Decimal | DecimalJsLike | number | string
    runningValue: Decimal | DecimalJsLike | number | string
    runningAvgCost: Decimal | DecimalJsLike | number | string
    batchId?: string | null
    userId?: string | null
    postedAt?: Date | string
  }

  export type InventoryLedgerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningAvgCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryLedgerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningAvgCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionOrderCreateInput = {
    id?: string
    orderNo: string
    qtyTarget: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string
    status?: $Enums.ProductionOrderStatus
    approvalStatus?: string | null
    approvalRequestId?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    item: ItemCreateNestedOneWithoutProductionOrdersInput
    warehouse: WarehouseCreateNestedOneWithoutProductionOrdersInput
    bom?: BomCreateNestedOneWithoutProductionOrdersInput
    wipLedger?: WipLedgerCreateNestedManyWithoutProductionOrderInput
    laborTimes?: LaborTimeCreateNestedManyWithoutProductionOrderInput
  }

  export type ProductionOrderUncheckedCreateInput = {
    id?: string
    orderNo: string
    itemId: string
    qtyTarget: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string
    status?: $Enums.ProductionOrderStatus
    warehouseId: string
    bomId?: string | null
    approvalStatus?: string | null
    approvalRequestId?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    wipLedger?: WipLedgerUncheckedCreateNestedManyWithoutProductionOrderInput
    laborTimes?: LaborTimeUncheckedCreateNestedManyWithoutProductionOrderInput
  }

  export type ProductionOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    qtyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumProductionOrderStatusFieldUpdateOperationsInput | $Enums.ProductionOrderStatus
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    approvalRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutProductionOrdersNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutProductionOrdersNestedInput
    bom?: BomUpdateOneWithoutProductionOrdersNestedInput
    wipLedger?: WipLedgerUpdateManyWithoutProductionOrderNestedInput
    laborTimes?: LaborTimeUpdateManyWithoutProductionOrderNestedInput
  }

  export type ProductionOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qtyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumProductionOrderStatusFieldUpdateOperationsInput | $Enums.ProductionOrderStatus
    warehouseId?: StringFieldUpdateOperationsInput | string
    bomId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    approvalRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wipLedger?: WipLedgerUncheckedUpdateManyWithoutProductionOrderNestedInput
    laborTimes?: LaborTimeUncheckedUpdateManyWithoutProductionOrderNestedInput
  }

  export type ProductionOrderCreateManyInput = {
    id?: string
    orderNo: string
    itemId: string
    qtyTarget: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string
    status?: $Enums.ProductionOrderStatus
    warehouseId: string
    bomId?: string | null
    approvalStatus?: string | null
    approvalRequestId?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductionOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    qtyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumProductionOrderStatusFieldUpdateOperationsInput | $Enums.ProductionOrderStatus
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    approvalRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qtyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumProductionOrderStatusFieldUpdateOperationsInput | $Enums.ProductionOrderStatus
    warehouseId?: StringFieldUpdateOperationsInput | string
    bomId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    approvalRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WipLedgerCreateInput = {
    id?: string
    type: $Enums.WipLedgerType
    amount: Decimal | DecimalJsLike | number | string
    note?: string | null
    postedAt?: Date | string
    productionOrder: ProductionOrderCreateNestedOneWithoutWipLedgerInput
  }

  export type WipLedgerUncheckedCreateInput = {
    id?: string
    productionOrderId: string
    type: $Enums.WipLedgerType
    amount: Decimal | DecimalJsLike | number | string
    note?: string | null
    postedAt?: Date | string
  }

  export type WipLedgerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWipLedgerTypeFieldUpdateOperationsInput | $Enums.WipLedgerType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionOrder?: ProductionOrderUpdateOneRequiredWithoutWipLedgerNestedInput
  }

  export type WipLedgerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productionOrderId?: StringFieldUpdateOperationsInput | string
    type?: EnumWipLedgerTypeFieldUpdateOperationsInput | $Enums.WipLedgerType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WipLedgerCreateManyInput = {
    id?: string
    productionOrderId: string
    type: $Enums.WipLedgerType
    amount: Decimal | DecimalJsLike | number | string
    note?: string | null
    postedAt?: Date | string
  }

  export type WipLedgerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWipLedgerTypeFieldUpdateOperationsInput | $Enums.WipLedgerType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WipLedgerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productionOrderId?: StringFieldUpdateOperationsInput | string
    type?: EnumWipLedgerTypeFieldUpdateOperationsInput | $Enums.WipLedgerType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaborTimeCreateInput = {
    id?: string
    hours: Decimal | DecimalJsLike | number | string
    rate: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    employeeName?: string | null
    productionOrder: ProductionOrderCreateNestedOneWithoutLaborTimesInput
  }

  export type LaborTimeUncheckedCreateInput = {
    id?: string
    productionOrderId: string
    hours: Decimal | DecimalJsLike | number | string
    rate: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    employeeName?: string | null
  }

  export type LaborTimeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    productionOrder?: ProductionOrderUpdateOneRequiredWithoutLaborTimesNestedInput
  }

  export type LaborTimeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productionOrderId?: StringFieldUpdateOperationsInput | string
    hours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LaborTimeCreateManyInput = {
    id?: string
    productionOrderId: string
    hours: Decimal | DecimalJsLike | number | string
    rate: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    employeeName?: string | null
  }

  export type LaborTimeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LaborTimeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productionOrderId?: StringFieldUpdateOperationsInput | string
    hours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VendorCreateInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    paymentTerms?: string | null
    isActive?: boolean
    createdAt?: Date | string
    purchases?: PurchaseCreateNestedManyWithoutVendorInput
    purchasePayments?: PurchasePaymentCreateNestedManyWithoutVendorInput
    assets?: AssetCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    paymentTerms?: string | null
    isActive?: boolean
    createdAt?: Date | string
    purchases?: PurchaseUncheckedCreateNestedManyWithoutVendorInput
    purchasePayments?: PurchasePaymentUncheckedCreateNestedManyWithoutVendorInput
    assets?: AssetUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchaseUpdateManyWithoutVendorNestedInput
    purchasePayments?: PurchasePaymentUpdateManyWithoutVendorNestedInput
    assets?: AssetUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchaseUncheckedUpdateManyWithoutVendorNestedInput
    purchasePayments?: PurchasePaymentUncheckedUpdateManyWithoutVendorNestedInput
    assets?: AssetUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorCreateManyInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    paymentTerms?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type VendorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    CustomerGroup: string
    isActive?: boolean
    createdAt?: Date | string
    sales?: SaleCreateNestedManyWithoutCustomerInput
    salesReceipts?: SalesReceiptCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    CustomerGroup: string
    isActive?: boolean
    createdAt?: Date | string
    sales?: SaleUncheckedCreateNestedManyWithoutCustomerInput
    salesReceipts?: SalesReceiptUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    CustomerGroup?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUpdateManyWithoutCustomerNestedInput
    salesReceipts?: SalesReceiptUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    CustomerGroup?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUncheckedUpdateManyWithoutCustomerNestedInput
    salesReceipts?: SalesReceiptUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    CustomerGroup: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    CustomerGroup?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    CustomerGroup?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseCreateInput = {
    id?: string
    orderNo: string
    orderDate: Date | string
    status?: $Enums.PurchaseStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutPurchasesInput
    purchaseLines?: PurchaseLineCreateNestedManyWithoutPurchaseInput
    purchasePayments?: PurchasePaymentCreateNestedManyWithoutPurchaseInput
    assets?: AssetCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseUncheckedCreateInput = {
    id?: string
    orderNo: string
    vendorId: string
    orderDate: Date | string
    status?: $Enums.PurchaseStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseLines?: PurchaseLineUncheckedCreateNestedManyWithoutPurchaseInput
    purchasePayments?: PurchasePaymentUncheckedCreateNestedManyWithoutPurchaseInput
    assets?: AssetUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutPurchasesNestedInput
    purchaseLines?: PurchaseLineUpdateManyWithoutPurchaseNestedInput
    purchasePayments?: PurchasePaymentUpdateManyWithoutPurchaseNestedInput
    assets?: AssetUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseLines?: PurchaseLineUncheckedUpdateManyWithoutPurchaseNestedInput
    purchasePayments?: PurchasePaymentUncheckedUpdateManyWithoutPurchaseNestedInput
    assets?: AssetUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseCreateManyInput = {
    id?: string
    orderNo: string
    vendorId: string
    orderDate: Date | string
    status?: $Enums.PurchaseStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseLineCreateInput = {
    id?: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    purchase: PurchaseCreateNestedOneWithoutPurchaseLinesInput
    item: ItemCreateNestedOneWithoutPurchaseLinesInput
  }

  export type PurchaseLineUncheckedCreateInput = {
    id?: string
    purchaseId: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type PurchaseLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchase?: PurchaseUpdateOneRequiredWithoutPurchaseLinesNestedInput
    item?: ItemUpdateOneRequiredWithoutPurchaseLinesNestedInput
  }

  export type PurchaseLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchaseLineCreateManyInput = {
    id?: string
    purchaseId: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type PurchaseLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchaseLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleCreateInput = {
    id?: string
    orderNo: string
    orderDate: Date | string
    status?: $Enums.SaleStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSalesInput
    saleLines?: SaleLineCreateNestedManyWithoutSaleInput
    salesReceipts?: SalesReceiptCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateInput = {
    id?: string
    orderNo: string
    customerId: string
    orderDate: Date | string
    status?: $Enums.SaleStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    saleLines?: SaleLineUncheckedCreateNestedManyWithoutSaleInput
    salesReceipts?: SalesReceiptUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSalesNestedInput
    saleLines?: SaleLineUpdateManyWithoutSaleNestedInput
    salesReceipts?: SalesReceiptUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleLines?: SaleLineUncheckedUpdateManyWithoutSaleNestedInput
    salesReceipts?: SalesReceiptUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleCreateManyInput = {
    id?: string
    orderNo: string
    customerId: string
    orderDate: Date | string
    status?: $Enums.SaleStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleLineCreateInput = {
    id?: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    sale: SaleCreateNestedOneWithoutSaleLinesInput
    item: ItemCreateNestedOneWithoutSaleLinesInput
  }

  export type SaleLineUncheckedCreateInput = {
    id?: string
    saleId: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SaleLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale?: SaleUpdateOneRequiredWithoutSaleLinesNestedInput
    item?: ItemUpdateOneRequiredWithoutSaleLinesNestedInput
  }

  export type SaleLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleLineCreateManyInput = {
    id?: string
    saleId: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SaleLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ChartOfAccountCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    accountType: string
    isActive?: boolean
    createdAt?: Date | string
    parent?: ChartOfAccountCreateNestedOneWithoutChildrenInput
    children?: ChartOfAccountCreateNestedManyWithoutParentInput
    journalLines?: JournalLineCreateNestedManyWithoutAccountInput
    cashTransactionsGL?: CashTransactionCreateNestedManyWithoutGlAccountInput
    cashTransactionsContra?: CashTransactionCreateNestedManyWithoutContraAccountInput
    cashAccounts?: CashAccountCreateNestedManyWithoutChartOfAccountInput
    assetCategoriesAsset?: AssetCategoryCreateNestedManyWithoutGlAssetAccountInput
    assetCategoriesDepreciation?: AssetCategoryCreateNestedManyWithoutGlDepreciationAccountInput
    assetCategoriesAccumulated?: AssetCategoryCreateNestedManyWithoutGlAccumulatedDepreciationAccountInput
  }

  export type ChartOfAccountUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    accountType: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    children?: ChartOfAccountUncheckedCreateNestedManyWithoutParentInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAccountInput
    cashTransactionsGL?: CashTransactionUncheckedCreateNestedManyWithoutGlAccountInput
    cashTransactionsContra?: CashTransactionUncheckedCreateNestedManyWithoutContraAccountInput
    cashAccounts?: CashAccountUncheckedCreateNestedManyWithoutChartOfAccountInput
    assetCategoriesAsset?: AssetCategoryUncheckedCreateNestedManyWithoutGlAssetAccountInput
    assetCategoriesDepreciation?: AssetCategoryUncheckedCreateNestedManyWithoutGlDepreciationAccountInput
    assetCategoriesAccumulated?: AssetCategoryUncheckedCreateNestedManyWithoutGlAccumulatedDepreciationAccountInput
  }

  export type ChartOfAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ChartOfAccountUpdateOneWithoutChildrenNestedInput
    children?: ChartOfAccountUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUpdateManyWithoutAccountNestedInput
    cashTransactionsGL?: CashTransactionUpdateManyWithoutGlAccountNestedInput
    cashTransactionsContra?: CashTransactionUpdateManyWithoutContraAccountNestedInput
    cashAccounts?: CashAccountUpdateManyWithoutChartOfAccountNestedInput
    assetCategoriesAsset?: AssetCategoryUpdateManyWithoutGlAssetAccountNestedInput
    assetCategoriesDepreciation?: AssetCategoryUpdateManyWithoutGlDepreciationAccountNestedInput
    assetCategoriesAccumulated?: AssetCategoryUpdateManyWithoutGlAccumulatedDepreciationAccountNestedInput
  }

  export type ChartOfAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChartOfAccountUncheckedUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutAccountNestedInput
    cashTransactionsGL?: CashTransactionUncheckedUpdateManyWithoutGlAccountNestedInput
    cashTransactionsContra?: CashTransactionUncheckedUpdateManyWithoutContraAccountNestedInput
    cashAccounts?: CashAccountUncheckedUpdateManyWithoutChartOfAccountNestedInput
    assetCategoriesAsset?: AssetCategoryUncheckedUpdateManyWithoutGlAssetAccountNestedInput
    assetCategoriesDepreciation?: AssetCategoryUncheckedUpdateManyWithoutGlDepreciationAccountNestedInput
    assetCategoriesAccumulated?: AssetCategoryUncheckedUpdateManyWithoutGlAccumulatedDepreciationAccountNestedInput
  }

  export type ChartOfAccountCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    accountType: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ChartOfAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartOfAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalCreateInput = {
    id?: string
    journalNo: string
    date: Date | string
    memo?: string | null
    postedAt?: Date | string
    postedByUser: UserCreateNestedOneWithoutJournalsInput
    journalLines?: JournalLineCreateNestedManyWithoutJournalInput
    assetDepreciation?: AssetDepreciationCreateNestedManyWithoutJournalInput
    assetDisposals?: AssetDisposalCreateNestedManyWithoutJournalInput
  }

  export type JournalUncheckedCreateInput = {
    id?: string
    journalNo: string
    date: Date | string
    memo?: string | null
    postedBy: string
    postedAt?: Date | string
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutJournalInput
    assetDepreciation?: AssetDepreciationUncheckedCreateNestedManyWithoutJournalInput
    assetDisposals?: AssetDisposalUncheckedCreateNestedManyWithoutJournalInput
  }

  export type JournalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByUser?: UserUpdateOneRequiredWithoutJournalsNestedInput
    journalLines?: JournalLineUpdateManyWithoutJournalNestedInput
    assetDepreciation?: AssetDepreciationUpdateManyWithoutJournalNestedInput
    assetDisposals?: AssetDisposalUpdateManyWithoutJournalNestedInput
  }

  export type JournalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    postedBy?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journalLines?: JournalLineUncheckedUpdateManyWithoutJournalNestedInput
    assetDepreciation?: AssetDepreciationUncheckedUpdateManyWithoutJournalNestedInput
    assetDisposals?: AssetDisposalUncheckedUpdateManyWithoutJournalNestedInput
  }

  export type JournalCreateManyInput = {
    id?: string
    journalNo: string
    date: Date | string
    memo?: string | null
    postedBy: string
    postedAt?: Date | string
  }

  export type JournalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    postedBy?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLineCreateInput = {
    id?: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    refType?: string | null
    refId?: string | null
    journal: JournalCreateNestedOneWithoutJournalLinesInput
    account: ChartOfAccountCreateNestedOneWithoutJournalLinesInput
  }

  export type JournalLineUncheckedCreateInput = {
    id?: string
    journalId: string
    accountId: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    refType?: string | null
    refId?: string | null
  }

  export type JournalLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: JournalUpdateOneRequiredWithoutJournalLinesNestedInput
    account?: ChartOfAccountUpdateOneRequiredWithoutJournalLinesNestedInput
  }

  export type JournalLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalLineCreateManyInput = {
    id?: string
    journalId: string
    accountId: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    refType?: string | null
    refId?: string | null
  }

  export type JournalLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PolicyCreateInput = {
    id?: string
    key: string
    valueJson: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PolicyUncheckedCreateInput = {
    id?: string
    key: string
    valueJson: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PolicyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    valueJson?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    valueJson?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyCreateManyInput = {
    id?: string
    key: string
    valueJson: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PolicyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    valueJson?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PolicyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    valueJson?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    entity: string
    entityId: string
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    entity: string
    entityId: string
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashAccountCreateInput = {
    id?: string
    code: string
    name: string
    accountType: string
    accountNumber?: string | null
    glAccountId?: string | null
    bankName?: string | null
    balance?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    cashTransactions?: CashTransactionCreateNestedManyWithoutCashAccountInput
    salesReceipts?: SalesReceiptCreateNestedManyWithoutCashAccountInput
    purchasePayments?: PurchasePaymentCreateNestedManyWithoutCashAccountInput
    chartOfAccount?: ChartOfAccountCreateNestedOneWithoutCashAccountsInput
  }

  export type CashAccountUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    accountType: string
    accountNumber?: string | null
    glAccountId?: string | null
    bankName?: string | null
    balance?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    chartOfAccountId?: string | null
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCashAccountInput
    salesReceipts?: SalesReceiptUncheckedCreateNestedManyWithoutCashAccountInput
    purchasePayments?: PurchasePaymentUncheckedCreateNestedManyWithoutCashAccountInput
  }

  export type CashAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashTransactions?: CashTransactionUpdateManyWithoutCashAccountNestedInput
    salesReceipts?: SalesReceiptUpdateManyWithoutCashAccountNestedInput
    purchasePayments?: PurchasePaymentUpdateManyWithoutCashAccountNestedInput
    chartOfAccount?: ChartOfAccountUpdateOneWithoutCashAccountsNestedInput
  }

  export type CashAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chartOfAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCashAccountNestedInput
    salesReceipts?: SalesReceiptUncheckedUpdateManyWithoutCashAccountNestedInput
    purchasePayments?: PurchasePaymentUncheckedUpdateManyWithoutCashAccountNestedInput
  }

  export type CashAccountCreateManyInput = {
    id?: string
    code: string
    name: string
    accountType: string
    accountNumber?: string | null
    glAccountId?: string | null
    bankName?: string | null
    balance?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    chartOfAccountId?: string | null
  }

  export type CashAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chartOfAccountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CashTransactionCreateInput = {
    id?: string
    transactionNo: string
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    refType?: string | null
    refId?: string | null
    transactionDate: Date | string
    isReconciled?: boolean
    reconciledAt?: Date | string | null
    createdAt?: Date | string
    reference: string
    cashAccount: CashAccountCreateNestedOneWithoutCashTransactionsInput
    glAccount?: ChartOfAccountCreateNestedOneWithoutCashTransactionsGLInput
    contraAccount?: ChartOfAccountCreateNestedOneWithoutCashTransactionsContraInput
    user: UserCreateNestedOneWithoutCashTransactionsInput
  }

  export type CashTransactionUncheckedCreateInput = {
    id?: string
    transactionNo: string
    cashAccountId: string
    glAccountId?: string | null
    contraAccountId?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    refType?: string | null
    refId?: string | null
    transactionDate: Date | string
    isReconciled?: boolean
    reconciledAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    reference: string
  }

  export type CashTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionNo?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    cashAccount?: CashAccountUpdateOneRequiredWithoutCashTransactionsNestedInput
    glAccount?: ChartOfAccountUpdateOneWithoutCashTransactionsGLNestedInput
    contraAccount?: ChartOfAccountUpdateOneWithoutCashTransactionsContraNestedInput
    user?: UserUpdateOneRequiredWithoutCashTransactionsNestedInput
  }

  export type CashTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionNo?: StringFieldUpdateOperationsInput | string
    cashAccountId?: StringFieldUpdateOperationsInput | string
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    contraAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
  }

  export type CashTransactionCreateManyInput = {
    id?: string
    transactionNo: string
    cashAccountId: string
    glAccountId?: string | null
    contraAccountId?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    refType?: string | null
    refId?: string | null
    transactionDate: Date | string
    isReconciled?: boolean
    reconciledAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    reference: string
  }

  export type CashTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionNo?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
  }

  export type CashTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionNo?: StringFieldUpdateOperationsInput | string
    cashAccountId?: StringFieldUpdateOperationsInput | string
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    contraAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
  }

  export type SalesReceiptCreateInput = {
    id?: string
    receiptNo: string
    amountReceived: Decimal | DecimalJsLike | number | string
    receiptDate: Date | string
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    sale: SaleCreateNestedOneWithoutSalesReceiptsInput
    customer: CustomerCreateNestedOneWithoutSalesReceiptsInput
    cashAccount: CashAccountCreateNestedOneWithoutSalesReceiptsInput
    user: UserCreateNestedOneWithoutSalesReceiptsInput
  }

  export type SalesReceiptUncheckedCreateInput = {
    id?: string
    receiptNo: string
    saleId: string
    customerId: string
    cashAccountId: string
    amountReceived: Decimal | DecimalJsLike | number | string
    receiptDate: Date | string
    reference?: string | null
    notes?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type SalesReceiptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNo?: StringFieldUpdateOperationsInput | string
    amountReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutSalesReceiptsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSalesReceiptsNestedInput
    cashAccount?: CashAccountUpdateOneRequiredWithoutSalesReceiptsNestedInput
    user?: UserUpdateOneRequiredWithoutSalesReceiptsNestedInput
  }

  export type SalesReceiptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNo?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    cashAccountId?: StringFieldUpdateOperationsInput | string
    amountReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesReceiptCreateManyInput = {
    id?: string
    receiptNo: string
    saleId: string
    customerId: string
    cashAccountId: string
    amountReceived: Decimal | DecimalJsLike | number | string
    receiptDate: Date | string
    reference?: string | null
    notes?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type SalesReceiptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNo?: StringFieldUpdateOperationsInput | string
    amountReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesReceiptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNo?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    cashAccountId?: StringFieldUpdateOperationsInput | string
    amountReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePaymentCreateInput = {
    id?: string
    paymentNo: string
    amountPaid: Decimal | DecimalJsLike | number | string
    paymentDate: Date | string
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutPurchasePaymentsInput
    vendor: VendorCreateNestedOneWithoutPurchasePaymentsInput
    cashAccount: CashAccountCreateNestedOneWithoutPurchasePaymentsInput
    user: UserCreateNestedOneWithoutPurchasePaymentsInput
  }

  export type PurchasePaymentUncheckedCreateInput = {
    id?: string
    paymentNo: string
    purchaseId: string
    vendorId: string
    cashAccountId: string
    amountPaid: Decimal | DecimalJsLike | number | string
    paymentDate: Date | string
    reference?: string | null
    notes?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type PurchasePaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNo?: StringFieldUpdateOperationsInput | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutPurchasePaymentsNestedInput
    vendor?: VendorUpdateOneRequiredWithoutPurchasePaymentsNestedInput
    cashAccount?: CashAccountUpdateOneRequiredWithoutPurchasePaymentsNestedInput
    user?: UserUpdateOneRequiredWithoutPurchasePaymentsNestedInput
  }

  export type PurchasePaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNo?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    cashAccountId?: StringFieldUpdateOperationsInput | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePaymentCreateManyInput = {
    id?: string
    paymentNo: string
    purchaseId: string
    vendorId: string
    cashAccountId: string
    amountPaid: Decimal | DecimalJsLike | number | string
    paymentDate: Date | string
    reference?: string | null
    notes?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type PurchasePaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNo?: StringFieldUpdateOperationsInput | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNo?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    cashAccountId?: StringFieldUpdateOperationsInput | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateInput = {
    id?: string
    category: string
    key: string
    value?: string | null
    dataType?: string | null
    description?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    updatedByUser?: UserCreateNestedOneWithoutSystemSettingInput
  }

  export type SystemSettingUncheckedCreateInput = {
    id?: string
    category: string
    key: string
    value?: string | null
    dataType?: string | null
    description?: string | null
    updatedBy?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type SystemSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedByUser?: UserUpdateOneWithoutSystemSettingNestedInput
  }

  export type SystemSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateManyInput = {
    id?: string
    category: string
    key: string
    value?: string | null
    dataType?: string | null
    description?: string | null
    updatedBy?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type SystemSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiscalYearCreateInput = {
    id?: string
    year: number
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    periods?: FiscalPeriodCreateNestedManyWithoutFiscalYearInput
  }

  export type FiscalYearUncheckedCreateInput = {
    id?: string
    year: number
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    periods?: FiscalPeriodUncheckedCreateNestedManyWithoutFiscalYearInput
  }

  export type FiscalYearUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    periods?: FiscalPeriodUpdateManyWithoutFiscalYearNestedInput
  }

  export type FiscalYearUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    periods?: FiscalPeriodUncheckedUpdateManyWithoutFiscalYearNestedInput
  }

  export type FiscalYearCreateManyInput = {
    id?: string
    year: number
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FiscalYearUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiscalYearUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiscalPeriodCreateInput = {
    id?: string
    periodNumber: number
    name: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fiscalYear: FiscalYearCreateNestedOneWithoutPeriodsInput
  }

  export type FiscalPeriodUncheckedCreateInput = {
    id?: string
    fiscalYearId: string
    periodNumber: number
    name: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FiscalPeriodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fiscalYear?: FiscalYearUpdateOneRequiredWithoutPeriodsNestedInput
  }

  export type FiscalPeriodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fiscalYearId?: StringFieldUpdateOperationsInput | string
    periodNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiscalPeriodCreateManyInput = {
    id?: string
    fiscalYearId: string
    periodNumber: number
    name: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FiscalPeriodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiscalPeriodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fiscalYearId?: StringFieldUpdateOperationsInput | string
    periodNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalWorkflowCreateInput = {
    id?: string
    name: string
    entity: string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: ApprovalStepCreateNestedManyWithoutWorkflowInput
    ApprovalRequest?: ApprovalRequestCreateNestedManyWithoutWorkflowInput
  }

  export type ApprovalWorkflowUncheckedCreateInput = {
    id?: string
    name: string
    entity: string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: ApprovalStepUncheckedCreateNestedManyWithoutWorkflowInput
    ApprovalRequest?: ApprovalRequestUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type ApprovalWorkflowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: ApprovalStepUpdateManyWithoutWorkflowNestedInput
    ApprovalRequest?: ApprovalRequestUpdateManyWithoutWorkflowNestedInput
  }

  export type ApprovalWorkflowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: ApprovalStepUncheckedUpdateManyWithoutWorkflowNestedInput
    ApprovalRequest?: ApprovalRequestUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type ApprovalWorkflowCreateManyInput = {
    id?: string
    name: string
    entity: string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalWorkflowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalWorkflowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalStepCreateInput = {
    id?: string
    stepOrder: number
    name: string
    isRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workflow: ApprovalWorkflowCreateNestedOneWithoutStepsInput
    role: RoleCreateNestedOneWithoutApprovalStepInput
    ApprovalRequest?: ApprovalRequestCreateNestedManyWithoutCurrentStepInput
    ApprovalAction?: ApprovalActionCreateNestedManyWithoutStepInput
  }

  export type ApprovalStepUncheckedCreateInput = {
    id?: string
    workflowId: string
    stepOrder: number
    name: string
    roleId: string
    isRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ApprovalRequest?: ApprovalRequestUncheckedCreateNestedManyWithoutCurrentStepInput
    ApprovalAction?: ApprovalActionUncheckedCreateNestedManyWithoutStepInput
  }

  export type ApprovalStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: ApprovalWorkflowUpdateOneRequiredWithoutStepsNestedInput
    role?: RoleUpdateOneRequiredWithoutApprovalStepNestedInput
    ApprovalRequest?: ApprovalRequestUpdateManyWithoutCurrentStepNestedInput
    ApprovalAction?: ApprovalActionUpdateManyWithoutStepNestedInput
  }

  export type ApprovalStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ApprovalRequest?: ApprovalRequestUncheckedUpdateManyWithoutCurrentStepNestedInput
    ApprovalAction?: ApprovalActionUncheckedUpdateManyWithoutStepNestedInput
  }

  export type ApprovalStepCreateManyInput = {
    id?: string
    workflowId: string
    stepOrder: number
    name: string
    roleId: string
    isRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalRequestCreateInput = {
    id?: string
    entityType: string
    entityId: string
    status: string
    requestedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workflow: ApprovalWorkflowCreateNestedOneWithoutApprovalRequestInput
    requestedByUser: UserCreateNestedOneWithoutApprovalRequestInput
    currentStep?: ApprovalStepCreateNestedOneWithoutApprovalRequestInput
    actions?: ApprovalActionCreateNestedManyWithoutRequestInput
  }

  export type ApprovalRequestUncheckedCreateInput = {
    id?: string
    workflowId: string
    entityType: string
    entityId: string
    requestedBy: string
    currentStepId?: string | null
    status: string
    requestedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actions?: ApprovalActionUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ApprovalRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: ApprovalWorkflowUpdateOneRequiredWithoutApprovalRequestNestedInput
    requestedByUser?: UserUpdateOneRequiredWithoutApprovalRequestNestedInput
    currentStep?: ApprovalStepUpdateOneWithoutApprovalRequestNestedInput
    actions?: ApprovalActionUpdateManyWithoutRequestNestedInput
  }

  export type ApprovalRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actions?: ApprovalActionUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type ApprovalRequestCreateManyInput = {
    id?: string
    workflowId: string
    entityType: string
    entityId: string
    requestedBy: string
    currentStepId?: string | null
    status: string
    requestedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalActionCreateInput = {
    id?: string
    action: string
    comments?: string | null
    actionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    request: ApprovalRequestCreateNestedOneWithoutActionsInput
    step: ApprovalStepCreateNestedOneWithoutApprovalActionInput
    user: UserCreateNestedOneWithoutApprovalActionInput
  }

  export type ApprovalActionUncheckedCreateInput = {
    id?: string
    requestId: string
    stepId: string
    userId: string
    action: string
    comments?: string | null
    actionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalActionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: ApprovalRequestUpdateOneRequiredWithoutActionsNestedInput
    step?: ApprovalStepUpdateOneRequiredWithoutApprovalActionNestedInput
    user?: UserUpdateOneRequiredWithoutApprovalActionNestedInput
  }

  export type ApprovalActionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalActionCreateManyInput = {
    id?: string
    requestId: string
    stepId: string
    userId: string
    action: string
    comments?: string | null
    actionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalActionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalActionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCategoryCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    depreciationMethod: string
    usefulLife?: number
    residualValue?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    assets?: AssetCreateNestedManyWithoutCategoryInput
    glAssetAccount: ChartOfAccountCreateNestedOneWithoutAssetCategoriesAssetInput
    glDepreciationAccount: ChartOfAccountCreateNestedOneWithoutAssetCategoriesDepreciationInput
    glAccumulatedDepreciationAccount: ChartOfAccountCreateNestedOneWithoutAssetCategoriesAccumulatedInput
  }

  export type AssetCategoryUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    depreciationMethod: string
    usefulLife?: number
    residualValue?: Decimal | DecimalJsLike | number | string
    glAssetAccountId: string
    glDepreciationAccountId: string
    glAccumulatedDepreciationAccountId: string
    isActive?: boolean
    createdAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type AssetCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUpdateManyWithoutCategoryNestedInput
    glAssetAccount?: ChartOfAccountUpdateOneRequiredWithoutAssetCategoriesAssetNestedInput
    glDepreciationAccount?: ChartOfAccountUpdateOneRequiredWithoutAssetCategoriesDepreciationNestedInput
    glAccumulatedDepreciationAccount?: ChartOfAccountUpdateOneRequiredWithoutAssetCategoriesAccumulatedNestedInput
  }

  export type AssetCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    glAssetAccountId?: StringFieldUpdateOperationsInput | string
    glDepreciationAccountId?: StringFieldUpdateOperationsInput | string
    glAccumulatedDepreciationAccountId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type AssetCategoryCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    depreciationMethod: string
    usefulLife?: number
    residualValue?: Decimal | DecimalJsLike | number | string
    glAssetAccountId: string
    glDepreciationAccountId: string
    glAccumulatedDepreciationAccountId: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type AssetCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    glAssetAccountId?: StringFieldUpdateOperationsInput | string
    glDepreciationAccountId?: StringFieldUpdateOperationsInput | string
    glAccumulatedDepreciationAccountId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateInput = {
    id?: string
    assetNo: string
    name: string
    description?: string | null
    acquisitionDate: Date | string
    acquisitionCost: Decimal | DecimalJsLike | number | string
    residualValue?: Decimal | DecimalJsLike | number | string
    usefulLife: number
    depreciationMethod: string
    serialNumber?: string | null
    supplier?: string | null
    status?: string
    disposalDate?: Date | string | null
    disposalAmount?: Decimal | DecimalJsLike | number | string | null
    disposalMethod?: string | null
    createdAt?: Date | string
    category: AssetCategoryCreateNestedOneWithoutAssetsInput
    location?: LocationCreateNestedOneWithoutAssetsInput
    purchaseOrder?: PurchaseCreateNestedOneWithoutAssetsInput
    createdByUser: UserCreateNestedOneWithoutAssetsCreatedInput
    depreciationEntries?: AssetDepreciationCreateNestedManyWithoutAssetInput
    disposals?: AssetDisposalCreateNestedManyWithoutAssetInput
    Vendor?: VendorCreateNestedOneWithoutAssetsInput
  }

  export type AssetUncheckedCreateInput = {
    id?: string
    assetNo: string
    name: string
    description?: string | null
    categoryId: string
    acquisitionDate: Date | string
    acquisitionCost: Decimal | DecimalJsLike | number | string
    residualValue?: Decimal | DecimalJsLike | number | string
    usefulLife: number
    depreciationMethod: string
    locationId?: string | null
    serialNumber?: string | null
    supplier?: string | null
    purchaseOrderId?: string | null
    status?: string
    disposalDate?: Date | string | null
    disposalAmount?: Decimal | DecimalJsLike | number | string | null
    disposalMethod?: string | null
    createdBy: string
    createdAt?: Date | string
    vendorId?: string | null
    depreciationEntries?: AssetDepreciationUncheckedCreateNestedManyWithoutAssetInput
    disposals?: AssetDisposalUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquisitionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disposalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: AssetCategoryUpdateOneRequiredWithoutAssetsNestedInput
    location?: LocationUpdateOneWithoutAssetsNestedInput
    purchaseOrder?: PurchaseUpdateOneWithoutAssetsNestedInput
    createdByUser?: UserUpdateOneRequiredWithoutAssetsCreatedNestedInput
    depreciationEntries?: AssetDepreciationUpdateManyWithoutAssetNestedInput
    disposals?: AssetDisposalUpdateManyWithoutAssetNestedInput
    Vendor?: VendorUpdateOneWithoutAssetsNestedInput
  }

  export type AssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquisitionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disposalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    depreciationEntries?: AssetDepreciationUncheckedUpdateManyWithoutAssetNestedInput
    disposals?: AssetDisposalUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetCreateManyInput = {
    id?: string
    assetNo: string
    name: string
    description?: string | null
    categoryId: string
    acquisitionDate: Date | string
    acquisitionCost: Decimal | DecimalJsLike | number | string
    residualValue?: Decimal | DecimalJsLike | number | string
    usefulLife: number
    depreciationMethod: string
    locationId?: string | null
    serialNumber?: string | null
    supplier?: string | null
    purchaseOrderId?: string | null
    status?: string
    disposalDate?: Date | string | null
    disposalAmount?: Decimal | DecimalJsLike | number | string | null
    disposalMethod?: string | null
    createdBy: string
    createdAt?: Date | string
    vendorId?: string | null
  }

  export type AssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquisitionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disposalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquisitionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disposalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetDepreciationCreateInput = {
    id?: string
    periodYear: number
    periodMonth: number
    depreciationAmount: Decimal | DecimalJsLike | number | string
    accumulatedDepreciation: Decimal | DecimalJsLike | number | string
    netBookValue: Decimal | DecimalJsLike | number | string
    isPosted?: boolean
    postedAt?: Date | string | null
    createdAt?: Date | string
    asset: AssetCreateNestedOneWithoutDepreciationEntriesInput
    journal?: JournalCreateNestedOneWithoutAssetDepreciationInput
  }

  export type AssetDepreciationUncheckedCreateInput = {
    id?: string
    assetId: string
    periodYear: number
    periodMonth: number
    depreciationAmount: Decimal | DecimalJsLike | number | string
    accumulatedDepreciation: Decimal | DecimalJsLike | number | string
    netBookValue: Decimal | DecimalJsLike | number | string
    isPosted?: boolean
    postedAt?: Date | string | null
    journalId?: string | null
    createdAt?: Date | string
  }

  export type AssetDepreciationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodYear?: IntFieldUpdateOperationsInput | number
    periodMonth?: IntFieldUpdateOperationsInput | number
    depreciationAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accumulatedDepreciation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netBookValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asset?: AssetUpdateOneRequiredWithoutDepreciationEntriesNestedInput
    journal?: JournalUpdateOneWithoutAssetDepreciationNestedInput
  }

  export type AssetDepreciationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    periodYear?: IntFieldUpdateOperationsInput | number
    periodMonth?: IntFieldUpdateOperationsInput | number
    depreciationAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accumulatedDepreciation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netBookValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetDepreciationCreateManyInput = {
    id?: string
    assetId: string
    periodYear: number
    periodMonth: number
    depreciationAmount: Decimal | DecimalJsLike | number | string
    accumulatedDepreciation: Decimal | DecimalJsLike | number | string
    netBookValue: Decimal | DecimalJsLike | number | string
    isPosted?: boolean
    postedAt?: Date | string | null
    journalId?: string | null
    createdAt?: Date | string
  }

  export type AssetDepreciationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodYear?: IntFieldUpdateOperationsInput | number
    periodMonth?: IntFieldUpdateOperationsInput | number
    depreciationAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accumulatedDepreciation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netBookValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetDepreciationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    periodYear?: IntFieldUpdateOperationsInput | number
    periodMonth?: IntFieldUpdateOperationsInput | number
    depreciationAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accumulatedDepreciation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netBookValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetDisposalCreateInput = {
    id?: string
    disposalDate: Date | string
    disposalAmount: Decimal | DecimalJsLike | number | string
    disposalMethod: string
    buyerDetails?: string | null
    gainLoss: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    asset: AssetCreateNestedOneWithoutDisposalsInput
    journal?: JournalCreateNestedOneWithoutAssetDisposalsInput
    disposedByUser: UserCreateNestedOneWithoutAssetDisposalsInput
  }

  export type AssetDisposalUncheckedCreateInput = {
    id?: string
    assetId: string
    disposalDate: Date | string
    disposalAmount: Decimal | DecimalJsLike | number | string
    disposalMethod: string
    buyerDetails?: string | null
    gainLoss: Decimal | DecimalJsLike | number | string
    notes?: string | null
    journalId?: string | null
    disposedBy: string
    createdAt?: Date | string
  }

  export type AssetDisposalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    disposalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    disposalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disposalMethod?: StringFieldUpdateOperationsInput | string
    buyerDetails?: NullableStringFieldUpdateOperationsInput | string | null
    gainLoss?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asset?: AssetUpdateOneRequiredWithoutDisposalsNestedInput
    journal?: JournalUpdateOneWithoutAssetDisposalsNestedInput
    disposedByUser?: UserUpdateOneRequiredWithoutAssetDisposalsNestedInput
  }

  export type AssetDisposalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    disposalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    disposalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disposalMethod?: StringFieldUpdateOperationsInput | string
    buyerDetails?: NullableStringFieldUpdateOperationsInput | string | null
    gainLoss?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    journalId?: NullableStringFieldUpdateOperationsInput | string | null
    disposedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetDisposalCreateManyInput = {
    id?: string
    assetId: string
    disposalDate: Date | string
    disposalAmount: Decimal | DecimalJsLike | number | string
    disposalMethod: string
    buyerDetails?: string | null
    gainLoss: Decimal | DecimalJsLike | number | string
    notes?: string | null
    journalId?: string | null
    disposedBy: string
    createdAt?: Date | string
  }

  export type AssetDisposalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    disposalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    disposalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disposalMethod?: StringFieldUpdateOperationsInput | string
    buyerDetails?: NullableStringFieldUpdateOperationsInput | string | null
    gainLoss?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetDisposalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    disposalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    disposalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disposalMethod?: StringFieldUpdateOperationsInput | string
    buyerDetails?: NullableStringFieldUpdateOperationsInput | string | null
    gainLoss?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    journalId?: NullableStringFieldUpdateOperationsInput | string | null
    disposedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type JournalListRelationFilter = {
    every?: JournalWhereInput
    some?: JournalWhereInput
    none?: JournalWhereInput
  }

  export type InventoryLedgerListRelationFilter = {
    every?: InventoryLedgerWhereInput
    some?: InventoryLedgerWhereInput
    none?: InventoryLedgerWhereInput
  }

  export type CashTransactionListRelationFilter = {
    every?: CashTransactionWhereInput
    some?: CashTransactionWhereInput
    none?: CashTransactionWhereInput
  }

  export type SalesReceiptListRelationFilter = {
    every?: SalesReceiptWhereInput
    some?: SalesReceiptWhereInput
    none?: SalesReceiptWhereInput
  }

  export type PurchasePaymentListRelationFilter = {
    every?: PurchasePaymentWhereInput
    some?: PurchasePaymentWhereInput
    none?: PurchasePaymentWhereInput
  }

  export type SystemSettingListRelationFilter = {
    every?: SystemSettingWhereInput
    some?: SystemSettingWhereInput
    none?: SystemSettingWhereInput
  }

  export type ApprovalRequestListRelationFilter = {
    every?: ApprovalRequestWhereInput
    some?: ApprovalRequestWhereInput
    none?: ApprovalRequestWhereInput
  }

  export type ApprovalActionListRelationFilter = {
    every?: ApprovalActionWhereInput
    some?: ApprovalActionWhereInput
    none?: ApprovalActionWhereInput
  }

  export type AssetListRelationFilter = {
    every?: AssetWhereInput
    some?: AssetWhereInput
    none?: AssetWhereInput
  }

  export type AssetDisposalListRelationFilter = {
    every?: AssetDisposalWhereInput
    some?: AssetDisposalWhereInput
    none?: AssetDisposalWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryLedgerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CashTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesReceiptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchasePaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SystemSettingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApprovalRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApprovalActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetDisposalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    status?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    status?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    status?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type ApprovalStepListRelationFilter = {
    every?: ApprovalStepWhereInput
    some?: ApprovalStepWhereInput
    none?: ApprovalStepWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApprovalStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    description?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    description?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    description?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserRoleUserIdRoleIdCompoundUniqueInput = {
    userId: string
    roleId: string
  }

  export type UserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type PermissionRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RolePermissionRoleIdPermissionIdCompoundUniqueInput = {
    roleId: string
    permissionId: string
  }

  export type RolePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    baseCurrency?: SortOrder
    timezone?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    baseCurrency?: SortOrder
    timezone?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    baseCurrency?: SortOrder
    timezone?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type WarehouseListRelationFilter = {
    every?: WarehouseWhereInput
    some?: WarehouseWhereInput
    none?: WarehouseWhereInput
  }

  export type WarehouseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type LocationRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type BinListRelationFilter = {
    every?: BinWhereInput
    some?: BinWhereInput
    none?: BinWhereInput
  }

  export type InventoryBatchListRelationFilter = {
    every?: InventoryBatchWhereInput
    some?: InventoryBatchWhereInput
    none?: InventoryBatchWhereInput
  }

  export type ProductionOrderListRelationFilter = {
    every?: ProductionOrderWhereInput
    some?: ProductionOrderWhereInput
    none?: ProductionOrderWhereInput
  }

  export type BinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryBatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductionOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehouseCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    locationId?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type WarehouseMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    locationId?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type WarehouseMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    locationId?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type WarehouseRelationFilter = {
    is?: WarehouseWhereInput
    isNot?: WarehouseWhereInput
  }

  export type BinWarehouseIdCodeCompoundUniqueInput = {
    warehouseId: string
    code: string
  }

  export type BinCountOrderByAggregateInput = {
    id?: SortOrder
    warehouseId?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type BinMaxOrderByAggregateInput = {
    id?: SortOrder
    warehouseId?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type BinMinOrderByAggregateInput = {
    id?: SortOrder
    warehouseId?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type EnumItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeFilter<$PrismaModel> | $Enums.ItemType
  }

  export type EnumCostingMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.CostingMethod | EnumCostingMethodFieldRefInput<$PrismaModel>
    in?: $Enums.CostingMethod[] | ListEnumCostingMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.CostingMethod[] | ListEnumCostingMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumCostingMethodFilter<$PrismaModel> | $Enums.CostingMethod
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BomListRelationFilter = {
    every?: BomWhereInput
    some?: BomWhereInput
    none?: BomWhereInput
  }

  export type BomLineListRelationFilter = {
    every?: BomLineWhereInput
    some?: BomLineWhereInput
    none?: BomLineWhereInput
  }

  export type PurchaseLineListRelationFilter = {
    every?: PurchaseLineWhereInput
    some?: PurchaseLineWhereInput
    none?: PurchaseLineWhereInput
  }

  export type SaleLineListRelationFilter = {
    every?: SaleLineWhereInput
    some?: SaleLineWhereInput
    none?: SaleLineWhereInput
  }

  export type BomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BomLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    uom?: SortOrder
    costingMethod?: SortOrder
    standardCost?: SortOrder
    sellingPriceOrdinary?: SortOrder
    sellingPriceBulk?: SortOrder
    sellingPriceWIC?: SortOrder
    taxCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    standardCost?: SortOrder
    sellingPriceOrdinary?: SortOrder
    sellingPriceBulk?: SortOrder
    sellingPriceWIC?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    uom?: SortOrder
    costingMethod?: SortOrder
    standardCost?: SortOrder
    sellingPriceOrdinary?: SortOrder
    sellingPriceBulk?: SortOrder
    sellingPriceWIC?: SortOrder
    taxCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    uom?: SortOrder
    costingMethod?: SortOrder
    standardCost?: SortOrder
    sellingPriceOrdinary?: SortOrder
    sellingPriceBulk?: SortOrder
    sellingPriceWIC?: SortOrder
    taxCode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    standardCost?: SortOrder
    sellingPriceOrdinary?: SortOrder
    sellingPriceBulk?: SortOrder
    sellingPriceWIC?: SortOrder
  }

  export type EnumItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.ItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemTypeFilter<$PrismaModel>
    _max?: NestedEnumItemTypeFilter<$PrismaModel>
  }

  export type EnumCostingMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CostingMethod | EnumCostingMethodFieldRefInput<$PrismaModel>
    in?: $Enums.CostingMethod[] | ListEnumCostingMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.CostingMethod[] | ListEnumCostingMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumCostingMethodWithAggregatesFilter<$PrismaModel> | $Enums.CostingMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCostingMethodFilter<$PrismaModel>
    _max?: NestedEnumCostingMethodFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type ItemRelationFilter = {
    is?: ItemWhereInput
    isNot?: ItemWhereInput
  }

  export type BomItemIdVersionCompoundUniqueInput = {
    itemId: string
    version: string
  }

  export type BomCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BomMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BomMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BomRelationFilter = {
    is?: BomWhereInput
    isNot?: BomWhereInput
  }

  export type BomLineCountOrderByAggregateInput = {
    id?: SortOrder
    bomId?: SortOrder
    componentItemId?: SortOrder
    qtyPer?: SortOrder
    scrapPercent?: SortOrder
  }

  export type BomLineAvgOrderByAggregateInput = {
    qtyPer?: SortOrder
    scrapPercent?: SortOrder
  }

  export type BomLineMaxOrderByAggregateInput = {
    id?: SortOrder
    bomId?: SortOrder
    componentItemId?: SortOrder
    qtyPer?: SortOrder
    scrapPercent?: SortOrder
  }

  export type BomLineMinOrderByAggregateInput = {
    id?: SortOrder
    bomId?: SortOrder
    componentItemId?: SortOrder
    qtyPer?: SortOrder
    scrapPercent?: SortOrder
  }

  export type BomLineSumOrderByAggregateInput = {
    qtyPer?: SortOrder
    scrapPercent?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BinNullableRelationFilter = {
    is?: BinWhereInput | null
    isNot?: BinWhereInput | null
  }

  export type InventoryBatchCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    warehouseId?: SortOrder
    binId?: SortOrder
    qtyOnHand?: SortOrder
    unitCost?: SortOrder
    receivedAt?: SortOrder
  }

  export type InventoryBatchAvgOrderByAggregateInput = {
    qtyOnHand?: SortOrder
    unitCost?: SortOrder
  }

  export type InventoryBatchMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    warehouseId?: SortOrder
    binId?: SortOrder
    qtyOnHand?: SortOrder
    unitCost?: SortOrder
    receivedAt?: SortOrder
  }

  export type InventoryBatchMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    warehouseId?: SortOrder
    binId?: SortOrder
    qtyOnHand?: SortOrder
    unitCost?: SortOrder
    receivedAt?: SortOrder
  }

  export type InventoryBatchSumOrderByAggregateInput = {
    qtyOnHand?: SortOrder
    unitCost?: SortOrder
  }

  export type EnumLedgerDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerDirection | EnumLedgerDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerDirection[] | ListEnumLedgerDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerDirection[] | ListEnumLedgerDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerDirectionFilter<$PrismaModel> | $Enums.LedgerDirection
  }

  export type InventoryBatchNullableRelationFilter = {
    is?: InventoryBatchWhereInput | null
    isNot?: InventoryBatchWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type InventoryLedgerCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    warehouseId?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    direction?: SortOrder
    qty?: SortOrder
    unitCost?: SortOrder
    value?: SortOrder
    runningQty?: SortOrder
    runningValue?: SortOrder
    runningAvgCost?: SortOrder
    batchId?: SortOrder
    userId?: SortOrder
    postedAt?: SortOrder
  }

  export type InventoryLedgerAvgOrderByAggregateInput = {
    qty?: SortOrder
    unitCost?: SortOrder
    value?: SortOrder
    runningQty?: SortOrder
    runningValue?: SortOrder
    runningAvgCost?: SortOrder
  }

  export type InventoryLedgerMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    warehouseId?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    direction?: SortOrder
    qty?: SortOrder
    unitCost?: SortOrder
    value?: SortOrder
    runningQty?: SortOrder
    runningValue?: SortOrder
    runningAvgCost?: SortOrder
    batchId?: SortOrder
    userId?: SortOrder
    postedAt?: SortOrder
  }

  export type InventoryLedgerMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    warehouseId?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    direction?: SortOrder
    qty?: SortOrder
    unitCost?: SortOrder
    value?: SortOrder
    runningQty?: SortOrder
    runningValue?: SortOrder
    runningAvgCost?: SortOrder
    batchId?: SortOrder
    userId?: SortOrder
    postedAt?: SortOrder
  }

  export type InventoryLedgerSumOrderByAggregateInput = {
    qty?: SortOrder
    unitCost?: SortOrder
    value?: SortOrder
    runningQty?: SortOrder
    runningValue?: SortOrder
    runningAvgCost?: SortOrder
  }

  export type EnumLedgerDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerDirection | EnumLedgerDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerDirection[] | ListEnumLedgerDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerDirection[] | ListEnumLedgerDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerDirectionWithAggregatesFilter<$PrismaModel> | $Enums.LedgerDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerDirectionFilter<$PrismaModel>
    _max?: NestedEnumLedgerDirectionFilter<$PrismaModel>
  }

  export type EnumProductionOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductionOrderStatus | EnumProductionOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductionOrderStatus[] | ListEnumProductionOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductionOrderStatus[] | ListEnumProductionOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductionOrderStatusFilter<$PrismaModel> | $Enums.ProductionOrderStatus
  }

  export type BomNullableRelationFilter = {
    is?: BomWhereInput | null
    isNot?: BomWhereInput | null
  }

  export type WipLedgerListRelationFilter = {
    every?: WipLedgerWhereInput
    some?: WipLedgerWhereInput
    none?: WipLedgerWhereInput
  }

  export type LaborTimeListRelationFilter = {
    every?: LaborTimeWhereInput
    some?: LaborTimeWhereInput
    none?: LaborTimeWhereInput
  }

  export type WipLedgerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LaborTimeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductionOrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    itemId?: SortOrder
    qtyTarget?: SortOrder
    qtyProduced?: SortOrder
    status?: SortOrder
    warehouseId?: SortOrder
    bomId?: SortOrder
    approvalStatus?: SortOrder
    approvalRequestId?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionOrderAvgOrderByAggregateInput = {
    qtyTarget?: SortOrder
    qtyProduced?: SortOrder
  }

  export type ProductionOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    itemId?: SortOrder
    qtyTarget?: SortOrder
    qtyProduced?: SortOrder
    status?: SortOrder
    warehouseId?: SortOrder
    bomId?: SortOrder
    approvalStatus?: SortOrder
    approvalRequestId?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionOrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    itemId?: SortOrder
    qtyTarget?: SortOrder
    qtyProduced?: SortOrder
    status?: SortOrder
    warehouseId?: SortOrder
    bomId?: SortOrder
    approvalStatus?: SortOrder
    approvalRequestId?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductionOrderSumOrderByAggregateInput = {
    qtyTarget?: SortOrder
    qtyProduced?: SortOrder
  }

  export type EnumProductionOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductionOrderStatus | EnumProductionOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductionOrderStatus[] | ListEnumProductionOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductionOrderStatus[] | ListEnumProductionOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductionOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductionOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductionOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumProductionOrderStatusFilter<$PrismaModel>
  }

  export type EnumWipLedgerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WipLedgerType | EnumWipLedgerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WipLedgerType[] | ListEnumWipLedgerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WipLedgerType[] | ListEnumWipLedgerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWipLedgerTypeFilter<$PrismaModel> | $Enums.WipLedgerType
  }

  export type ProductionOrderRelationFilter = {
    is?: ProductionOrderWhereInput
    isNot?: ProductionOrderWhereInput
  }

  export type WipLedgerCountOrderByAggregateInput = {
    id?: SortOrder
    productionOrderId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    note?: SortOrder
    postedAt?: SortOrder
  }

  export type WipLedgerAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type WipLedgerMaxOrderByAggregateInput = {
    id?: SortOrder
    productionOrderId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    note?: SortOrder
    postedAt?: SortOrder
  }

  export type WipLedgerMinOrderByAggregateInput = {
    id?: SortOrder
    productionOrderId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    note?: SortOrder
    postedAt?: SortOrder
  }

  export type WipLedgerSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumWipLedgerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WipLedgerType | EnumWipLedgerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WipLedgerType[] | ListEnumWipLedgerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WipLedgerType[] | ListEnumWipLedgerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWipLedgerTypeWithAggregatesFilter<$PrismaModel> | $Enums.WipLedgerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWipLedgerTypeFilter<$PrismaModel>
    _max?: NestedEnumWipLedgerTypeFilter<$PrismaModel>
  }

  export type LaborTimeCountOrderByAggregateInput = {
    id?: SortOrder
    productionOrderId?: SortOrder
    hours?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    employeeName?: SortOrder
  }

  export type LaborTimeAvgOrderByAggregateInput = {
    hours?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
  }

  export type LaborTimeMaxOrderByAggregateInput = {
    id?: SortOrder
    productionOrderId?: SortOrder
    hours?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    employeeName?: SortOrder
  }

  export type LaborTimeMinOrderByAggregateInput = {
    id?: SortOrder
    productionOrderId?: SortOrder
    hours?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    employeeName?: SortOrder
  }

  export type LaborTimeSumOrderByAggregateInput = {
    hours?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
  }

  export type PurchaseListRelationFilter = {
    every?: PurchaseWhereInput
    some?: PurchaseWhereInput
    none?: PurchaseWhereInput
  }

  export type PurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    paymentTerms?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    paymentTerms?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    paymentTerms?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type SaleListRelationFilter = {
    every?: SaleWhereInput
    some?: SaleWhereInput
    none?: SaleWhereInput
  }

  export type SaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    creditLimit?: SortOrder
    CustomerGroup?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    creditLimit?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    creditLimit?: SortOrder
    CustomerGroup?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    creditLimit?: SortOrder
    CustomerGroup?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    creditLimit?: SortOrder
  }

  export type EnumPurchaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseStatusFilter<$PrismaModel> | $Enums.PurchaseStatus
  }

  export type VendorRelationFilter = {
    is?: VendorWhereInput
    isNot?: VendorWhereInput
  }

  export type PurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    vendorId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type PurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    vendorId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    vendorId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type EnumPurchaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseStatusFilter<$PrismaModel>
    _max?: NestedEnumPurchaseStatusFilter<$PrismaModel>
  }

  export type PurchaseRelationFilter = {
    is?: PurchaseWhereInput
    isNot?: PurchaseWhereInput
  }

  export type PurchaseLineCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type PurchaseLineAvgOrderByAggregateInput = {
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type PurchaseLineMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type PurchaseLineMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type PurchaseLineSumOrderByAggregateInput = {
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type EnumSaleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SaleStatus | EnumSaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SaleStatus[] | ListEnumSaleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SaleStatus[] | ListEnumSaleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSaleStatusFilter<$PrismaModel> | $Enums.SaleStatus
  }

  export type CustomerRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type SaleCountOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    customerId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type SaleMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    customerId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleMinOrderByAggregateInput = {
    id?: SortOrder
    orderNo?: SortOrder
    customerId?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type EnumSaleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SaleStatus | EnumSaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SaleStatus[] | ListEnumSaleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SaleStatus[] | ListEnumSaleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSaleStatusWithAggregatesFilter<$PrismaModel> | $Enums.SaleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSaleStatusFilter<$PrismaModel>
    _max?: NestedEnumSaleStatusFilter<$PrismaModel>
  }

  export type SaleRelationFilter = {
    is?: SaleWhereInput
    isNot?: SaleWhereInput
  }

  export type SaleLineCountOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type SaleLineAvgOrderByAggregateInput = {
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type SaleLineMaxOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type SaleLineMinOrderByAggregateInput = {
    id?: SortOrder
    saleId?: SortOrder
    itemId?: SortOrder
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type SaleLineSumOrderByAggregateInput = {
    qty?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type ChartOfAccountNullableRelationFilter = {
    is?: ChartOfAccountWhereInput | null
    isNot?: ChartOfAccountWhereInput | null
  }

  export type ChartOfAccountListRelationFilter = {
    every?: ChartOfAccountWhereInput
    some?: ChartOfAccountWhereInput
    none?: ChartOfAccountWhereInput
  }

  export type JournalLineListRelationFilter = {
    every?: JournalLineWhereInput
    some?: JournalLineWhereInput
    none?: JournalLineWhereInput
  }

  export type CashAccountListRelationFilter = {
    every?: CashAccountWhereInput
    some?: CashAccountWhereInput
    none?: CashAccountWhereInput
  }

  export type AssetCategoryListRelationFilter = {
    every?: AssetCategoryWhereInput
    some?: AssetCategoryWhereInput
    none?: AssetCategoryWhereInput
  }

  export type ChartOfAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CashAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChartOfAccountCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    accountType?: SortOrder
    parentId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ChartOfAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    accountType?: SortOrder
    parentId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ChartOfAccountMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    accountType?: SortOrder
    parentId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AssetDepreciationListRelationFilter = {
    every?: AssetDepreciationWhereInput
    some?: AssetDepreciationWhereInput
    none?: AssetDepreciationWhereInput
  }

  export type AssetDepreciationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalCountOrderByAggregateInput = {
    id?: SortOrder
    journalNo?: SortOrder
    date?: SortOrder
    memo?: SortOrder
    postedBy?: SortOrder
    postedAt?: SortOrder
  }

  export type JournalMaxOrderByAggregateInput = {
    id?: SortOrder
    journalNo?: SortOrder
    date?: SortOrder
    memo?: SortOrder
    postedBy?: SortOrder
    postedAt?: SortOrder
  }

  export type JournalMinOrderByAggregateInput = {
    id?: SortOrder
    journalNo?: SortOrder
    date?: SortOrder
    memo?: SortOrder
    postedBy?: SortOrder
    postedAt?: SortOrder
  }

  export type JournalRelationFilter = {
    is?: JournalWhereInput
    isNot?: JournalWhereInput
  }

  export type ChartOfAccountRelationFilter = {
    is?: ChartOfAccountWhereInput
    isNot?: ChartOfAccountWhereInput
  }

  export type JournalLineCountOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
  }

  export type JournalLineAvgOrderByAggregateInput = {
    debit?: SortOrder
    credit?: SortOrder
  }

  export type JournalLineMaxOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
  }

  export type JournalLineMinOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
  }

  export type JournalLineSumOrderByAggregateInput = {
    debit?: SortOrder
    credit?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PolicyCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    valueJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PolicyMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    beforeJson?: SortOrder
    afterJson?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type CashAccountCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    accountType?: SortOrder
    accountNumber?: SortOrder
    glAccountId?: SortOrder
    bankName?: SortOrder
    balance?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    chartOfAccountId?: SortOrder
  }

  export type CashAccountAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type CashAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    accountType?: SortOrder
    accountNumber?: SortOrder
    glAccountId?: SortOrder
    bankName?: SortOrder
    balance?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    chartOfAccountId?: SortOrder
  }

  export type CashAccountMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    accountType?: SortOrder
    accountNumber?: SortOrder
    glAccountId?: SortOrder
    bankName?: SortOrder
    balance?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    chartOfAccountId?: SortOrder
  }

  export type CashAccountSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type CashAccountRelationFilter = {
    is?: CashAccountWhereInput
    isNot?: CashAccountWhereInput
  }

  export type CashTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    transactionNo?: SortOrder
    cashAccountId?: SortOrder
    glAccountId?: SortOrder
    contraAccountId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    transactionDate?: SortOrder
    isReconciled?: SortOrder
    reconciledAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    reference?: SortOrder
  }

  export type CashTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type CashTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionNo?: SortOrder
    cashAccountId?: SortOrder
    glAccountId?: SortOrder
    contraAccountId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    transactionDate?: SortOrder
    isReconciled?: SortOrder
    reconciledAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    reference?: SortOrder
  }

  export type CashTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    transactionNo?: SortOrder
    cashAccountId?: SortOrder
    glAccountId?: SortOrder
    contraAccountId?: SortOrder
    transactionType?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    transactionDate?: SortOrder
    isReconciled?: SortOrder
    reconciledAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    reference?: SortOrder
  }

  export type CashTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SalesReceiptCountOrderByAggregateInput = {
    id?: SortOrder
    receiptNo?: SortOrder
    saleId?: SortOrder
    customerId?: SortOrder
    cashAccountId?: SortOrder
    amountReceived?: SortOrder
    receiptDate?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type SalesReceiptAvgOrderByAggregateInput = {
    amountReceived?: SortOrder
  }

  export type SalesReceiptMaxOrderByAggregateInput = {
    id?: SortOrder
    receiptNo?: SortOrder
    saleId?: SortOrder
    customerId?: SortOrder
    cashAccountId?: SortOrder
    amountReceived?: SortOrder
    receiptDate?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type SalesReceiptMinOrderByAggregateInput = {
    id?: SortOrder
    receiptNo?: SortOrder
    saleId?: SortOrder
    customerId?: SortOrder
    cashAccountId?: SortOrder
    amountReceived?: SortOrder
    receiptDate?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type SalesReceiptSumOrderByAggregateInput = {
    amountReceived?: SortOrder
  }

  export type PurchasePaymentCountOrderByAggregateInput = {
    id?: SortOrder
    paymentNo?: SortOrder
    purchaseId?: SortOrder
    vendorId?: SortOrder
    cashAccountId?: SortOrder
    amountPaid?: SortOrder
    paymentDate?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchasePaymentAvgOrderByAggregateInput = {
    amountPaid?: SortOrder
  }

  export type PurchasePaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentNo?: SortOrder
    purchaseId?: SortOrder
    vendorId?: SortOrder
    cashAccountId?: SortOrder
    amountPaid?: SortOrder
    paymentDate?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchasePaymentMinOrderByAggregateInput = {
    id?: SortOrder
    paymentNo?: SortOrder
    purchaseId?: SortOrder
    vendorId?: SortOrder
    cashAccountId?: SortOrder
    amountPaid?: SortOrder
    paymentDate?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchasePaymentSumOrderByAggregateInput = {
    amountPaid?: SortOrder
  }

  export type SystemSettingCategory_keyCompoundUniqueInput = {
    category: string
    key: string
  }

  export type SystemSettingCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    key?: SortOrder
    value?: SortOrder
    dataType?: SortOrder
    description?: SortOrder
    updatedBy?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    key?: SortOrder
    value?: SortOrder
    dataType?: SortOrder
    description?: SortOrder
    updatedBy?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemSettingMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    key?: SortOrder
    value?: SortOrder
    dataType?: SortOrder
    description?: SortOrder
    updatedBy?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FiscalPeriodListRelationFilter = {
    every?: FiscalPeriodWhereInput
    some?: FiscalPeriodWhereInput
    none?: FiscalPeriodWhereInput
  }

  export type FiscalPeriodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FiscalYearCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FiscalYearAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type FiscalYearMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FiscalYearMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FiscalYearSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FiscalYearRelationFilter = {
    is?: FiscalYearWhereInput
    isNot?: FiscalYearWhereInput
  }

  export type FiscalPeriodCountOrderByAggregateInput = {
    id?: SortOrder
    fiscalYearId?: SortOrder
    periodNumber?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FiscalPeriodAvgOrderByAggregateInput = {
    periodNumber?: SortOrder
  }

  export type FiscalPeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    fiscalYearId?: SortOrder
    periodNumber?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FiscalPeriodMinOrderByAggregateInput = {
    id?: SortOrder
    fiscalYearId?: SortOrder
    periodNumber?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FiscalPeriodSumOrderByAggregateInput = {
    periodNumber?: SortOrder
  }

  export type ApprovalWorkflowCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    entity?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalWorkflowAvgOrderByAggregateInput = {
    minAmount?: SortOrder
    maxAmount?: SortOrder
  }

  export type ApprovalWorkflowMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    entity?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalWorkflowMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    entity?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalWorkflowSumOrderByAggregateInput = {
    minAmount?: SortOrder
    maxAmount?: SortOrder
  }

  export type ApprovalWorkflowRelationFilter = {
    is?: ApprovalWorkflowWhereInput
    isNot?: ApprovalWorkflowWhereInput
  }

  export type ApprovalStepCountOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    stepOrder?: SortOrder
    name?: SortOrder
    roleId?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalStepAvgOrderByAggregateInput = {
    stepOrder?: SortOrder
  }

  export type ApprovalStepMaxOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    stepOrder?: SortOrder
    name?: SortOrder
    roleId?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalStepMinOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    stepOrder?: SortOrder
    name?: SortOrder
    roleId?: SortOrder
    isRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalStepSumOrderByAggregateInput = {
    stepOrder?: SortOrder
  }

  export type ApprovalStepNullableRelationFilter = {
    is?: ApprovalStepWhereInput | null
    isNot?: ApprovalStepWhereInput | null
  }

  export type ApprovalRequestCountOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    requestedBy?: SortOrder
    currentStepId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    requestedBy?: SortOrder
    currentStepId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalRequestMinOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    requestedBy?: SortOrder
    currentStepId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalRequestRelationFilter = {
    is?: ApprovalRequestWhereInput
    isNot?: ApprovalRequestWhereInput
  }

  export type ApprovalStepRelationFilter = {
    is?: ApprovalStepWhereInput
    isNot?: ApprovalStepWhereInput
  }

  export type ApprovalActionCountOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    stepId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    comments?: SortOrder
    actionDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalActionMaxOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    stepId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    comments?: SortOrder
    actionDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalActionMinOrderByAggregateInput = {
    id?: SortOrder
    requestId?: SortOrder
    stepId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    comments?: SortOrder
    actionDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssetCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    depreciationMethod?: SortOrder
    usefulLife?: SortOrder
    residualValue?: SortOrder
    glAssetAccountId?: SortOrder
    glDepreciationAccountId?: SortOrder
    glAccumulatedDepreciationAccountId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AssetCategoryAvgOrderByAggregateInput = {
    usefulLife?: SortOrder
    residualValue?: SortOrder
  }

  export type AssetCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    depreciationMethod?: SortOrder
    usefulLife?: SortOrder
    residualValue?: SortOrder
    glAssetAccountId?: SortOrder
    glDepreciationAccountId?: SortOrder
    glAccumulatedDepreciationAccountId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AssetCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    depreciationMethod?: SortOrder
    usefulLife?: SortOrder
    residualValue?: SortOrder
    glAssetAccountId?: SortOrder
    glDepreciationAccountId?: SortOrder
    glAccumulatedDepreciationAccountId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type AssetCategorySumOrderByAggregateInput = {
    usefulLife?: SortOrder
    residualValue?: SortOrder
  }

  export type AssetCategoryRelationFilter = {
    is?: AssetCategoryWhereInput
    isNot?: AssetCategoryWhereInput
  }

  export type LocationNullableRelationFilter = {
    is?: LocationWhereInput | null
    isNot?: LocationWhereInput | null
  }

  export type PurchaseNullableRelationFilter = {
    is?: PurchaseWhereInput | null
    isNot?: PurchaseWhereInput | null
  }

  export type VendorNullableRelationFilter = {
    is?: VendorWhereInput | null
    isNot?: VendorWhereInput | null
  }

  export type AssetCountOrderByAggregateInput = {
    id?: SortOrder
    assetNo?: SortOrder
    name?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    acquisitionDate?: SortOrder
    acquisitionCost?: SortOrder
    residualValue?: SortOrder
    usefulLife?: SortOrder
    depreciationMethod?: SortOrder
    locationId?: SortOrder
    serialNumber?: SortOrder
    supplier?: SortOrder
    purchaseOrderId?: SortOrder
    status?: SortOrder
    disposalDate?: SortOrder
    disposalAmount?: SortOrder
    disposalMethod?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    vendorId?: SortOrder
  }

  export type AssetAvgOrderByAggregateInput = {
    acquisitionCost?: SortOrder
    residualValue?: SortOrder
    usefulLife?: SortOrder
    disposalAmount?: SortOrder
  }

  export type AssetMaxOrderByAggregateInput = {
    id?: SortOrder
    assetNo?: SortOrder
    name?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    acquisitionDate?: SortOrder
    acquisitionCost?: SortOrder
    residualValue?: SortOrder
    usefulLife?: SortOrder
    depreciationMethod?: SortOrder
    locationId?: SortOrder
    serialNumber?: SortOrder
    supplier?: SortOrder
    purchaseOrderId?: SortOrder
    status?: SortOrder
    disposalDate?: SortOrder
    disposalAmount?: SortOrder
    disposalMethod?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    vendorId?: SortOrder
  }

  export type AssetMinOrderByAggregateInput = {
    id?: SortOrder
    assetNo?: SortOrder
    name?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    acquisitionDate?: SortOrder
    acquisitionCost?: SortOrder
    residualValue?: SortOrder
    usefulLife?: SortOrder
    depreciationMethod?: SortOrder
    locationId?: SortOrder
    serialNumber?: SortOrder
    supplier?: SortOrder
    purchaseOrderId?: SortOrder
    status?: SortOrder
    disposalDate?: SortOrder
    disposalAmount?: SortOrder
    disposalMethod?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    vendorId?: SortOrder
  }

  export type AssetSumOrderByAggregateInput = {
    acquisitionCost?: SortOrder
    residualValue?: SortOrder
    usefulLife?: SortOrder
    disposalAmount?: SortOrder
  }

  export type AssetRelationFilter = {
    is?: AssetWhereInput
    isNot?: AssetWhereInput
  }

  export type JournalNullableRelationFilter = {
    is?: JournalWhereInput | null
    isNot?: JournalWhereInput | null
  }

  export type AssetDepreciationAssetIdPeriodYearPeriodMonthCompoundUniqueInput = {
    assetId: string
    periodYear: number
    periodMonth: number
  }

  export type AssetDepreciationCountOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    periodYear?: SortOrder
    periodMonth?: SortOrder
    depreciationAmount?: SortOrder
    accumulatedDepreciation?: SortOrder
    netBookValue?: SortOrder
    isPosted?: SortOrder
    postedAt?: SortOrder
    journalId?: SortOrder
    createdAt?: SortOrder
  }

  export type AssetDepreciationAvgOrderByAggregateInput = {
    periodYear?: SortOrder
    periodMonth?: SortOrder
    depreciationAmount?: SortOrder
    accumulatedDepreciation?: SortOrder
    netBookValue?: SortOrder
  }

  export type AssetDepreciationMaxOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    periodYear?: SortOrder
    periodMonth?: SortOrder
    depreciationAmount?: SortOrder
    accumulatedDepreciation?: SortOrder
    netBookValue?: SortOrder
    isPosted?: SortOrder
    postedAt?: SortOrder
    journalId?: SortOrder
    createdAt?: SortOrder
  }

  export type AssetDepreciationMinOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    periodYear?: SortOrder
    periodMonth?: SortOrder
    depreciationAmount?: SortOrder
    accumulatedDepreciation?: SortOrder
    netBookValue?: SortOrder
    isPosted?: SortOrder
    postedAt?: SortOrder
    journalId?: SortOrder
    createdAt?: SortOrder
  }

  export type AssetDepreciationSumOrderByAggregateInput = {
    periodYear?: SortOrder
    periodMonth?: SortOrder
    depreciationAmount?: SortOrder
    accumulatedDepreciation?: SortOrder
    netBookValue?: SortOrder
  }

  export type AssetDisposalCountOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    disposalDate?: SortOrder
    disposalAmount?: SortOrder
    disposalMethod?: SortOrder
    buyerDetails?: SortOrder
    gainLoss?: SortOrder
    notes?: SortOrder
    journalId?: SortOrder
    disposedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type AssetDisposalAvgOrderByAggregateInput = {
    disposalAmount?: SortOrder
    gainLoss?: SortOrder
  }

  export type AssetDisposalMaxOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    disposalDate?: SortOrder
    disposalAmount?: SortOrder
    disposalMethod?: SortOrder
    buyerDetails?: SortOrder
    gainLoss?: SortOrder
    notes?: SortOrder
    journalId?: SortOrder
    disposedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type AssetDisposalMinOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    disposalDate?: SortOrder
    disposalAmount?: SortOrder
    disposalMethod?: SortOrder
    buyerDetails?: SortOrder
    gainLoss?: SortOrder
    notes?: SortOrder
    journalId?: SortOrder
    disposedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type AssetDisposalSumOrderByAggregateInput = {
    disposalAmount?: SortOrder
    gainLoss?: SortOrder
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type JournalCreateNestedManyWithoutPostedByUserInput = {
    create?: XOR<JournalCreateWithoutPostedByUserInput, JournalUncheckedCreateWithoutPostedByUserInput> | JournalCreateWithoutPostedByUserInput[] | JournalUncheckedCreateWithoutPostedByUserInput[]
    connectOrCreate?: JournalCreateOrConnectWithoutPostedByUserInput | JournalCreateOrConnectWithoutPostedByUserInput[]
    createMany?: JournalCreateManyPostedByUserInputEnvelope
    connect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
  }

  export type InventoryLedgerCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryLedgerCreateWithoutUserInput, InventoryLedgerUncheckedCreateWithoutUserInput> | InventoryLedgerCreateWithoutUserInput[] | InventoryLedgerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryLedgerCreateOrConnectWithoutUserInput | InventoryLedgerCreateOrConnectWithoutUserInput[]
    createMany?: InventoryLedgerCreateManyUserInputEnvelope
    connect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
  }

  export type CashTransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<CashTransactionCreateWithoutUserInput, CashTransactionUncheckedCreateWithoutUserInput> | CashTransactionCreateWithoutUserInput[] | CashTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutUserInput | CashTransactionCreateOrConnectWithoutUserInput[]
    createMany?: CashTransactionCreateManyUserInputEnvelope
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
  }

  export type SalesReceiptCreateNestedManyWithoutUserInput = {
    create?: XOR<SalesReceiptCreateWithoutUserInput, SalesReceiptUncheckedCreateWithoutUserInput> | SalesReceiptCreateWithoutUserInput[] | SalesReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalesReceiptCreateOrConnectWithoutUserInput | SalesReceiptCreateOrConnectWithoutUserInput[]
    createMany?: SalesReceiptCreateManyUserInputEnvelope
    connect?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
  }

  export type PurchasePaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PurchasePaymentCreateWithoutUserInput, PurchasePaymentUncheckedCreateWithoutUserInput> | PurchasePaymentCreateWithoutUserInput[] | PurchasePaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchasePaymentCreateOrConnectWithoutUserInput | PurchasePaymentCreateOrConnectWithoutUserInput[]
    createMany?: PurchasePaymentCreateManyUserInputEnvelope
    connect?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
  }

  export type SystemSettingCreateNestedManyWithoutUpdatedByUserInput = {
    create?: XOR<SystemSettingCreateWithoutUpdatedByUserInput, SystemSettingUncheckedCreateWithoutUpdatedByUserInput> | SystemSettingCreateWithoutUpdatedByUserInput[] | SystemSettingUncheckedCreateWithoutUpdatedByUserInput[]
    connectOrCreate?: SystemSettingCreateOrConnectWithoutUpdatedByUserInput | SystemSettingCreateOrConnectWithoutUpdatedByUserInput[]
    createMany?: SystemSettingCreateManyUpdatedByUserInputEnvelope
    connect?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
  }

  export type ApprovalRequestCreateNestedManyWithoutRequestedByUserInput = {
    create?: XOR<ApprovalRequestCreateWithoutRequestedByUserInput, ApprovalRequestUncheckedCreateWithoutRequestedByUserInput> | ApprovalRequestCreateWithoutRequestedByUserInput[] | ApprovalRequestUncheckedCreateWithoutRequestedByUserInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutRequestedByUserInput | ApprovalRequestCreateOrConnectWithoutRequestedByUserInput[]
    createMany?: ApprovalRequestCreateManyRequestedByUserInputEnvelope
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
  }

  export type ApprovalActionCreateNestedManyWithoutUserInput = {
    create?: XOR<ApprovalActionCreateWithoutUserInput, ApprovalActionUncheckedCreateWithoutUserInput> | ApprovalActionCreateWithoutUserInput[] | ApprovalActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApprovalActionCreateOrConnectWithoutUserInput | ApprovalActionCreateOrConnectWithoutUserInput[]
    createMany?: ApprovalActionCreateManyUserInputEnvelope
    connect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
  }

  export type AssetCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<AssetCreateWithoutCreatedByUserInput, AssetUncheckedCreateWithoutCreatedByUserInput> | AssetCreateWithoutCreatedByUserInput[] | AssetUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutCreatedByUserInput | AssetCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: AssetCreateManyCreatedByUserInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type AssetDisposalCreateNestedManyWithoutDisposedByUserInput = {
    create?: XOR<AssetDisposalCreateWithoutDisposedByUserInput, AssetDisposalUncheckedCreateWithoutDisposedByUserInput> | AssetDisposalCreateWithoutDisposedByUserInput[] | AssetDisposalUncheckedCreateWithoutDisposedByUserInput[]
    connectOrCreate?: AssetDisposalCreateOrConnectWithoutDisposedByUserInput | AssetDisposalCreateOrConnectWithoutDisposedByUserInput[]
    createMany?: AssetDisposalCreateManyDisposedByUserInputEnvelope
    connect?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type JournalUncheckedCreateNestedManyWithoutPostedByUserInput = {
    create?: XOR<JournalCreateWithoutPostedByUserInput, JournalUncheckedCreateWithoutPostedByUserInput> | JournalCreateWithoutPostedByUserInput[] | JournalUncheckedCreateWithoutPostedByUserInput[]
    connectOrCreate?: JournalCreateOrConnectWithoutPostedByUserInput | JournalCreateOrConnectWithoutPostedByUserInput[]
    createMany?: JournalCreateManyPostedByUserInputEnvelope
    connect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
  }

  export type InventoryLedgerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryLedgerCreateWithoutUserInput, InventoryLedgerUncheckedCreateWithoutUserInput> | InventoryLedgerCreateWithoutUserInput[] | InventoryLedgerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryLedgerCreateOrConnectWithoutUserInput | InventoryLedgerCreateOrConnectWithoutUserInput[]
    createMany?: InventoryLedgerCreateManyUserInputEnvelope
    connect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
  }

  export type CashTransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CashTransactionCreateWithoutUserInput, CashTransactionUncheckedCreateWithoutUserInput> | CashTransactionCreateWithoutUserInput[] | CashTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutUserInput | CashTransactionCreateOrConnectWithoutUserInput[]
    createMany?: CashTransactionCreateManyUserInputEnvelope
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
  }

  export type SalesReceiptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SalesReceiptCreateWithoutUserInput, SalesReceiptUncheckedCreateWithoutUserInput> | SalesReceiptCreateWithoutUserInput[] | SalesReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalesReceiptCreateOrConnectWithoutUserInput | SalesReceiptCreateOrConnectWithoutUserInput[]
    createMany?: SalesReceiptCreateManyUserInputEnvelope
    connect?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
  }

  export type PurchasePaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PurchasePaymentCreateWithoutUserInput, PurchasePaymentUncheckedCreateWithoutUserInput> | PurchasePaymentCreateWithoutUserInput[] | PurchasePaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchasePaymentCreateOrConnectWithoutUserInput | PurchasePaymentCreateOrConnectWithoutUserInput[]
    createMany?: PurchasePaymentCreateManyUserInputEnvelope
    connect?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
  }

  export type SystemSettingUncheckedCreateNestedManyWithoutUpdatedByUserInput = {
    create?: XOR<SystemSettingCreateWithoutUpdatedByUserInput, SystemSettingUncheckedCreateWithoutUpdatedByUserInput> | SystemSettingCreateWithoutUpdatedByUserInput[] | SystemSettingUncheckedCreateWithoutUpdatedByUserInput[]
    connectOrCreate?: SystemSettingCreateOrConnectWithoutUpdatedByUserInput | SystemSettingCreateOrConnectWithoutUpdatedByUserInput[]
    createMany?: SystemSettingCreateManyUpdatedByUserInputEnvelope
    connect?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
  }

  export type ApprovalRequestUncheckedCreateNestedManyWithoutRequestedByUserInput = {
    create?: XOR<ApprovalRequestCreateWithoutRequestedByUserInput, ApprovalRequestUncheckedCreateWithoutRequestedByUserInput> | ApprovalRequestCreateWithoutRequestedByUserInput[] | ApprovalRequestUncheckedCreateWithoutRequestedByUserInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutRequestedByUserInput | ApprovalRequestCreateOrConnectWithoutRequestedByUserInput[]
    createMany?: ApprovalRequestCreateManyRequestedByUserInputEnvelope
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
  }

  export type ApprovalActionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ApprovalActionCreateWithoutUserInput, ApprovalActionUncheckedCreateWithoutUserInput> | ApprovalActionCreateWithoutUserInput[] | ApprovalActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApprovalActionCreateOrConnectWithoutUserInput | ApprovalActionCreateOrConnectWithoutUserInput[]
    createMany?: ApprovalActionCreateManyUserInputEnvelope
    connect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutCreatedByUserInput = {
    create?: XOR<AssetCreateWithoutCreatedByUserInput, AssetUncheckedCreateWithoutCreatedByUserInput> | AssetCreateWithoutCreatedByUserInput[] | AssetUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutCreatedByUserInput | AssetCreateOrConnectWithoutCreatedByUserInput[]
    createMany?: AssetCreateManyCreatedByUserInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type AssetDisposalUncheckedCreateNestedManyWithoutDisposedByUserInput = {
    create?: XOR<AssetDisposalCreateWithoutDisposedByUserInput, AssetDisposalUncheckedCreateWithoutDisposedByUserInput> | AssetDisposalCreateWithoutDisposedByUserInput[] | AssetDisposalUncheckedCreateWithoutDisposedByUserInput[]
    connectOrCreate?: AssetDisposalCreateOrConnectWithoutDisposedByUserInput | AssetDisposalCreateOrConnectWithoutDisposedByUserInput[]
    createMany?: AssetDisposalCreateManyDisposedByUserInputEnvelope
    connect?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type JournalUpdateManyWithoutPostedByUserNestedInput = {
    create?: XOR<JournalCreateWithoutPostedByUserInput, JournalUncheckedCreateWithoutPostedByUserInput> | JournalCreateWithoutPostedByUserInput[] | JournalUncheckedCreateWithoutPostedByUserInput[]
    connectOrCreate?: JournalCreateOrConnectWithoutPostedByUserInput | JournalCreateOrConnectWithoutPostedByUserInput[]
    upsert?: JournalUpsertWithWhereUniqueWithoutPostedByUserInput | JournalUpsertWithWhereUniqueWithoutPostedByUserInput[]
    createMany?: JournalCreateManyPostedByUserInputEnvelope
    set?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    disconnect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    delete?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    connect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    update?: JournalUpdateWithWhereUniqueWithoutPostedByUserInput | JournalUpdateWithWhereUniqueWithoutPostedByUserInput[]
    updateMany?: JournalUpdateManyWithWhereWithoutPostedByUserInput | JournalUpdateManyWithWhereWithoutPostedByUserInput[]
    deleteMany?: JournalScalarWhereInput | JournalScalarWhereInput[]
  }

  export type InventoryLedgerUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryLedgerCreateWithoutUserInput, InventoryLedgerUncheckedCreateWithoutUserInput> | InventoryLedgerCreateWithoutUserInput[] | InventoryLedgerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryLedgerCreateOrConnectWithoutUserInput | InventoryLedgerCreateOrConnectWithoutUserInput[]
    upsert?: InventoryLedgerUpsertWithWhereUniqueWithoutUserInput | InventoryLedgerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventoryLedgerCreateManyUserInputEnvelope
    set?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    disconnect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    delete?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    connect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    update?: InventoryLedgerUpdateWithWhereUniqueWithoutUserInput | InventoryLedgerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryLedgerUpdateManyWithWhereWithoutUserInput | InventoryLedgerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryLedgerScalarWhereInput | InventoryLedgerScalarWhereInput[]
  }

  export type CashTransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<CashTransactionCreateWithoutUserInput, CashTransactionUncheckedCreateWithoutUserInput> | CashTransactionCreateWithoutUserInput[] | CashTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutUserInput | CashTransactionCreateOrConnectWithoutUserInput[]
    upsert?: CashTransactionUpsertWithWhereUniqueWithoutUserInput | CashTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CashTransactionCreateManyUserInputEnvelope
    set?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    disconnect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    delete?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    update?: CashTransactionUpdateWithWhereUniqueWithoutUserInput | CashTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CashTransactionUpdateManyWithWhereWithoutUserInput | CashTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
  }

  export type SalesReceiptUpdateManyWithoutUserNestedInput = {
    create?: XOR<SalesReceiptCreateWithoutUserInput, SalesReceiptUncheckedCreateWithoutUserInput> | SalesReceiptCreateWithoutUserInput[] | SalesReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalesReceiptCreateOrConnectWithoutUserInput | SalesReceiptCreateOrConnectWithoutUserInput[]
    upsert?: SalesReceiptUpsertWithWhereUniqueWithoutUserInput | SalesReceiptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SalesReceiptCreateManyUserInputEnvelope
    set?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    disconnect?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    delete?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    connect?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    update?: SalesReceiptUpdateWithWhereUniqueWithoutUserInput | SalesReceiptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SalesReceiptUpdateManyWithWhereWithoutUserInput | SalesReceiptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SalesReceiptScalarWhereInput | SalesReceiptScalarWhereInput[]
  }

  export type PurchasePaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PurchasePaymentCreateWithoutUserInput, PurchasePaymentUncheckedCreateWithoutUserInput> | PurchasePaymentCreateWithoutUserInput[] | PurchasePaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchasePaymentCreateOrConnectWithoutUserInput | PurchasePaymentCreateOrConnectWithoutUserInput[]
    upsert?: PurchasePaymentUpsertWithWhereUniqueWithoutUserInput | PurchasePaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PurchasePaymentCreateManyUserInputEnvelope
    set?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    disconnect?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    delete?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    connect?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    update?: PurchasePaymentUpdateWithWhereUniqueWithoutUserInput | PurchasePaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PurchasePaymentUpdateManyWithWhereWithoutUserInput | PurchasePaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PurchasePaymentScalarWhereInput | PurchasePaymentScalarWhereInput[]
  }

  export type SystemSettingUpdateManyWithoutUpdatedByUserNestedInput = {
    create?: XOR<SystemSettingCreateWithoutUpdatedByUserInput, SystemSettingUncheckedCreateWithoutUpdatedByUserInput> | SystemSettingCreateWithoutUpdatedByUserInput[] | SystemSettingUncheckedCreateWithoutUpdatedByUserInput[]
    connectOrCreate?: SystemSettingCreateOrConnectWithoutUpdatedByUserInput | SystemSettingCreateOrConnectWithoutUpdatedByUserInput[]
    upsert?: SystemSettingUpsertWithWhereUniqueWithoutUpdatedByUserInput | SystemSettingUpsertWithWhereUniqueWithoutUpdatedByUserInput[]
    createMany?: SystemSettingCreateManyUpdatedByUserInputEnvelope
    set?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    disconnect?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    delete?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    connect?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    update?: SystemSettingUpdateWithWhereUniqueWithoutUpdatedByUserInput | SystemSettingUpdateWithWhereUniqueWithoutUpdatedByUserInput[]
    updateMany?: SystemSettingUpdateManyWithWhereWithoutUpdatedByUserInput | SystemSettingUpdateManyWithWhereWithoutUpdatedByUserInput[]
    deleteMany?: SystemSettingScalarWhereInput | SystemSettingScalarWhereInput[]
  }

  export type ApprovalRequestUpdateManyWithoutRequestedByUserNestedInput = {
    create?: XOR<ApprovalRequestCreateWithoutRequestedByUserInput, ApprovalRequestUncheckedCreateWithoutRequestedByUserInput> | ApprovalRequestCreateWithoutRequestedByUserInput[] | ApprovalRequestUncheckedCreateWithoutRequestedByUserInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutRequestedByUserInput | ApprovalRequestCreateOrConnectWithoutRequestedByUserInput[]
    upsert?: ApprovalRequestUpsertWithWhereUniqueWithoutRequestedByUserInput | ApprovalRequestUpsertWithWhereUniqueWithoutRequestedByUserInput[]
    createMany?: ApprovalRequestCreateManyRequestedByUserInputEnvelope
    set?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    disconnect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    delete?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    update?: ApprovalRequestUpdateWithWhereUniqueWithoutRequestedByUserInput | ApprovalRequestUpdateWithWhereUniqueWithoutRequestedByUserInput[]
    updateMany?: ApprovalRequestUpdateManyWithWhereWithoutRequestedByUserInput | ApprovalRequestUpdateManyWithWhereWithoutRequestedByUserInput[]
    deleteMany?: ApprovalRequestScalarWhereInput | ApprovalRequestScalarWhereInput[]
  }

  export type ApprovalActionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApprovalActionCreateWithoutUserInput, ApprovalActionUncheckedCreateWithoutUserInput> | ApprovalActionCreateWithoutUserInput[] | ApprovalActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApprovalActionCreateOrConnectWithoutUserInput | ApprovalActionCreateOrConnectWithoutUserInput[]
    upsert?: ApprovalActionUpsertWithWhereUniqueWithoutUserInput | ApprovalActionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApprovalActionCreateManyUserInputEnvelope
    set?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    disconnect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    delete?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    connect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    update?: ApprovalActionUpdateWithWhereUniqueWithoutUserInput | ApprovalActionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApprovalActionUpdateManyWithWhereWithoutUserInput | ApprovalActionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApprovalActionScalarWhereInput | ApprovalActionScalarWhereInput[]
  }

  export type AssetUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<AssetCreateWithoutCreatedByUserInput, AssetUncheckedCreateWithoutCreatedByUserInput> | AssetCreateWithoutCreatedByUserInput[] | AssetUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutCreatedByUserInput | AssetCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutCreatedByUserInput | AssetUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: AssetCreateManyCreatedByUserInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutCreatedByUserInput | AssetUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutCreatedByUserInput | AssetUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AssetDisposalUpdateManyWithoutDisposedByUserNestedInput = {
    create?: XOR<AssetDisposalCreateWithoutDisposedByUserInput, AssetDisposalUncheckedCreateWithoutDisposedByUserInput> | AssetDisposalCreateWithoutDisposedByUserInput[] | AssetDisposalUncheckedCreateWithoutDisposedByUserInput[]
    connectOrCreate?: AssetDisposalCreateOrConnectWithoutDisposedByUserInput | AssetDisposalCreateOrConnectWithoutDisposedByUserInput[]
    upsert?: AssetDisposalUpsertWithWhereUniqueWithoutDisposedByUserInput | AssetDisposalUpsertWithWhereUniqueWithoutDisposedByUserInput[]
    createMany?: AssetDisposalCreateManyDisposedByUserInputEnvelope
    set?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
    disconnect?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
    delete?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
    connect?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
    update?: AssetDisposalUpdateWithWhereUniqueWithoutDisposedByUserInput | AssetDisposalUpdateWithWhereUniqueWithoutDisposedByUserInput[]
    updateMany?: AssetDisposalUpdateManyWithWhereWithoutDisposedByUserInput | AssetDisposalUpdateManyWithWhereWithoutDisposedByUserInput[]
    deleteMany?: AssetDisposalScalarWhereInput | AssetDisposalScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type JournalUncheckedUpdateManyWithoutPostedByUserNestedInput = {
    create?: XOR<JournalCreateWithoutPostedByUserInput, JournalUncheckedCreateWithoutPostedByUserInput> | JournalCreateWithoutPostedByUserInput[] | JournalUncheckedCreateWithoutPostedByUserInput[]
    connectOrCreate?: JournalCreateOrConnectWithoutPostedByUserInput | JournalCreateOrConnectWithoutPostedByUserInput[]
    upsert?: JournalUpsertWithWhereUniqueWithoutPostedByUserInput | JournalUpsertWithWhereUniqueWithoutPostedByUserInput[]
    createMany?: JournalCreateManyPostedByUserInputEnvelope
    set?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    disconnect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    delete?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    connect?: JournalWhereUniqueInput | JournalWhereUniqueInput[]
    update?: JournalUpdateWithWhereUniqueWithoutPostedByUserInput | JournalUpdateWithWhereUniqueWithoutPostedByUserInput[]
    updateMany?: JournalUpdateManyWithWhereWithoutPostedByUserInput | JournalUpdateManyWithWhereWithoutPostedByUserInput[]
    deleteMany?: JournalScalarWhereInput | JournalScalarWhereInput[]
  }

  export type InventoryLedgerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryLedgerCreateWithoutUserInput, InventoryLedgerUncheckedCreateWithoutUserInput> | InventoryLedgerCreateWithoutUserInput[] | InventoryLedgerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryLedgerCreateOrConnectWithoutUserInput | InventoryLedgerCreateOrConnectWithoutUserInput[]
    upsert?: InventoryLedgerUpsertWithWhereUniqueWithoutUserInput | InventoryLedgerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventoryLedgerCreateManyUserInputEnvelope
    set?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    disconnect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    delete?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    connect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    update?: InventoryLedgerUpdateWithWhereUniqueWithoutUserInput | InventoryLedgerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryLedgerUpdateManyWithWhereWithoutUserInput | InventoryLedgerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryLedgerScalarWhereInput | InventoryLedgerScalarWhereInput[]
  }

  export type CashTransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CashTransactionCreateWithoutUserInput, CashTransactionUncheckedCreateWithoutUserInput> | CashTransactionCreateWithoutUserInput[] | CashTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutUserInput | CashTransactionCreateOrConnectWithoutUserInput[]
    upsert?: CashTransactionUpsertWithWhereUniqueWithoutUserInput | CashTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CashTransactionCreateManyUserInputEnvelope
    set?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    disconnect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    delete?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    update?: CashTransactionUpdateWithWhereUniqueWithoutUserInput | CashTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CashTransactionUpdateManyWithWhereWithoutUserInput | CashTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
  }

  export type SalesReceiptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SalesReceiptCreateWithoutUserInput, SalesReceiptUncheckedCreateWithoutUserInput> | SalesReceiptCreateWithoutUserInput[] | SalesReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalesReceiptCreateOrConnectWithoutUserInput | SalesReceiptCreateOrConnectWithoutUserInput[]
    upsert?: SalesReceiptUpsertWithWhereUniqueWithoutUserInput | SalesReceiptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SalesReceiptCreateManyUserInputEnvelope
    set?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    disconnect?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    delete?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    connect?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    update?: SalesReceiptUpdateWithWhereUniqueWithoutUserInput | SalesReceiptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SalesReceiptUpdateManyWithWhereWithoutUserInput | SalesReceiptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SalesReceiptScalarWhereInput | SalesReceiptScalarWhereInput[]
  }

  export type PurchasePaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PurchasePaymentCreateWithoutUserInput, PurchasePaymentUncheckedCreateWithoutUserInput> | PurchasePaymentCreateWithoutUserInput[] | PurchasePaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PurchasePaymentCreateOrConnectWithoutUserInput | PurchasePaymentCreateOrConnectWithoutUserInput[]
    upsert?: PurchasePaymentUpsertWithWhereUniqueWithoutUserInput | PurchasePaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PurchasePaymentCreateManyUserInputEnvelope
    set?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    disconnect?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    delete?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    connect?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    update?: PurchasePaymentUpdateWithWhereUniqueWithoutUserInput | PurchasePaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PurchasePaymentUpdateManyWithWhereWithoutUserInput | PurchasePaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PurchasePaymentScalarWhereInput | PurchasePaymentScalarWhereInput[]
  }

  export type SystemSettingUncheckedUpdateManyWithoutUpdatedByUserNestedInput = {
    create?: XOR<SystemSettingCreateWithoutUpdatedByUserInput, SystemSettingUncheckedCreateWithoutUpdatedByUserInput> | SystemSettingCreateWithoutUpdatedByUserInput[] | SystemSettingUncheckedCreateWithoutUpdatedByUserInput[]
    connectOrCreate?: SystemSettingCreateOrConnectWithoutUpdatedByUserInput | SystemSettingCreateOrConnectWithoutUpdatedByUserInput[]
    upsert?: SystemSettingUpsertWithWhereUniqueWithoutUpdatedByUserInput | SystemSettingUpsertWithWhereUniqueWithoutUpdatedByUserInput[]
    createMany?: SystemSettingCreateManyUpdatedByUserInputEnvelope
    set?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    disconnect?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    delete?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    connect?: SystemSettingWhereUniqueInput | SystemSettingWhereUniqueInput[]
    update?: SystemSettingUpdateWithWhereUniqueWithoutUpdatedByUserInput | SystemSettingUpdateWithWhereUniqueWithoutUpdatedByUserInput[]
    updateMany?: SystemSettingUpdateManyWithWhereWithoutUpdatedByUserInput | SystemSettingUpdateManyWithWhereWithoutUpdatedByUserInput[]
    deleteMany?: SystemSettingScalarWhereInput | SystemSettingScalarWhereInput[]
  }

  export type ApprovalRequestUncheckedUpdateManyWithoutRequestedByUserNestedInput = {
    create?: XOR<ApprovalRequestCreateWithoutRequestedByUserInput, ApprovalRequestUncheckedCreateWithoutRequestedByUserInput> | ApprovalRequestCreateWithoutRequestedByUserInput[] | ApprovalRequestUncheckedCreateWithoutRequestedByUserInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutRequestedByUserInput | ApprovalRequestCreateOrConnectWithoutRequestedByUserInput[]
    upsert?: ApprovalRequestUpsertWithWhereUniqueWithoutRequestedByUserInput | ApprovalRequestUpsertWithWhereUniqueWithoutRequestedByUserInput[]
    createMany?: ApprovalRequestCreateManyRequestedByUserInputEnvelope
    set?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    disconnect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    delete?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    update?: ApprovalRequestUpdateWithWhereUniqueWithoutRequestedByUserInput | ApprovalRequestUpdateWithWhereUniqueWithoutRequestedByUserInput[]
    updateMany?: ApprovalRequestUpdateManyWithWhereWithoutRequestedByUserInput | ApprovalRequestUpdateManyWithWhereWithoutRequestedByUserInput[]
    deleteMany?: ApprovalRequestScalarWhereInput | ApprovalRequestScalarWhereInput[]
  }

  export type ApprovalActionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApprovalActionCreateWithoutUserInput, ApprovalActionUncheckedCreateWithoutUserInput> | ApprovalActionCreateWithoutUserInput[] | ApprovalActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApprovalActionCreateOrConnectWithoutUserInput | ApprovalActionCreateOrConnectWithoutUserInput[]
    upsert?: ApprovalActionUpsertWithWhereUniqueWithoutUserInput | ApprovalActionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApprovalActionCreateManyUserInputEnvelope
    set?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    disconnect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    delete?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    connect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    update?: ApprovalActionUpdateWithWhereUniqueWithoutUserInput | ApprovalActionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApprovalActionUpdateManyWithWhereWithoutUserInput | ApprovalActionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApprovalActionScalarWhereInput | ApprovalActionScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutCreatedByUserNestedInput = {
    create?: XOR<AssetCreateWithoutCreatedByUserInput, AssetUncheckedCreateWithoutCreatedByUserInput> | AssetCreateWithoutCreatedByUserInput[] | AssetUncheckedCreateWithoutCreatedByUserInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutCreatedByUserInput | AssetCreateOrConnectWithoutCreatedByUserInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutCreatedByUserInput | AssetUpsertWithWhereUniqueWithoutCreatedByUserInput[]
    createMany?: AssetCreateManyCreatedByUserInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutCreatedByUserInput | AssetUpdateWithWhereUniqueWithoutCreatedByUserInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutCreatedByUserInput | AssetUpdateManyWithWhereWithoutCreatedByUserInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AssetDisposalUncheckedUpdateManyWithoutDisposedByUserNestedInput = {
    create?: XOR<AssetDisposalCreateWithoutDisposedByUserInput, AssetDisposalUncheckedCreateWithoutDisposedByUserInput> | AssetDisposalCreateWithoutDisposedByUserInput[] | AssetDisposalUncheckedCreateWithoutDisposedByUserInput[]
    connectOrCreate?: AssetDisposalCreateOrConnectWithoutDisposedByUserInput | AssetDisposalCreateOrConnectWithoutDisposedByUserInput[]
    upsert?: AssetDisposalUpsertWithWhereUniqueWithoutDisposedByUserInput | AssetDisposalUpsertWithWhereUniqueWithoutDisposedByUserInput[]
    createMany?: AssetDisposalCreateManyDisposedByUserInputEnvelope
    set?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
    disconnect?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
    delete?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
    connect?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
    update?: AssetDisposalUpdateWithWhereUniqueWithoutDisposedByUserInput | AssetDisposalUpdateWithWhereUniqueWithoutDisposedByUserInput[]
    updateMany?: AssetDisposalUpdateManyWithWhereWithoutDisposedByUserInput | AssetDisposalUpdateManyWithWhereWithoutDisposedByUserInput[]
    deleteMany?: AssetDisposalScalarWhereInput | AssetDisposalScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type ApprovalStepCreateNestedManyWithoutRoleInput = {
    create?: XOR<ApprovalStepCreateWithoutRoleInput, ApprovalStepUncheckedCreateWithoutRoleInput> | ApprovalStepCreateWithoutRoleInput[] | ApprovalStepUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: ApprovalStepCreateOrConnectWithoutRoleInput | ApprovalStepCreateOrConnectWithoutRoleInput[]
    createMany?: ApprovalStepCreateManyRoleInputEnvelope
    connect?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type ApprovalStepUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<ApprovalStepCreateWithoutRoleInput, ApprovalStepUncheckedCreateWithoutRoleInput> | ApprovalStepCreateWithoutRoleInput[] | ApprovalStepUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: ApprovalStepCreateOrConnectWithoutRoleInput | ApprovalStepCreateOrConnectWithoutRoleInput[]
    createMany?: ApprovalStepCreateManyRoleInputEnvelope
    connect?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type ApprovalStepUpdateManyWithoutRoleNestedInput = {
    create?: XOR<ApprovalStepCreateWithoutRoleInput, ApprovalStepUncheckedCreateWithoutRoleInput> | ApprovalStepCreateWithoutRoleInput[] | ApprovalStepUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: ApprovalStepCreateOrConnectWithoutRoleInput | ApprovalStepCreateOrConnectWithoutRoleInput[]
    upsert?: ApprovalStepUpsertWithWhereUniqueWithoutRoleInput | ApprovalStepUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: ApprovalStepCreateManyRoleInputEnvelope
    set?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
    disconnect?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
    delete?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
    connect?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
    update?: ApprovalStepUpdateWithWhereUniqueWithoutRoleInput | ApprovalStepUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: ApprovalStepUpdateManyWithWhereWithoutRoleInput | ApprovalStepUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: ApprovalStepScalarWhereInput | ApprovalStepScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type ApprovalStepUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<ApprovalStepCreateWithoutRoleInput, ApprovalStepUncheckedCreateWithoutRoleInput> | ApprovalStepCreateWithoutRoleInput[] | ApprovalStepUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: ApprovalStepCreateOrConnectWithoutRoleInput | ApprovalStepCreateOrConnectWithoutRoleInput[]
    upsert?: ApprovalStepUpsertWithWhereUniqueWithoutRoleInput | ApprovalStepUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: ApprovalStepCreateManyRoleInputEnvelope
    set?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
    disconnect?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
    delete?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
    connect?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
    update?: ApprovalStepUpdateWithWhereUniqueWithoutRoleInput | ApprovalStepUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: ApprovalStepUpdateManyWithWhereWithoutRoleInput | ApprovalStepUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: ApprovalStepScalarWhereInput | ApprovalStepScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    upsert?: UserUpsertWithoutUserRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserRolesInput, UserUpdateWithoutUserRolesInput>, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    upsert?: RoleUpsertWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUserRolesInput, RoleUpdateWithoutUserRolesInput>, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleCreateNestedOneWithoutRolePermissionsInput = {
    create?: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolePermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutRolePermissionsInput = {
    create?: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolePermissionsInput
    connect?: PermissionWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutRolePermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolePermissionsInput
    upsert?: RoleUpsertWithoutRolePermissionsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutRolePermissionsInput, RoleUpdateWithoutRolePermissionsInput>, RoleUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput = {
    create?: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolePermissionsInput
    upsert?: PermissionUpsertWithoutRolePermissionsInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolePermissionsInput, PermissionUpdateWithoutRolePermissionsInput>, PermissionUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type WarehouseCreateNestedManyWithoutLocationInput = {
    create?: XOR<WarehouseCreateWithoutLocationInput, WarehouseUncheckedCreateWithoutLocationInput> | WarehouseCreateWithoutLocationInput[] | WarehouseUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: WarehouseCreateOrConnectWithoutLocationInput | WarehouseCreateOrConnectWithoutLocationInput[]
    createMany?: WarehouseCreateManyLocationInputEnvelope
    connect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
  }

  export type AssetCreateNestedManyWithoutLocationInput = {
    create?: XOR<AssetCreateWithoutLocationInput, AssetUncheckedCreateWithoutLocationInput> | AssetCreateWithoutLocationInput[] | AssetUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutLocationInput | AssetCreateOrConnectWithoutLocationInput[]
    createMany?: AssetCreateManyLocationInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type WarehouseUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<WarehouseCreateWithoutLocationInput, WarehouseUncheckedCreateWithoutLocationInput> | WarehouseCreateWithoutLocationInput[] | WarehouseUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: WarehouseCreateOrConnectWithoutLocationInput | WarehouseCreateOrConnectWithoutLocationInput[]
    createMany?: WarehouseCreateManyLocationInputEnvelope
    connect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<AssetCreateWithoutLocationInput, AssetUncheckedCreateWithoutLocationInput> | AssetCreateWithoutLocationInput[] | AssetUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutLocationInput | AssetCreateOrConnectWithoutLocationInput[]
    createMany?: AssetCreateManyLocationInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type WarehouseUpdateManyWithoutLocationNestedInput = {
    create?: XOR<WarehouseCreateWithoutLocationInput, WarehouseUncheckedCreateWithoutLocationInput> | WarehouseCreateWithoutLocationInput[] | WarehouseUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: WarehouseCreateOrConnectWithoutLocationInput | WarehouseCreateOrConnectWithoutLocationInput[]
    upsert?: WarehouseUpsertWithWhereUniqueWithoutLocationInput | WarehouseUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: WarehouseCreateManyLocationInputEnvelope
    set?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    disconnect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    delete?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    connect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    update?: WarehouseUpdateWithWhereUniqueWithoutLocationInput | WarehouseUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: WarehouseUpdateManyWithWhereWithoutLocationInput | WarehouseUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: WarehouseScalarWhereInput | WarehouseScalarWhereInput[]
  }

  export type AssetUpdateManyWithoutLocationNestedInput = {
    create?: XOR<AssetCreateWithoutLocationInput, AssetUncheckedCreateWithoutLocationInput> | AssetCreateWithoutLocationInput[] | AssetUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutLocationInput | AssetCreateOrConnectWithoutLocationInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutLocationInput | AssetUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: AssetCreateManyLocationInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutLocationInput | AssetUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutLocationInput | AssetUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type WarehouseUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<WarehouseCreateWithoutLocationInput, WarehouseUncheckedCreateWithoutLocationInput> | WarehouseCreateWithoutLocationInput[] | WarehouseUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: WarehouseCreateOrConnectWithoutLocationInput | WarehouseCreateOrConnectWithoutLocationInput[]
    upsert?: WarehouseUpsertWithWhereUniqueWithoutLocationInput | WarehouseUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: WarehouseCreateManyLocationInputEnvelope
    set?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    disconnect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    delete?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    connect?: WarehouseWhereUniqueInput | WarehouseWhereUniqueInput[]
    update?: WarehouseUpdateWithWhereUniqueWithoutLocationInput | WarehouseUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: WarehouseUpdateManyWithWhereWithoutLocationInput | WarehouseUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: WarehouseScalarWhereInput | WarehouseScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<AssetCreateWithoutLocationInput, AssetUncheckedCreateWithoutLocationInput> | AssetCreateWithoutLocationInput[] | AssetUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutLocationInput | AssetCreateOrConnectWithoutLocationInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutLocationInput | AssetUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: AssetCreateManyLocationInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutLocationInput | AssetUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutLocationInput | AssetUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type LocationCreateNestedOneWithoutWarehousesInput = {
    create?: XOR<LocationCreateWithoutWarehousesInput, LocationUncheckedCreateWithoutWarehousesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutWarehousesInput
    connect?: LocationWhereUniqueInput
  }

  export type BinCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<BinCreateWithoutWarehouseInput, BinUncheckedCreateWithoutWarehouseInput> | BinCreateWithoutWarehouseInput[] | BinUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: BinCreateOrConnectWithoutWarehouseInput | BinCreateOrConnectWithoutWarehouseInput[]
    createMany?: BinCreateManyWarehouseInputEnvelope
    connect?: BinWhereUniqueInput | BinWhereUniqueInput[]
  }

  export type InventoryBatchCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<InventoryBatchCreateWithoutWarehouseInput, InventoryBatchUncheckedCreateWithoutWarehouseInput> | InventoryBatchCreateWithoutWarehouseInput[] | InventoryBatchUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryBatchCreateOrConnectWithoutWarehouseInput | InventoryBatchCreateOrConnectWithoutWarehouseInput[]
    createMany?: InventoryBatchCreateManyWarehouseInputEnvelope
    connect?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
  }

  export type InventoryLedgerCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<InventoryLedgerCreateWithoutWarehouseInput, InventoryLedgerUncheckedCreateWithoutWarehouseInput> | InventoryLedgerCreateWithoutWarehouseInput[] | InventoryLedgerUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryLedgerCreateOrConnectWithoutWarehouseInput | InventoryLedgerCreateOrConnectWithoutWarehouseInput[]
    createMany?: InventoryLedgerCreateManyWarehouseInputEnvelope
    connect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
  }

  export type ProductionOrderCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<ProductionOrderCreateWithoutWarehouseInput, ProductionOrderUncheckedCreateWithoutWarehouseInput> | ProductionOrderCreateWithoutWarehouseInput[] | ProductionOrderUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ProductionOrderCreateOrConnectWithoutWarehouseInput | ProductionOrderCreateOrConnectWithoutWarehouseInput[]
    createMany?: ProductionOrderCreateManyWarehouseInputEnvelope
    connect?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
  }

  export type BinUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<BinCreateWithoutWarehouseInput, BinUncheckedCreateWithoutWarehouseInput> | BinCreateWithoutWarehouseInput[] | BinUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: BinCreateOrConnectWithoutWarehouseInput | BinCreateOrConnectWithoutWarehouseInput[]
    createMany?: BinCreateManyWarehouseInputEnvelope
    connect?: BinWhereUniqueInput | BinWhereUniqueInput[]
  }

  export type InventoryBatchUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<InventoryBatchCreateWithoutWarehouseInput, InventoryBatchUncheckedCreateWithoutWarehouseInput> | InventoryBatchCreateWithoutWarehouseInput[] | InventoryBatchUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryBatchCreateOrConnectWithoutWarehouseInput | InventoryBatchCreateOrConnectWithoutWarehouseInput[]
    createMany?: InventoryBatchCreateManyWarehouseInputEnvelope
    connect?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
  }

  export type InventoryLedgerUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<InventoryLedgerCreateWithoutWarehouseInput, InventoryLedgerUncheckedCreateWithoutWarehouseInput> | InventoryLedgerCreateWithoutWarehouseInput[] | InventoryLedgerUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryLedgerCreateOrConnectWithoutWarehouseInput | InventoryLedgerCreateOrConnectWithoutWarehouseInput[]
    createMany?: InventoryLedgerCreateManyWarehouseInputEnvelope
    connect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
  }

  export type ProductionOrderUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<ProductionOrderCreateWithoutWarehouseInput, ProductionOrderUncheckedCreateWithoutWarehouseInput> | ProductionOrderCreateWithoutWarehouseInput[] | ProductionOrderUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ProductionOrderCreateOrConnectWithoutWarehouseInput | ProductionOrderCreateOrConnectWithoutWarehouseInput[]
    createMany?: ProductionOrderCreateManyWarehouseInputEnvelope
    connect?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
  }

  export type LocationUpdateOneRequiredWithoutWarehousesNestedInput = {
    create?: XOR<LocationCreateWithoutWarehousesInput, LocationUncheckedCreateWithoutWarehousesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutWarehousesInput
    upsert?: LocationUpsertWithoutWarehousesInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutWarehousesInput, LocationUpdateWithoutWarehousesInput>, LocationUncheckedUpdateWithoutWarehousesInput>
  }

  export type BinUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<BinCreateWithoutWarehouseInput, BinUncheckedCreateWithoutWarehouseInput> | BinCreateWithoutWarehouseInput[] | BinUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: BinCreateOrConnectWithoutWarehouseInput | BinCreateOrConnectWithoutWarehouseInput[]
    upsert?: BinUpsertWithWhereUniqueWithoutWarehouseInput | BinUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: BinCreateManyWarehouseInputEnvelope
    set?: BinWhereUniqueInput | BinWhereUniqueInput[]
    disconnect?: BinWhereUniqueInput | BinWhereUniqueInput[]
    delete?: BinWhereUniqueInput | BinWhereUniqueInput[]
    connect?: BinWhereUniqueInput | BinWhereUniqueInput[]
    update?: BinUpdateWithWhereUniqueWithoutWarehouseInput | BinUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: BinUpdateManyWithWhereWithoutWarehouseInput | BinUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: BinScalarWhereInput | BinScalarWhereInput[]
  }

  export type InventoryBatchUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<InventoryBatchCreateWithoutWarehouseInput, InventoryBatchUncheckedCreateWithoutWarehouseInput> | InventoryBatchCreateWithoutWarehouseInput[] | InventoryBatchUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryBatchCreateOrConnectWithoutWarehouseInput | InventoryBatchCreateOrConnectWithoutWarehouseInput[]
    upsert?: InventoryBatchUpsertWithWhereUniqueWithoutWarehouseInput | InventoryBatchUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: InventoryBatchCreateManyWarehouseInputEnvelope
    set?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
    disconnect?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
    delete?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
    connect?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
    update?: InventoryBatchUpdateWithWhereUniqueWithoutWarehouseInput | InventoryBatchUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: InventoryBatchUpdateManyWithWhereWithoutWarehouseInput | InventoryBatchUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: InventoryBatchScalarWhereInput | InventoryBatchScalarWhereInput[]
  }

  export type InventoryLedgerUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<InventoryLedgerCreateWithoutWarehouseInput, InventoryLedgerUncheckedCreateWithoutWarehouseInput> | InventoryLedgerCreateWithoutWarehouseInput[] | InventoryLedgerUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryLedgerCreateOrConnectWithoutWarehouseInput | InventoryLedgerCreateOrConnectWithoutWarehouseInput[]
    upsert?: InventoryLedgerUpsertWithWhereUniqueWithoutWarehouseInput | InventoryLedgerUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: InventoryLedgerCreateManyWarehouseInputEnvelope
    set?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    disconnect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    delete?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    connect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    update?: InventoryLedgerUpdateWithWhereUniqueWithoutWarehouseInput | InventoryLedgerUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: InventoryLedgerUpdateManyWithWhereWithoutWarehouseInput | InventoryLedgerUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: InventoryLedgerScalarWhereInput | InventoryLedgerScalarWhereInput[]
  }

  export type ProductionOrderUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<ProductionOrderCreateWithoutWarehouseInput, ProductionOrderUncheckedCreateWithoutWarehouseInput> | ProductionOrderCreateWithoutWarehouseInput[] | ProductionOrderUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ProductionOrderCreateOrConnectWithoutWarehouseInput | ProductionOrderCreateOrConnectWithoutWarehouseInput[]
    upsert?: ProductionOrderUpsertWithWhereUniqueWithoutWarehouseInput | ProductionOrderUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: ProductionOrderCreateManyWarehouseInputEnvelope
    set?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
    disconnect?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
    delete?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
    connect?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
    update?: ProductionOrderUpdateWithWhereUniqueWithoutWarehouseInput | ProductionOrderUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: ProductionOrderUpdateManyWithWhereWithoutWarehouseInput | ProductionOrderUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: ProductionOrderScalarWhereInput | ProductionOrderScalarWhereInput[]
  }

  export type BinUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<BinCreateWithoutWarehouseInput, BinUncheckedCreateWithoutWarehouseInput> | BinCreateWithoutWarehouseInput[] | BinUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: BinCreateOrConnectWithoutWarehouseInput | BinCreateOrConnectWithoutWarehouseInput[]
    upsert?: BinUpsertWithWhereUniqueWithoutWarehouseInput | BinUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: BinCreateManyWarehouseInputEnvelope
    set?: BinWhereUniqueInput | BinWhereUniqueInput[]
    disconnect?: BinWhereUniqueInput | BinWhereUniqueInput[]
    delete?: BinWhereUniqueInput | BinWhereUniqueInput[]
    connect?: BinWhereUniqueInput | BinWhereUniqueInput[]
    update?: BinUpdateWithWhereUniqueWithoutWarehouseInput | BinUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: BinUpdateManyWithWhereWithoutWarehouseInput | BinUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: BinScalarWhereInput | BinScalarWhereInput[]
  }

  export type InventoryBatchUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<InventoryBatchCreateWithoutWarehouseInput, InventoryBatchUncheckedCreateWithoutWarehouseInput> | InventoryBatchCreateWithoutWarehouseInput[] | InventoryBatchUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryBatchCreateOrConnectWithoutWarehouseInput | InventoryBatchCreateOrConnectWithoutWarehouseInput[]
    upsert?: InventoryBatchUpsertWithWhereUniqueWithoutWarehouseInput | InventoryBatchUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: InventoryBatchCreateManyWarehouseInputEnvelope
    set?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
    disconnect?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
    delete?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
    connect?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
    update?: InventoryBatchUpdateWithWhereUniqueWithoutWarehouseInput | InventoryBatchUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: InventoryBatchUpdateManyWithWhereWithoutWarehouseInput | InventoryBatchUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: InventoryBatchScalarWhereInput | InventoryBatchScalarWhereInput[]
  }

  export type InventoryLedgerUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<InventoryLedgerCreateWithoutWarehouseInput, InventoryLedgerUncheckedCreateWithoutWarehouseInput> | InventoryLedgerCreateWithoutWarehouseInput[] | InventoryLedgerUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryLedgerCreateOrConnectWithoutWarehouseInput | InventoryLedgerCreateOrConnectWithoutWarehouseInput[]
    upsert?: InventoryLedgerUpsertWithWhereUniqueWithoutWarehouseInput | InventoryLedgerUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: InventoryLedgerCreateManyWarehouseInputEnvelope
    set?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    disconnect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    delete?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    connect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    update?: InventoryLedgerUpdateWithWhereUniqueWithoutWarehouseInput | InventoryLedgerUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: InventoryLedgerUpdateManyWithWhereWithoutWarehouseInput | InventoryLedgerUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: InventoryLedgerScalarWhereInput | InventoryLedgerScalarWhereInput[]
  }

  export type ProductionOrderUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<ProductionOrderCreateWithoutWarehouseInput, ProductionOrderUncheckedCreateWithoutWarehouseInput> | ProductionOrderCreateWithoutWarehouseInput[] | ProductionOrderUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: ProductionOrderCreateOrConnectWithoutWarehouseInput | ProductionOrderCreateOrConnectWithoutWarehouseInput[]
    upsert?: ProductionOrderUpsertWithWhereUniqueWithoutWarehouseInput | ProductionOrderUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: ProductionOrderCreateManyWarehouseInputEnvelope
    set?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
    disconnect?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
    delete?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
    connect?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
    update?: ProductionOrderUpdateWithWhereUniqueWithoutWarehouseInput | ProductionOrderUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: ProductionOrderUpdateManyWithWhereWithoutWarehouseInput | ProductionOrderUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: ProductionOrderScalarWhereInput | ProductionOrderScalarWhereInput[]
  }

  export type WarehouseCreateNestedOneWithoutBinsInput = {
    create?: XOR<WarehouseCreateWithoutBinsInput, WarehouseUncheckedCreateWithoutBinsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutBinsInput
    connect?: WarehouseWhereUniqueInput
  }

  export type InventoryBatchCreateNestedManyWithoutBinInput = {
    create?: XOR<InventoryBatchCreateWithoutBinInput, InventoryBatchUncheckedCreateWithoutBinInput> | InventoryBatchCreateWithoutBinInput[] | InventoryBatchUncheckedCreateWithoutBinInput[]
    connectOrCreate?: InventoryBatchCreateOrConnectWithoutBinInput | InventoryBatchCreateOrConnectWithoutBinInput[]
    createMany?: InventoryBatchCreateManyBinInputEnvelope
    connect?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
  }

  export type InventoryBatchUncheckedCreateNestedManyWithoutBinInput = {
    create?: XOR<InventoryBatchCreateWithoutBinInput, InventoryBatchUncheckedCreateWithoutBinInput> | InventoryBatchCreateWithoutBinInput[] | InventoryBatchUncheckedCreateWithoutBinInput[]
    connectOrCreate?: InventoryBatchCreateOrConnectWithoutBinInput | InventoryBatchCreateOrConnectWithoutBinInput[]
    createMany?: InventoryBatchCreateManyBinInputEnvelope
    connect?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
  }

  export type WarehouseUpdateOneRequiredWithoutBinsNestedInput = {
    create?: XOR<WarehouseCreateWithoutBinsInput, WarehouseUncheckedCreateWithoutBinsInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutBinsInput
    upsert?: WarehouseUpsertWithoutBinsInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutBinsInput, WarehouseUpdateWithoutBinsInput>, WarehouseUncheckedUpdateWithoutBinsInput>
  }

  export type InventoryBatchUpdateManyWithoutBinNestedInput = {
    create?: XOR<InventoryBatchCreateWithoutBinInput, InventoryBatchUncheckedCreateWithoutBinInput> | InventoryBatchCreateWithoutBinInput[] | InventoryBatchUncheckedCreateWithoutBinInput[]
    connectOrCreate?: InventoryBatchCreateOrConnectWithoutBinInput | InventoryBatchCreateOrConnectWithoutBinInput[]
    upsert?: InventoryBatchUpsertWithWhereUniqueWithoutBinInput | InventoryBatchUpsertWithWhereUniqueWithoutBinInput[]
    createMany?: InventoryBatchCreateManyBinInputEnvelope
    set?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
    disconnect?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
    delete?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
    connect?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
    update?: InventoryBatchUpdateWithWhereUniqueWithoutBinInput | InventoryBatchUpdateWithWhereUniqueWithoutBinInput[]
    updateMany?: InventoryBatchUpdateManyWithWhereWithoutBinInput | InventoryBatchUpdateManyWithWhereWithoutBinInput[]
    deleteMany?: InventoryBatchScalarWhereInput | InventoryBatchScalarWhereInput[]
  }

  export type InventoryBatchUncheckedUpdateManyWithoutBinNestedInput = {
    create?: XOR<InventoryBatchCreateWithoutBinInput, InventoryBatchUncheckedCreateWithoutBinInput> | InventoryBatchCreateWithoutBinInput[] | InventoryBatchUncheckedCreateWithoutBinInput[]
    connectOrCreate?: InventoryBatchCreateOrConnectWithoutBinInput | InventoryBatchCreateOrConnectWithoutBinInput[]
    upsert?: InventoryBatchUpsertWithWhereUniqueWithoutBinInput | InventoryBatchUpsertWithWhereUniqueWithoutBinInput[]
    createMany?: InventoryBatchCreateManyBinInputEnvelope
    set?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
    disconnect?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
    delete?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
    connect?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
    update?: InventoryBatchUpdateWithWhereUniqueWithoutBinInput | InventoryBatchUpdateWithWhereUniqueWithoutBinInput[]
    updateMany?: InventoryBatchUpdateManyWithWhereWithoutBinInput | InventoryBatchUpdateManyWithWhereWithoutBinInput[]
    deleteMany?: InventoryBatchScalarWhereInput | InventoryBatchScalarWhereInput[]
  }

  export type BomCreateNestedManyWithoutItemInput = {
    create?: XOR<BomCreateWithoutItemInput, BomUncheckedCreateWithoutItemInput> | BomCreateWithoutItemInput[] | BomUncheckedCreateWithoutItemInput[]
    connectOrCreate?: BomCreateOrConnectWithoutItemInput | BomCreateOrConnectWithoutItemInput[]
    createMany?: BomCreateManyItemInputEnvelope
    connect?: BomWhereUniqueInput | BomWhereUniqueInput[]
  }

  export type BomLineCreateNestedManyWithoutComponentItemInput = {
    create?: XOR<BomLineCreateWithoutComponentItemInput, BomLineUncheckedCreateWithoutComponentItemInput> | BomLineCreateWithoutComponentItemInput[] | BomLineUncheckedCreateWithoutComponentItemInput[]
    connectOrCreate?: BomLineCreateOrConnectWithoutComponentItemInput | BomLineCreateOrConnectWithoutComponentItemInput[]
    createMany?: BomLineCreateManyComponentItemInputEnvelope
    connect?: BomLineWhereUniqueInput | BomLineWhereUniqueInput[]
  }

  export type InventoryBatchCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryBatchCreateWithoutItemInput, InventoryBatchUncheckedCreateWithoutItemInput> | InventoryBatchCreateWithoutItemInput[] | InventoryBatchUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryBatchCreateOrConnectWithoutItemInput | InventoryBatchCreateOrConnectWithoutItemInput[]
    createMany?: InventoryBatchCreateManyItemInputEnvelope
    connect?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
  }

  export type InventoryLedgerCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryLedgerCreateWithoutItemInput, InventoryLedgerUncheckedCreateWithoutItemInput> | InventoryLedgerCreateWithoutItemInput[] | InventoryLedgerUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryLedgerCreateOrConnectWithoutItemInput | InventoryLedgerCreateOrConnectWithoutItemInput[]
    createMany?: InventoryLedgerCreateManyItemInputEnvelope
    connect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
  }

  export type ProductionOrderCreateNestedManyWithoutItemInput = {
    create?: XOR<ProductionOrderCreateWithoutItemInput, ProductionOrderUncheckedCreateWithoutItemInput> | ProductionOrderCreateWithoutItemInput[] | ProductionOrderUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ProductionOrderCreateOrConnectWithoutItemInput | ProductionOrderCreateOrConnectWithoutItemInput[]
    createMany?: ProductionOrderCreateManyItemInputEnvelope
    connect?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
  }

  export type PurchaseLineCreateNestedManyWithoutItemInput = {
    create?: XOR<PurchaseLineCreateWithoutItemInput, PurchaseLineUncheckedCreateWithoutItemInput> | PurchaseLineCreateWithoutItemInput[] | PurchaseLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseLineCreateOrConnectWithoutItemInput | PurchaseLineCreateOrConnectWithoutItemInput[]
    createMany?: PurchaseLineCreateManyItemInputEnvelope
    connect?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
  }

  export type SaleLineCreateNestedManyWithoutItemInput = {
    create?: XOR<SaleLineCreateWithoutItemInput, SaleLineUncheckedCreateWithoutItemInput> | SaleLineCreateWithoutItemInput[] | SaleLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SaleLineCreateOrConnectWithoutItemInput | SaleLineCreateOrConnectWithoutItemInput[]
    createMany?: SaleLineCreateManyItemInputEnvelope
    connect?: SaleLineWhereUniqueInput | SaleLineWhereUniqueInput[]
  }

  export type BomUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<BomCreateWithoutItemInput, BomUncheckedCreateWithoutItemInput> | BomCreateWithoutItemInput[] | BomUncheckedCreateWithoutItemInput[]
    connectOrCreate?: BomCreateOrConnectWithoutItemInput | BomCreateOrConnectWithoutItemInput[]
    createMany?: BomCreateManyItemInputEnvelope
    connect?: BomWhereUniqueInput | BomWhereUniqueInput[]
  }

  export type BomLineUncheckedCreateNestedManyWithoutComponentItemInput = {
    create?: XOR<BomLineCreateWithoutComponentItemInput, BomLineUncheckedCreateWithoutComponentItemInput> | BomLineCreateWithoutComponentItemInput[] | BomLineUncheckedCreateWithoutComponentItemInput[]
    connectOrCreate?: BomLineCreateOrConnectWithoutComponentItemInput | BomLineCreateOrConnectWithoutComponentItemInput[]
    createMany?: BomLineCreateManyComponentItemInputEnvelope
    connect?: BomLineWhereUniqueInput | BomLineWhereUniqueInput[]
  }

  export type InventoryBatchUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryBatchCreateWithoutItemInput, InventoryBatchUncheckedCreateWithoutItemInput> | InventoryBatchCreateWithoutItemInput[] | InventoryBatchUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryBatchCreateOrConnectWithoutItemInput | InventoryBatchCreateOrConnectWithoutItemInput[]
    createMany?: InventoryBatchCreateManyItemInputEnvelope
    connect?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
  }

  export type InventoryLedgerUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryLedgerCreateWithoutItemInput, InventoryLedgerUncheckedCreateWithoutItemInput> | InventoryLedgerCreateWithoutItemInput[] | InventoryLedgerUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryLedgerCreateOrConnectWithoutItemInput | InventoryLedgerCreateOrConnectWithoutItemInput[]
    createMany?: InventoryLedgerCreateManyItemInputEnvelope
    connect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
  }

  export type ProductionOrderUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ProductionOrderCreateWithoutItemInput, ProductionOrderUncheckedCreateWithoutItemInput> | ProductionOrderCreateWithoutItemInput[] | ProductionOrderUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ProductionOrderCreateOrConnectWithoutItemInput | ProductionOrderCreateOrConnectWithoutItemInput[]
    createMany?: ProductionOrderCreateManyItemInputEnvelope
    connect?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
  }

  export type PurchaseLineUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<PurchaseLineCreateWithoutItemInput, PurchaseLineUncheckedCreateWithoutItemInput> | PurchaseLineCreateWithoutItemInput[] | PurchaseLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseLineCreateOrConnectWithoutItemInput | PurchaseLineCreateOrConnectWithoutItemInput[]
    createMany?: PurchaseLineCreateManyItemInputEnvelope
    connect?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
  }

  export type SaleLineUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<SaleLineCreateWithoutItemInput, SaleLineUncheckedCreateWithoutItemInput> | SaleLineCreateWithoutItemInput[] | SaleLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SaleLineCreateOrConnectWithoutItemInput | SaleLineCreateOrConnectWithoutItemInput[]
    createMany?: SaleLineCreateManyItemInputEnvelope
    connect?: SaleLineWhereUniqueInput | SaleLineWhereUniqueInput[]
  }

  export type EnumItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.ItemType
  }

  export type EnumCostingMethodFieldUpdateOperationsInput = {
    set?: $Enums.CostingMethod
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BomUpdateManyWithoutItemNestedInput = {
    create?: XOR<BomCreateWithoutItemInput, BomUncheckedCreateWithoutItemInput> | BomCreateWithoutItemInput[] | BomUncheckedCreateWithoutItemInput[]
    connectOrCreate?: BomCreateOrConnectWithoutItemInput | BomCreateOrConnectWithoutItemInput[]
    upsert?: BomUpsertWithWhereUniqueWithoutItemInput | BomUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: BomCreateManyItemInputEnvelope
    set?: BomWhereUniqueInput | BomWhereUniqueInput[]
    disconnect?: BomWhereUniqueInput | BomWhereUniqueInput[]
    delete?: BomWhereUniqueInput | BomWhereUniqueInput[]
    connect?: BomWhereUniqueInput | BomWhereUniqueInput[]
    update?: BomUpdateWithWhereUniqueWithoutItemInput | BomUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: BomUpdateManyWithWhereWithoutItemInput | BomUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: BomScalarWhereInput | BomScalarWhereInput[]
  }

  export type BomLineUpdateManyWithoutComponentItemNestedInput = {
    create?: XOR<BomLineCreateWithoutComponentItemInput, BomLineUncheckedCreateWithoutComponentItemInput> | BomLineCreateWithoutComponentItemInput[] | BomLineUncheckedCreateWithoutComponentItemInput[]
    connectOrCreate?: BomLineCreateOrConnectWithoutComponentItemInput | BomLineCreateOrConnectWithoutComponentItemInput[]
    upsert?: BomLineUpsertWithWhereUniqueWithoutComponentItemInput | BomLineUpsertWithWhereUniqueWithoutComponentItemInput[]
    createMany?: BomLineCreateManyComponentItemInputEnvelope
    set?: BomLineWhereUniqueInput | BomLineWhereUniqueInput[]
    disconnect?: BomLineWhereUniqueInput | BomLineWhereUniqueInput[]
    delete?: BomLineWhereUniqueInput | BomLineWhereUniqueInput[]
    connect?: BomLineWhereUniqueInput | BomLineWhereUniqueInput[]
    update?: BomLineUpdateWithWhereUniqueWithoutComponentItemInput | BomLineUpdateWithWhereUniqueWithoutComponentItemInput[]
    updateMany?: BomLineUpdateManyWithWhereWithoutComponentItemInput | BomLineUpdateManyWithWhereWithoutComponentItemInput[]
    deleteMany?: BomLineScalarWhereInput | BomLineScalarWhereInput[]
  }

  export type InventoryBatchUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryBatchCreateWithoutItemInput, InventoryBatchUncheckedCreateWithoutItemInput> | InventoryBatchCreateWithoutItemInput[] | InventoryBatchUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryBatchCreateOrConnectWithoutItemInput | InventoryBatchCreateOrConnectWithoutItemInput[]
    upsert?: InventoryBatchUpsertWithWhereUniqueWithoutItemInput | InventoryBatchUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryBatchCreateManyItemInputEnvelope
    set?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
    disconnect?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
    delete?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
    connect?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
    update?: InventoryBatchUpdateWithWhereUniqueWithoutItemInput | InventoryBatchUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryBatchUpdateManyWithWhereWithoutItemInput | InventoryBatchUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryBatchScalarWhereInput | InventoryBatchScalarWhereInput[]
  }

  export type InventoryLedgerUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryLedgerCreateWithoutItemInput, InventoryLedgerUncheckedCreateWithoutItemInput> | InventoryLedgerCreateWithoutItemInput[] | InventoryLedgerUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryLedgerCreateOrConnectWithoutItemInput | InventoryLedgerCreateOrConnectWithoutItemInput[]
    upsert?: InventoryLedgerUpsertWithWhereUniqueWithoutItemInput | InventoryLedgerUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryLedgerCreateManyItemInputEnvelope
    set?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    disconnect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    delete?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    connect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    update?: InventoryLedgerUpdateWithWhereUniqueWithoutItemInput | InventoryLedgerUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryLedgerUpdateManyWithWhereWithoutItemInput | InventoryLedgerUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryLedgerScalarWhereInput | InventoryLedgerScalarWhereInput[]
  }

  export type ProductionOrderUpdateManyWithoutItemNestedInput = {
    create?: XOR<ProductionOrderCreateWithoutItemInput, ProductionOrderUncheckedCreateWithoutItemInput> | ProductionOrderCreateWithoutItemInput[] | ProductionOrderUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ProductionOrderCreateOrConnectWithoutItemInput | ProductionOrderCreateOrConnectWithoutItemInput[]
    upsert?: ProductionOrderUpsertWithWhereUniqueWithoutItemInput | ProductionOrderUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ProductionOrderCreateManyItemInputEnvelope
    set?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
    disconnect?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
    delete?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
    connect?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
    update?: ProductionOrderUpdateWithWhereUniqueWithoutItemInput | ProductionOrderUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ProductionOrderUpdateManyWithWhereWithoutItemInput | ProductionOrderUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ProductionOrderScalarWhereInput | ProductionOrderScalarWhereInput[]
  }

  export type PurchaseLineUpdateManyWithoutItemNestedInput = {
    create?: XOR<PurchaseLineCreateWithoutItemInput, PurchaseLineUncheckedCreateWithoutItemInput> | PurchaseLineCreateWithoutItemInput[] | PurchaseLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseLineCreateOrConnectWithoutItemInput | PurchaseLineCreateOrConnectWithoutItemInput[]
    upsert?: PurchaseLineUpsertWithWhereUniqueWithoutItemInput | PurchaseLineUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: PurchaseLineCreateManyItemInputEnvelope
    set?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    disconnect?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    delete?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    connect?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    update?: PurchaseLineUpdateWithWhereUniqueWithoutItemInput | PurchaseLineUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: PurchaseLineUpdateManyWithWhereWithoutItemInput | PurchaseLineUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: PurchaseLineScalarWhereInput | PurchaseLineScalarWhereInput[]
  }

  export type SaleLineUpdateManyWithoutItemNestedInput = {
    create?: XOR<SaleLineCreateWithoutItemInput, SaleLineUncheckedCreateWithoutItemInput> | SaleLineCreateWithoutItemInput[] | SaleLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SaleLineCreateOrConnectWithoutItemInput | SaleLineCreateOrConnectWithoutItemInput[]
    upsert?: SaleLineUpsertWithWhereUniqueWithoutItemInput | SaleLineUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SaleLineCreateManyItemInputEnvelope
    set?: SaleLineWhereUniqueInput | SaleLineWhereUniqueInput[]
    disconnect?: SaleLineWhereUniqueInput | SaleLineWhereUniqueInput[]
    delete?: SaleLineWhereUniqueInput | SaleLineWhereUniqueInput[]
    connect?: SaleLineWhereUniqueInput | SaleLineWhereUniqueInput[]
    update?: SaleLineUpdateWithWhereUniqueWithoutItemInput | SaleLineUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SaleLineUpdateManyWithWhereWithoutItemInput | SaleLineUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SaleLineScalarWhereInput | SaleLineScalarWhereInput[]
  }

  export type BomUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<BomCreateWithoutItemInput, BomUncheckedCreateWithoutItemInput> | BomCreateWithoutItemInput[] | BomUncheckedCreateWithoutItemInput[]
    connectOrCreate?: BomCreateOrConnectWithoutItemInput | BomCreateOrConnectWithoutItemInput[]
    upsert?: BomUpsertWithWhereUniqueWithoutItemInput | BomUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: BomCreateManyItemInputEnvelope
    set?: BomWhereUniqueInput | BomWhereUniqueInput[]
    disconnect?: BomWhereUniqueInput | BomWhereUniqueInput[]
    delete?: BomWhereUniqueInput | BomWhereUniqueInput[]
    connect?: BomWhereUniqueInput | BomWhereUniqueInput[]
    update?: BomUpdateWithWhereUniqueWithoutItemInput | BomUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: BomUpdateManyWithWhereWithoutItemInput | BomUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: BomScalarWhereInput | BomScalarWhereInput[]
  }

  export type BomLineUncheckedUpdateManyWithoutComponentItemNestedInput = {
    create?: XOR<BomLineCreateWithoutComponentItemInput, BomLineUncheckedCreateWithoutComponentItemInput> | BomLineCreateWithoutComponentItemInput[] | BomLineUncheckedCreateWithoutComponentItemInput[]
    connectOrCreate?: BomLineCreateOrConnectWithoutComponentItemInput | BomLineCreateOrConnectWithoutComponentItemInput[]
    upsert?: BomLineUpsertWithWhereUniqueWithoutComponentItemInput | BomLineUpsertWithWhereUniqueWithoutComponentItemInput[]
    createMany?: BomLineCreateManyComponentItemInputEnvelope
    set?: BomLineWhereUniqueInput | BomLineWhereUniqueInput[]
    disconnect?: BomLineWhereUniqueInput | BomLineWhereUniqueInput[]
    delete?: BomLineWhereUniqueInput | BomLineWhereUniqueInput[]
    connect?: BomLineWhereUniqueInput | BomLineWhereUniqueInput[]
    update?: BomLineUpdateWithWhereUniqueWithoutComponentItemInput | BomLineUpdateWithWhereUniqueWithoutComponentItemInput[]
    updateMany?: BomLineUpdateManyWithWhereWithoutComponentItemInput | BomLineUpdateManyWithWhereWithoutComponentItemInput[]
    deleteMany?: BomLineScalarWhereInput | BomLineScalarWhereInput[]
  }

  export type InventoryBatchUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryBatchCreateWithoutItemInput, InventoryBatchUncheckedCreateWithoutItemInput> | InventoryBatchCreateWithoutItemInput[] | InventoryBatchUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryBatchCreateOrConnectWithoutItemInput | InventoryBatchCreateOrConnectWithoutItemInput[]
    upsert?: InventoryBatchUpsertWithWhereUniqueWithoutItemInput | InventoryBatchUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryBatchCreateManyItemInputEnvelope
    set?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
    disconnect?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
    delete?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
    connect?: InventoryBatchWhereUniqueInput | InventoryBatchWhereUniqueInput[]
    update?: InventoryBatchUpdateWithWhereUniqueWithoutItemInput | InventoryBatchUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryBatchUpdateManyWithWhereWithoutItemInput | InventoryBatchUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryBatchScalarWhereInput | InventoryBatchScalarWhereInput[]
  }

  export type InventoryLedgerUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryLedgerCreateWithoutItemInput, InventoryLedgerUncheckedCreateWithoutItemInput> | InventoryLedgerCreateWithoutItemInput[] | InventoryLedgerUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryLedgerCreateOrConnectWithoutItemInput | InventoryLedgerCreateOrConnectWithoutItemInput[]
    upsert?: InventoryLedgerUpsertWithWhereUniqueWithoutItemInput | InventoryLedgerUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryLedgerCreateManyItemInputEnvelope
    set?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    disconnect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    delete?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    connect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    update?: InventoryLedgerUpdateWithWhereUniqueWithoutItemInput | InventoryLedgerUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryLedgerUpdateManyWithWhereWithoutItemInput | InventoryLedgerUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryLedgerScalarWhereInput | InventoryLedgerScalarWhereInput[]
  }

  export type ProductionOrderUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ProductionOrderCreateWithoutItemInput, ProductionOrderUncheckedCreateWithoutItemInput> | ProductionOrderCreateWithoutItemInput[] | ProductionOrderUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ProductionOrderCreateOrConnectWithoutItemInput | ProductionOrderCreateOrConnectWithoutItemInput[]
    upsert?: ProductionOrderUpsertWithWhereUniqueWithoutItemInput | ProductionOrderUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ProductionOrderCreateManyItemInputEnvelope
    set?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
    disconnect?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
    delete?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
    connect?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
    update?: ProductionOrderUpdateWithWhereUniqueWithoutItemInput | ProductionOrderUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ProductionOrderUpdateManyWithWhereWithoutItemInput | ProductionOrderUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ProductionOrderScalarWhereInput | ProductionOrderScalarWhereInput[]
  }

  export type PurchaseLineUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<PurchaseLineCreateWithoutItemInput, PurchaseLineUncheckedCreateWithoutItemInput> | PurchaseLineCreateWithoutItemInput[] | PurchaseLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseLineCreateOrConnectWithoutItemInput | PurchaseLineCreateOrConnectWithoutItemInput[]
    upsert?: PurchaseLineUpsertWithWhereUniqueWithoutItemInput | PurchaseLineUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: PurchaseLineCreateManyItemInputEnvelope
    set?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    disconnect?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    delete?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    connect?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    update?: PurchaseLineUpdateWithWhereUniqueWithoutItemInput | PurchaseLineUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: PurchaseLineUpdateManyWithWhereWithoutItemInput | PurchaseLineUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: PurchaseLineScalarWhereInput | PurchaseLineScalarWhereInput[]
  }

  export type SaleLineUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<SaleLineCreateWithoutItemInput, SaleLineUncheckedCreateWithoutItemInput> | SaleLineCreateWithoutItemInput[] | SaleLineUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SaleLineCreateOrConnectWithoutItemInput | SaleLineCreateOrConnectWithoutItemInput[]
    upsert?: SaleLineUpsertWithWhereUniqueWithoutItemInput | SaleLineUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SaleLineCreateManyItemInputEnvelope
    set?: SaleLineWhereUniqueInput | SaleLineWhereUniqueInput[]
    disconnect?: SaleLineWhereUniqueInput | SaleLineWhereUniqueInput[]
    delete?: SaleLineWhereUniqueInput | SaleLineWhereUniqueInput[]
    connect?: SaleLineWhereUniqueInput | SaleLineWhereUniqueInput[]
    update?: SaleLineUpdateWithWhereUniqueWithoutItemInput | SaleLineUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SaleLineUpdateManyWithWhereWithoutItemInput | SaleLineUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SaleLineScalarWhereInput | SaleLineScalarWhereInput[]
  }

  export type ItemCreateNestedOneWithoutBomsInput = {
    create?: XOR<ItemCreateWithoutBomsInput, ItemUncheckedCreateWithoutBomsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutBomsInput
    connect?: ItemWhereUniqueInput
  }

  export type BomLineCreateNestedManyWithoutBomInput = {
    create?: XOR<BomLineCreateWithoutBomInput, BomLineUncheckedCreateWithoutBomInput> | BomLineCreateWithoutBomInput[] | BomLineUncheckedCreateWithoutBomInput[]
    connectOrCreate?: BomLineCreateOrConnectWithoutBomInput | BomLineCreateOrConnectWithoutBomInput[]
    createMany?: BomLineCreateManyBomInputEnvelope
    connect?: BomLineWhereUniqueInput | BomLineWhereUniqueInput[]
  }

  export type ProductionOrderCreateNestedManyWithoutBomInput = {
    create?: XOR<ProductionOrderCreateWithoutBomInput, ProductionOrderUncheckedCreateWithoutBomInput> | ProductionOrderCreateWithoutBomInput[] | ProductionOrderUncheckedCreateWithoutBomInput[]
    connectOrCreate?: ProductionOrderCreateOrConnectWithoutBomInput | ProductionOrderCreateOrConnectWithoutBomInput[]
    createMany?: ProductionOrderCreateManyBomInputEnvelope
    connect?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
  }

  export type BomLineUncheckedCreateNestedManyWithoutBomInput = {
    create?: XOR<BomLineCreateWithoutBomInput, BomLineUncheckedCreateWithoutBomInput> | BomLineCreateWithoutBomInput[] | BomLineUncheckedCreateWithoutBomInput[]
    connectOrCreate?: BomLineCreateOrConnectWithoutBomInput | BomLineCreateOrConnectWithoutBomInput[]
    createMany?: BomLineCreateManyBomInputEnvelope
    connect?: BomLineWhereUniqueInput | BomLineWhereUniqueInput[]
  }

  export type ProductionOrderUncheckedCreateNestedManyWithoutBomInput = {
    create?: XOR<ProductionOrderCreateWithoutBomInput, ProductionOrderUncheckedCreateWithoutBomInput> | ProductionOrderCreateWithoutBomInput[] | ProductionOrderUncheckedCreateWithoutBomInput[]
    connectOrCreate?: ProductionOrderCreateOrConnectWithoutBomInput | ProductionOrderCreateOrConnectWithoutBomInput[]
    createMany?: ProductionOrderCreateManyBomInputEnvelope
    connect?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
  }

  export type ItemUpdateOneRequiredWithoutBomsNestedInput = {
    create?: XOR<ItemCreateWithoutBomsInput, ItemUncheckedCreateWithoutBomsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutBomsInput
    upsert?: ItemUpsertWithoutBomsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutBomsInput, ItemUpdateWithoutBomsInput>, ItemUncheckedUpdateWithoutBomsInput>
  }

  export type BomLineUpdateManyWithoutBomNestedInput = {
    create?: XOR<BomLineCreateWithoutBomInput, BomLineUncheckedCreateWithoutBomInput> | BomLineCreateWithoutBomInput[] | BomLineUncheckedCreateWithoutBomInput[]
    connectOrCreate?: BomLineCreateOrConnectWithoutBomInput | BomLineCreateOrConnectWithoutBomInput[]
    upsert?: BomLineUpsertWithWhereUniqueWithoutBomInput | BomLineUpsertWithWhereUniqueWithoutBomInput[]
    createMany?: BomLineCreateManyBomInputEnvelope
    set?: BomLineWhereUniqueInput | BomLineWhereUniqueInput[]
    disconnect?: BomLineWhereUniqueInput | BomLineWhereUniqueInput[]
    delete?: BomLineWhereUniqueInput | BomLineWhereUniqueInput[]
    connect?: BomLineWhereUniqueInput | BomLineWhereUniqueInput[]
    update?: BomLineUpdateWithWhereUniqueWithoutBomInput | BomLineUpdateWithWhereUniqueWithoutBomInput[]
    updateMany?: BomLineUpdateManyWithWhereWithoutBomInput | BomLineUpdateManyWithWhereWithoutBomInput[]
    deleteMany?: BomLineScalarWhereInput | BomLineScalarWhereInput[]
  }

  export type ProductionOrderUpdateManyWithoutBomNestedInput = {
    create?: XOR<ProductionOrderCreateWithoutBomInput, ProductionOrderUncheckedCreateWithoutBomInput> | ProductionOrderCreateWithoutBomInput[] | ProductionOrderUncheckedCreateWithoutBomInput[]
    connectOrCreate?: ProductionOrderCreateOrConnectWithoutBomInput | ProductionOrderCreateOrConnectWithoutBomInput[]
    upsert?: ProductionOrderUpsertWithWhereUniqueWithoutBomInput | ProductionOrderUpsertWithWhereUniqueWithoutBomInput[]
    createMany?: ProductionOrderCreateManyBomInputEnvelope
    set?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
    disconnect?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
    delete?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
    connect?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
    update?: ProductionOrderUpdateWithWhereUniqueWithoutBomInput | ProductionOrderUpdateWithWhereUniqueWithoutBomInput[]
    updateMany?: ProductionOrderUpdateManyWithWhereWithoutBomInput | ProductionOrderUpdateManyWithWhereWithoutBomInput[]
    deleteMany?: ProductionOrderScalarWhereInput | ProductionOrderScalarWhereInput[]
  }

  export type BomLineUncheckedUpdateManyWithoutBomNestedInput = {
    create?: XOR<BomLineCreateWithoutBomInput, BomLineUncheckedCreateWithoutBomInput> | BomLineCreateWithoutBomInput[] | BomLineUncheckedCreateWithoutBomInput[]
    connectOrCreate?: BomLineCreateOrConnectWithoutBomInput | BomLineCreateOrConnectWithoutBomInput[]
    upsert?: BomLineUpsertWithWhereUniqueWithoutBomInput | BomLineUpsertWithWhereUniqueWithoutBomInput[]
    createMany?: BomLineCreateManyBomInputEnvelope
    set?: BomLineWhereUniqueInput | BomLineWhereUniqueInput[]
    disconnect?: BomLineWhereUniqueInput | BomLineWhereUniqueInput[]
    delete?: BomLineWhereUniqueInput | BomLineWhereUniqueInput[]
    connect?: BomLineWhereUniqueInput | BomLineWhereUniqueInput[]
    update?: BomLineUpdateWithWhereUniqueWithoutBomInput | BomLineUpdateWithWhereUniqueWithoutBomInput[]
    updateMany?: BomLineUpdateManyWithWhereWithoutBomInput | BomLineUpdateManyWithWhereWithoutBomInput[]
    deleteMany?: BomLineScalarWhereInput | BomLineScalarWhereInput[]
  }

  export type ProductionOrderUncheckedUpdateManyWithoutBomNestedInput = {
    create?: XOR<ProductionOrderCreateWithoutBomInput, ProductionOrderUncheckedCreateWithoutBomInput> | ProductionOrderCreateWithoutBomInput[] | ProductionOrderUncheckedCreateWithoutBomInput[]
    connectOrCreate?: ProductionOrderCreateOrConnectWithoutBomInput | ProductionOrderCreateOrConnectWithoutBomInput[]
    upsert?: ProductionOrderUpsertWithWhereUniqueWithoutBomInput | ProductionOrderUpsertWithWhereUniqueWithoutBomInput[]
    createMany?: ProductionOrderCreateManyBomInputEnvelope
    set?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
    disconnect?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
    delete?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
    connect?: ProductionOrderWhereUniqueInput | ProductionOrderWhereUniqueInput[]
    update?: ProductionOrderUpdateWithWhereUniqueWithoutBomInput | ProductionOrderUpdateWithWhereUniqueWithoutBomInput[]
    updateMany?: ProductionOrderUpdateManyWithWhereWithoutBomInput | ProductionOrderUpdateManyWithWhereWithoutBomInput[]
    deleteMany?: ProductionOrderScalarWhereInput | ProductionOrderScalarWhereInput[]
  }

  export type BomCreateNestedOneWithoutBomLinesInput = {
    create?: XOR<BomCreateWithoutBomLinesInput, BomUncheckedCreateWithoutBomLinesInput>
    connectOrCreate?: BomCreateOrConnectWithoutBomLinesInput
    connect?: BomWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutBomLinesInput = {
    create?: XOR<ItemCreateWithoutBomLinesInput, ItemUncheckedCreateWithoutBomLinesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutBomLinesInput
    connect?: ItemWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BomUpdateOneRequiredWithoutBomLinesNestedInput = {
    create?: XOR<BomCreateWithoutBomLinesInput, BomUncheckedCreateWithoutBomLinesInput>
    connectOrCreate?: BomCreateOrConnectWithoutBomLinesInput
    upsert?: BomUpsertWithoutBomLinesInput
    connect?: BomWhereUniqueInput
    update?: XOR<XOR<BomUpdateToOneWithWhereWithoutBomLinesInput, BomUpdateWithoutBomLinesInput>, BomUncheckedUpdateWithoutBomLinesInput>
  }

  export type ItemUpdateOneRequiredWithoutBomLinesNestedInput = {
    create?: XOR<ItemCreateWithoutBomLinesInput, ItemUncheckedCreateWithoutBomLinesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutBomLinesInput
    upsert?: ItemUpsertWithoutBomLinesInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutBomLinesInput, ItemUpdateWithoutBomLinesInput>, ItemUncheckedUpdateWithoutBomLinesInput>
  }

  export type ItemCreateNestedOneWithoutInventoryBatchesInput = {
    create?: XOR<ItemCreateWithoutInventoryBatchesInput, ItemUncheckedCreateWithoutInventoryBatchesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInventoryBatchesInput
    connect?: ItemWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutInventoryBatchesInput = {
    create?: XOR<WarehouseCreateWithoutInventoryBatchesInput, WarehouseUncheckedCreateWithoutInventoryBatchesInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutInventoryBatchesInput
    connect?: WarehouseWhereUniqueInput
  }

  export type BinCreateNestedOneWithoutInventoryBatchesInput = {
    create?: XOR<BinCreateWithoutInventoryBatchesInput, BinUncheckedCreateWithoutInventoryBatchesInput>
    connectOrCreate?: BinCreateOrConnectWithoutInventoryBatchesInput
    connect?: BinWhereUniqueInput
  }

  export type InventoryLedgerCreateNestedManyWithoutBatchInput = {
    create?: XOR<InventoryLedgerCreateWithoutBatchInput, InventoryLedgerUncheckedCreateWithoutBatchInput> | InventoryLedgerCreateWithoutBatchInput[] | InventoryLedgerUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: InventoryLedgerCreateOrConnectWithoutBatchInput | InventoryLedgerCreateOrConnectWithoutBatchInput[]
    createMany?: InventoryLedgerCreateManyBatchInputEnvelope
    connect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
  }

  export type InventoryLedgerUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<InventoryLedgerCreateWithoutBatchInput, InventoryLedgerUncheckedCreateWithoutBatchInput> | InventoryLedgerCreateWithoutBatchInput[] | InventoryLedgerUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: InventoryLedgerCreateOrConnectWithoutBatchInput | InventoryLedgerCreateOrConnectWithoutBatchInput[]
    createMany?: InventoryLedgerCreateManyBatchInputEnvelope
    connect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
  }

  export type ItemUpdateOneRequiredWithoutInventoryBatchesNestedInput = {
    create?: XOR<ItemCreateWithoutInventoryBatchesInput, ItemUncheckedCreateWithoutInventoryBatchesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInventoryBatchesInput
    upsert?: ItemUpsertWithoutInventoryBatchesInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutInventoryBatchesInput, ItemUpdateWithoutInventoryBatchesInput>, ItemUncheckedUpdateWithoutInventoryBatchesInput>
  }

  export type WarehouseUpdateOneRequiredWithoutInventoryBatchesNestedInput = {
    create?: XOR<WarehouseCreateWithoutInventoryBatchesInput, WarehouseUncheckedCreateWithoutInventoryBatchesInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutInventoryBatchesInput
    upsert?: WarehouseUpsertWithoutInventoryBatchesInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutInventoryBatchesInput, WarehouseUpdateWithoutInventoryBatchesInput>, WarehouseUncheckedUpdateWithoutInventoryBatchesInput>
  }

  export type BinUpdateOneWithoutInventoryBatchesNestedInput = {
    create?: XOR<BinCreateWithoutInventoryBatchesInput, BinUncheckedCreateWithoutInventoryBatchesInput>
    connectOrCreate?: BinCreateOrConnectWithoutInventoryBatchesInput
    upsert?: BinUpsertWithoutInventoryBatchesInput
    disconnect?: BinWhereInput | boolean
    delete?: BinWhereInput | boolean
    connect?: BinWhereUniqueInput
    update?: XOR<XOR<BinUpdateToOneWithWhereWithoutInventoryBatchesInput, BinUpdateWithoutInventoryBatchesInput>, BinUncheckedUpdateWithoutInventoryBatchesInput>
  }

  export type InventoryLedgerUpdateManyWithoutBatchNestedInput = {
    create?: XOR<InventoryLedgerCreateWithoutBatchInput, InventoryLedgerUncheckedCreateWithoutBatchInput> | InventoryLedgerCreateWithoutBatchInput[] | InventoryLedgerUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: InventoryLedgerCreateOrConnectWithoutBatchInput | InventoryLedgerCreateOrConnectWithoutBatchInput[]
    upsert?: InventoryLedgerUpsertWithWhereUniqueWithoutBatchInput | InventoryLedgerUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: InventoryLedgerCreateManyBatchInputEnvelope
    set?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    disconnect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    delete?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    connect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    update?: InventoryLedgerUpdateWithWhereUniqueWithoutBatchInput | InventoryLedgerUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: InventoryLedgerUpdateManyWithWhereWithoutBatchInput | InventoryLedgerUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: InventoryLedgerScalarWhereInput | InventoryLedgerScalarWhereInput[]
  }

  export type InventoryLedgerUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<InventoryLedgerCreateWithoutBatchInput, InventoryLedgerUncheckedCreateWithoutBatchInput> | InventoryLedgerCreateWithoutBatchInput[] | InventoryLedgerUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: InventoryLedgerCreateOrConnectWithoutBatchInput | InventoryLedgerCreateOrConnectWithoutBatchInput[]
    upsert?: InventoryLedgerUpsertWithWhereUniqueWithoutBatchInput | InventoryLedgerUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: InventoryLedgerCreateManyBatchInputEnvelope
    set?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    disconnect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    delete?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    connect?: InventoryLedgerWhereUniqueInput | InventoryLedgerWhereUniqueInput[]
    update?: InventoryLedgerUpdateWithWhereUniqueWithoutBatchInput | InventoryLedgerUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: InventoryLedgerUpdateManyWithWhereWithoutBatchInput | InventoryLedgerUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: InventoryLedgerScalarWhereInput | InventoryLedgerScalarWhereInput[]
  }

  export type ItemCreateNestedOneWithoutInventoryLedgerInput = {
    create?: XOR<ItemCreateWithoutInventoryLedgerInput, ItemUncheckedCreateWithoutInventoryLedgerInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInventoryLedgerInput
    connect?: ItemWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutInventoryLedgerInput = {
    create?: XOR<WarehouseCreateWithoutInventoryLedgerInput, WarehouseUncheckedCreateWithoutInventoryLedgerInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutInventoryLedgerInput
    connect?: WarehouseWhereUniqueInput
  }

  export type InventoryBatchCreateNestedOneWithoutInventoryLedgerInput = {
    create?: XOR<InventoryBatchCreateWithoutInventoryLedgerInput, InventoryBatchUncheckedCreateWithoutInventoryLedgerInput>
    connectOrCreate?: InventoryBatchCreateOrConnectWithoutInventoryLedgerInput
    connect?: InventoryBatchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInventoryLedgerInput = {
    create?: XOR<UserCreateWithoutInventoryLedgerInput, UserUncheckedCreateWithoutInventoryLedgerInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryLedgerInput
    connect?: UserWhereUniqueInput
  }

  export type EnumLedgerDirectionFieldUpdateOperationsInput = {
    set?: $Enums.LedgerDirection
  }

  export type ItemUpdateOneRequiredWithoutInventoryLedgerNestedInput = {
    create?: XOR<ItemCreateWithoutInventoryLedgerInput, ItemUncheckedCreateWithoutInventoryLedgerInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInventoryLedgerInput
    upsert?: ItemUpsertWithoutInventoryLedgerInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutInventoryLedgerInput, ItemUpdateWithoutInventoryLedgerInput>, ItemUncheckedUpdateWithoutInventoryLedgerInput>
  }

  export type WarehouseUpdateOneRequiredWithoutInventoryLedgerNestedInput = {
    create?: XOR<WarehouseCreateWithoutInventoryLedgerInput, WarehouseUncheckedCreateWithoutInventoryLedgerInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutInventoryLedgerInput
    upsert?: WarehouseUpsertWithoutInventoryLedgerInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutInventoryLedgerInput, WarehouseUpdateWithoutInventoryLedgerInput>, WarehouseUncheckedUpdateWithoutInventoryLedgerInput>
  }

  export type InventoryBatchUpdateOneWithoutInventoryLedgerNestedInput = {
    create?: XOR<InventoryBatchCreateWithoutInventoryLedgerInput, InventoryBatchUncheckedCreateWithoutInventoryLedgerInput>
    connectOrCreate?: InventoryBatchCreateOrConnectWithoutInventoryLedgerInput
    upsert?: InventoryBatchUpsertWithoutInventoryLedgerInput
    disconnect?: InventoryBatchWhereInput | boolean
    delete?: InventoryBatchWhereInput | boolean
    connect?: InventoryBatchWhereUniqueInput
    update?: XOR<XOR<InventoryBatchUpdateToOneWithWhereWithoutInventoryLedgerInput, InventoryBatchUpdateWithoutInventoryLedgerInput>, InventoryBatchUncheckedUpdateWithoutInventoryLedgerInput>
  }

  export type UserUpdateOneWithoutInventoryLedgerNestedInput = {
    create?: XOR<UserCreateWithoutInventoryLedgerInput, UserUncheckedCreateWithoutInventoryLedgerInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryLedgerInput
    upsert?: UserUpsertWithoutInventoryLedgerInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryLedgerInput, UserUpdateWithoutInventoryLedgerInput>, UserUncheckedUpdateWithoutInventoryLedgerInput>
  }

  export type ItemCreateNestedOneWithoutProductionOrdersInput = {
    create?: XOR<ItemCreateWithoutProductionOrdersInput, ItemUncheckedCreateWithoutProductionOrdersInput>
    connectOrCreate?: ItemCreateOrConnectWithoutProductionOrdersInput
    connect?: ItemWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutProductionOrdersInput = {
    create?: XOR<WarehouseCreateWithoutProductionOrdersInput, WarehouseUncheckedCreateWithoutProductionOrdersInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutProductionOrdersInput
    connect?: WarehouseWhereUniqueInput
  }

  export type BomCreateNestedOneWithoutProductionOrdersInput = {
    create?: XOR<BomCreateWithoutProductionOrdersInput, BomUncheckedCreateWithoutProductionOrdersInput>
    connectOrCreate?: BomCreateOrConnectWithoutProductionOrdersInput
    connect?: BomWhereUniqueInput
  }

  export type WipLedgerCreateNestedManyWithoutProductionOrderInput = {
    create?: XOR<WipLedgerCreateWithoutProductionOrderInput, WipLedgerUncheckedCreateWithoutProductionOrderInput> | WipLedgerCreateWithoutProductionOrderInput[] | WipLedgerUncheckedCreateWithoutProductionOrderInput[]
    connectOrCreate?: WipLedgerCreateOrConnectWithoutProductionOrderInput | WipLedgerCreateOrConnectWithoutProductionOrderInput[]
    createMany?: WipLedgerCreateManyProductionOrderInputEnvelope
    connect?: WipLedgerWhereUniqueInput | WipLedgerWhereUniqueInput[]
  }

  export type LaborTimeCreateNestedManyWithoutProductionOrderInput = {
    create?: XOR<LaborTimeCreateWithoutProductionOrderInput, LaborTimeUncheckedCreateWithoutProductionOrderInput> | LaborTimeCreateWithoutProductionOrderInput[] | LaborTimeUncheckedCreateWithoutProductionOrderInput[]
    connectOrCreate?: LaborTimeCreateOrConnectWithoutProductionOrderInput | LaborTimeCreateOrConnectWithoutProductionOrderInput[]
    createMany?: LaborTimeCreateManyProductionOrderInputEnvelope
    connect?: LaborTimeWhereUniqueInput | LaborTimeWhereUniqueInput[]
  }

  export type WipLedgerUncheckedCreateNestedManyWithoutProductionOrderInput = {
    create?: XOR<WipLedgerCreateWithoutProductionOrderInput, WipLedgerUncheckedCreateWithoutProductionOrderInput> | WipLedgerCreateWithoutProductionOrderInput[] | WipLedgerUncheckedCreateWithoutProductionOrderInput[]
    connectOrCreate?: WipLedgerCreateOrConnectWithoutProductionOrderInput | WipLedgerCreateOrConnectWithoutProductionOrderInput[]
    createMany?: WipLedgerCreateManyProductionOrderInputEnvelope
    connect?: WipLedgerWhereUniqueInput | WipLedgerWhereUniqueInput[]
  }

  export type LaborTimeUncheckedCreateNestedManyWithoutProductionOrderInput = {
    create?: XOR<LaborTimeCreateWithoutProductionOrderInput, LaborTimeUncheckedCreateWithoutProductionOrderInput> | LaborTimeCreateWithoutProductionOrderInput[] | LaborTimeUncheckedCreateWithoutProductionOrderInput[]
    connectOrCreate?: LaborTimeCreateOrConnectWithoutProductionOrderInput | LaborTimeCreateOrConnectWithoutProductionOrderInput[]
    createMany?: LaborTimeCreateManyProductionOrderInputEnvelope
    connect?: LaborTimeWhereUniqueInput | LaborTimeWhereUniqueInput[]
  }

  export type EnumProductionOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProductionOrderStatus
  }

  export type ItemUpdateOneRequiredWithoutProductionOrdersNestedInput = {
    create?: XOR<ItemCreateWithoutProductionOrdersInput, ItemUncheckedCreateWithoutProductionOrdersInput>
    connectOrCreate?: ItemCreateOrConnectWithoutProductionOrdersInput
    upsert?: ItemUpsertWithoutProductionOrdersInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutProductionOrdersInput, ItemUpdateWithoutProductionOrdersInput>, ItemUncheckedUpdateWithoutProductionOrdersInput>
  }

  export type WarehouseUpdateOneRequiredWithoutProductionOrdersNestedInput = {
    create?: XOR<WarehouseCreateWithoutProductionOrdersInput, WarehouseUncheckedCreateWithoutProductionOrdersInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutProductionOrdersInput
    upsert?: WarehouseUpsertWithoutProductionOrdersInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutProductionOrdersInput, WarehouseUpdateWithoutProductionOrdersInput>, WarehouseUncheckedUpdateWithoutProductionOrdersInput>
  }

  export type BomUpdateOneWithoutProductionOrdersNestedInput = {
    create?: XOR<BomCreateWithoutProductionOrdersInput, BomUncheckedCreateWithoutProductionOrdersInput>
    connectOrCreate?: BomCreateOrConnectWithoutProductionOrdersInput
    upsert?: BomUpsertWithoutProductionOrdersInput
    disconnect?: BomWhereInput | boolean
    delete?: BomWhereInput | boolean
    connect?: BomWhereUniqueInput
    update?: XOR<XOR<BomUpdateToOneWithWhereWithoutProductionOrdersInput, BomUpdateWithoutProductionOrdersInput>, BomUncheckedUpdateWithoutProductionOrdersInput>
  }

  export type WipLedgerUpdateManyWithoutProductionOrderNestedInput = {
    create?: XOR<WipLedgerCreateWithoutProductionOrderInput, WipLedgerUncheckedCreateWithoutProductionOrderInput> | WipLedgerCreateWithoutProductionOrderInput[] | WipLedgerUncheckedCreateWithoutProductionOrderInput[]
    connectOrCreate?: WipLedgerCreateOrConnectWithoutProductionOrderInput | WipLedgerCreateOrConnectWithoutProductionOrderInput[]
    upsert?: WipLedgerUpsertWithWhereUniqueWithoutProductionOrderInput | WipLedgerUpsertWithWhereUniqueWithoutProductionOrderInput[]
    createMany?: WipLedgerCreateManyProductionOrderInputEnvelope
    set?: WipLedgerWhereUniqueInput | WipLedgerWhereUniqueInput[]
    disconnect?: WipLedgerWhereUniqueInput | WipLedgerWhereUniqueInput[]
    delete?: WipLedgerWhereUniqueInput | WipLedgerWhereUniqueInput[]
    connect?: WipLedgerWhereUniqueInput | WipLedgerWhereUniqueInput[]
    update?: WipLedgerUpdateWithWhereUniqueWithoutProductionOrderInput | WipLedgerUpdateWithWhereUniqueWithoutProductionOrderInput[]
    updateMany?: WipLedgerUpdateManyWithWhereWithoutProductionOrderInput | WipLedgerUpdateManyWithWhereWithoutProductionOrderInput[]
    deleteMany?: WipLedgerScalarWhereInput | WipLedgerScalarWhereInput[]
  }

  export type LaborTimeUpdateManyWithoutProductionOrderNestedInput = {
    create?: XOR<LaborTimeCreateWithoutProductionOrderInput, LaborTimeUncheckedCreateWithoutProductionOrderInput> | LaborTimeCreateWithoutProductionOrderInput[] | LaborTimeUncheckedCreateWithoutProductionOrderInput[]
    connectOrCreate?: LaborTimeCreateOrConnectWithoutProductionOrderInput | LaborTimeCreateOrConnectWithoutProductionOrderInput[]
    upsert?: LaborTimeUpsertWithWhereUniqueWithoutProductionOrderInput | LaborTimeUpsertWithWhereUniqueWithoutProductionOrderInput[]
    createMany?: LaborTimeCreateManyProductionOrderInputEnvelope
    set?: LaborTimeWhereUniqueInput | LaborTimeWhereUniqueInput[]
    disconnect?: LaborTimeWhereUniqueInput | LaborTimeWhereUniqueInput[]
    delete?: LaborTimeWhereUniqueInput | LaborTimeWhereUniqueInput[]
    connect?: LaborTimeWhereUniqueInput | LaborTimeWhereUniqueInput[]
    update?: LaborTimeUpdateWithWhereUniqueWithoutProductionOrderInput | LaborTimeUpdateWithWhereUniqueWithoutProductionOrderInput[]
    updateMany?: LaborTimeUpdateManyWithWhereWithoutProductionOrderInput | LaborTimeUpdateManyWithWhereWithoutProductionOrderInput[]
    deleteMany?: LaborTimeScalarWhereInput | LaborTimeScalarWhereInput[]
  }

  export type WipLedgerUncheckedUpdateManyWithoutProductionOrderNestedInput = {
    create?: XOR<WipLedgerCreateWithoutProductionOrderInput, WipLedgerUncheckedCreateWithoutProductionOrderInput> | WipLedgerCreateWithoutProductionOrderInput[] | WipLedgerUncheckedCreateWithoutProductionOrderInput[]
    connectOrCreate?: WipLedgerCreateOrConnectWithoutProductionOrderInput | WipLedgerCreateOrConnectWithoutProductionOrderInput[]
    upsert?: WipLedgerUpsertWithWhereUniqueWithoutProductionOrderInput | WipLedgerUpsertWithWhereUniqueWithoutProductionOrderInput[]
    createMany?: WipLedgerCreateManyProductionOrderInputEnvelope
    set?: WipLedgerWhereUniqueInput | WipLedgerWhereUniqueInput[]
    disconnect?: WipLedgerWhereUniqueInput | WipLedgerWhereUniqueInput[]
    delete?: WipLedgerWhereUniqueInput | WipLedgerWhereUniqueInput[]
    connect?: WipLedgerWhereUniqueInput | WipLedgerWhereUniqueInput[]
    update?: WipLedgerUpdateWithWhereUniqueWithoutProductionOrderInput | WipLedgerUpdateWithWhereUniqueWithoutProductionOrderInput[]
    updateMany?: WipLedgerUpdateManyWithWhereWithoutProductionOrderInput | WipLedgerUpdateManyWithWhereWithoutProductionOrderInput[]
    deleteMany?: WipLedgerScalarWhereInput | WipLedgerScalarWhereInput[]
  }

  export type LaborTimeUncheckedUpdateManyWithoutProductionOrderNestedInput = {
    create?: XOR<LaborTimeCreateWithoutProductionOrderInput, LaborTimeUncheckedCreateWithoutProductionOrderInput> | LaborTimeCreateWithoutProductionOrderInput[] | LaborTimeUncheckedCreateWithoutProductionOrderInput[]
    connectOrCreate?: LaborTimeCreateOrConnectWithoutProductionOrderInput | LaborTimeCreateOrConnectWithoutProductionOrderInput[]
    upsert?: LaborTimeUpsertWithWhereUniqueWithoutProductionOrderInput | LaborTimeUpsertWithWhereUniqueWithoutProductionOrderInput[]
    createMany?: LaborTimeCreateManyProductionOrderInputEnvelope
    set?: LaborTimeWhereUniqueInput | LaborTimeWhereUniqueInput[]
    disconnect?: LaborTimeWhereUniqueInput | LaborTimeWhereUniqueInput[]
    delete?: LaborTimeWhereUniqueInput | LaborTimeWhereUniqueInput[]
    connect?: LaborTimeWhereUniqueInput | LaborTimeWhereUniqueInput[]
    update?: LaborTimeUpdateWithWhereUniqueWithoutProductionOrderInput | LaborTimeUpdateWithWhereUniqueWithoutProductionOrderInput[]
    updateMany?: LaborTimeUpdateManyWithWhereWithoutProductionOrderInput | LaborTimeUpdateManyWithWhereWithoutProductionOrderInput[]
    deleteMany?: LaborTimeScalarWhereInput | LaborTimeScalarWhereInput[]
  }

  export type ProductionOrderCreateNestedOneWithoutWipLedgerInput = {
    create?: XOR<ProductionOrderCreateWithoutWipLedgerInput, ProductionOrderUncheckedCreateWithoutWipLedgerInput>
    connectOrCreate?: ProductionOrderCreateOrConnectWithoutWipLedgerInput
    connect?: ProductionOrderWhereUniqueInput
  }

  export type EnumWipLedgerTypeFieldUpdateOperationsInput = {
    set?: $Enums.WipLedgerType
  }

  export type ProductionOrderUpdateOneRequiredWithoutWipLedgerNestedInput = {
    create?: XOR<ProductionOrderCreateWithoutWipLedgerInput, ProductionOrderUncheckedCreateWithoutWipLedgerInput>
    connectOrCreate?: ProductionOrderCreateOrConnectWithoutWipLedgerInput
    upsert?: ProductionOrderUpsertWithoutWipLedgerInput
    connect?: ProductionOrderWhereUniqueInput
    update?: XOR<XOR<ProductionOrderUpdateToOneWithWhereWithoutWipLedgerInput, ProductionOrderUpdateWithoutWipLedgerInput>, ProductionOrderUncheckedUpdateWithoutWipLedgerInput>
  }

  export type ProductionOrderCreateNestedOneWithoutLaborTimesInput = {
    create?: XOR<ProductionOrderCreateWithoutLaborTimesInput, ProductionOrderUncheckedCreateWithoutLaborTimesInput>
    connectOrCreate?: ProductionOrderCreateOrConnectWithoutLaborTimesInput
    connect?: ProductionOrderWhereUniqueInput
  }

  export type ProductionOrderUpdateOneRequiredWithoutLaborTimesNestedInput = {
    create?: XOR<ProductionOrderCreateWithoutLaborTimesInput, ProductionOrderUncheckedCreateWithoutLaborTimesInput>
    connectOrCreate?: ProductionOrderCreateOrConnectWithoutLaborTimesInput
    upsert?: ProductionOrderUpsertWithoutLaborTimesInput
    connect?: ProductionOrderWhereUniqueInput
    update?: XOR<XOR<ProductionOrderUpdateToOneWithWhereWithoutLaborTimesInput, ProductionOrderUpdateWithoutLaborTimesInput>, ProductionOrderUncheckedUpdateWithoutLaborTimesInput>
  }

  export type PurchaseCreateNestedManyWithoutVendorInput = {
    create?: XOR<PurchaseCreateWithoutVendorInput, PurchaseUncheckedCreateWithoutVendorInput> | PurchaseCreateWithoutVendorInput[] | PurchaseUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutVendorInput | PurchaseCreateOrConnectWithoutVendorInput[]
    createMany?: PurchaseCreateManyVendorInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type PurchasePaymentCreateNestedManyWithoutVendorInput = {
    create?: XOR<PurchasePaymentCreateWithoutVendorInput, PurchasePaymentUncheckedCreateWithoutVendorInput> | PurchasePaymentCreateWithoutVendorInput[] | PurchasePaymentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchasePaymentCreateOrConnectWithoutVendorInput | PurchasePaymentCreateOrConnectWithoutVendorInput[]
    createMany?: PurchasePaymentCreateManyVendorInputEnvelope
    connect?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
  }

  export type AssetCreateNestedManyWithoutVendorInput = {
    create?: XOR<AssetCreateWithoutVendorInput, AssetUncheckedCreateWithoutVendorInput> | AssetCreateWithoutVendorInput[] | AssetUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutVendorInput | AssetCreateOrConnectWithoutVendorInput[]
    createMany?: AssetCreateManyVendorInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<PurchaseCreateWithoutVendorInput, PurchaseUncheckedCreateWithoutVendorInput> | PurchaseCreateWithoutVendorInput[] | PurchaseUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutVendorInput | PurchaseCreateOrConnectWithoutVendorInput[]
    createMany?: PurchaseCreateManyVendorInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type PurchasePaymentUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<PurchasePaymentCreateWithoutVendorInput, PurchasePaymentUncheckedCreateWithoutVendorInput> | PurchasePaymentCreateWithoutVendorInput[] | PurchasePaymentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchasePaymentCreateOrConnectWithoutVendorInput | PurchasePaymentCreateOrConnectWithoutVendorInput[]
    createMany?: PurchasePaymentCreateManyVendorInputEnvelope
    connect?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<AssetCreateWithoutVendorInput, AssetUncheckedCreateWithoutVendorInput> | AssetCreateWithoutVendorInput[] | AssetUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutVendorInput | AssetCreateOrConnectWithoutVendorInput[]
    createMany?: AssetCreateManyVendorInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type PurchaseUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PurchaseCreateWithoutVendorInput, PurchaseUncheckedCreateWithoutVendorInput> | PurchaseCreateWithoutVendorInput[] | PurchaseUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutVendorInput | PurchaseCreateOrConnectWithoutVendorInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutVendorInput | PurchaseUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PurchaseCreateManyVendorInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutVendorInput | PurchaseUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutVendorInput | PurchaseUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type PurchasePaymentUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PurchasePaymentCreateWithoutVendorInput, PurchasePaymentUncheckedCreateWithoutVendorInput> | PurchasePaymentCreateWithoutVendorInput[] | PurchasePaymentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchasePaymentCreateOrConnectWithoutVendorInput | PurchasePaymentCreateOrConnectWithoutVendorInput[]
    upsert?: PurchasePaymentUpsertWithWhereUniqueWithoutVendorInput | PurchasePaymentUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PurchasePaymentCreateManyVendorInputEnvelope
    set?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    disconnect?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    delete?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    connect?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    update?: PurchasePaymentUpdateWithWhereUniqueWithoutVendorInput | PurchasePaymentUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PurchasePaymentUpdateManyWithWhereWithoutVendorInput | PurchasePaymentUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PurchasePaymentScalarWhereInput | PurchasePaymentScalarWhereInput[]
  }

  export type AssetUpdateManyWithoutVendorNestedInput = {
    create?: XOR<AssetCreateWithoutVendorInput, AssetUncheckedCreateWithoutVendorInput> | AssetCreateWithoutVendorInput[] | AssetUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutVendorInput | AssetCreateOrConnectWithoutVendorInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutVendorInput | AssetUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: AssetCreateManyVendorInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutVendorInput | AssetUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutVendorInput | AssetUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PurchaseCreateWithoutVendorInput, PurchaseUncheckedCreateWithoutVendorInput> | PurchaseCreateWithoutVendorInput[] | PurchaseUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutVendorInput | PurchaseCreateOrConnectWithoutVendorInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutVendorInput | PurchaseUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PurchaseCreateManyVendorInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutVendorInput | PurchaseUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutVendorInput | PurchaseUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type PurchasePaymentUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PurchasePaymentCreateWithoutVendorInput, PurchasePaymentUncheckedCreateWithoutVendorInput> | PurchasePaymentCreateWithoutVendorInput[] | PurchasePaymentUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchasePaymentCreateOrConnectWithoutVendorInput | PurchasePaymentCreateOrConnectWithoutVendorInput[]
    upsert?: PurchasePaymentUpsertWithWhereUniqueWithoutVendorInput | PurchasePaymentUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PurchasePaymentCreateManyVendorInputEnvelope
    set?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    disconnect?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    delete?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    connect?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    update?: PurchasePaymentUpdateWithWhereUniqueWithoutVendorInput | PurchasePaymentUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PurchasePaymentUpdateManyWithWhereWithoutVendorInput | PurchasePaymentUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PurchasePaymentScalarWhereInput | PurchasePaymentScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<AssetCreateWithoutVendorInput, AssetUncheckedCreateWithoutVendorInput> | AssetCreateWithoutVendorInput[] | AssetUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutVendorInput | AssetCreateOrConnectWithoutVendorInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutVendorInput | AssetUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: AssetCreateManyVendorInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutVendorInput | AssetUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutVendorInput | AssetUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type SaleCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type SalesReceiptCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SalesReceiptCreateWithoutCustomerInput, SalesReceiptUncheckedCreateWithoutCustomerInput> | SalesReceiptCreateWithoutCustomerInput[] | SalesReceiptUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesReceiptCreateOrConnectWithoutCustomerInput | SalesReceiptCreateOrConnectWithoutCustomerInput[]
    createMany?: SalesReceiptCreateManyCustomerInputEnvelope
    connect?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type SalesReceiptUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SalesReceiptCreateWithoutCustomerInput, SalesReceiptUncheckedCreateWithoutCustomerInput> | SalesReceiptCreateWithoutCustomerInput[] | SalesReceiptUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesReceiptCreateOrConnectWithoutCustomerInput | SalesReceiptCreateOrConnectWithoutCustomerInput[]
    createMany?: SalesReceiptCreateManyCustomerInputEnvelope
    connect?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
  }

  export type SaleUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutCustomerInput | SaleUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutCustomerInput | SaleUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutCustomerInput | SaleUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type SalesReceiptUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SalesReceiptCreateWithoutCustomerInput, SalesReceiptUncheckedCreateWithoutCustomerInput> | SalesReceiptCreateWithoutCustomerInput[] | SalesReceiptUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesReceiptCreateOrConnectWithoutCustomerInput | SalesReceiptCreateOrConnectWithoutCustomerInput[]
    upsert?: SalesReceiptUpsertWithWhereUniqueWithoutCustomerInput | SalesReceiptUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SalesReceiptCreateManyCustomerInputEnvelope
    set?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    disconnect?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    delete?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    connect?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    update?: SalesReceiptUpdateWithWhereUniqueWithoutCustomerInput | SalesReceiptUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SalesReceiptUpdateManyWithWhereWithoutCustomerInput | SalesReceiptUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SalesReceiptScalarWhereInput | SalesReceiptScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutCustomerInput | SaleUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutCustomerInput | SaleUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutCustomerInput | SaleUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type SalesReceiptUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SalesReceiptCreateWithoutCustomerInput, SalesReceiptUncheckedCreateWithoutCustomerInput> | SalesReceiptCreateWithoutCustomerInput[] | SalesReceiptUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesReceiptCreateOrConnectWithoutCustomerInput | SalesReceiptCreateOrConnectWithoutCustomerInput[]
    upsert?: SalesReceiptUpsertWithWhereUniqueWithoutCustomerInput | SalesReceiptUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SalesReceiptCreateManyCustomerInputEnvelope
    set?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    disconnect?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    delete?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    connect?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    update?: SalesReceiptUpdateWithWhereUniqueWithoutCustomerInput | SalesReceiptUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SalesReceiptUpdateManyWithWhereWithoutCustomerInput | SalesReceiptUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SalesReceiptScalarWhereInput | SalesReceiptScalarWhereInput[]
  }

  export type VendorCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<VendorCreateWithoutPurchasesInput, VendorUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPurchasesInput
    connect?: VendorWhereUniqueInput
  }

  export type PurchaseLineCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<PurchaseLineCreateWithoutPurchaseInput, PurchaseLineUncheckedCreateWithoutPurchaseInput> | PurchaseLineCreateWithoutPurchaseInput[] | PurchaseLineUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseLineCreateOrConnectWithoutPurchaseInput | PurchaseLineCreateOrConnectWithoutPurchaseInput[]
    createMany?: PurchaseLineCreateManyPurchaseInputEnvelope
    connect?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
  }

  export type PurchasePaymentCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<PurchasePaymentCreateWithoutPurchaseInput, PurchasePaymentUncheckedCreateWithoutPurchaseInput> | PurchasePaymentCreateWithoutPurchaseInput[] | PurchasePaymentUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchasePaymentCreateOrConnectWithoutPurchaseInput | PurchasePaymentCreateOrConnectWithoutPurchaseInput[]
    createMany?: PurchasePaymentCreateManyPurchaseInputEnvelope
    connect?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
  }

  export type AssetCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<AssetCreateWithoutPurchaseOrderInput, AssetUncheckedCreateWithoutPurchaseOrderInput> | AssetCreateWithoutPurchaseOrderInput[] | AssetUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutPurchaseOrderInput | AssetCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: AssetCreateManyPurchaseOrderInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type PurchaseLineUncheckedCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<PurchaseLineCreateWithoutPurchaseInput, PurchaseLineUncheckedCreateWithoutPurchaseInput> | PurchaseLineCreateWithoutPurchaseInput[] | PurchaseLineUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseLineCreateOrConnectWithoutPurchaseInput | PurchaseLineCreateOrConnectWithoutPurchaseInput[]
    createMany?: PurchaseLineCreateManyPurchaseInputEnvelope
    connect?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
  }

  export type PurchasePaymentUncheckedCreateNestedManyWithoutPurchaseInput = {
    create?: XOR<PurchasePaymentCreateWithoutPurchaseInput, PurchasePaymentUncheckedCreateWithoutPurchaseInput> | PurchasePaymentCreateWithoutPurchaseInput[] | PurchasePaymentUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchasePaymentCreateOrConnectWithoutPurchaseInput | PurchasePaymentCreateOrConnectWithoutPurchaseInput[]
    createMany?: PurchasePaymentCreateManyPurchaseInputEnvelope
    connect?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<AssetCreateWithoutPurchaseOrderInput, AssetUncheckedCreateWithoutPurchaseOrderInput> | AssetCreateWithoutPurchaseOrderInput[] | AssetUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutPurchaseOrderInput | AssetCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: AssetCreateManyPurchaseOrderInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type EnumPurchaseStatusFieldUpdateOperationsInput = {
    set?: $Enums.PurchaseStatus
  }

  export type VendorUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<VendorCreateWithoutPurchasesInput, VendorUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPurchasesInput
    upsert?: VendorUpsertWithoutPurchasesInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutPurchasesInput, VendorUpdateWithoutPurchasesInput>, VendorUncheckedUpdateWithoutPurchasesInput>
  }

  export type PurchaseLineUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<PurchaseLineCreateWithoutPurchaseInput, PurchaseLineUncheckedCreateWithoutPurchaseInput> | PurchaseLineCreateWithoutPurchaseInput[] | PurchaseLineUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseLineCreateOrConnectWithoutPurchaseInput | PurchaseLineCreateOrConnectWithoutPurchaseInput[]
    upsert?: PurchaseLineUpsertWithWhereUniqueWithoutPurchaseInput | PurchaseLineUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: PurchaseLineCreateManyPurchaseInputEnvelope
    set?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    disconnect?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    delete?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    connect?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    update?: PurchaseLineUpdateWithWhereUniqueWithoutPurchaseInput | PurchaseLineUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: PurchaseLineUpdateManyWithWhereWithoutPurchaseInput | PurchaseLineUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: PurchaseLineScalarWhereInput | PurchaseLineScalarWhereInput[]
  }

  export type PurchasePaymentUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<PurchasePaymentCreateWithoutPurchaseInput, PurchasePaymentUncheckedCreateWithoutPurchaseInput> | PurchasePaymentCreateWithoutPurchaseInput[] | PurchasePaymentUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchasePaymentCreateOrConnectWithoutPurchaseInput | PurchasePaymentCreateOrConnectWithoutPurchaseInput[]
    upsert?: PurchasePaymentUpsertWithWhereUniqueWithoutPurchaseInput | PurchasePaymentUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: PurchasePaymentCreateManyPurchaseInputEnvelope
    set?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    disconnect?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    delete?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    connect?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    update?: PurchasePaymentUpdateWithWhereUniqueWithoutPurchaseInput | PurchasePaymentUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: PurchasePaymentUpdateManyWithWhereWithoutPurchaseInput | PurchasePaymentUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: PurchasePaymentScalarWhereInput | PurchasePaymentScalarWhereInput[]
  }

  export type AssetUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<AssetCreateWithoutPurchaseOrderInput, AssetUncheckedCreateWithoutPurchaseOrderInput> | AssetCreateWithoutPurchaseOrderInput[] | AssetUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutPurchaseOrderInput | AssetCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutPurchaseOrderInput | AssetUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: AssetCreateManyPurchaseOrderInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutPurchaseOrderInput | AssetUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutPurchaseOrderInput | AssetUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type PurchaseLineUncheckedUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<PurchaseLineCreateWithoutPurchaseInput, PurchaseLineUncheckedCreateWithoutPurchaseInput> | PurchaseLineCreateWithoutPurchaseInput[] | PurchaseLineUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchaseLineCreateOrConnectWithoutPurchaseInput | PurchaseLineCreateOrConnectWithoutPurchaseInput[]
    upsert?: PurchaseLineUpsertWithWhereUniqueWithoutPurchaseInput | PurchaseLineUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: PurchaseLineCreateManyPurchaseInputEnvelope
    set?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    disconnect?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    delete?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    connect?: PurchaseLineWhereUniqueInput | PurchaseLineWhereUniqueInput[]
    update?: PurchaseLineUpdateWithWhereUniqueWithoutPurchaseInput | PurchaseLineUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: PurchaseLineUpdateManyWithWhereWithoutPurchaseInput | PurchaseLineUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: PurchaseLineScalarWhereInput | PurchaseLineScalarWhereInput[]
  }

  export type PurchasePaymentUncheckedUpdateManyWithoutPurchaseNestedInput = {
    create?: XOR<PurchasePaymentCreateWithoutPurchaseInput, PurchasePaymentUncheckedCreateWithoutPurchaseInput> | PurchasePaymentCreateWithoutPurchaseInput[] | PurchasePaymentUncheckedCreateWithoutPurchaseInput[]
    connectOrCreate?: PurchasePaymentCreateOrConnectWithoutPurchaseInput | PurchasePaymentCreateOrConnectWithoutPurchaseInput[]
    upsert?: PurchasePaymentUpsertWithWhereUniqueWithoutPurchaseInput | PurchasePaymentUpsertWithWhereUniqueWithoutPurchaseInput[]
    createMany?: PurchasePaymentCreateManyPurchaseInputEnvelope
    set?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    disconnect?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    delete?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    connect?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    update?: PurchasePaymentUpdateWithWhereUniqueWithoutPurchaseInput | PurchasePaymentUpdateWithWhereUniqueWithoutPurchaseInput[]
    updateMany?: PurchasePaymentUpdateManyWithWhereWithoutPurchaseInput | PurchasePaymentUpdateManyWithWhereWithoutPurchaseInput[]
    deleteMany?: PurchasePaymentScalarWhereInput | PurchasePaymentScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<AssetCreateWithoutPurchaseOrderInput, AssetUncheckedCreateWithoutPurchaseOrderInput> | AssetCreateWithoutPurchaseOrderInput[] | AssetUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutPurchaseOrderInput | AssetCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutPurchaseOrderInput | AssetUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: AssetCreateManyPurchaseOrderInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutPurchaseOrderInput | AssetUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutPurchaseOrderInput | AssetUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type PurchaseCreateNestedOneWithoutPurchaseLinesInput = {
    create?: XOR<PurchaseCreateWithoutPurchaseLinesInput, PurchaseUncheckedCreateWithoutPurchaseLinesInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutPurchaseLinesInput
    connect?: PurchaseWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutPurchaseLinesInput = {
    create?: XOR<ItemCreateWithoutPurchaseLinesInput, ItemUncheckedCreateWithoutPurchaseLinesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutPurchaseLinesInput
    connect?: ItemWhereUniqueInput
  }

  export type PurchaseUpdateOneRequiredWithoutPurchaseLinesNestedInput = {
    create?: XOR<PurchaseCreateWithoutPurchaseLinesInput, PurchaseUncheckedCreateWithoutPurchaseLinesInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutPurchaseLinesInput
    upsert?: PurchaseUpsertWithoutPurchaseLinesInput
    connect?: PurchaseWhereUniqueInput
    update?: XOR<XOR<PurchaseUpdateToOneWithWhereWithoutPurchaseLinesInput, PurchaseUpdateWithoutPurchaseLinesInput>, PurchaseUncheckedUpdateWithoutPurchaseLinesInput>
  }

  export type ItemUpdateOneRequiredWithoutPurchaseLinesNestedInput = {
    create?: XOR<ItemCreateWithoutPurchaseLinesInput, ItemUncheckedCreateWithoutPurchaseLinesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutPurchaseLinesInput
    upsert?: ItemUpsertWithoutPurchaseLinesInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutPurchaseLinesInput, ItemUpdateWithoutPurchaseLinesInput>, ItemUncheckedUpdateWithoutPurchaseLinesInput>
  }

  export type CustomerCreateNestedOneWithoutSalesInput = {
    create?: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesInput
    connect?: CustomerWhereUniqueInput
  }

  export type SaleLineCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleLineCreateWithoutSaleInput, SaleLineUncheckedCreateWithoutSaleInput> | SaleLineCreateWithoutSaleInput[] | SaleLineUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleLineCreateOrConnectWithoutSaleInput | SaleLineCreateOrConnectWithoutSaleInput[]
    createMany?: SaleLineCreateManySaleInputEnvelope
    connect?: SaleLineWhereUniqueInput | SaleLineWhereUniqueInput[]
  }

  export type SalesReceiptCreateNestedManyWithoutSaleInput = {
    create?: XOR<SalesReceiptCreateWithoutSaleInput, SalesReceiptUncheckedCreateWithoutSaleInput> | SalesReceiptCreateWithoutSaleInput[] | SalesReceiptUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SalesReceiptCreateOrConnectWithoutSaleInput | SalesReceiptCreateOrConnectWithoutSaleInput[]
    createMany?: SalesReceiptCreateManySaleInputEnvelope
    connect?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
  }

  export type SaleLineUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleLineCreateWithoutSaleInput, SaleLineUncheckedCreateWithoutSaleInput> | SaleLineCreateWithoutSaleInput[] | SaleLineUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleLineCreateOrConnectWithoutSaleInput | SaleLineCreateOrConnectWithoutSaleInput[]
    createMany?: SaleLineCreateManySaleInputEnvelope
    connect?: SaleLineWhereUniqueInput | SaleLineWhereUniqueInput[]
  }

  export type SalesReceiptUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<SalesReceiptCreateWithoutSaleInput, SalesReceiptUncheckedCreateWithoutSaleInput> | SalesReceiptCreateWithoutSaleInput[] | SalesReceiptUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SalesReceiptCreateOrConnectWithoutSaleInput | SalesReceiptCreateOrConnectWithoutSaleInput[]
    createMany?: SalesReceiptCreateManySaleInputEnvelope
    connect?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
  }

  export type EnumSaleStatusFieldUpdateOperationsInput = {
    set?: $Enums.SaleStatus
  }

  export type CustomerUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesInput
    upsert?: CustomerUpsertWithoutSalesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSalesInput, CustomerUpdateWithoutSalesInput>, CustomerUncheckedUpdateWithoutSalesInput>
  }

  export type SaleLineUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleLineCreateWithoutSaleInput, SaleLineUncheckedCreateWithoutSaleInput> | SaleLineCreateWithoutSaleInput[] | SaleLineUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleLineCreateOrConnectWithoutSaleInput | SaleLineCreateOrConnectWithoutSaleInput[]
    upsert?: SaleLineUpsertWithWhereUniqueWithoutSaleInput | SaleLineUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleLineCreateManySaleInputEnvelope
    set?: SaleLineWhereUniqueInput | SaleLineWhereUniqueInput[]
    disconnect?: SaleLineWhereUniqueInput | SaleLineWhereUniqueInput[]
    delete?: SaleLineWhereUniqueInput | SaleLineWhereUniqueInput[]
    connect?: SaleLineWhereUniqueInput | SaleLineWhereUniqueInput[]
    update?: SaleLineUpdateWithWhereUniqueWithoutSaleInput | SaleLineUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleLineUpdateManyWithWhereWithoutSaleInput | SaleLineUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleLineScalarWhereInput | SaleLineScalarWhereInput[]
  }

  export type SalesReceiptUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SalesReceiptCreateWithoutSaleInput, SalesReceiptUncheckedCreateWithoutSaleInput> | SalesReceiptCreateWithoutSaleInput[] | SalesReceiptUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SalesReceiptCreateOrConnectWithoutSaleInput | SalesReceiptCreateOrConnectWithoutSaleInput[]
    upsert?: SalesReceiptUpsertWithWhereUniqueWithoutSaleInput | SalesReceiptUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SalesReceiptCreateManySaleInputEnvelope
    set?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    disconnect?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    delete?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    connect?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    update?: SalesReceiptUpdateWithWhereUniqueWithoutSaleInput | SalesReceiptUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SalesReceiptUpdateManyWithWhereWithoutSaleInput | SalesReceiptUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SalesReceiptScalarWhereInput | SalesReceiptScalarWhereInput[]
  }

  export type SaleLineUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleLineCreateWithoutSaleInput, SaleLineUncheckedCreateWithoutSaleInput> | SaleLineCreateWithoutSaleInput[] | SaleLineUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleLineCreateOrConnectWithoutSaleInput | SaleLineCreateOrConnectWithoutSaleInput[]
    upsert?: SaleLineUpsertWithWhereUniqueWithoutSaleInput | SaleLineUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleLineCreateManySaleInputEnvelope
    set?: SaleLineWhereUniqueInput | SaleLineWhereUniqueInput[]
    disconnect?: SaleLineWhereUniqueInput | SaleLineWhereUniqueInput[]
    delete?: SaleLineWhereUniqueInput | SaleLineWhereUniqueInput[]
    connect?: SaleLineWhereUniqueInput | SaleLineWhereUniqueInput[]
    update?: SaleLineUpdateWithWhereUniqueWithoutSaleInput | SaleLineUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleLineUpdateManyWithWhereWithoutSaleInput | SaleLineUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleLineScalarWhereInput | SaleLineScalarWhereInput[]
  }

  export type SalesReceiptUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SalesReceiptCreateWithoutSaleInput, SalesReceiptUncheckedCreateWithoutSaleInput> | SalesReceiptCreateWithoutSaleInput[] | SalesReceiptUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SalesReceiptCreateOrConnectWithoutSaleInput | SalesReceiptCreateOrConnectWithoutSaleInput[]
    upsert?: SalesReceiptUpsertWithWhereUniqueWithoutSaleInput | SalesReceiptUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SalesReceiptCreateManySaleInputEnvelope
    set?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    disconnect?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    delete?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    connect?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    update?: SalesReceiptUpdateWithWhereUniqueWithoutSaleInput | SalesReceiptUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SalesReceiptUpdateManyWithWhereWithoutSaleInput | SalesReceiptUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SalesReceiptScalarWhereInput | SalesReceiptScalarWhereInput[]
  }

  export type SaleCreateNestedOneWithoutSaleLinesInput = {
    create?: XOR<SaleCreateWithoutSaleLinesInput, SaleUncheckedCreateWithoutSaleLinesInput>
    connectOrCreate?: SaleCreateOrConnectWithoutSaleLinesInput
    connect?: SaleWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutSaleLinesInput = {
    create?: XOR<ItemCreateWithoutSaleLinesInput, ItemUncheckedCreateWithoutSaleLinesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutSaleLinesInput
    connect?: ItemWhereUniqueInput
  }

  export type SaleUpdateOneRequiredWithoutSaleLinesNestedInput = {
    create?: XOR<SaleCreateWithoutSaleLinesInput, SaleUncheckedCreateWithoutSaleLinesInput>
    connectOrCreate?: SaleCreateOrConnectWithoutSaleLinesInput
    upsert?: SaleUpsertWithoutSaleLinesInput
    connect?: SaleWhereUniqueInput
    update?: XOR<XOR<SaleUpdateToOneWithWhereWithoutSaleLinesInput, SaleUpdateWithoutSaleLinesInput>, SaleUncheckedUpdateWithoutSaleLinesInput>
  }

  export type ItemUpdateOneRequiredWithoutSaleLinesNestedInput = {
    create?: XOR<ItemCreateWithoutSaleLinesInput, ItemUncheckedCreateWithoutSaleLinesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutSaleLinesInput
    upsert?: ItemUpsertWithoutSaleLinesInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutSaleLinesInput, ItemUpdateWithoutSaleLinesInput>, ItemUncheckedUpdateWithoutSaleLinesInput>
  }

  export type ChartOfAccountCreateNestedOneWithoutChildrenInput = {
    create?: XOR<ChartOfAccountCreateWithoutChildrenInput, ChartOfAccountUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutChildrenInput
    connect?: ChartOfAccountWhereUniqueInput
  }

  export type ChartOfAccountCreateNestedManyWithoutParentInput = {
    create?: XOR<ChartOfAccountCreateWithoutParentInput, ChartOfAccountUncheckedCreateWithoutParentInput> | ChartOfAccountCreateWithoutParentInput[] | ChartOfAccountUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutParentInput | ChartOfAccountCreateOrConnectWithoutParentInput[]
    createMany?: ChartOfAccountCreateManyParentInputEnvelope
    connect?: ChartOfAccountWhereUniqueInput | ChartOfAccountWhereUniqueInput[]
  }

  export type JournalLineCreateNestedManyWithoutAccountInput = {
    create?: XOR<JournalLineCreateWithoutAccountInput, JournalLineUncheckedCreateWithoutAccountInput> | JournalLineCreateWithoutAccountInput[] | JournalLineUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutAccountInput | JournalLineCreateOrConnectWithoutAccountInput[]
    createMany?: JournalLineCreateManyAccountInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type CashTransactionCreateNestedManyWithoutGlAccountInput = {
    create?: XOR<CashTransactionCreateWithoutGlAccountInput, CashTransactionUncheckedCreateWithoutGlAccountInput> | CashTransactionCreateWithoutGlAccountInput[] | CashTransactionUncheckedCreateWithoutGlAccountInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutGlAccountInput | CashTransactionCreateOrConnectWithoutGlAccountInput[]
    createMany?: CashTransactionCreateManyGlAccountInputEnvelope
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
  }

  export type CashTransactionCreateNestedManyWithoutContraAccountInput = {
    create?: XOR<CashTransactionCreateWithoutContraAccountInput, CashTransactionUncheckedCreateWithoutContraAccountInput> | CashTransactionCreateWithoutContraAccountInput[] | CashTransactionUncheckedCreateWithoutContraAccountInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutContraAccountInput | CashTransactionCreateOrConnectWithoutContraAccountInput[]
    createMany?: CashTransactionCreateManyContraAccountInputEnvelope
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
  }

  export type CashAccountCreateNestedManyWithoutChartOfAccountInput = {
    create?: XOR<CashAccountCreateWithoutChartOfAccountInput, CashAccountUncheckedCreateWithoutChartOfAccountInput> | CashAccountCreateWithoutChartOfAccountInput[] | CashAccountUncheckedCreateWithoutChartOfAccountInput[]
    connectOrCreate?: CashAccountCreateOrConnectWithoutChartOfAccountInput | CashAccountCreateOrConnectWithoutChartOfAccountInput[]
    createMany?: CashAccountCreateManyChartOfAccountInputEnvelope
    connect?: CashAccountWhereUniqueInput | CashAccountWhereUniqueInput[]
  }

  export type AssetCategoryCreateNestedManyWithoutGlAssetAccountInput = {
    create?: XOR<AssetCategoryCreateWithoutGlAssetAccountInput, AssetCategoryUncheckedCreateWithoutGlAssetAccountInput> | AssetCategoryCreateWithoutGlAssetAccountInput[] | AssetCategoryUncheckedCreateWithoutGlAssetAccountInput[]
    connectOrCreate?: AssetCategoryCreateOrConnectWithoutGlAssetAccountInput | AssetCategoryCreateOrConnectWithoutGlAssetAccountInput[]
    createMany?: AssetCategoryCreateManyGlAssetAccountInputEnvelope
    connect?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
  }

  export type AssetCategoryCreateNestedManyWithoutGlDepreciationAccountInput = {
    create?: XOR<AssetCategoryCreateWithoutGlDepreciationAccountInput, AssetCategoryUncheckedCreateWithoutGlDepreciationAccountInput> | AssetCategoryCreateWithoutGlDepreciationAccountInput[] | AssetCategoryUncheckedCreateWithoutGlDepreciationAccountInput[]
    connectOrCreate?: AssetCategoryCreateOrConnectWithoutGlDepreciationAccountInput | AssetCategoryCreateOrConnectWithoutGlDepreciationAccountInput[]
    createMany?: AssetCategoryCreateManyGlDepreciationAccountInputEnvelope
    connect?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
  }

  export type AssetCategoryCreateNestedManyWithoutGlAccumulatedDepreciationAccountInput = {
    create?: XOR<AssetCategoryCreateWithoutGlAccumulatedDepreciationAccountInput, AssetCategoryUncheckedCreateWithoutGlAccumulatedDepreciationAccountInput> | AssetCategoryCreateWithoutGlAccumulatedDepreciationAccountInput[] | AssetCategoryUncheckedCreateWithoutGlAccumulatedDepreciationAccountInput[]
    connectOrCreate?: AssetCategoryCreateOrConnectWithoutGlAccumulatedDepreciationAccountInput | AssetCategoryCreateOrConnectWithoutGlAccumulatedDepreciationAccountInput[]
    createMany?: AssetCategoryCreateManyGlAccumulatedDepreciationAccountInputEnvelope
    connect?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
  }

  export type ChartOfAccountUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<ChartOfAccountCreateWithoutParentInput, ChartOfAccountUncheckedCreateWithoutParentInput> | ChartOfAccountCreateWithoutParentInput[] | ChartOfAccountUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutParentInput | ChartOfAccountCreateOrConnectWithoutParentInput[]
    createMany?: ChartOfAccountCreateManyParentInputEnvelope
    connect?: ChartOfAccountWhereUniqueInput | ChartOfAccountWhereUniqueInput[]
  }

  export type JournalLineUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<JournalLineCreateWithoutAccountInput, JournalLineUncheckedCreateWithoutAccountInput> | JournalLineCreateWithoutAccountInput[] | JournalLineUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutAccountInput | JournalLineCreateOrConnectWithoutAccountInput[]
    createMany?: JournalLineCreateManyAccountInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type CashTransactionUncheckedCreateNestedManyWithoutGlAccountInput = {
    create?: XOR<CashTransactionCreateWithoutGlAccountInput, CashTransactionUncheckedCreateWithoutGlAccountInput> | CashTransactionCreateWithoutGlAccountInput[] | CashTransactionUncheckedCreateWithoutGlAccountInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutGlAccountInput | CashTransactionCreateOrConnectWithoutGlAccountInput[]
    createMany?: CashTransactionCreateManyGlAccountInputEnvelope
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
  }

  export type CashTransactionUncheckedCreateNestedManyWithoutContraAccountInput = {
    create?: XOR<CashTransactionCreateWithoutContraAccountInput, CashTransactionUncheckedCreateWithoutContraAccountInput> | CashTransactionCreateWithoutContraAccountInput[] | CashTransactionUncheckedCreateWithoutContraAccountInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutContraAccountInput | CashTransactionCreateOrConnectWithoutContraAccountInput[]
    createMany?: CashTransactionCreateManyContraAccountInputEnvelope
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
  }

  export type CashAccountUncheckedCreateNestedManyWithoutChartOfAccountInput = {
    create?: XOR<CashAccountCreateWithoutChartOfAccountInput, CashAccountUncheckedCreateWithoutChartOfAccountInput> | CashAccountCreateWithoutChartOfAccountInput[] | CashAccountUncheckedCreateWithoutChartOfAccountInput[]
    connectOrCreate?: CashAccountCreateOrConnectWithoutChartOfAccountInput | CashAccountCreateOrConnectWithoutChartOfAccountInput[]
    createMany?: CashAccountCreateManyChartOfAccountInputEnvelope
    connect?: CashAccountWhereUniqueInput | CashAccountWhereUniqueInput[]
  }

  export type AssetCategoryUncheckedCreateNestedManyWithoutGlAssetAccountInput = {
    create?: XOR<AssetCategoryCreateWithoutGlAssetAccountInput, AssetCategoryUncheckedCreateWithoutGlAssetAccountInput> | AssetCategoryCreateWithoutGlAssetAccountInput[] | AssetCategoryUncheckedCreateWithoutGlAssetAccountInput[]
    connectOrCreate?: AssetCategoryCreateOrConnectWithoutGlAssetAccountInput | AssetCategoryCreateOrConnectWithoutGlAssetAccountInput[]
    createMany?: AssetCategoryCreateManyGlAssetAccountInputEnvelope
    connect?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
  }

  export type AssetCategoryUncheckedCreateNestedManyWithoutGlDepreciationAccountInput = {
    create?: XOR<AssetCategoryCreateWithoutGlDepreciationAccountInput, AssetCategoryUncheckedCreateWithoutGlDepreciationAccountInput> | AssetCategoryCreateWithoutGlDepreciationAccountInput[] | AssetCategoryUncheckedCreateWithoutGlDepreciationAccountInput[]
    connectOrCreate?: AssetCategoryCreateOrConnectWithoutGlDepreciationAccountInput | AssetCategoryCreateOrConnectWithoutGlDepreciationAccountInput[]
    createMany?: AssetCategoryCreateManyGlDepreciationAccountInputEnvelope
    connect?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
  }

  export type AssetCategoryUncheckedCreateNestedManyWithoutGlAccumulatedDepreciationAccountInput = {
    create?: XOR<AssetCategoryCreateWithoutGlAccumulatedDepreciationAccountInput, AssetCategoryUncheckedCreateWithoutGlAccumulatedDepreciationAccountInput> | AssetCategoryCreateWithoutGlAccumulatedDepreciationAccountInput[] | AssetCategoryUncheckedCreateWithoutGlAccumulatedDepreciationAccountInput[]
    connectOrCreate?: AssetCategoryCreateOrConnectWithoutGlAccumulatedDepreciationAccountInput | AssetCategoryCreateOrConnectWithoutGlAccumulatedDepreciationAccountInput[]
    createMany?: AssetCategoryCreateManyGlAccumulatedDepreciationAccountInputEnvelope
    connect?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
  }

  export type ChartOfAccountUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<ChartOfAccountCreateWithoutChildrenInput, ChartOfAccountUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutChildrenInput
    upsert?: ChartOfAccountUpsertWithoutChildrenInput
    disconnect?: ChartOfAccountWhereInput | boolean
    delete?: ChartOfAccountWhereInput | boolean
    connect?: ChartOfAccountWhereUniqueInput
    update?: XOR<XOR<ChartOfAccountUpdateToOneWithWhereWithoutChildrenInput, ChartOfAccountUpdateWithoutChildrenInput>, ChartOfAccountUncheckedUpdateWithoutChildrenInput>
  }

  export type ChartOfAccountUpdateManyWithoutParentNestedInput = {
    create?: XOR<ChartOfAccountCreateWithoutParentInput, ChartOfAccountUncheckedCreateWithoutParentInput> | ChartOfAccountCreateWithoutParentInput[] | ChartOfAccountUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutParentInput | ChartOfAccountCreateOrConnectWithoutParentInput[]
    upsert?: ChartOfAccountUpsertWithWhereUniqueWithoutParentInput | ChartOfAccountUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ChartOfAccountCreateManyParentInputEnvelope
    set?: ChartOfAccountWhereUniqueInput | ChartOfAccountWhereUniqueInput[]
    disconnect?: ChartOfAccountWhereUniqueInput | ChartOfAccountWhereUniqueInput[]
    delete?: ChartOfAccountWhereUniqueInput | ChartOfAccountWhereUniqueInput[]
    connect?: ChartOfAccountWhereUniqueInput | ChartOfAccountWhereUniqueInput[]
    update?: ChartOfAccountUpdateWithWhereUniqueWithoutParentInput | ChartOfAccountUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ChartOfAccountUpdateManyWithWhereWithoutParentInput | ChartOfAccountUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ChartOfAccountScalarWhereInput | ChartOfAccountScalarWhereInput[]
  }

  export type JournalLineUpdateManyWithoutAccountNestedInput = {
    create?: XOR<JournalLineCreateWithoutAccountInput, JournalLineUncheckedCreateWithoutAccountInput> | JournalLineCreateWithoutAccountInput[] | JournalLineUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutAccountInput | JournalLineCreateOrConnectWithoutAccountInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutAccountInput | JournalLineUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: JournalLineCreateManyAccountInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutAccountInput | JournalLineUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutAccountInput | JournalLineUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type CashTransactionUpdateManyWithoutGlAccountNestedInput = {
    create?: XOR<CashTransactionCreateWithoutGlAccountInput, CashTransactionUncheckedCreateWithoutGlAccountInput> | CashTransactionCreateWithoutGlAccountInput[] | CashTransactionUncheckedCreateWithoutGlAccountInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutGlAccountInput | CashTransactionCreateOrConnectWithoutGlAccountInput[]
    upsert?: CashTransactionUpsertWithWhereUniqueWithoutGlAccountInput | CashTransactionUpsertWithWhereUniqueWithoutGlAccountInput[]
    createMany?: CashTransactionCreateManyGlAccountInputEnvelope
    set?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    disconnect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    delete?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    update?: CashTransactionUpdateWithWhereUniqueWithoutGlAccountInput | CashTransactionUpdateWithWhereUniqueWithoutGlAccountInput[]
    updateMany?: CashTransactionUpdateManyWithWhereWithoutGlAccountInput | CashTransactionUpdateManyWithWhereWithoutGlAccountInput[]
    deleteMany?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
  }

  export type CashTransactionUpdateManyWithoutContraAccountNestedInput = {
    create?: XOR<CashTransactionCreateWithoutContraAccountInput, CashTransactionUncheckedCreateWithoutContraAccountInput> | CashTransactionCreateWithoutContraAccountInput[] | CashTransactionUncheckedCreateWithoutContraAccountInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutContraAccountInput | CashTransactionCreateOrConnectWithoutContraAccountInput[]
    upsert?: CashTransactionUpsertWithWhereUniqueWithoutContraAccountInput | CashTransactionUpsertWithWhereUniqueWithoutContraAccountInput[]
    createMany?: CashTransactionCreateManyContraAccountInputEnvelope
    set?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    disconnect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    delete?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    update?: CashTransactionUpdateWithWhereUniqueWithoutContraAccountInput | CashTransactionUpdateWithWhereUniqueWithoutContraAccountInput[]
    updateMany?: CashTransactionUpdateManyWithWhereWithoutContraAccountInput | CashTransactionUpdateManyWithWhereWithoutContraAccountInput[]
    deleteMany?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
  }

  export type CashAccountUpdateManyWithoutChartOfAccountNestedInput = {
    create?: XOR<CashAccountCreateWithoutChartOfAccountInput, CashAccountUncheckedCreateWithoutChartOfAccountInput> | CashAccountCreateWithoutChartOfAccountInput[] | CashAccountUncheckedCreateWithoutChartOfAccountInput[]
    connectOrCreate?: CashAccountCreateOrConnectWithoutChartOfAccountInput | CashAccountCreateOrConnectWithoutChartOfAccountInput[]
    upsert?: CashAccountUpsertWithWhereUniqueWithoutChartOfAccountInput | CashAccountUpsertWithWhereUniqueWithoutChartOfAccountInput[]
    createMany?: CashAccountCreateManyChartOfAccountInputEnvelope
    set?: CashAccountWhereUniqueInput | CashAccountWhereUniqueInput[]
    disconnect?: CashAccountWhereUniqueInput | CashAccountWhereUniqueInput[]
    delete?: CashAccountWhereUniqueInput | CashAccountWhereUniqueInput[]
    connect?: CashAccountWhereUniqueInput | CashAccountWhereUniqueInput[]
    update?: CashAccountUpdateWithWhereUniqueWithoutChartOfAccountInput | CashAccountUpdateWithWhereUniqueWithoutChartOfAccountInput[]
    updateMany?: CashAccountUpdateManyWithWhereWithoutChartOfAccountInput | CashAccountUpdateManyWithWhereWithoutChartOfAccountInput[]
    deleteMany?: CashAccountScalarWhereInput | CashAccountScalarWhereInput[]
  }

  export type AssetCategoryUpdateManyWithoutGlAssetAccountNestedInput = {
    create?: XOR<AssetCategoryCreateWithoutGlAssetAccountInput, AssetCategoryUncheckedCreateWithoutGlAssetAccountInput> | AssetCategoryCreateWithoutGlAssetAccountInput[] | AssetCategoryUncheckedCreateWithoutGlAssetAccountInput[]
    connectOrCreate?: AssetCategoryCreateOrConnectWithoutGlAssetAccountInput | AssetCategoryCreateOrConnectWithoutGlAssetAccountInput[]
    upsert?: AssetCategoryUpsertWithWhereUniqueWithoutGlAssetAccountInput | AssetCategoryUpsertWithWhereUniqueWithoutGlAssetAccountInput[]
    createMany?: AssetCategoryCreateManyGlAssetAccountInputEnvelope
    set?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
    disconnect?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
    delete?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
    connect?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
    update?: AssetCategoryUpdateWithWhereUniqueWithoutGlAssetAccountInput | AssetCategoryUpdateWithWhereUniqueWithoutGlAssetAccountInput[]
    updateMany?: AssetCategoryUpdateManyWithWhereWithoutGlAssetAccountInput | AssetCategoryUpdateManyWithWhereWithoutGlAssetAccountInput[]
    deleteMany?: AssetCategoryScalarWhereInput | AssetCategoryScalarWhereInput[]
  }

  export type AssetCategoryUpdateManyWithoutGlDepreciationAccountNestedInput = {
    create?: XOR<AssetCategoryCreateWithoutGlDepreciationAccountInput, AssetCategoryUncheckedCreateWithoutGlDepreciationAccountInput> | AssetCategoryCreateWithoutGlDepreciationAccountInput[] | AssetCategoryUncheckedCreateWithoutGlDepreciationAccountInput[]
    connectOrCreate?: AssetCategoryCreateOrConnectWithoutGlDepreciationAccountInput | AssetCategoryCreateOrConnectWithoutGlDepreciationAccountInput[]
    upsert?: AssetCategoryUpsertWithWhereUniqueWithoutGlDepreciationAccountInput | AssetCategoryUpsertWithWhereUniqueWithoutGlDepreciationAccountInput[]
    createMany?: AssetCategoryCreateManyGlDepreciationAccountInputEnvelope
    set?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
    disconnect?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
    delete?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
    connect?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
    update?: AssetCategoryUpdateWithWhereUniqueWithoutGlDepreciationAccountInput | AssetCategoryUpdateWithWhereUniqueWithoutGlDepreciationAccountInput[]
    updateMany?: AssetCategoryUpdateManyWithWhereWithoutGlDepreciationAccountInput | AssetCategoryUpdateManyWithWhereWithoutGlDepreciationAccountInput[]
    deleteMany?: AssetCategoryScalarWhereInput | AssetCategoryScalarWhereInput[]
  }

  export type AssetCategoryUpdateManyWithoutGlAccumulatedDepreciationAccountNestedInput = {
    create?: XOR<AssetCategoryCreateWithoutGlAccumulatedDepreciationAccountInput, AssetCategoryUncheckedCreateWithoutGlAccumulatedDepreciationAccountInput> | AssetCategoryCreateWithoutGlAccumulatedDepreciationAccountInput[] | AssetCategoryUncheckedCreateWithoutGlAccumulatedDepreciationAccountInput[]
    connectOrCreate?: AssetCategoryCreateOrConnectWithoutGlAccumulatedDepreciationAccountInput | AssetCategoryCreateOrConnectWithoutGlAccumulatedDepreciationAccountInput[]
    upsert?: AssetCategoryUpsertWithWhereUniqueWithoutGlAccumulatedDepreciationAccountInput | AssetCategoryUpsertWithWhereUniqueWithoutGlAccumulatedDepreciationAccountInput[]
    createMany?: AssetCategoryCreateManyGlAccumulatedDepreciationAccountInputEnvelope
    set?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
    disconnect?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
    delete?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
    connect?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
    update?: AssetCategoryUpdateWithWhereUniqueWithoutGlAccumulatedDepreciationAccountInput | AssetCategoryUpdateWithWhereUniqueWithoutGlAccumulatedDepreciationAccountInput[]
    updateMany?: AssetCategoryUpdateManyWithWhereWithoutGlAccumulatedDepreciationAccountInput | AssetCategoryUpdateManyWithWhereWithoutGlAccumulatedDepreciationAccountInput[]
    deleteMany?: AssetCategoryScalarWhereInput | AssetCategoryScalarWhereInput[]
  }

  export type ChartOfAccountUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<ChartOfAccountCreateWithoutParentInput, ChartOfAccountUncheckedCreateWithoutParentInput> | ChartOfAccountCreateWithoutParentInput[] | ChartOfAccountUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutParentInput | ChartOfAccountCreateOrConnectWithoutParentInput[]
    upsert?: ChartOfAccountUpsertWithWhereUniqueWithoutParentInput | ChartOfAccountUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ChartOfAccountCreateManyParentInputEnvelope
    set?: ChartOfAccountWhereUniqueInput | ChartOfAccountWhereUniqueInput[]
    disconnect?: ChartOfAccountWhereUniqueInput | ChartOfAccountWhereUniqueInput[]
    delete?: ChartOfAccountWhereUniqueInput | ChartOfAccountWhereUniqueInput[]
    connect?: ChartOfAccountWhereUniqueInput | ChartOfAccountWhereUniqueInput[]
    update?: ChartOfAccountUpdateWithWhereUniqueWithoutParentInput | ChartOfAccountUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ChartOfAccountUpdateManyWithWhereWithoutParentInput | ChartOfAccountUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ChartOfAccountScalarWhereInput | ChartOfAccountScalarWhereInput[]
  }

  export type JournalLineUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<JournalLineCreateWithoutAccountInput, JournalLineUncheckedCreateWithoutAccountInput> | JournalLineCreateWithoutAccountInput[] | JournalLineUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutAccountInput | JournalLineCreateOrConnectWithoutAccountInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutAccountInput | JournalLineUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: JournalLineCreateManyAccountInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutAccountInput | JournalLineUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutAccountInput | JournalLineUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type CashTransactionUncheckedUpdateManyWithoutGlAccountNestedInput = {
    create?: XOR<CashTransactionCreateWithoutGlAccountInput, CashTransactionUncheckedCreateWithoutGlAccountInput> | CashTransactionCreateWithoutGlAccountInput[] | CashTransactionUncheckedCreateWithoutGlAccountInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutGlAccountInput | CashTransactionCreateOrConnectWithoutGlAccountInput[]
    upsert?: CashTransactionUpsertWithWhereUniqueWithoutGlAccountInput | CashTransactionUpsertWithWhereUniqueWithoutGlAccountInput[]
    createMany?: CashTransactionCreateManyGlAccountInputEnvelope
    set?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    disconnect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    delete?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    update?: CashTransactionUpdateWithWhereUniqueWithoutGlAccountInput | CashTransactionUpdateWithWhereUniqueWithoutGlAccountInput[]
    updateMany?: CashTransactionUpdateManyWithWhereWithoutGlAccountInput | CashTransactionUpdateManyWithWhereWithoutGlAccountInput[]
    deleteMany?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
  }

  export type CashTransactionUncheckedUpdateManyWithoutContraAccountNestedInput = {
    create?: XOR<CashTransactionCreateWithoutContraAccountInput, CashTransactionUncheckedCreateWithoutContraAccountInput> | CashTransactionCreateWithoutContraAccountInput[] | CashTransactionUncheckedCreateWithoutContraAccountInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutContraAccountInput | CashTransactionCreateOrConnectWithoutContraAccountInput[]
    upsert?: CashTransactionUpsertWithWhereUniqueWithoutContraAccountInput | CashTransactionUpsertWithWhereUniqueWithoutContraAccountInput[]
    createMany?: CashTransactionCreateManyContraAccountInputEnvelope
    set?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    disconnect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    delete?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    update?: CashTransactionUpdateWithWhereUniqueWithoutContraAccountInput | CashTransactionUpdateWithWhereUniqueWithoutContraAccountInput[]
    updateMany?: CashTransactionUpdateManyWithWhereWithoutContraAccountInput | CashTransactionUpdateManyWithWhereWithoutContraAccountInput[]
    deleteMany?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
  }

  export type CashAccountUncheckedUpdateManyWithoutChartOfAccountNestedInput = {
    create?: XOR<CashAccountCreateWithoutChartOfAccountInput, CashAccountUncheckedCreateWithoutChartOfAccountInput> | CashAccountCreateWithoutChartOfAccountInput[] | CashAccountUncheckedCreateWithoutChartOfAccountInput[]
    connectOrCreate?: CashAccountCreateOrConnectWithoutChartOfAccountInput | CashAccountCreateOrConnectWithoutChartOfAccountInput[]
    upsert?: CashAccountUpsertWithWhereUniqueWithoutChartOfAccountInput | CashAccountUpsertWithWhereUniqueWithoutChartOfAccountInput[]
    createMany?: CashAccountCreateManyChartOfAccountInputEnvelope
    set?: CashAccountWhereUniqueInput | CashAccountWhereUniqueInput[]
    disconnect?: CashAccountWhereUniqueInput | CashAccountWhereUniqueInput[]
    delete?: CashAccountWhereUniqueInput | CashAccountWhereUniqueInput[]
    connect?: CashAccountWhereUniqueInput | CashAccountWhereUniqueInput[]
    update?: CashAccountUpdateWithWhereUniqueWithoutChartOfAccountInput | CashAccountUpdateWithWhereUniqueWithoutChartOfAccountInput[]
    updateMany?: CashAccountUpdateManyWithWhereWithoutChartOfAccountInput | CashAccountUpdateManyWithWhereWithoutChartOfAccountInput[]
    deleteMany?: CashAccountScalarWhereInput | CashAccountScalarWhereInput[]
  }

  export type AssetCategoryUncheckedUpdateManyWithoutGlAssetAccountNestedInput = {
    create?: XOR<AssetCategoryCreateWithoutGlAssetAccountInput, AssetCategoryUncheckedCreateWithoutGlAssetAccountInput> | AssetCategoryCreateWithoutGlAssetAccountInput[] | AssetCategoryUncheckedCreateWithoutGlAssetAccountInput[]
    connectOrCreate?: AssetCategoryCreateOrConnectWithoutGlAssetAccountInput | AssetCategoryCreateOrConnectWithoutGlAssetAccountInput[]
    upsert?: AssetCategoryUpsertWithWhereUniqueWithoutGlAssetAccountInput | AssetCategoryUpsertWithWhereUniqueWithoutGlAssetAccountInput[]
    createMany?: AssetCategoryCreateManyGlAssetAccountInputEnvelope
    set?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
    disconnect?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
    delete?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
    connect?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
    update?: AssetCategoryUpdateWithWhereUniqueWithoutGlAssetAccountInput | AssetCategoryUpdateWithWhereUniqueWithoutGlAssetAccountInput[]
    updateMany?: AssetCategoryUpdateManyWithWhereWithoutGlAssetAccountInput | AssetCategoryUpdateManyWithWhereWithoutGlAssetAccountInput[]
    deleteMany?: AssetCategoryScalarWhereInput | AssetCategoryScalarWhereInput[]
  }

  export type AssetCategoryUncheckedUpdateManyWithoutGlDepreciationAccountNestedInput = {
    create?: XOR<AssetCategoryCreateWithoutGlDepreciationAccountInput, AssetCategoryUncheckedCreateWithoutGlDepreciationAccountInput> | AssetCategoryCreateWithoutGlDepreciationAccountInput[] | AssetCategoryUncheckedCreateWithoutGlDepreciationAccountInput[]
    connectOrCreate?: AssetCategoryCreateOrConnectWithoutGlDepreciationAccountInput | AssetCategoryCreateOrConnectWithoutGlDepreciationAccountInput[]
    upsert?: AssetCategoryUpsertWithWhereUniqueWithoutGlDepreciationAccountInput | AssetCategoryUpsertWithWhereUniqueWithoutGlDepreciationAccountInput[]
    createMany?: AssetCategoryCreateManyGlDepreciationAccountInputEnvelope
    set?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
    disconnect?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
    delete?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
    connect?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
    update?: AssetCategoryUpdateWithWhereUniqueWithoutGlDepreciationAccountInput | AssetCategoryUpdateWithWhereUniqueWithoutGlDepreciationAccountInput[]
    updateMany?: AssetCategoryUpdateManyWithWhereWithoutGlDepreciationAccountInput | AssetCategoryUpdateManyWithWhereWithoutGlDepreciationAccountInput[]
    deleteMany?: AssetCategoryScalarWhereInput | AssetCategoryScalarWhereInput[]
  }

  export type AssetCategoryUncheckedUpdateManyWithoutGlAccumulatedDepreciationAccountNestedInput = {
    create?: XOR<AssetCategoryCreateWithoutGlAccumulatedDepreciationAccountInput, AssetCategoryUncheckedCreateWithoutGlAccumulatedDepreciationAccountInput> | AssetCategoryCreateWithoutGlAccumulatedDepreciationAccountInput[] | AssetCategoryUncheckedCreateWithoutGlAccumulatedDepreciationAccountInput[]
    connectOrCreate?: AssetCategoryCreateOrConnectWithoutGlAccumulatedDepreciationAccountInput | AssetCategoryCreateOrConnectWithoutGlAccumulatedDepreciationAccountInput[]
    upsert?: AssetCategoryUpsertWithWhereUniqueWithoutGlAccumulatedDepreciationAccountInput | AssetCategoryUpsertWithWhereUniqueWithoutGlAccumulatedDepreciationAccountInput[]
    createMany?: AssetCategoryCreateManyGlAccumulatedDepreciationAccountInputEnvelope
    set?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
    disconnect?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
    delete?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
    connect?: AssetCategoryWhereUniqueInput | AssetCategoryWhereUniqueInput[]
    update?: AssetCategoryUpdateWithWhereUniqueWithoutGlAccumulatedDepreciationAccountInput | AssetCategoryUpdateWithWhereUniqueWithoutGlAccumulatedDepreciationAccountInput[]
    updateMany?: AssetCategoryUpdateManyWithWhereWithoutGlAccumulatedDepreciationAccountInput | AssetCategoryUpdateManyWithWhereWithoutGlAccumulatedDepreciationAccountInput[]
    deleteMany?: AssetCategoryScalarWhereInput | AssetCategoryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutJournalsInput = {
    create?: XOR<UserCreateWithoutJournalsInput, UserUncheckedCreateWithoutJournalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutJournalsInput
    connect?: UserWhereUniqueInput
  }

  export type JournalLineCreateNestedManyWithoutJournalInput = {
    create?: XOR<JournalLineCreateWithoutJournalInput, JournalLineUncheckedCreateWithoutJournalInput> | JournalLineCreateWithoutJournalInput[] | JournalLineUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutJournalInput | JournalLineCreateOrConnectWithoutJournalInput[]
    createMany?: JournalLineCreateManyJournalInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type AssetDepreciationCreateNestedManyWithoutJournalInput = {
    create?: XOR<AssetDepreciationCreateWithoutJournalInput, AssetDepreciationUncheckedCreateWithoutJournalInput> | AssetDepreciationCreateWithoutJournalInput[] | AssetDepreciationUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: AssetDepreciationCreateOrConnectWithoutJournalInput | AssetDepreciationCreateOrConnectWithoutJournalInput[]
    createMany?: AssetDepreciationCreateManyJournalInputEnvelope
    connect?: AssetDepreciationWhereUniqueInput | AssetDepreciationWhereUniqueInput[]
  }

  export type AssetDisposalCreateNestedManyWithoutJournalInput = {
    create?: XOR<AssetDisposalCreateWithoutJournalInput, AssetDisposalUncheckedCreateWithoutJournalInput> | AssetDisposalCreateWithoutJournalInput[] | AssetDisposalUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: AssetDisposalCreateOrConnectWithoutJournalInput | AssetDisposalCreateOrConnectWithoutJournalInput[]
    createMany?: AssetDisposalCreateManyJournalInputEnvelope
    connect?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
  }

  export type JournalLineUncheckedCreateNestedManyWithoutJournalInput = {
    create?: XOR<JournalLineCreateWithoutJournalInput, JournalLineUncheckedCreateWithoutJournalInput> | JournalLineCreateWithoutJournalInput[] | JournalLineUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutJournalInput | JournalLineCreateOrConnectWithoutJournalInput[]
    createMany?: JournalLineCreateManyJournalInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type AssetDepreciationUncheckedCreateNestedManyWithoutJournalInput = {
    create?: XOR<AssetDepreciationCreateWithoutJournalInput, AssetDepreciationUncheckedCreateWithoutJournalInput> | AssetDepreciationCreateWithoutJournalInput[] | AssetDepreciationUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: AssetDepreciationCreateOrConnectWithoutJournalInput | AssetDepreciationCreateOrConnectWithoutJournalInput[]
    createMany?: AssetDepreciationCreateManyJournalInputEnvelope
    connect?: AssetDepreciationWhereUniqueInput | AssetDepreciationWhereUniqueInput[]
  }

  export type AssetDisposalUncheckedCreateNestedManyWithoutJournalInput = {
    create?: XOR<AssetDisposalCreateWithoutJournalInput, AssetDisposalUncheckedCreateWithoutJournalInput> | AssetDisposalCreateWithoutJournalInput[] | AssetDisposalUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: AssetDisposalCreateOrConnectWithoutJournalInput | AssetDisposalCreateOrConnectWithoutJournalInput[]
    createMany?: AssetDisposalCreateManyJournalInputEnvelope
    connect?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutJournalsNestedInput = {
    create?: XOR<UserCreateWithoutJournalsInput, UserUncheckedCreateWithoutJournalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutJournalsInput
    upsert?: UserUpsertWithoutJournalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutJournalsInput, UserUpdateWithoutJournalsInput>, UserUncheckedUpdateWithoutJournalsInput>
  }

  export type JournalLineUpdateManyWithoutJournalNestedInput = {
    create?: XOR<JournalLineCreateWithoutJournalInput, JournalLineUncheckedCreateWithoutJournalInput> | JournalLineCreateWithoutJournalInput[] | JournalLineUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutJournalInput | JournalLineCreateOrConnectWithoutJournalInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutJournalInput | JournalLineUpsertWithWhereUniqueWithoutJournalInput[]
    createMany?: JournalLineCreateManyJournalInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutJournalInput | JournalLineUpdateWithWhereUniqueWithoutJournalInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutJournalInput | JournalLineUpdateManyWithWhereWithoutJournalInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type AssetDepreciationUpdateManyWithoutJournalNestedInput = {
    create?: XOR<AssetDepreciationCreateWithoutJournalInput, AssetDepreciationUncheckedCreateWithoutJournalInput> | AssetDepreciationCreateWithoutJournalInput[] | AssetDepreciationUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: AssetDepreciationCreateOrConnectWithoutJournalInput | AssetDepreciationCreateOrConnectWithoutJournalInput[]
    upsert?: AssetDepreciationUpsertWithWhereUniqueWithoutJournalInput | AssetDepreciationUpsertWithWhereUniqueWithoutJournalInput[]
    createMany?: AssetDepreciationCreateManyJournalInputEnvelope
    set?: AssetDepreciationWhereUniqueInput | AssetDepreciationWhereUniqueInput[]
    disconnect?: AssetDepreciationWhereUniqueInput | AssetDepreciationWhereUniqueInput[]
    delete?: AssetDepreciationWhereUniqueInput | AssetDepreciationWhereUniqueInput[]
    connect?: AssetDepreciationWhereUniqueInput | AssetDepreciationWhereUniqueInput[]
    update?: AssetDepreciationUpdateWithWhereUniqueWithoutJournalInput | AssetDepreciationUpdateWithWhereUniqueWithoutJournalInput[]
    updateMany?: AssetDepreciationUpdateManyWithWhereWithoutJournalInput | AssetDepreciationUpdateManyWithWhereWithoutJournalInput[]
    deleteMany?: AssetDepreciationScalarWhereInput | AssetDepreciationScalarWhereInput[]
  }

  export type AssetDisposalUpdateManyWithoutJournalNestedInput = {
    create?: XOR<AssetDisposalCreateWithoutJournalInput, AssetDisposalUncheckedCreateWithoutJournalInput> | AssetDisposalCreateWithoutJournalInput[] | AssetDisposalUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: AssetDisposalCreateOrConnectWithoutJournalInput | AssetDisposalCreateOrConnectWithoutJournalInput[]
    upsert?: AssetDisposalUpsertWithWhereUniqueWithoutJournalInput | AssetDisposalUpsertWithWhereUniqueWithoutJournalInput[]
    createMany?: AssetDisposalCreateManyJournalInputEnvelope
    set?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
    disconnect?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
    delete?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
    connect?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
    update?: AssetDisposalUpdateWithWhereUniqueWithoutJournalInput | AssetDisposalUpdateWithWhereUniqueWithoutJournalInput[]
    updateMany?: AssetDisposalUpdateManyWithWhereWithoutJournalInput | AssetDisposalUpdateManyWithWhereWithoutJournalInput[]
    deleteMany?: AssetDisposalScalarWhereInput | AssetDisposalScalarWhereInput[]
  }

  export type JournalLineUncheckedUpdateManyWithoutJournalNestedInput = {
    create?: XOR<JournalLineCreateWithoutJournalInput, JournalLineUncheckedCreateWithoutJournalInput> | JournalLineCreateWithoutJournalInput[] | JournalLineUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutJournalInput | JournalLineCreateOrConnectWithoutJournalInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutJournalInput | JournalLineUpsertWithWhereUniqueWithoutJournalInput[]
    createMany?: JournalLineCreateManyJournalInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutJournalInput | JournalLineUpdateWithWhereUniqueWithoutJournalInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutJournalInput | JournalLineUpdateManyWithWhereWithoutJournalInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type AssetDepreciationUncheckedUpdateManyWithoutJournalNestedInput = {
    create?: XOR<AssetDepreciationCreateWithoutJournalInput, AssetDepreciationUncheckedCreateWithoutJournalInput> | AssetDepreciationCreateWithoutJournalInput[] | AssetDepreciationUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: AssetDepreciationCreateOrConnectWithoutJournalInput | AssetDepreciationCreateOrConnectWithoutJournalInput[]
    upsert?: AssetDepreciationUpsertWithWhereUniqueWithoutJournalInput | AssetDepreciationUpsertWithWhereUniqueWithoutJournalInput[]
    createMany?: AssetDepreciationCreateManyJournalInputEnvelope
    set?: AssetDepreciationWhereUniqueInput | AssetDepreciationWhereUniqueInput[]
    disconnect?: AssetDepreciationWhereUniqueInput | AssetDepreciationWhereUniqueInput[]
    delete?: AssetDepreciationWhereUniqueInput | AssetDepreciationWhereUniqueInput[]
    connect?: AssetDepreciationWhereUniqueInput | AssetDepreciationWhereUniqueInput[]
    update?: AssetDepreciationUpdateWithWhereUniqueWithoutJournalInput | AssetDepreciationUpdateWithWhereUniqueWithoutJournalInput[]
    updateMany?: AssetDepreciationUpdateManyWithWhereWithoutJournalInput | AssetDepreciationUpdateManyWithWhereWithoutJournalInput[]
    deleteMany?: AssetDepreciationScalarWhereInput | AssetDepreciationScalarWhereInput[]
  }

  export type AssetDisposalUncheckedUpdateManyWithoutJournalNestedInput = {
    create?: XOR<AssetDisposalCreateWithoutJournalInput, AssetDisposalUncheckedCreateWithoutJournalInput> | AssetDisposalCreateWithoutJournalInput[] | AssetDisposalUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: AssetDisposalCreateOrConnectWithoutJournalInput | AssetDisposalCreateOrConnectWithoutJournalInput[]
    upsert?: AssetDisposalUpsertWithWhereUniqueWithoutJournalInput | AssetDisposalUpsertWithWhereUniqueWithoutJournalInput[]
    createMany?: AssetDisposalCreateManyJournalInputEnvelope
    set?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
    disconnect?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
    delete?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
    connect?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
    update?: AssetDisposalUpdateWithWhereUniqueWithoutJournalInput | AssetDisposalUpdateWithWhereUniqueWithoutJournalInput[]
    updateMany?: AssetDisposalUpdateManyWithWhereWithoutJournalInput | AssetDisposalUpdateManyWithWhereWithoutJournalInput[]
    deleteMany?: AssetDisposalScalarWhereInput | AssetDisposalScalarWhereInput[]
  }

  export type JournalCreateNestedOneWithoutJournalLinesInput = {
    create?: XOR<JournalCreateWithoutJournalLinesInput, JournalUncheckedCreateWithoutJournalLinesInput>
    connectOrCreate?: JournalCreateOrConnectWithoutJournalLinesInput
    connect?: JournalWhereUniqueInput
  }

  export type ChartOfAccountCreateNestedOneWithoutJournalLinesInput = {
    create?: XOR<ChartOfAccountCreateWithoutJournalLinesInput, ChartOfAccountUncheckedCreateWithoutJournalLinesInput>
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutJournalLinesInput
    connect?: ChartOfAccountWhereUniqueInput
  }

  export type JournalUpdateOneRequiredWithoutJournalLinesNestedInput = {
    create?: XOR<JournalCreateWithoutJournalLinesInput, JournalUncheckedCreateWithoutJournalLinesInput>
    connectOrCreate?: JournalCreateOrConnectWithoutJournalLinesInput
    upsert?: JournalUpsertWithoutJournalLinesInput
    connect?: JournalWhereUniqueInput
    update?: XOR<XOR<JournalUpdateToOneWithWhereWithoutJournalLinesInput, JournalUpdateWithoutJournalLinesInput>, JournalUncheckedUpdateWithoutJournalLinesInput>
  }

  export type ChartOfAccountUpdateOneRequiredWithoutJournalLinesNestedInput = {
    create?: XOR<ChartOfAccountCreateWithoutJournalLinesInput, ChartOfAccountUncheckedCreateWithoutJournalLinesInput>
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutJournalLinesInput
    upsert?: ChartOfAccountUpsertWithoutJournalLinesInput
    connect?: ChartOfAccountWhereUniqueInput
    update?: XOR<XOR<ChartOfAccountUpdateToOneWithWhereWithoutJournalLinesInput, ChartOfAccountUpdateWithoutJournalLinesInput>, ChartOfAccountUncheckedUpdateWithoutJournalLinesInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type CashTransactionCreateNestedManyWithoutCashAccountInput = {
    create?: XOR<CashTransactionCreateWithoutCashAccountInput, CashTransactionUncheckedCreateWithoutCashAccountInput> | CashTransactionCreateWithoutCashAccountInput[] | CashTransactionUncheckedCreateWithoutCashAccountInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutCashAccountInput | CashTransactionCreateOrConnectWithoutCashAccountInput[]
    createMany?: CashTransactionCreateManyCashAccountInputEnvelope
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
  }

  export type SalesReceiptCreateNestedManyWithoutCashAccountInput = {
    create?: XOR<SalesReceiptCreateWithoutCashAccountInput, SalesReceiptUncheckedCreateWithoutCashAccountInput> | SalesReceiptCreateWithoutCashAccountInput[] | SalesReceiptUncheckedCreateWithoutCashAccountInput[]
    connectOrCreate?: SalesReceiptCreateOrConnectWithoutCashAccountInput | SalesReceiptCreateOrConnectWithoutCashAccountInput[]
    createMany?: SalesReceiptCreateManyCashAccountInputEnvelope
    connect?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
  }

  export type PurchasePaymentCreateNestedManyWithoutCashAccountInput = {
    create?: XOR<PurchasePaymentCreateWithoutCashAccountInput, PurchasePaymentUncheckedCreateWithoutCashAccountInput> | PurchasePaymentCreateWithoutCashAccountInput[] | PurchasePaymentUncheckedCreateWithoutCashAccountInput[]
    connectOrCreate?: PurchasePaymentCreateOrConnectWithoutCashAccountInput | PurchasePaymentCreateOrConnectWithoutCashAccountInput[]
    createMany?: PurchasePaymentCreateManyCashAccountInputEnvelope
    connect?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
  }

  export type ChartOfAccountCreateNestedOneWithoutCashAccountsInput = {
    create?: XOR<ChartOfAccountCreateWithoutCashAccountsInput, ChartOfAccountUncheckedCreateWithoutCashAccountsInput>
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutCashAccountsInput
    connect?: ChartOfAccountWhereUniqueInput
  }

  export type CashTransactionUncheckedCreateNestedManyWithoutCashAccountInput = {
    create?: XOR<CashTransactionCreateWithoutCashAccountInput, CashTransactionUncheckedCreateWithoutCashAccountInput> | CashTransactionCreateWithoutCashAccountInput[] | CashTransactionUncheckedCreateWithoutCashAccountInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutCashAccountInput | CashTransactionCreateOrConnectWithoutCashAccountInput[]
    createMany?: CashTransactionCreateManyCashAccountInputEnvelope
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
  }

  export type SalesReceiptUncheckedCreateNestedManyWithoutCashAccountInput = {
    create?: XOR<SalesReceiptCreateWithoutCashAccountInput, SalesReceiptUncheckedCreateWithoutCashAccountInput> | SalesReceiptCreateWithoutCashAccountInput[] | SalesReceiptUncheckedCreateWithoutCashAccountInput[]
    connectOrCreate?: SalesReceiptCreateOrConnectWithoutCashAccountInput | SalesReceiptCreateOrConnectWithoutCashAccountInput[]
    createMany?: SalesReceiptCreateManyCashAccountInputEnvelope
    connect?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
  }

  export type PurchasePaymentUncheckedCreateNestedManyWithoutCashAccountInput = {
    create?: XOR<PurchasePaymentCreateWithoutCashAccountInput, PurchasePaymentUncheckedCreateWithoutCashAccountInput> | PurchasePaymentCreateWithoutCashAccountInput[] | PurchasePaymentUncheckedCreateWithoutCashAccountInput[]
    connectOrCreate?: PurchasePaymentCreateOrConnectWithoutCashAccountInput | PurchasePaymentCreateOrConnectWithoutCashAccountInput[]
    createMany?: PurchasePaymentCreateManyCashAccountInputEnvelope
    connect?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
  }

  export type CashTransactionUpdateManyWithoutCashAccountNestedInput = {
    create?: XOR<CashTransactionCreateWithoutCashAccountInput, CashTransactionUncheckedCreateWithoutCashAccountInput> | CashTransactionCreateWithoutCashAccountInput[] | CashTransactionUncheckedCreateWithoutCashAccountInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutCashAccountInput | CashTransactionCreateOrConnectWithoutCashAccountInput[]
    upsert?: CashTransactionUpsertWithWhereUniqueWithoutCashAccountInput | CashTransactionUpsertWithWhereUniqueWithoutCashAccountInput[]
    createMany?: CashTransactionCreateManyCashAccountInputEnvelope
    set?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    disconnect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    delete?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    update?: CashTransactionUpdateWithWhereUniqueWithoutCashAccountInput | CashTransactionUpdateWithWhereUniqueWithoutCashAccountInput[]
    updateMany?: CashTransactionUpdateManyWithWhereWithoutCashAccountInput | CashTransactionUpdateManyWithWhereWithoutCashAccountInput[]
    deleteMany?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
  }

  export type SalesReceiptUpdateManyWithoutCashAccountNestedInput = {
    create?: XOR<SalesReceiptCreateWithoutCashAccountInput, SalesReceiptUncheckedCreateWithoutCashAccountInput> | SalesReceiptCreateWithoutCashAccountInput[] | SalesReceiptUncheckedCreateWithoutCashAccountInput[]
    connectOrCreate?: SalesReceiptCreateOrConnectWithoutCashAccountInput | SalesReceiptCreateOrConnectWithoutCashAccountInput[]
    upsert?: SalesReceiptUpsertWithWhereUniqueWithoutCashAccountInput | SalesReceiptUpsertWithWhereUniqueWithoutCashAccountInput[]
    createMany?: SalesReceiptCreateManyCashAccountInputEnvelope
    set?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    disconnect?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    delete?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    connect?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    update?: SalesReceiptUpdateWithWhereUniqueWithoutCashAccountInput | SalesReceiptUpdateWithWhereUniqueWithoutCashAccountInput[]
    updateMany?: SalesReceiptUpdateManyWithWhereWithoutCashAccountInput | SalesReceiptUpdateManyWithWhereWithoutCashAccountInput[]
    deleteMany?: SalesReceiptScalarWhereInput | SalesReceiptScalarWhereInput[]
  }

  export type PurchasePaymentUpdateManyWithoutCashAccountNestedInput = {
    create?: XOR<PurchasePaymentCreateWithoutCashAccountInput, PurchasePaymentUncheckedCreateWithoutCashAccountInput> | PurchasePaymentCreateWithoutCashAccountInput[] | PurchasePaymentUncheckedCreateWithoutCashAccountInput[]
    connectOrCreate?: PurchasePaymentCreateOrConnectWithoutCashAccountInput | PurchasePaymentCreateOrConnectWithoutCashAccountInput[]
    upsert?: PurchasePaymentUpsertWithWhereUniqueWithoutCashAccountInput | PurchasePaymentUpsertWithWhereUniqueWithoutCashAccountInput[]
    createMany?: PurchasePaymentCreateManyCashAccountInputEnvelope
    set?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    disconnect?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    delete?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    connect?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    update?: PurchasePaymentUpdateWithWhereUniqueWithoutCashAccountInput | PurchasePaymentUpdateWithWhereUniqueWithoutCashAccountInput[]
    updateMany?: PurchasePaymentUpdateManyWithWhereWithoutCashAccountInput | PurchasePaymentUpdateManyWithWhereWithoutCashAccountInput[]
    deleteMany?: PurchasePaymentScalarWhereInput | PurchasePaymentScalarWhereInput[]
  }

  export type ChartOfAccountUpdateOneWithoutCashAccountsNestedInput = {
    create?: XOR<ChartOfAccountCreateWithoutCashAccountsInput, ChartOfAccountUncheckedCreateWithoutCashAccountsInput>
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutCashAccountsInput
    upsert?: ChartOfAccountUpsertWithoutCashAccountsInput
    disconnect?: ChartOfAccountWhereInput | boolean
    delete?: ChartOfAccountWhereInput | boolean
    connect?: ChartOfAccountWhereUniqueInput
    update?: XOR<XOR<ChartOfAccountUpdateToOneWithWhereWithoutCashAccountsInput, ChartOfAccountUpdateWithoutCashAccountsInput>, ChartOfAccountUncheckedUpdateWithoutCashAccountsInput>
  }

  export type CashTransactionUncheckedUpdateManyWithoutCashAccountNestedInput = {
    create?: XOR<CashTransactionCreateWithoutCashAccountInput, CashTransactionUncheckedCreateWithoutCashAccountInput> | CashTransactionCreateWithoutCashAccountInput[] | CashTransactionUncheckedCreateWithoutCashAccountInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutCashAccountInput | CashTransactionCreateOrConnectWithoutCashAccountInput[]
    upsert?: CashTransactionUpsertWithWhereUniqueWithoutCashAccountInput | CashTransactionUpsertWithWhereUniqueWithoutCashAccountInput[]
    createMany?: CashTransactionCreateManyCashAccountInputEnvelope
    set?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    disconnect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    delete?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    update?: CashTransactionUpdateWithWhereUniqueWithoutCashAccountInput | CashTransactionUpdateWithWhereUniqueWithoutCashAccountInput[]
    updateMany?: CashTransactionUpdateManyWithWhereWithoutCashAccountInput | CashTransactionUpdateManyWithWhereWithoutCashAccountInput[]
    deleteMany?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
  }

  export type SalesReceiptUncheckedUpdateManyWithoutCashAccountNestedInput = {
    create?: XOR<SalesReceiptCreateWithoutCashAccountInput, SalesReceiptUncheckedCreateWithoutCashAccountInput> | SalesReceiptCreateWithoutCashAccountInput[] | SalesReceiptUncheckedCreateWithoutCashAccountInput[]
    connectOrCreate?: SalesReceiptCreateOrConnectWithoutCashAccountInput | SalesReceiptCreateOrConnectWithoutCashAccountInput[]
    upsert?: SalesReceiptUpsertWithWhereUniqueWithoutCashAccountInput | SalesReceiptUpsertWithWhereUniqueWithoutCashAccountInput[]
    createMany?: SalesReceiptCreateManyCashAccountInputEnvelope
    set?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    disconnect?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    delete?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    connect?: SalesReceiptWhereUniqueInput | SalesReceiptWhereUniqueInput[]
    update?: SalesReceiptUpdateWithWhereUniqueWithoutCashAccountInput | SalesReceiptUpdateWithWhereUniqueWithoutCashAccountInput[]
    updateMany?: SalesReceiptUpdateManyWithWhereWithoutCashAccountInput | SalesReceiptUpdateManyWithWhereWithoutCashAccountInput[]
    deleteMany?: SalesReceiptScalarWhereInput | SalesReceiptScalarWhereInput[]
  }

  export type PurchasePaymentUncheckedUpdateManyWithoutCashAccountNestedInput = {
    create?: XOR<PurchasePaymentCreateWithoutCashAccountInput, PurchasePaymentUncheckedCreateWithoutCashAccountInput> | PurchasePaymentCreateWithoutCashAccountInput[] | PurchasePaymentUncheckedCreateWithoutCashAccountInput[]
    connectOrCreate?: PurchasePaymentCreateOrConnectWithoutCashAccountInput | PurchasePaymentCreateOrConnectWithoutCashAccountInput[]
    upsert?: PurchasePaymentUpsertWithWhereUniqueWithoutCashAccountInput | PurchasePaymentUpsertWithWhereUniqueWithoutCashAccountInput[]
    createMany?: PurchasePaymentCreateManyCashAccountInputEnvelope
    set?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    disconnect?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    delete?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    connect?: PurchasePaymentWhereUniqueInput | PurchasePaymentWhereUniqueInput[]
    update?: PurchasePaymentUpdateWithWhereUniqueWithoutCashAccountInput | PurchasePaymentUpdateWithWhereUniqueWithoutCashAccountInput[]
    updateMany?: PurchasePaymentUpdateManyWithWhereWithoutCashAccountInput | PurchasePaymentUpdateManyWithWhereWithoutCashAccountInput[]
    deleteMany?: PurchasePaymentScalarWhereInput | PurchasePaymentScalarWhereInput[]
  }

  export type CashAccountCreateNestedOneWithoutCashTransactionsInput = {
    create?: XOR<CashAccountCreateWithoutCashTransactionsInput, CashAccountUncheckedCreateWithoutCashTransactionsInput>
    connectOrCreate?: CashAccountCreateOrConnectWithoutCashTransactionsInput
    connect?: CashAccountWhereUniqueInput
  }

  export type ChartOfAccountCreateNestedOneWithoutCashTransactionsGLInput = {
    create?: XOR<ChartOfAccountCreateWithoutCashTransactionsGLInput, ChartOfAccountUncheckedCreateWithoutCashTransactionsGLInput>
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutCashTransactionsGLInput
    connect?: ChartOfAccountWhereUniqueInput
  }

  export type ChartOfAccountCreateNestedOneWithoutCashTransactionsContraInput = {
    create?: XOR<ChartOfAccountCreateWithoutCashTransactionsContraInput, ChartOfAccountUncheckedCreateWithoutCashTransactionsContraInput>
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutCashTransactionsContraInput
    connect?: ChartOfAccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCashTransactionsInput = {
    create?: XOR<UserCreateWithoutCashTransactionsInput, UserUncheckedCreateWithoutCashTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type CashAccountUpdateOneRequiredWithoutCashTransactionsNestedInput = {
    create?: XOR<CashAccountCreateWithoutCashTransactionsInput, CashAccountUncheckedCreateWithoutCashTransactionsInput>
    connectOrCreate?: CashAccountCreateOrConnectWithoutCashTransactionsInput
    upsert?: CashAccountUpsertWithoutCashTransactionsInput
    connect?: CashAccountWhereUniqueInput
    update?: XOR<XOR<CashAccountUpdateToOneWithWhereWithoutCashTransactionsInput, CashAccountUpdateWithoutCashTransactionsInput>, CashAccountUncheckedUpdateWithoutCashTransactionsInput>
  }

  export type ChartOfAccountUpdateOneWithoutCashTransactionsGLNestedInput = {
    create?: XOR<ChartOfAccountCreateWithoutCashTransactionsGLInput, ChartOfAccountUncheckedCreateWithoutCashTransactionsGLInput>
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutCashTransactionsGLInput
    upsert?: ChartOfAccountUpsertWithoutCashTransactionsGLInput
    disconnect?: ChartOfAccountWhereInput | boolean
    delete?: ChartOfAccountWhereInput | boolean
    connect?: ChartOfAccountWhereUniqueInput
    update?: XOR<XOR<ChartOfAccountUpdateToOneWithWhereWithoutCashTransactionsGLInput, ChartOfAccountUpdateWithoutCashTransactionsGLInput>, ChartOfAccountUncheckedUpdateWithoutCashTransactionsGLInput>
  }

  export type ChartOfAccountUpdateOneWithoutCashTransactionsContraNestedInput = {
    create?: XOR<ChartOfAccountCreateWithoutCashTransactionsContraInput, ChartOfAccountUncheckedCreateWithoutCashTransactionsContraInput>
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutCashTransactionsContraInput
    upsert?: ChartOfAccountUpsertWithoutCashTransactionsContraInput
    disconnect?: ChartOfAccountWhereInput | boolean
    delete?: ChartOfAccountWhereInput | boolean
    connect?: ChartOfAccountWhereUniqueInput
    update?: XOR<XOR<ChartOfAccountUpdateToOneWithWhereWithoutCashTransactionsContraInput, ChartOfAccountUpdateWithoutCashTransactionsContraInput>, ChartOfAccountUncheckedUpdateWithoutCashTransactionsContraInput>
  }

  export type UserUpdateOneRequiredWithoutCashTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutCashTransactionsInput, UserUncheckedCreateWithoutCashTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCashTransactionsInput
    upsert?: UserUpsertWithoutCashTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCashTransactionsInput, UserUpdateWithoutCashTransactionsInput>, UserUncheckedUpdateWithoutCashTransactionsInput>
  }

  export type SaleCreateNestedOneWithoutSalesReceiptsInput = {
    create?: XOR<SaleCreateWithoutSalesReceiptsInput, SaleUncheckedCreateWithoutSalesReceiptsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutSalesReceiptsInput
    connect?: SaleWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutSalesReceiptsInput = {
    create?: XOR<CustomerCreateWithoutSalesReceiptsInput, CustomerUncheckedCreateWithoutSalesReceiptsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesReceiptsInput
    connect?: CustomerWhereUniqueInput
  }

  export type CashAccountCreateNestedOneWithoutSalesReceiptsInput = {
    create?: XOR<CashAccountCreateWithoutSalesReceiptsInput, CashAccountUncheckedCreateWithoutSalesReceiptsInput>
    connectOrCreate?: CashAccountCreateOrConnectWithoutSalesReceiptsInput
    connect?: CashAccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSalesReceiptsInput = {
    create?: XOR<UserCreateWithoutSalesReceiptsInput, UserUncheckedCreateWithoutSalesReceiptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesReceiptsInput
    connect?: UserWhereUniqueInput
  }

  export type SaleUpdateOneRequiredWithoutSalesReceiptsNestedInput = {
    create?: XOR<SaleCreateWithoutSalesReceiptsInput, SaleUncheckedCreateWithoutSalesReceiptsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutSalesReceiptsInput
    upsert?: SaleUpsertWithoutSalesReceiptsInput
    connect?: SaleWhereUniqueInput
    update?: XOR<XOR<SaleUpdateToOneWithWhereWithoutSalesReceiptsInput, SaleUpdateWithoutSalesReceiptsInput>, SaleUncheckedUpdateWithoutSalesReceiptsInput>
  }

  export type CustomerUpdateOneRequiredWithoutSalesReceiptsNestedInput = {
    create?: XOR<CustomerCreateWithoutSalesReceiptsInput, CustomerUncheckedCreateWithoutSalesReceiptsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesReceiptsInput
    upsert?: CustomerUpsertWithoutSalesReceiptsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSalesReceiptsInput, CustomerUpdateWithoutSalesReceiptsInput>, CustomerUncheckedUpdateWithoutSalesReceiptsInput>
  }

  export type CashAccountUpdateOneRequiredWithoutSalesReceiptsNestedInput = {
    create?: XOR<CashAccountCreateWithoutSalesReceiptsInput, CashAccountUncheckedCreateWithoutSalesReceiptsInput>
    connectOrCreate?: CashAccountCreateOrConnectWithoutSalesReceiptsInput
    upsert?: CashAccountUpsertWithoutSalesReceiptsInput
    connect?: CashAccountWhereUniqueInput
    update?: XOR<XOR<CashAccountUpdateToOneWithWhereWithoutSalesReceiptsInput, CashAccountUpdateWithoutSalesReceiptsInput>, CashAccountUncheckedUpdateWithoutSalesReceiptsInput>
  }

  export type UserUpdateOneRequiredWithoutSalesReceiptsNestedInput = {
    create?: XOR<UserCreateWithoutSalesReceiptsInput, UserUncheckedCreateWithoutSalesReceiptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesReceiptsInput
    upsert?: UserUpsertWithoutSalesReceiptsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSalesReceiptsInput, UserUpdateWithoutSalesReceiptsInput>, UserUncheckedUpdateWithoutSalesReceiptsInput>
  }

  export type PurchaseCreateNestedOneWithoutPurchasePaymentsInput = {
    create?: XOR<PurchaseCreateWithoutPurchasePaymentsInput, PurchaseUncheckedCreateWithoutPurchasePaymentsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutPurchasePaymentsInput
    connect?: PurchaseWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutPurchasePaymentsInput = {
    create?: XOR<VendorCreateWithoutPurchasePaymentsInput, VendorUncheckedCreateWithoutPurchasePaymentsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPurchasePaymentsInput
    connect?: VendorWhereUniqueInput
  }

  export type CashAccountCreateNestedOneWithoutPurchasePaymentsInput = {
    create?: XOR<CashAccountCreateWithoutPurchasePaymentsInput, CashAccountUncheckedCreateWithoutPurchasePaymentsInput>
    connectOrCreate?: CashAccountCreateOrConnectWithoutPurchasePaymentsInput
    connect?: CashAccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPurchasePaymentsInput = {
    create?: XOR<UserCreateWithoutPurchasePaymentsInput, UserUncheckedCreateWithoutPurchasePaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchasePaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type PurchaseUpdateOneRequiredWithoutPurchasePaymentsNestedInput = {
    create?: XOR<PurchaseCreateWithoutPurchasePaymentsInput, PurchaseUncheckedCreateWithoutPurchasePaymentsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutPurchasePaymentsInput
    upsert?: PurchaseUpsertWithoutPurchasePaymentsInput
    connect?: PurchaseWhereUniqueInput
    update?: XOR<XOR<PurchaseUpdateToOneWithWhereWithoutPurchasePaymentsInput, PurchaseUpdateWithoutPurchasePaymentsInput>, PurchaseUncheckedUpdateWithoutPurchasePaymentsInput>
  }

  export type VendorUpdateOneRequiredWithoutPurchasePaymentsNestedInput = {
    create?: XOR<VendorCreateWithoutPurchasePaymentsInput, VendorUncheckedCreateWithoutPurchasePaymentsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPurchasePaymentsInput
    upsert?: VendorUpsertWithoutPurchasePaymentsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutPurchasePaymentsInput, VendorUpdateWithoutPurchasePaymentsInput>, VendorUncheckedUpdateWithoutPurchasePaymentsInput>
  }

  export type CashAccountUpdateOneRequiredWithoutPurchasePaymentsNestedInput = {
    create?: XOR<CashAccountCreateWithoutPurchasePaymentsInput, CashAccountUncheckedCreateWithoutPurchasePaymentsInput>
    connectOrCreate?: CashAccountCreateOrConnectWithoutPurchasePaymentsInput
    upsert?: CashAccountUpsertWithoutPurchasePaymentsInput
    connect?: CashAccountWhereUniqueInput
    update?: XOR<XOR<CashAccountUpdateToOneWithWhereWithoutPurchasePaymentsInput, CashAccountUpdateWithoutPurchasePaymentsInput>, CashAccountUncheckedUpdateWithoutPurchasePaymentsInput>
  }

  export type UserUpdateOneRequiredWithoutPurchasePaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPurchasePaymentsInput, UserUncheckedCreateWithoutPurchasePaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchasePaymentsInput
    upsert?: UserUpsertWithoutPurchasePaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPurchasePaymentsInput, UserUpdateWithoutPurchasePaymentsInput>, UserUncheckedUpdateWithoutPurchasePaymentsInput>
  }

  export type UserCreateNestedOneWithoutSystemSettingInput = {
    create?: XOR<UserCreateWithoutSystemSettingInput, UserUncheckedCreateWithoutSystemSettingInput>
    connectOrCreate?: UserCreateOrConnectWithoutSystemSettingInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutSystemSettingNestedInput = {
    create?: XOR<UserCreateWithoutSystemSettingInput, UserUncheckedCreateWithoutSystemSettingInput>
    connectOrCreate?: UserCreateOrConnectWithoutSystemSettingInput
    upsert?: UserUpsertWithoutSystemSettingInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSystemSettingInput, UserUpdateWithoutSystemSettingInput>, UserUncheckedUpdateWithoutSystemSettingInput>
  }

  export type FiscalPeriodCreateNestedManyWithoutFiscalYearInput = {
    create?: XOR<FiscalPeriodCreateWithoutFiscalYearInput, FiscalPeriodUncheckedCreateWithoutFiscalYearInput> | FiscalPeriodCreateWithoutFiscalYearInput[] | FiscalPeriodUncheckedCreateWithoutFiscalYearInput[]
    connectOrCreate?: FiscalPeriodCreateOrConnectWithoutFiscalYearInput | FiscalPeriodCreateOrConnectWithoutFiscalYearInput[]
    createMany?: FiscalPeriodCreateManyFiscalYearInputEnvelope
    connect?: FiscalPeriodWhereUniqueInput | FiscalPeriodWhereUniqueInput[]
  }

  export type FiscalPeriodUncheckedCreateNestedManyWithoutFiscalYearInput = {
    create?: XOR<FiscalPeriodCreateWithoutFiscalYearInput, FiscalPeriodUncheckedCreateWithoutFiscalYearInput> | FiscalPeriodCreateWithoutFiscalYearInput[] | FiscalPeriodUncheckedCreateWithoutFiscalYearInput[]
    connectOrCreate?: FiscalPeriodCreateOrConnectWithoutFiscalYearInput | FiscalPeriodCreateOrConnectWithoutFiscalYearInput[]
    createMany?: FiscalPeriodCreateManyFiscalYearInputEnvelope
    connect?: FiscalPeriodWhereUniqueInput | FiscalPeriodWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FiscalPeriodUpdateManyWithoutFiscalYearNestedInput = {
    create?: XOR<FiscalPeriodCreateWithoutFiscalYearInput, FiscalPeriodUncheckedCreateWithoutFiscalYearInput> | FiscalPeriodCreateWithoutFiscalYearInput[] | FiscalPeriodUncheckedCreateWithoutFiscalYearInput[]
    connectOrCreate?: FiscalPeriodCreateOrConnectWithoutFiscalYearInput | FiscalPeriodCreateOrConnectWithoutFiscalYearInput[]
    upsert?: FiscalPeriodUpsertWithWhereUniqueWithoutFiscalYearInput | FiscalPeriodUpsertWithWhereUniqueWithoutFiscalYearInput[]
    createMany?: FiscalPeriodCreateManyFiscalYearInputEnvelope
    set?: FiscalPeriodWhereUniqueInput | FiscalPeriodWhereUniqueInput[]
    disconnect?: FiscalPeriodWhereUniqueInput | FiscalPeriodWhereUniqueInput[]
    delete?: FiscalPeriodWhereUniqueInput | FiscalPeriodWhereUniqueInput[]
    connect?: FiscalPeriodWhereUniqueInput | FiscalPeriodWhereUniqueInput[]
    update?: FiscalPeriodUpdateWithWhereUniqueWithoutFiscalYearInput | FiscalPeriodUpdateWithWhereUniqueWithoutFiscalYearInput[]
    updateMany?: FiscalPeriodUpdateManyWithWhereWithoutFiscalYearInput | FiscalPeriodUpdateManyWithWhereWithoutFiscalYearInput[]
    deleteMany?: FiscalPeriodScalarWhereInput | FiscalPeriodScalarWhereInput[]
  }

  export type FiscalPeriodUncheckedUpdateManyWithoutFiscalYearNestedInput = {
    create?: XOR<FiscalPeriodCreateWithoutFiscalYearInput, FiscalPeriodUncheckedCreateWithoutFiscalYearInput> | FiscalPeriodCreateWithoutFiscalYearInput[] | FiscalPeriodUncheckedCreateWithoutFiscalYearInput[]
    connectOrCreate?: FiscalPeriodCreateOrConnectWithoutFiscalYearInput | FiscalPeriodCreateOrConnectWithoutFiscalYearInput[]
    upsert?: FiscalPeriodUpsertWithWhereUniqueWithoutFiscalYearInput | FiscalPeriodUpsertWithWhereUniqueWithoutFiscalYearInput[]
    createMany?: FiscalPeriodCreateManyFiscalYearInputEnvelope
    set?: FiscalPeriodWhereUniqueInput | FiscalPeriodWhereUniqueInput[]
    disconnect?: FiscalPeriodWhereUniqueInput | FiscalPeriodWhereUniqueInput[]
    delete?: FiscalPeriodWhereUniqueInput | FiscalPeriodWhereUniqueInput[]
    connect?: FiscalPeriodWhereUniqueInput | FiscalPeriodWhereUniqueInput[]
    update?: FiscalPeriodUpdateWithWhereUniqueWithoutFiscalYearInput | FiscalPeriodUpdateWithWhereUniqueWithoutFiscalYearInput[]
    updateMany?: FiscalPeriodUpdateManyWithWhereWithoutFiscalYearInput | FiscalPeriodUpdateManyWithWhereWithoutFiscalYearInput[]
    deleteMany?: FiscalPeriodScalarWhereInput | FiscalPeriodScalarWhereInput[]
  }

  export type FiscalYearCreateNestedOneWithoutPeriodsInput = {
    create?: XOR<FiscalYearCreateWithoutPeriodsInput, FiscalYearUncheckedCreateWithoutPeriodsInput>
    connectOrCreate?: FiscalYearCreateOrConnectWithoutPeriodsInput
    connect?: FiscalYearWhereUniqueInput
  }

  export type FiscalYearUpdateOneRequiredWithoutPeriodsNestedInput = {
    create?: XOR<FiscalYearCreateWithoutPeriodsInput, FiscalYearUncheckedCreateWithoutPeriodsInput>
    connectOrCreate?: FiscalYearCreateOrConnectWithoutPeriodsInput
    upsert?: FiscalYearUpsertWithoutPeriodsInput
    connect?: FiscalYearWhereUniqueInput
    update?: XOR<XOR<FiscalYearUpdateToOneWithWhereWithoutPeriodsInput, FiscalYearUpdateWithoutPeriodsInput>, FiscalYearUncheckedUpdateWithoutPeriodsInput>
  }

  export type ApprovalStepCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<ApprovalStepCreateWithoutWorkflowInput, ApprovalStepUncheckedCreateWithoutWorkflowInput> | ApprovalStepCreateWithoutWorkflowInput[] | ApprovalStepUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: ApprovalStepCreateOrConnectWithoutWorkflowInput | ApprovalStepCreateOrConnectWithoutWorkflowInput[]
    createMany?: ApprovalStepCreateManyWorkflowInputEnvelope
    connect?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
  }

  export type ApprovalRequestCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<ApprovalRequestCreateWithoutWorkflowInput, ApprovalRequestUncheckedCreateWithoutWorkflowInput> | ApprovalRequestCreateWithoutWorkflowInput[] | ApprovalRequestUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutWorkflowInput | ApprovalRequestCreateOrConnectWithoutWorkflowInput[]
    createMany?: ApprovalRequestCreateManyWorkflowInputEnvelope
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
  }

  export type ApprovalStepUncheckedCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<ApprovalStepCreateWithoutWorkflowInput, ApprovalStepUncheckedCreateWithoutWorkflowInput> | ApprovalStepCreateWithoutWorkflowInput[] | ApprovalStepUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: ApprovalStepCreateOrConnectWithoutWorkflowInput | ApprovalStepCreateOrConnectWithoutWorkflowInput[]
    createMany?: ApprovalStepCreateManyWorkflowInputEnvelope
    connect?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
  }

  export type ApprovalRequestUncheckedCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<ApprovalRequestCreateWithoutWorkflowInput, ApprovalRequestUncheckedCreateWithoutWorkflowInput> | ApprovalRequestCreateWithoutWorkflowInput[] | ApprovalRequestUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutWorkflowInput | ApprovalRequestCreateOrConnectWithoutWorkflowInput[]
    createMany?: ApprovalRequestCreateManyWorkflowInputEnvelope
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
  }

  export type ApprovalStepUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<ApprovalStepCreateWithoutWorkflowInput, ApprovalStepUncheckedCreateWithoutWorkflowInput> | ApprovalStepCreateWithoutWorkflowInput[] | ApprovalStepUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: ApprovalStepCreateOrConnectWithoutWorkflowInput | ApprovalStepCreateOrConnectWithoutWorkflowInput[]
    upsert?: ApprovalStepUpsertWithWhereUniqueWithoutWorkflowInput | ApprovalStepUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: ApprovalStepCreateManyWorkflowInputEnvelope
    set?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
    disconnect?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
    delete?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
    connect?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
    update?: ApprovalStepUpdateWithWhereUniqueWithoutWorkflowInput | ApprovalStepUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: ApprovalStepUpdateManyWithWhereWithoutWorkflowInput | ApprovalStepUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: ApprovalStepScalarWhereInput | ApprovalStepScalarWhereInput[]
  }

  export type ApprovalRequestUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<ApprovalRequestCreateWithoutWorkflowInput, ApprovalRequestUncheckedCreateWithoutWorkflowInput> | ApprovalRequestCreateWithoutWorkflowInput[] | ApprovalRequestUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutWorkflowInput | ApprovalRequestCreateOrConnectWithoutWorkflowInput[]
    upsert?: ApprovalRequestUpsertWithWhereUniqueWithoutWorkflowInput | ApprovalRequestUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: ApprovalRequestCreateManyWorkflowInputEnvelope
    set?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    disconnect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    delete?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    update?: ApprovalRequestUpdateWithWhereUniqueWithoutWorkflowInput | ApprovalRequestUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: ApprovalRequestUpdateManyWithWhereWithoutWorkflowInput | ApprovalRequestUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: ApprovalRequestScalarWhereInput | ApprovalRequestScalarWhereInput[]
  }

  export type ApprovalStepUncheckedUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<ApprovalStepCreateWithoutWorkflowInput, ApprovalStepUncheckedCreateWithoutWorkflowInput> | ApprovalStepCreateWithoutWorkflowInput[] | ApprovalStepUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: ApprovalStepCreateOrConnectWithoutWorkflowInput | ApprovalStepCreateOrConnectWithoutWorkflowInput[]
    upsert?: ApprovalStepUpsertWithWhereUniqueWithoutWorkflowInput | ApprovalStepUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: ApprovalStepCreateManyWorkflowInputEnvelope
    set?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
    disconnect?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
    delete?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
    connect?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
    update?: ApprovalStepUpdateWithWhereUniqueWithoutWorkflowInput | ApprovalStepUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: ApprovalStepUpdateManyWithWhereWithoutWorkflowInput | ApprovalStepUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: ApprovalStepScalarWhereInput | ApprovalStepScalarWhereInput[]
  }

  export type ApprovalRequestUncheckedUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<ApprovalRequestCreateWithoutWorkflowInput, ApprovalRequestUncheckedCreateWithoutWorkflowInput> | ApprovalRequestCreateWithoutWorkflowInput[] | ApprovalRequestUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutWorkflowInput | ApprovalRequestCreateOrConnectWithoutWorkflowInput[]
    upsert?: ApprovalRequestUpsertWithWhereUniqueWithoutWorkflowInput | ApprovalRequestUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: ApprovalRequestCreateManyWorkflowInputEnvelope
    set?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    disconnect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    delete?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    update?: ApprovalRequestUpdateWithWhereUniqueWithoutWorkflowInput | ApprovalRequestUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: ApprovalRequestUpdateManyWithWhereWithoutWorkflowInput | ApprovalRequestUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: ApprovalRequestScalarWhereInput | ApprovalRequestScalarWhereInput[]
  }

  export type ApprovalWorkflowCreateNestedOneWithoutStepsInput = {
    create?: XOR<ApprovalWorkflowCreateWithoutStepsInput, ApprovalWorkflowUncheckedCreateWithoutStepsInput>
    connectOrCreate?: ApprovalWorkflowCreateOrConnectWithoutStepsInput
    connect?: ApprovalWorkflowWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutApprovalStepInput = {
    create?: XOR<RoleCreateWithoutApprovalStepInput, RoleUncheckedCreateWithoutApprovalStepInput>
    connectOrCreate?: RoleCreateOrConnectWithoutApprovalStepInput
    connect?: RoleWhereUniqueInput
  }

  export type ApprovalRequestCreateNestedManyWithoutCurrentStepInput = {
    create?: XOR<ApprovalRequestCreateWithoutCurrentStepInput, ApprovalRequestUncheckedCreateWithoutCurrentStepInput> | ApprovalRequestCreateWithoutCurrentStepInput[] | ApprovalRequestUncheckedCreateWithoutCurrentStepInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutCurrentStepInput | ApprovalRequestCreateOrConnectWithoutCurrentStepInput[]
    createMany?: ApprovalRequestCreateManyCurrentStepInputEnvelope
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
  }

  export type ApprovalActionCreateNestedManyWithoutStepInput = {
    create?: XOR<ApprovalActionCreateWithoutStepInput, ApprovalActionUncheckedCreateWithoutStepInput> | ApprovalActionCreateWithoutStepInput[] | ApprovalActionUncheckedCreateWithoutStepInput[]
    connectOrCreate?: ApprovalActionCreateOrConnectWithoutStepInput | ApprovalActionCreateOrConnectWithoutStepInput[]
    createMany?: ApprovalActionCreateManyStepInputEnvelope
    connect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
  }

  export type ApprovalRequestUncheckedCreateNestedManyWithoutCurrentStepInput = {
    create?: XOR<ApprovalRequestCreateWithoutCurrentStepInput, ApprovalRequestUncheckedCreateWithoutCurrentStepInput> | ApprovalRequestCreateWithoutCurrentStepInput[] | ApprovalRequestUncheckedCreateWithoutCurrentStepInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutCurrentStepInput | ApprovalRequestCreateOrConnectWithoutCurrentStepInput[]
    createMany?: ApprovalRequestCreateManyCurrentStepInputEnvelope
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
  }

  export type ApprovalActionUncheckedCreateNestedManyWithoutStepInput = {
    create?: XOR<ApprovalActionCreateWithoutStepInput, ApprovalActionUncheckedCreateWithoutStepInput> | ApprovalActionCreateWithoutStepInput[] | ApprovalActionUncheckedCreateWithoutStepInput[]
    connectOrCreate?: ApprovalActionCreateOrConnectWithoutStepInput | ApprovalActionCreateOrConnectWithoutStepInput[]
    createMany?: ApprovalActionCreateManyStepInputEnvelope
    connect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
  }

  export type ApprovalWorkflowUpdateOneRequiredWithoutStepsNestedInput = {
    create?: XOR<ApprovalWorkflowCreateWithoutStepsInput, ApprovalWorkflowUncheckedCreateWithoutStepsInput>
    connectOrCreate?: ApprovalWorkflowCreateOrConnectWithoutStepsInput
    upsert?: ApprovalWorkflowUpsertWithoutStepsInput
    connect?: ApprovalWorkflowWhereUniqueInput
    update?: XOR<XOR<ApprovalWorkflowUpdateToOneWithWhereWithoutStepsInput, ApprovalWorkflowUpdateWithoutStepsInput>, ApprovalWorkflowUncheckedUpdateWithoutStepsInput>
  }

  export type RoleUpdateOneRequiredWithoutApprovalStepNestedInput = {
    create?: XOR<RoleCreateWithoutApprovalStepInput, RoleUncheckedCreateWithoutApprovalStepInput>
    connectOrCreate?: RoleCreateOrConnectWithoutApprovalStepInput
    upsert?: RoleUpsertWithoutApprovalStepInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutApprovalStepInput, RoleUpdateWithoutApprovalStepInput>, RoleUncheckedUpdateWithoutApprovalStepInput>
  }

  export type ApprovalRequestUpdateManyWithoutCurrentStepNestedInput = {
    create?: XOR<ApprovalRequestCreateWithoutCurrentStepInput, ApprovalRequestUncheckedCreateWithoutCurrentStepInput> | ApprovalRequestCreateWithoutCurrentStepInput[] | ApprovalRequestUncheckedCreateWithoutCurrentStepInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutCurrentStepInput | ApprovalRequestCreateOrConnectWithoutCurrentStepInput[]
    upsert?: ApprovalRequestUpsertWithWhereUniqueWithoutCurrentStepInput | ApprovalRequestUpsertWithWhereUniqueWithoutCurrentStepInput[]
    createMany?: ApprovalRequestCreateManyCurrentStepInputEnvelope
    set?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    disconnect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    delete?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    update?: ApprovalRequestUpdateWithWhereUniqueWithoutCurrentStepInput | ApprovalRequestUpdateWithWhereUniqueWithoutCurrentStepInput[]
    updateMany?: ApprovalRequestUpdateManyWithWhereWithoutCurrentStepInput | ApprovalRequestUpdateManyWithWhereWithoutCurrentStepInput[]
    deleteMany?: ApprovalRequestScalarWhereInput | ApprovalRequestScalarWhereInput[]
  }

  export type ApprovalActionUpdateManyWithoutStepNestedInput = {
    create?: XOR<ApprovalActionCreateWithoutStepInput, ApprovalActionUncheckedCreateWithoutStepInput> | ApprovalActionCreateWithoutStepInput[] | ApprovalActionUncheckedCreateWithoutStepInput[]
    connectOrCreate?: ApprovalActionCreateOrConnectWithoutStepInput | ApprovalActionCreateOrConnectWithoutStepInput[]
    upsert?: ApprovalActionUpsertWithWhereUniqueWithoutStepInput | ApprovalActionUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: ApprovalActionCreateManyStepInputEnvelope
    set?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    disconnect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    delete?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    connect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    update?: ApprovalActionUpdateWithWhereUniqueWithoutStepInput | ApprovalActionUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: ApprovalActionUpdateManyWithWhereWithoutStepInput | ApprovalActionUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: ApprovalActionScalarWhereInput | ApprovalActionScalarWhereInput[]
  }

  export type ApprovalRequestUncheckedUpdateManyWithoutCurrentStepNestedInput = {
    create?: XOR<ApprovalRequestCreateWithoutCurrentStepInput, ApprovalRequestUncheckedCreateWithoutCurrentStepInput> | ApprovalRequestCreateWithoutCurrentStepInput[] | ApprovalRequestUncheckedCreateWithoutCurrentStepInput[]
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutCurrentStepInput | ApprovalRequestCreateOrConnectWithoutCurrentStepInput[]
    upsert?: ApprovalRequestUpsertWithWhereUniqueWithoutCurrentStepInput | ApprovalRequestUpsertWithWhereUniqueWithoutCurrentStepInput[]
    createMany?: ApprovalRequestCreateManyCurrentStepInputEnvelope
    set?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    disconnect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    delete?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    connect?: ApprovalRequestWhereUniqueInput | ApprovalRequestWhereUniqueInput[]
    update?: ApprovalRequestUpdateWithWhereUniqueWithoutCurrentStepInput | ApprovalRequestUpdateWithWhereUniqueWithoutCurrentStepInput[]
    updateMany?: ApprovalRequestUpdateManyWithWhereWithoutCurrentStepInput | ApprovalRequestUpdateManyWithWhereWithoutCurrentStepInput[]
    deleteMany?: ApprovalRequestScalarWhereInput | ApprovalRequestScalarWhereInput[]
  }

  export type ApprovalActionUncheckedUpdateManyWithoutStepNestedInput = {
    create?: XOR<ApprovalActionCreateWithoutStepInput, ApprovalActionUncheckedCreateWithoutStepInput> | ApprovalActionCreateWithoutStepInput[] | ApprovalActionUncheckedCreateWithoutStepInput[]
    connectOrCreate?: ApprovalActionCreateOrConnectWithoutStepInput | ApprovalActionCreateOrConnectWithoutStepInput[]
    upsert?: ApprovalActionUpsertWithWhereUniqueWithoutStepInput | ApprovalActionUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: ApprovalActionCreateManyStepInputEnvelope
    set?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    disconnect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    delete?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    connect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    update?: ApprovalActionUpdateWithWhereUniqueWithoutStepInput | ApprovalActionUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: ApprovalActionUpdateManyWithWhereWithoutStepInput | ApprovalActionUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: ApprovalActionScalarWhereInput | ApprovalActionScalarWhereInput[]
  }

  export type ApprovalWorkflowCreateNestedOneWithoutApprovalRequestInput = {
    create?: XOR<ApprovalWorkflowCreateWithoutApprovalRequestInput, ApprovalWorkflowUncheckedCreateWithoutApprovalRequestInput>
    connectOrCreate?: ApprovalWorkflowCreateOrConnectWithoutApprovalRequestInput
    connect?: ApprovalWorkflowWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovalRequestInput = {
    create?: XOR<UserCreateWithoutApprovalRequestInput, UserUncheckedCreateWithoutApprovalRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalRequestInput
    connect?: UserWhereUniqueInput
  }

  export type ApprovalStepCreateNestedOneWithoutApprovalRequestInput = {
    create?: XOR<ApprovalStepCreateWithoutApprovalRequestInput, ApprovalStepUncheckedCreateWithoutApprovalRequestInput>
    connectOrCreate?: ApprovalStepCreateOrConnectWithoutApprovalRequestInput
    connect?: ApprovalStepWhereUniqueInput
  }

  export type ApprovalActionCreateNestedManyWithoutRequestInput = {
    create?: XOR<ApprovalActionCreateWithoutRequestInput, ApprovalActionUncheckedCreateWithoutRequestInput> | ApprovalActionCreateWithoutRequestInput[] | ApprovalActionUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: ApprovalActionCreateOrConnectWithoutRequestInput | ApprovalActionCreateOrConnectWithoutRequestInput[]
    createMany?: ApprovalActionCreateManyRequestInputEnvelope
    connect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
  }

  export type ApprovalActionUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<ApprovalActionCreateWithoutRequestInput, ApprovalActionUncheckedCreateWithoutRequestInput> | ApprovalActionCreateWithoutRequestInput[] | ApprovalActionUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: ApprovalActionCreateOrConnectWithoutRequestInput | ApprovalActionCreateOrConnectWithoutRequestInput[]
    createMany?: ApprovalActionCreateManyRequestInputEnvelope
    connect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
  }

  export type ApprovalWorkflowUpdateOneRequiredWithoutApprovalRequestNestedInput = {
    create?: XOR<ApprovalWorkflowCreateWithoutApprovalRequestInput, ApprovalWorkflowUncheckedCreateWithoutApprovalRequestInput>
    connectOrCreate?: ApprovalWorkflowCreateOrConnectWithoutApprovalRequestInput
    upsert?: ApprovalWorkflowUpsertWithoutApprovalRequestInput
    connect?: ApprovalWorkflowWhereUniqueInput
    update?: XOR<XOR<ApprovalWorkflowUpdateToOneWithWhereWithoutApprovalRequestInput, ApprovalWorkflowUpdateWithoutApprovalRequestInput>, ApprovalWorkflowUncheckedUpdateWithoutApprovalRequestInput>
  }

  export type UserUpdateOneRequiredWithoutApprovalRequestNestedInput = {
    create?: XOR<UserCreateWithoutApprovalRequestInput, UserUncheckedCreateWithoutApprovalRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalRequestInput
    upsert?: UserUpsertWithoutApprovalRequestInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovalRequestInput, UserUpdateWithoutApprovalRequestInput>, UserUncheckedUpdateWithoutApprovalRequestInput>
  }

  export type ApprovalStepUpdateOneWithoutApprovalRequestNestedInput = {
    create?: XOR<ApprovalStepCreateWithoutApprovalRequestInput, ApprovalStepUncheckedCreateWithoutApprovalRequestInput>
    connectOrCreate?: ApprovalStepCreateOrConnectWithoutApprovalRequestInput
    upsert?: ApprovalStepUpsertWithoutApprovalRequestInput
    disconnect?: ApprovalStepWhereInput | boolean
    delete?: ApprovalStepWhereInput | boolean
    connect?: ApprovalStepWhereUniqueInput
    update?: XOR<XOR<ApprovalStepUpdateToOneWithWhereWithoutApprovalRequestInput, ApprovalStepUpdateWithoutApprovalRequestInput>, ApprovalStepUncheckedUpdateWithoutApprovalRequestInput>
  }

  export type ApprovalActionUpdateManyWithoutRequestNestedInput = {
    create?: XOR<ApprovalActionCreateWithoutRequestInput, ApprovalActionUncheckedCreateWithoutRequestInput> | ApprovalActionCreateWithoutRequestInput[] | ApprovalActionUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: ApprovalActionCreateOrConnectWithoutRequestInput | ApprovalActionCreateOrConnectWithoutRequestInput[]
    upsert?: ApprovalActionUpsertWithWhereUniqueWithoutRequestInput | ApprovalActionUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: ApprovalActionCreateManyRequestInputEnvelope
    set?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    disconnect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    delete?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    connect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    update?: ApprovalActionUpdateWithWhereUniqueWithoutRequestInput | ApprovalActionUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: ApprovalActionUpdateManyWithWhereWithoutRequestInput | ApprovalActionUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: ApprovalActionScalarWhereInput | ApprovalActionScalarWhereInput[]
  }

  export type ApprovalActionUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<ApprovalActionCreateWithoutRequestInput, ApprovalActionUncheckedCreateWithoutRequestInput> | ApprovalActionCreateWithoutRequestInput[] | ApprovalActionUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: ApprovalActionCreateOrConnectWithoutRequestInput | ApprovalActionCreateOrConnectWithoutRequestInput[]
    upsert?: ApprovalActionUpsertWithWhereUniqueWithoutRequestInput | ApprovalActionUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: ApprovalActionCreateManyRequestInputEnvelope
    set?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    disconnect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    delete?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    connect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    update?: ApprovalActionUpdateWithWhereUniqueWithoutRequestInput | ApprovalActionUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: ApprovalActionUpdateManyWithWhereWithoutRequestInput | ApprovalActionUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: ApprovalActionScalarWhereInput | ApprovalActionScalarWhereInput[]
  }

  export type ApprovalRequestCreateNestedOneWithoutActionsInput = {
    create?: XOR<ApprovalRequestCreateWithoutActionsInput, ApprovalRequestUncheckedCreateWithoutActionsInput>
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutActionsInput
    connect?: ApprovalRequestWhereUniqueInput
  }

  export type ApprovalStepCreateNestedOneWithoutApprovalActionInput = {
    create?: XOR<ApprovalStepCreateWithoutApprovalActionInput, ApprovalStepUncheckedCreateWithoutApprovalActionInput>
    connectOrCreate?: ApprovalStepCreateOrConnectWithoutApprovalActionInput
    connect?: ApprovalStepWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovalActionInput = {
    create?: XOR<UserCreateWithoutApprovalActionInput, UserUncheckedCreateWithoutApprovalActionInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalActionInput
    connect?: UserWhereUniqueInput
  }

  export type ApprovalRequestUpdateOneRequiredWithoutActionsNestedInput = {
    create?: XOR<ApprovalRequestCreateWithoutActionsInput, ApprovalRequestUncheckedCreateWithoutActionsInput>
    connectOrCreate?: ApprovalRequestCreateOrConnectWithoutActionsInput
    upsert?: ApprovalRequestUpsertWithoutActionsInput
    connect?: ApprovalRequestWhereUniqueInput
    update?: XOR<XOR<ApprovalRequestUpdateToOneWithWhereWithoutActionsInput, ApprovalRequestUpdateWithoutActionsInput>, ApprovalRequestUncheckedUpdateWithoutActionsInput>
  }

  export type ApprovalStepUpdateOneRequiredWithoutApprovalActionNestedInput = {
    create?: XOR<ApprovalStepCreateWithoutApprovalActionInput, ApprovalStepUncheckedCreateWithoutApprovalActionInput>
    connectOrCreate?: ApprovalStepCreateOrConnectWithoutApprovalActionInput
    upsert?: ApprovalStepUpsertWithoutApprovalActionInput
    connect?: ApprovalStepWhereUniqueInput
    update?: XOR<XOR<ApprovalStepUpdateToOneWithWhereWithoutApprovalActionInput, ApprovalStepUpdateWithoutApprovalActionInput>, ApprovalStepUncheckedUpdateWithoutApprovalActionInput>
  }

  export type UserUpdateOneRequiredWithoutApprovalActionNestedInput = {
    create?: XOR<UserCreateWithoutApprovalActionInput, UserUncheckedCreateWithoutApprovalActionInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalActionInput
    upsert?: UserUpsertWithoutApprovalActionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovalActionInput, UserUpdateWithoutApprovalActionInput>, UserUncheckedUpdateWithoutApprovalActionInput>
  }

  export type AssetCreateNestedManyWithoutCategoryInput = {
    create?: XOR<AssetCreateWithoutCategoryInput, AssetUncheckedCreateWithoutCategoryInput> | AssetCreateWithoutCategoryInput[] | AssetUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutCategoryInput | AssetCreateOrConnectWithoutCategoryInput[]
    createMany?: AssetCreateManyCategoryInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type ChartOfAccountCreateNestedOneWithoutAssetCategoriesAssetInput = {
    create?: XOR<ChartOfAccountCreateWithoutAssetCategoriesAssetInput, ChartOfAccountUncheckedCreateWithoutAssetCategoriesAssetInput>
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutAssetCategoriesAssetInput
    connect?: ChartOfAccountWhereUniqueInput
  }

  export type ChartOfAccountCreateNestedOneWithoutAssetCategoriesDepreciationInput = {
    create?: XOR<ChartOfAccountCreateWithoutAssetCategoriesDepreciationInput, ChartOfAccountUncheckedCreateWithoutAssetCategoriesDepreciationInput>
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutAssetCategoriesDepreciationInput
    connect?: ChartOfAccountWhereUniqueInput
  }

  export type ChartOfAccountCreateNestedOneWithoutAssetCategoriesAccumulatedInput = {
    create?: XOR<ChartOfAccountCreateWithoutAssetCategoriesAccumulatedInput, ChartOfAccountUncheckedCreateWithoutAssetCategoriesAccumulatedInput>
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutAssetCategoriesAccumulatedInput
    connect?: ChartOfAccountWhereUniqueInput
  }

  export type AssetUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<AssetCreateWithoutCategoryInput, AssetUncheckedCreateWithoutCategoryInput> | AssetCreateWithoutCategoryInput[] | AssetUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutCategoryInput | AssetCreateOrConnectWithoutCategoryInput[]
    createMany?: AssetCreateManyCategoryInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type AssetUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<AssetCreateWithoutCategoryInput, AssetUncheckedCreateWithoutCategoryInput> | AssetCreateWithoutCategoryInput[] | AssetUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutCategoryInput | AssetCreateOrConnectWithoutCategoryInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutCategoryInput | AssetUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: AssetCreateManyCategoryInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutCategoryInput | AssetUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutCategoryInput | AssetUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type ChartOfAccountUpdateOneRequiredWithoutAssetCategoriesAssetNestedInput = {
    create?: XOR<ChartOfAccountCreateWithoutAssetCategoriesAssetInput, ChartOfAccountUncheckedCreateWithoutAssetCategoriesAssetInput>
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutAssetCategoriesAssetInput
    upsert?: ChartOfAccountUpsertWithoutAssetCategoriesAssetInput
    connect?: ChartOfAccountWhereUniqueInput
    update?: XOR<XOR<ChartOfAccountUpdateToOneWithWhereWithoutAssetCategoriesAssetInput, ChartOfAccountUpdateWithoutAssetCategoriesAssetInput>, ChartOfAccountUncheckedUpdateWithoutAssetCategoriesAssetInput>
  }

  export type ChartOfAccountUpdateOneRequiredWithoutAssetCategoriesDepreciationNestedInput = {
    create?: XOR<ChartOfAccountCreateWithoutAssetCategoriesDepreciationInput, ChartOfAccountUncheckedCreateWithoutAssetCategoriesDepreciationInput>
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutAssetCategoriesDepreciationInput
    upsert?: ChartOfAccountUpsertWithoutAssetCategoriesDepreciationInput
    connect?: ChartOfAccountWhereUniqueInput
    update?: XOR<XOR<ChartOfAccountUpdateToOneWithWhereWithoutAssetCategoriesDepreciationInput, ChartOfAccountUpdateWithoutAssetCategoriesDepreciationInput>, ChartOfAccountUncheckedUpdateWithoutAssetCategoriesDepreciationInput>
  }

  export type ChartOfAccountUpdateOneRequiredWithoutAssetCategoriesAccumulatedNestedInput = {
    create?: XOR<ChartOfAccountCreateWithoutAssetCategoriesAccumulatedInput, ChartOfAccountUncheckedCreateWithoutAssetCategoriesAccumulatedInput>
    connectOrCreate?: ChartOfAccountCreateOrConnectWithoutAssetCategoriesAccumulatedInput
    upsert?: ChartOfAccountUpsertWithoutAssetCategoriesAccumulatedInput
    connect?: ChartOfAccountWhereUniqueInput
    update?: XOR<XOR<ChartOfAccountUpdateToOneWithWhereWithoutAssetCategoriesAccumulatedInput, ChartOfAccountUpdateWithoutAssetCategoriesAccumulatedInput>, ChartOfAccountUncheckedUpdateWithoutAssetCategoriesAccumulatedInput>
  }

  export type AssetUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<AssetCreateWithoutCategoryInput, AssetUncheckedCreateWithoutCategoryInput> | AssetCreateWithoutCategoryInput[] | AssetUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutCategoryInput | AssetCreateOrConnectWithoutCategoryInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutCategoryInput | AssetUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: AssetCreateManyCategoryInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutCategoryInput | AssetUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutCategoryInput | AssetUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type AssetCategoryCreateNestedOneWithoutAssetsInput = {
    create?: XOR<AssetCategoryCreateWithoutAssetsInput, AssetCategoryUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: AssetCategoryCreateOrConnectWithoutAssetsInput
    connect?: AssetCategoryWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutAssetsInput = {
    create?: XOR<LocationCreateWithoutAssetsInput, LocationUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutAssetsInput
    connect?: LocationWhereUniqueInput
  }

  export type PurchaseCreateNestedOneWithoutAssetsInput = {
    create?: XOR<PurchaseCreateWithoutAssetsInput, PurchaseUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutAssetsInput
    connect?: PurchaseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssetsCreatedInput = {
    create?: XOR<UserCreateWithoutAssetsCreatedInput, UserUncheckedCreateWithoutAssetsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssetsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type AssetDepreciationCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetDepreciationCreateWithoutAssetInput, AssetDepreciationUncheckedCreateWithoutAssetInput> | AssetDepreciationCreateWithoutAssetInput[] | AssetDepreciationUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetDepreciationCreateOrConnectWithoutAssetInput | AssetDepreciationCreateOrConnectWithoutAssetInput[]
    createMany?: AssetDepreciationCreateManyAssetInputEnvelope
    connect?: AssetDepreciationWhereUniqueInput | AssetDepreciationWhereUniqueInput[]
  }

  export type AssetDisposalCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetDisposalCreateWithoutAssetInput, AssetDisposalUncheckedCreateWithoutAssetInput> | AssetDisposalCreateWithoutAssetInput[] | AssetDisposalUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetDisposalCreateOrConnectWithoutAssetInput | AssetDisposalCreateOrConnectWithoutAssetInput[]
    createMany?: AssetDisposalCreateManyAssetInputEnvelope
    connect?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
  }

  export type VendorCreateNestedOneWithoutAssetsInput = {
    create?: XOR<VendorCreateWithoutAssetsInput, VendorUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutAssetsInput
    connect?: VendorWhereUniqueInput
  }

  export type AssetDepreciationUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetDepreciationCreateWithoutAssetInput, AssetDepreciationUncheckedCreateWithoutAssetInput> | AssetDepreciationCreateWithoutAssetInput[] | AssetDepreciationUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetDepreciationCreateOrConnectWithoutAssetInput | AssetDepreciationCreateOrConnectWithoutAssetInput[]
    createMany?: AssetDepreciationCreateManyAssetInputEnvelope
    connect?: AssetDepreciationWhereUniqueInput | AssetDepreciationWhereUniqueInput[]
  }

  export type AssetDisposalUncheckedCreateNestedManyWithoutAssetInput = {
    create?: XOR<AssetDisposalCreateWithoutAssetInput, AssetDisposalUncheckedCreateWithoutAssetInput> | AssetDisposalCreateWithoutAssetInput[] | AssetDisposalUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetDisposalCreateOrConnectWithoutAssetInput | AssetDisposalCreateOrConnectWithoutAssetInput[]
    createMany?: AssetDisposalCreateManyAssetInputEnvelope
    connect?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
  }

  export type AssetCategoryUpdateOneRequiredWithoutAssetsNestedInput = {
    create?: XOR<AssetCategoryCreateWithoutAssetsInput, AssetCategoryUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: AssetCategoryCreateOrConnectWithoutAssetsInput
    upsert?: AssetCategoryUpsertWithoutAssetsInput
    connect?: AssetCategoryWhereUniqueInput
    update?: XOR<XOR<AssetCategoryUpdateToOneWithWhereWithoutAssetsInput, AssetCategoryUpdateWithoutAssetsInput>, AssetCategoryUncheckedUpdateWithoutAssetsInput>
  }

  export type LocationUpdateOneWithoutAssetsNestedInput = {
    create?: XOR<LocationCreateWithoutAssetsInput, LocationUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutAssetsInput
    upsert?: LocationUpsertWithoutAssetsInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutAssetsInput, LocationUpdateWithoutAssetsInput>, LocationUncheckedUpdateWithoutAssetsInput>
  }

  export type PurchaseUpdateOneWithoutAssetsNestedInput = {
    create?: XOR<PurchaseCreateWithoutAssetsInput, PurchaseUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: PurchaseCreateOrConnectWithoutAssetsInput
    upsert?: PurchaseUpsertWithoutAssetsInput
    disconnect?: PurchaseWhereInput | boolean
    delete?: PurchaseWhereInput | boolean
    connect?: PurchaseWhereUniqueInput
    update?: XOR<XOR<PurchaseUpdateToOneWithWhereWithoutAssetsInput, PurchaseUpdateWithoutAssetsInput>, PurchaseUncheckedUpdateWithoutAssetsInput>
  }

  export type UserUpdateOneRequiredWithoutAssetsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutAssetsCreatedInput, UserUncheckedCreateWithoutAssetsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssetsCreatedInput
    upsert?: UserUpsertWithoutAssetsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssetsCreatedInput, UserUpdateWithoutAssetsCreatedInput>, UserUncheckedUpdateWithoutAssetsCreatedInput>
  }

  export type AssetDepreciationUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetDepreciationCreateWithoutAssetInput, AssetDepreciationUncheckedCreateWithoutAssetInput> | AssetDepreciationCreateWithoutAssetInput[] | AssetDepreciationUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetDepreciationCreateOrConnectWithoutAssetInput | AssetDepreciationCreateOrConnectWithoutAssetInput[]
    upsert?: AssetDepreciationUpsertWithWhereUniqueWithoutAssetInput | AssetDepreciationUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetDepreciationCreateManyAssetInputEnvelope
    set?: AssetDepreciationWhereUniqueInput | AssetDepreciationWhereUniqueInput[]
    disconnect?: AssetDepreciationWhereUniqueInput | AssetDepreciationWhereUniqueInput[]
    delete?: AssetDepreciationWhereUniqueInput | AssetDepreciationWhereUniqueInput[]
    connect?: AssetDepreciationWhereUniqueInput | AssetDepreciationWhereUniqueInput[]
    update?: AssetDepreciationUpdateWithWhereUniqueWithoutAssetInput | AssetDepreciationUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetDepreciationUpdateManyWithWhereWithoutAssetInput | AssetDepreciationUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetDepreciationScalarWhereInput | AssetDepreciationScalarWhereInput[]
  }

  export type AssetDisposalUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetDisposalCreateWithoutAssetInput, AssetDisposalUncheckedCreateWithoutAssetInput> | AssetDisposalCreateWithoutAssetInput[] | AssetDisposalUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetDisposalCreateOrConnectWithoutAssetInput | AssetDisposalCreateOrConnectWithoutAssetInput[]
    upsert?: AssetDisposalUpsertWithWhereUniqueWithoutAssetInput | AssetDisposalUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetDisposalCreateManyAssetInputEnvelope
    set?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
    disconnect?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
    delete?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
    connect?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
    update?: AssetDisposalUpdateWithWhereUniqueWithoutAssetInput | AssetDisposalUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetDisposalUpdateManyWithWhereWithoutAssetInput | AssetDisposalUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetDisposalScalarWhereInput | AssetDisposalScalarWhereInput[]
  }

  export type VendorUpdateOneWithoutAssetsNestedInput = {
    create?: XOR<VendorCreateWithoutAssetsInput, VendorUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutAssetsInput
    upsert?: VendorUpsertWithoutAssetsInput
    disconnect?: VendorWhereInput | boolean
    delete?: VendorWhereInput | boolean
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutAssetsInput, VendorUpdateWithoutAssetsInput>, VendorUncheckedUpdateWithoutAssetsInput>
  }

  export type AssetDepreciationUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetDepreciationCreateWithoutAssetInput, AssetDepreciationUncheckedCreateWithoutAssetInput> | AssetDepreciationCreateWithoutAssetInput[] | AssetDepreciationUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetDepreciationCreateOrConnectWithoutAssetInput | AssetDepreciationCreateOrConnectWithoutAssetInput[]
    upsert?: AssetDepreciationUpsertWithWhereUniqueWithoutAssetInput | AssetDepreciationUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetDepreciationCreateManyAssetInputEnvelope
    set?: AssetDepreciationWhereUniqueInput | AssetDepreciationWhereUniqueInput[]
    disconnect?: AssetDepreciationWhereUniqueInput | AssetDepreciationWhereUniqueInput[]
    delete?: AssetDepreciationWhereUniqueInput | AssetDepreciationWhereUniqueInput[]
    connect?: AssetDepreciationWhereUniqueInput | AssetDepreciationWhereUniqueInput[]
    update?: AssetDepreciationUpdateWithWhereUniqueWithoutAssetInput | AssetDepreciationUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetDepreciationUpdateManyWithWhereWithoutAssetInput | AssetDepreciationUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetDepreciationScalarWhereInput | AssetDepreciationScalarWhereInput[]
  }

  export type AssetDisposalUncheckedUpdateManyWithoutAssetNestedInput = {
    create?: XOR<AssetDisposalCreateWithoutAssetInput, AssetDisposalUncheckedCreateWithoutAssetInput> | AssetDisposalCreateWithoutAssetInput[] | AssetDisposalUncheckedCreateWithoutAssetInput[]
    connectOrCreate?: AssetDisposalCreateOrConnectWithoutAssetInput | AssetDisposalCreateOrConnectWithoutAssetInput[]
    upsert?: AssetDisposalUpsertWithWhereUniqueWithoutAssetInput | AssetDisposalUpsertWithWhereUniqueWithoutAssetInput[]
    createMany?: AssetDisposalCreateManyAssetInputEnvelope
    set?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
    disconnect?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
    delete?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
    connect?: AssetDisposalWhereUniqueInput | AssetDisposalWhereUniqueInput[]
    update?: AssetDisposalUpdateWithWhereUniqueWithoutAssetInput | AssetDisposalUpdateWithWhereUniqueWithoutAssetInput[]
    updateMany?: AssetDisposalUpdateManyWithWhereWithoutAssetInput | AssetDisposalUpdateManyWithWhereWithoutAssetInput[]
    deleteMany?: AssetDisposalScalarWhereInput | AssetDisposalScalarWhereInput[]
  }

  export type AssetCreateNestedOneWithoutDepreciationEntriesInput = {
    create?: XOR<AssetCreateWithoutDepreciationEntriesInput, AssetUncheckedCreateWithoutDepreciationEntriesInput>
    connectOrCreate?: AssetCreateOrConnectWithoutDepreciationEntriesInput
    connect?: AssetWhereUniqueInput
  }

  export type JournalCreateNestedOneWithoutAssetDepreciationInput = {
    create?: XOR<JournalCreateWithoutAssetDepreciationInput, JournalUncheckedCreateWithoutAssetDepreciationInput>
    connectOrCreate?: JournalCreateOrConnectWithoutAssetDepreciationInput
    connect?: JournalWhereUniqueInput
  }

  export type AssetUpdateOneRequiredWithoutDepreciationEntriesNestedInput = {
    create?: XOR<AssetCreateWithoutDepreciationEntriesInput, AssetUncheckedCreateWithoutDepreciationEntriesInput>
    connectOrCreate?: AssetCreateOrConnectWithoutDepreciationEntriesInput
    upsert?: AssetUpsertWithoutDepreciationEntriesInput
    connect?: AssetWhereUniqueInput
    update?: XOR<XOR<AssetUpdateToOneWithWhereWithoutDepreciationEntriesInput, AssetUpdateWithoutDepreciationEntriesInput>, AssetUncheckedUpdateWithoutDepreciationEntriesInput>
  }

  export type JournalUpdateOneWithoutAssetDepreciationNestedInput = {
    create?: XOR<JournalCreateWithoutAssetDepreciationInput, JournalUncheckedCreateWithoutAssetDepreciationInput>
    connectOrCreate?: JournalCreateOrConnectWithoutAssetDepreciationInput
    upsert?: JournalUpsertWithoutAssetDepreciationInput
    disconnect?: JournalWhereInput | boolean
    delete?: JournalWhereInput | boolean
    connect?: JournalWhereUniqueInput
    update?: XOR<XOR<JournalUpdateToOneWithWhereWithoutAssetDepreciationInput, JournalUpdateWithoutAssetDepreciationInput>, JournalUncheckedUpdateWithoutAssetDepreciationInput>
  }

  export type AssetCreateNestedOneWithoutDisposalsInput = {
    create?: XOR<AssetCreateWithoutDisposalsInput, AssetUncheckedCreateWithoutDisposalsInput>
    connectOrCreate?: AssetCreateOrConnectWithoutDisposalsInput
    connect?: AssetWhereUniqueInput
  }

  export type JournalCreateNestedOneWithoutAssetDisposalsInput = {
    create?: XOR<JournalCreateWithoutAssetDisposalsInput, JournalUncheckedCreateWithoutAssetDisposalsInput>
    connectOrCreate?: JournalCreateOrConnectWithoutAssetDisposalsInput
    connect?: JournalWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssetDisposalsInput = {
    create?: XOR<UserCreateWithoutAssetDisposalsInput, UserUncheckedCreateWithoutAssetDisposalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssetDisposalsInput
    connect?: UserWhereUniqueInput
  }

  export type AssetUpdateOneRequiredWithoutDisposalsNestedInput = {
    create?: XOR<AssetCreateWithoutDisposalsInput, AssetUncheckedCreateWithoutDisposalsInput>
    connectOrCreate?: AssetCreateOrConnectWithoutDisposalsInput
    upsert?: AssetUpsertWithoutDisposalsInput
    connect?: AssetWhereUniqueInput
    update?: XOR<XOR<AssetUpdateToOneWithWhereWithoutDisposalsInput, AssetUpdateWithoutDisposalsInput>, AssetUncheckedUpdateWithoutDisposalsInput>
  }

  export type JournalUpdateOneWithoutAssetDisposalsNestedInput = {
    create?: XOR<JournalCreateWithoutAssetDisposalsInput, JournalUncheckedCreateWithoutAssetDisposalsInput>
    connectOrCreate?: JournalCreateOrConnectWithoutAssetDisposalsInput
    upsert?: JournalUpsertWithoutAssetDisposalsInput
    disconnect?: JournalWhereInput | boolean
    delete?: JournalWhereInput | boolean
    connect?: JournalWhereUniqueInput
    update?: XOR<XOR<JournalUpdateToOneWithWhereWithoutAssetDisposalsInput, JournalUpdateWithoutAssetDisposalsInput>, JournalUncheckedUpdateWithoutAssetDisposalsInput>
  }

  export type UserUpdateOneRequiredWithoutAssetDisposalsNestedInput = {
    create?: XOR<UserCreateWithoutAssetDisposalsInput, UserUncheckedCreateWithoutAssetDisposalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssetDisposalsInput
    upsert?: UserUpsertWithoutAssetDisposalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssetDisposalsInput, UserUpdateWithoutAssetDisposalsInput>, UserUncheckedUpdateWithoutAssetDisposalsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeFilter<$PrismaModel> | $Enums.ItemType
  }

  export type NestedEnumCostingMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.CostingMethod | EnumCostingMethodFieldRefInput<$PrismaModel>
    in?: $Enums.CostingMethod[] | ListEnumCostingMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.CostingMethod[] | ListEnumCostingMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumCostingMethodFilter<$PrismaModel> | $Enums.CostingMethod
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.ItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemTypeFilter<$PrismaModel>
    _max?: NestedEnumItemTypeFilter<$PrismaModel>
  }

  export type NestedEnumCostingMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CostingMethod | EnumCostingMethodFieldRefInput<$PrismaModel>
    in?: $Enums.CostingMethod[] | ListEnumCostingMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.CostingMethod[] | ListEnumCostingMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumCostingMethodWithAggregatesFilter<$PrismaModel> | $Enums.CostingMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCostingMethodFilter<$PrismaModel>
    _max?: NestedEnumCostingMethodFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumLedgerDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerDirection | EnumLedgerDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerDirection[] | ListEnumLedgerDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerDirection[] | ListEnumLedgerDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerDirectionFilter<$PrismaModel> | $Enums.LedgerDirection
  }

  export type NestedEnumLedgerDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerDirection | EnumLedgerDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerDirection[] | ListEnumLedgerDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerDirection[] | ListEnumLedgerDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerDirectionWithAggregatesFilter<$PrismaModel> | $Enums.LedgerDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerDirectionFilter<$PrismaModel>
    _max?: NestedEnumLedgerDirectionFilter<$PrismaModel>
  }

  export type NestedEnumProductionOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductionOrderStatus | EnumProductionOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductionOrderStatus[] | ListEnumProductionOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductionOrderStatus[] | ListEnumProductionOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductionOrderStatusFilter<$PrismaModel> | $Enums.ProductionOrderStatus
  }

  export type NestedEnumProductionOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductionOrderStatus | EnumProductionOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductionOrderStatus[] | ListEnumProductionOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductionOrderStatus[] | ListEnumProductionOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductionOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductionOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductionOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumProductionOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumWipLedgerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WipLedgerType | EnumWipLedgerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WipLedgerType[] | ListEnumWipLedgerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WipLedgerType[] | ListEnumWipLedgerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWipLedgerTypeFilter<$PrismaModel> | $Enums.WipLedgerType
  }

  export type NestedEnumWipLedgerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WipLedgerType | EnumWipLedgerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WipLedgerType[] | ListEnumWipLedgerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WipLedgerType[] | ListEnumWipLedgerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWipLedgerTypeWithAggregatesFilter<$PrismaModel> | $Enums.WipLedgerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWipLedgerTypeFilter<$PrismaModel>
    _max?: NestedEnumWipLedgerTypeFilter<$PrismaModel>
  }

  export type NestedEnumPurchaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseStatusFilter<$PrismaModel> | $Enums.PurchaseStatus
  }

  export type NestedEnumPurchaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseStatusFilter<$PrismaModel>
    _max?: NestedEnumPurchaseStatusFilter<$PrismaModel>
  }

  export type NestedEnumSaleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SaleStatus | EnumSaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SaleStatus[] | ListEnumSaleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SaleStatus[] | ListEnumSaleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSaleStatusFilter<$PrismaModel> | $Enums.SaleStatus
  }

  export type NestedEnumSaleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SaleStatus | EnumSaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SaleStatus[] | ListEnumSaleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SaleStatus[] | ListEnumSaleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSaleStatusWithAggregatesFilter<$PrismaModel> | $Enums.SaleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSaleStatusFilter<$PrismaModel>
    _max?: NestedEnumSaleStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type UserRoleCreateWithoutUserInput = {
    id?: string
    role: RoleCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    id?: string
    roleId: string
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type JournalCreateWithoutPostedByUserInput = {
    id?: string
    journalNo: string
    date: Date | string
    memo?: string | null
    postedAt?: Date | string
    journalLines?: JournalLineCreateNestedManyWithoutJournalInput
    assetDepreciation?: AssetDepreciationCreateNestedManyWithoutJournalInput
    assetDisposals?: AssetDisposalCreateNestedManyWithoutJournalInput
  }

  export type JournalUncheckedCreateWithoutPostedByUserInput = {
    id?: string
    journalNo: string
    date: Date | string
    memo?: string | null
    postedAt?: Date | string
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutJournalInput
    assetDepreciation?: AssetDepreciationUncheckedCreateNestedManyWithoutJournalInput
    assetDisposals?: AssetDisposalUncheckedCreateNestedManyWithoutJournalInput
  }

  export type JournalCreateOrConnectWithoutPostedByUserInput = {
    where: JournalWhereUniqueInput
    create: XOR<JournalCreateWithoutPostedByUserInput, JournalUncheckedCreateWithoutPostedByUserInput>
  }

  export type JournalCreateManyPostedByUserInputEnvelope = {
    data: JournalCreateManyPostedByUserInput | JournalCreateManyPostedByUserInput[]
    skipDuplicates?: boolean
  }

  export type InventoryLedgerCreateWithoutUserInput = {
    id?: string
    refType: string
    refId: string
    direction: $Enums.LedgerDirection
    qty: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    value: Decimal | DecimalJsLike | number | string
    runningQty: Decimal | DecimalJsLike | number | string
    runningValue: Decimal | DecimalJsLike | number | string
    runningAvgCost: Decimal | DecimalJsLike | number | string
    postedAt?: Date | string
    item: ItemCreateNestedOneWithoutInventoryLedgerInput
    warehouse: WarehouseCreateNestedOneWithoutInventoryLedgerInput
    batch?: InventoryBatchCreateNestedOneWithoutInventoryLedgerInput
  }

  export type InventoryLedgerUncheckedCreateWithoutUserInput = {
    id?: string
    itemId: string
    warehouseId: string
    refType: string
    refId: string
    direction: $Enums.LedgerDirection
    qty: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    value: Decimal | DecimalJsLike | number | string
    runningQty: Decimal | DecimalJsLike | number | string
    runningValue: Decimal | DecimalJsLike | number | string
    runningAvgCost: Decimal | DecimalJsLike | number | string
    batchId?: string | null
    postedAt?: Date | string
  }

  export type InventoryLedgerCreateOrConnectWithoutUserInput = {
    where: InventoryLedgerWhereUniqueInput
    create: XOR<InventoryLedgerCreateWithoutUserInput, InventoryLedgerUncheckedCreateWithoutUserInput>
  }

  export type InventoryLedgerCreateManyUserInputEnvelope = {
    data: InventoryLedgerCreateManyUserInput | InventoryLedgerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CashTransactionCreateWithoutUserInput = {
    id?: string
    transactionNo: string
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    refType?: string | null
    refId?: string | null
    transactionDate: Date | string
    isReconciled?: boolean
    reconciledAt?: Date | string | null
    createdAt?: Date | string
    reference: string
    cashAccount: CashAccountCreateNestedOneWithoutCashTransactionsInput
    glAccount?: ChartOfAccountCreateNestedOneWithoutCashTransactionsGLInput
    contraAccount?: ChartOfAccountCreateNestedOneWithoutCashTransactionsContraInput
  }

  export type CashTransactionUncheckedCreateWithoutUserInput = {
    id?: string
    transactionNo: string
    cashAccountId: string
    glAccountId?: string | null
    contraAccountId?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    refType?: string | null
    refId?: string | null
    transactionDate: Date | string
    isReconciled?: boolean
    reconciledAt?: Date | string | null
    createdAt?: Date | string
    reference: string
  }

  export type CashTransactionCreateOrConnectWithoutUserInput = {
    where: CashTransactionWhereUniqueInput
    create: XOR<CashTransactionCreateWithoutUserInput, CashTransactionUncheckedCreateWithoutUserInput>
  }

  export type CashTransactionCreateManyUserInputEnvelope = {
    data: CashTransactionCreateManyUserInput | CashTransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SalesReceiptCreateWithoutUserInput = {
    id?: string
    receiptNo: string
    amountReceived: Decimal | DecimalJsLike | number | string
    receiptDate: Date | string
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    sale: SaleCreateNestedOneWithoutSalesReceiptsInput
    customer: CustomerCreateNestedOneWithoutSalesReceiptsInput
    cashAccount: CashAccountCreateNestedOneWithoutSalesReceiptsInput
  }

  export type SalesReceiptUncheckedCreateWithoutUserInput = {
    id?: string
    receiptNo: string
    saleId: string
    customerId: string
    cashAccountId: string
    amountReceived: Decimal | DecimalJsLike | number | string
    receiptDate: Date | string
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type SalesReceiptCreateOrConnectWithoutUserInput = {
    where: SalesReceiptWhereUniqueInput
    create: XOR<SalesReceiptCreateWithoutUserInput, SalesReceiptUncheckedCreateWithoutUserInput>
  }

  export type SalesReceiptCreateManyUserInputEnvelope = {
    data: SalesReceiptCreateManyUserInput | SalesReceiptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PurchasePaymentCreateWithoutUserInput = {
    id?: string
    paymentNo: string
    amountPaid: Decimal | DecimalJsLike | number | string
    paymentDate: Date | string
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutPurchasePaymentsInput
    vendor: VendorCreateNestedOneWithoutPurchasePaymentsInput
    cashAccount: CashAccountCreateNestedOneWithoutPurchasePaymentsInput
  }

  export type PurchasePaymentUncheckedCreateWithoutUserInput = {
    id?: string
    paymentNo: string
    purchaseId: string
    vendorId: string
    cashAccountId: string
    amountPaid: Decimal | DecimalJsLike | number | string
    paymentDate: Date | string
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type PurchasePaymentCreateOrConnectWithoutUserInput = {
    where: PurchasePaymentWhereUniqueInput
    create: XOR<PurchasePaymentCreateWithoutUserInput, PurchasePaymentUncheckedCreateWithoutUserInput>
  }

  export type PurchasePaymentCreateManyUserInputEnvelope = {
    data: PurchasePaymentCreateManyUserInput | PurchasePaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SystemSettingCreateWithoutUpdatedByUserInput = {
    id?: string
    category: string
    key: string
    value?: string | null
    dataType?: string | null
    description?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type SystemSettingUncheckedCreateWithoutUpdatedByUserInput = {
    id?: string
    category: string
    key: string
    value?: string | null
    dataType?: string | null
    description?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type SystemSettingCreateOrConnectWithoutUpdatedByUserInput = {
    where: SystemSettingWhereUniqueInput
    create: XOR<SystemSettingCreateWithoutUpdatedByUserInput, SystemSettingUncheckedCreateWithoutUpdatedByUserInput>
  }

  export type SystemSettingCreateManyUpdatedByUserInputEnvelope = {
    data: SystemSettingCreateManyUpdatedByUserInput | SystemSettingCreateManyUpdatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type ApprovalRequestCreateWithoutRequestedByUserInput = {
    id?: string
    entityType: string
    entityId: string
    status: string
    requestedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workflow: ApprovalWorkflowCreateNestedOneWithoutApprovalRequestInput
    currentStep?: ApprovalStepCreateNestedOneWithoutApprovalRequestInput
    actions?: ApprovalActionCreateNestedManyWithoutRequestInput
  }

  export type ApprovalRequestUncheckedCreateWithoutRequestedByUserInput = {
    id?: string
    workflowId: string
    entityType: string
    entityId: string
    currentStepId?: string | null
    status: string
    requestedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actions?: ApprovalActionUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ApprovalRequestCreateOrConnectWithoutRequestedByUserInput = {
    where: ApprovalRequestWhereUniqueInput
    create: XOR<ApprovalRequestCreateWithoutRequestedByUserInput, ApprovalRequestUncheckedCreateWithoutRequestedByUserInput>
  }

  export type ApprovalRequestCreateManyRequestedByUserInputEnvelope = {
    data: ApprovalRequestCreateManyRequestedByUserInput | ApprovalRequestCreateManyRequestedByUserInput[]
    skipDuplicates?: boolean
  }

  export type ApprovalActionCreateWithoutUserInput = {
    id?: string
    action: string
    comments?: string | null
    actionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    request: ApprovalRequestCreateNestedOneWithoutActionsInput
    step: ApprovalStepCreateNestedOneWithoutApprovalActionInput
  }

  export type ApprovalActionUncheckedCreateWithoutUserInput = {
    id?: string
    requestId: string
    stepId: string
    action: string
    comments?: string | null
    actionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalActionCreateOrConnectWithoutUserInput = {
    where: ApprovalActionWhereUniqueInput
    create: XOR<ApprovalActionCreateWithoutUserInput, ApprovalActionUncheckedCreateWithoutUserInput>
  }

  export type ApprovalActionCreateManyUserInputEnvelope = {
    data: ApprovalActionCreateManyUserInput | ApprovalActionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AssetCreateWithoutCreatedByUserInput = {
    id?: string
    assetNo: string
    name: string
    description?: string | null
    acquisitionDate: Date | string
    acquisitionCost: Decimal | DecimalJsLike | number | string
    residualValue?: Decimal | DecimalJsLike | number | string
    usefulLife: number
    depreciationMethod: string
    serialNumber?: string | null
    supplier?: string | null
    status?: string
    disposalDate?: Date | string | null
    disposalAmount?: Decimal | DecimalJsLike | number | string | null
    disposalMethod?: string | null
    createdAt?: Date | string
    category: AssetCategoryCreateNestedOneWithoutAssetsInput
    location?: LocationCreateNestedOneWithoutAssetsInput
    purchaseOrder?: PurchaseCreateNestedOneWithoutAssetsInput
    depreciationEntries?: AssetDepreciationCreateNestedManyWithoutAssetInput
    disposals?: AssetDisposalCreateNestedManyWithoutAssetInput
    Vendor?: VendorCreateNestedOneWithoutAssetsInput
  }

  export type AssetUncheckedCreateWithoutCreatedByUserInput = {
    id?: string
    assetNo: string
    name: string
    description?: string | null
    categoryId: string
    acquisitionDate: Date | string
    acquisitionCost: Decimal | DecimalJsLike | number | string
    residualValue?: Decimal | DecimalJsLike | number | string
    usefulLife: number
    depreciationMethod: string
    locationId?: string | null
    serialNumber?: string | null
    supplier?: string | null
    purchaseOrderId?: string | null
    status?: string
    disposalDate?: Date | string | null
    disposalAmount?: Decimal | DecimalJsLike | number | string | null
    disposalMethod?: string | null
    createdAt?: Date | string
    vendorId?: string | null
    depreciationEntries?: AssetDepreciationUncheckedCreateNestedManyWithoutAssetInput
    disposals?: AssetDisposalUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutCreatedByUserInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutCreatedByUserInput, AssetUncheckedCreateWithoutCreatedByUserInput>
  }

  export type AssetCreateManyCreatedByUserInputEnvelope = {
    data: AssetCreateManyCreatedByUserInput | AssetCreateManyCreatedByUserInput[]
    skipDuplicates?: boolean
  }

  export type AssetDisposalCreateWithoutDisposedByUserInput = {
    id?: string
    disposalDate: Date | string
    disposalAmount: Decimal | DecimalJsLike | number | string
    disposalMethod: string
    buyerDetails?: string | null
    gainLoss: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    asset: AssetCreateNestedOneWithoutDisposalsInput
    journal?: JournalCreateNestedOneWithoutAssetDisposalsInput
  }

  export type AssetDisposalUncheckedCreateWithoutDisposedByUserInput = {
    id?: string
    assetId: string
    disposalDate: Date | string
    disposalAmount: Decimal | DecimalJsLike | number | string
    disposalMethod: string
    buyerDetails?: string | null
    gainLoss: Decimal | DecimalJsLike | number | string
    notes?: string | null
    journalId?: string | null
    createdAt?: Date | string
  }

  export type AssetDisposalCreateOrConnectWithoutDisposedByUserInput = {
    where: AssetDisposalWhereUniqueInput
    create: XOR<AssetDisposalCreateWithoutDisposedByUserInput, AssetDisposalUncheckedCreateWithoutDisposedByUserInput>
  }

  export type AssetDisposalCreateManyDisposedByUserInputEnvelope = {
    data: AssetDisposalCreateManyDisposedByUserInput | AssetDisposalCreateManyDisposedByUserInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    id?: StringFilter<"UserRole"> | string
    userId?: StringFilter<"UserRole"> | string
    roleId?: StringFilter<"UserRole"> | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    beforeJson?: JsonNullableFilter<"AuditLog">
    afterJson?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type JournalUpsertWithWhereUniqueWithoutPostedByUserInput = {
    where: JournalWhereUniqueInput
    update: XOR<JournalUpdateWithoutPostedByUserInput, JournalUncheckedUpdateWithoutPostedByUserInput>
    create: XOR<JournalCreateWithoutPostedByUserInput, JournalUncheckedCreateWithoutPostedByUserInput>
  }

  export type JournalUpdateWithWhereUniqueWithoutPostedByUserInput = {
    where: JournalWhereUniqueInput
    data: XOR<JournalUpdateWithoutPostedByUserInput, JournalUncheckedUpdateWithoutPostedByUserInput>
  }

  export type JournalUpdateManyWithWhereWithoutPostedByUserInput = {
    where: JournalScalarWhereInput
    data: XOR<JournalUpdateManyMutationInput, JournalUncheckedUpdateManyWithoutPostedByUserInput>
  }

  export type JournalScalarWhereInput = {
    AND?: JournalScalarWhereInput | JournalScalarWhereInput[]
    OR?: JournalScalarWhereInput[]
    NOT?: JournalScalarWhereInput | JournalScalarWhereInput[]
    id?: StringFilter<"Journal"> | string
    journalNo?: StringFilter<"Journal"> | string
    date?: DateTimeFilter<"Journal"> | Date | string
    memo?: StringNullableFilter<"Journal"> | string | null
    postedBy?: StringFilter<"Journal"> | string
    postedAt?: DateTimeFilter<"Journal"> | Date | string
  }

  export type InventoryLedgerUpsertWithWhereUniqueWithoutUserInput = {
    where: InventoryLedgerWhereUniqueInput
    update: XOR<InventoryLedgerUpdateWithoutUserInput, InventoryLedgerUncheckedUpdateWithoutUserInput>
    create: XOR<InventoryLedgerCreateWithoutUserInput, InventoryLedgerUncheckedCreateWithoutUserInput>
  }

  export type InventoryLedgerUpdateWithWhereUniqueWithoutUserInput = {
    where: InventoryLedgerWhereUniqueInput
    data: XOR<InventoryLedgerUpdateWithoutUserInput, InventoryLedgerUncheckedUpdateWithoutUserInput>
  }

  export type InventoryLedgerUpdateManyWithWhereWithoutUserInput = {
    where: InventoryLedgerScalarWhereInput
    data: XOR<InventoryLedgerUpdateManyMutationInput, InventoryLedgerUncheckedUpdateManyWithoutUserInput>
  }

  export type InventoryLedgerScalarWhereInput = {
    AND?: InventoryLedgerScalarWhereInput | InventoryLedgerScalarWhereInput[]
    OR?: InventoryLedgerScalarWhereInput[]
    NOT?: InventoryLedgerScalarWhereInput | InventoryLedgerScalarWhereInput[]
    id?: StringFilter<"InventoryLedger"> | string
    itemId?: StringFilter<"InventoryLedger"> | string
    warehouseId?: StringFilter<"InventoryLedger"> | string
    refType?: StringFilter<"InventoryLedger"> | string
    refId?: StringFilter<"InventoryLedger"> | string
    direction?: EnumLedgerDirectionFilter<"InventoryLedger"> | $Enums.LedgerDirection
    qty?: DecimalFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    value?: DecimalFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    runningQty?: DecimalFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    runningValue?: DecimalFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    runningAvgCost?: DecimalFilter<"InventoryLedger"> | Decimal | DecimalJsLike | number | string
    batchId?: StringNullableFilter<"InventoryLedger"> | string | null
    userId?: StringNullableFilter<"InventoryLedger"> | string | null
    postedAt?: DateTimeFilter<"InventoryLedger"> | Date | string
  }

  export type CashTransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: CashTransactionWhereUniqueInput
    update: XOR<CashTransactionUpdateWithoutUserInput, CashTransactionUncheckedUpdateWithoutUserInput>
    create: XOR<CashTransactionCreateWithoutUserInput, CashTransactionUncheckedCreateWithoutUserInput>
  }

  export type CashTransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: CashTransactionWhereUniqueInput
    data: XOR<CashTransactionUpdateWithoutUserInput, CashTransactionUncheckedUpdateWithoutUserInput>
  }

  export type CashTransactionUpdateManyWithWhereWithoutUserInput = {
    where: CashTransactionScalarWhereInput
    data: XOR<CashTransactionUpdateManyMutationInput, CashTransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type CashTransactionScalarWhereInput = {
    AND?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
    OR?: CashTransactionScalarWhereInput[]
    NOT?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
    id?: StringFilter<"CashTransaction"> | string
    transactionNo?: StringFilter<"CashTransaction"> | string
    cashAccountId?: StringFilter<"CashTransaction"> | string
    glAccountId?: StringNullableFilter<"CashTransaction"> | string | null
    contraAccountId?: StringNullableFilter<"CashTransaction"> | string | null
    transactionType?: StringFilter<"CashTransaction"> | string
    amount?: DecimalFilter<"CashTransaction"> | Decimal | DecimalJsLike | number | string
    description?: StringFilter<"CashTransaction"> | string
    refType?: StringNullableFilter<"CashTransaction"> | string | null
    refId?: StringNullableFilter<"CashTransaction"> | string | null
    transactionDate?: DateTimeFilter<"CashTransaction"> | Date | string
    isReconciled?: BoolFilter<"CashTransaction"> | boolean
    reconciledAt?: DateTimeNullableFilter<"CashTransaction"> | Date | string | null
    userId?: StringFilter<"CashTransaction"> | string
    createdAt?: DateTimeFilter<"CashTransaction"> | Date | string
    reference?: StringFilter<"CashTransaction"> | string
  }

  export type SalesReceiptUpsertWithWhereUniqueWithoutUserInput = {
    where: SalesReceiptWhereUniqueInput
    update: XOR<SalesReceiptUpdateWithoutUserInput, SalesReceiptUncheckedUpdateWithoutUserInput>
    create: XOR<SalesReceiptCreateWithoutUserInput, SalesReceiptUncheckedCreateWithoutUserInput>
  }

  export type SalesReceiptUpdateWithWhereUniqueWithoutUserInput = {
    where: SalesReceiptWhereUniqueInput
    data: XOR<SalesReceiptUpdateWithoutUserInput, SalesReceiptUncheckedUpdateWithoutUserInput>
  }

  export type SalesReceiptUpdateManyWithWhereWithoutUserInput = {
    where: SalesReceiptScalarWhereInput
    data: XOR<SalesReceiptUpdateManyMutationInput, SalesReceiptUncheckedUpdateManyWithoutUserInput>
  }

  export type SalesReceiptScalarWhereInput = {
    AND?: SalesReceiptScalarWhereInput | SalesReceiptScalarWhereInput[]
    OR?: SalesReceiptScalarWhereInput[]
    NOT?: SalesReceiptScalarWhereInput | SalesReceiptScalarWhereInput[]
    id?: StringFilter<"SalesReceipt"> | string
    receiptNo?: StringFilter<"SalesReceipt"> | string
    saleId?: StringFilter<"SalesReceipt"> | string
    customerId?: StringFilter<"SalesReceipt"> | string
    cashAccountId?: StringFilter<"SalesReceipt"> | string
    amountReceived?: DecimalFilter<"SalesReceipt"> | Decimal | DecimalJsLike | number | string
    receiptDate?: DateTimeFilter<"SalesReceipt"> | Date | string
    reference?: StringNullableFilter<"SalesReceipt"> | string | null
    notes?: StringNullableFilter<"SalesReceipt"> | string | null
    userId?: StringFilter<"SalesReceipt"> | string
    createdAt?: DateTimeFilter<"SalesReceipt"> | Date | string
  }

  export type PurchasePaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PurchasePaymentWhereUniqueInput
    update: XOR<PurchasePaymentUpdateWithoutUserInput, PurchasePaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PurchasePaymentCreateWithoutUserInput, PurchasePaymentUncheckedCreateWithoutUserInput>
  }

  export type PurchasePaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PurchasePaymentWhereUniqueInput
    data: XOR<PurchasePaymentUpdateWithoutUserInput, PurchasePaymentUncheckedUpdateWithoutUserInput>
  }

  export type PurchasePaymentUpdateManyWithWhereWithoutUserInput = {
    where: PurchasePaymentScalarWhereInput
    data: XOR<PurchasePaymentUpdateManyMutationInput, PurchasePaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PurchasePaymentScalarWhereInput = {
    AND?: PurchasePaymentScalarWhereInput | PurchasePaymentScalarWhereInput[]
    OR?: PurchasePaymentScalarWhereInput[]
    NOT?: PurchasePaymentScalarWhereInput | PurchasePaymentScalarWhereInput[]
    id?: StringFilter<"PurchasePayment"> | string
    paymentNo?: StringFilter<"PurchasePayment"> | string
    purchaseId?: StringFilter<"PurchasePayment"> | string
    vendorId?: StringFilter<"PurchasePayment"> | string
    cashAccountId?: StringFilter<"PurchasePayment"> | string
    amountPaid?: DecimalFilter<"PurchasePayment"> | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFilter<"PurchasePayment"> | Date | string
    reference?: StringNullableFilter<"PurchasePayment"> | string | null
    notes?: StringNullableFilter<"PurchasePayment"> | string | null
    userId?: StringFilter<"PurchasePayment"> | string
    createdAt?: DateTimeFilter<"PurchasePayment"> | Date | string
  }

  export type SystemSettingUpsertWithWhereUniqueWithoutUpdatedByUserInput = {
    where: SystemSettingWhereUniqueInput
    update: XOR<SystemSettingUpdateWithoutUpdatedByUserInput, SystemSettingUncheckedUpdateWithoutUpdatedByUserInput>
    create: XOR<SystemSettingCreateWithoutUpdatedByUserInput, SystemSettingUncheckedCreateWithoutUpdatedByUserInput>
  }

  export type SystemSettingUpdateWithWhereUniqueWithoutUpdatedByUserInput = {
    where: SystemSettingWhereUniqueInput
    data: XOR<SystemSettingUpdateWithoutUpdatedByUserInput, SystemSettingUncheckedUpdateWithoutUpdatedByUserInput>
  }

  export type SystemSettingUpdateManyWithWhereWithoutUpdatedByUserInput = {
    where: SystemSettingScalarWhereInput
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyWithoutUpdatedByUserInput>
  }

  export type SystemSettingScalarWhereInput = {
    AND?: SystemSettingScalarWhereInput | SystemSettingScalarWhereInput[]
    OR?: SystemSettingScalarWhereInput[]
    NOT?: SystemSettingScalarWhereInput | SystemSettingScalarWhereInput[]
    id?: StringFilter<"SystemSetting"> | string
    category?: StringFilter<"SystemSetting"> | string
    key?: StringFilter<"SystemSetting"> | string
    value?: StringNullableFilter<"SystemSetting"> | string | null
    dataType?: StringNullableFilter<"SystemSetting"> | string | null
    description?: StringNullableFilter<"SystemSetting"> | string | null
    updatedBy?: StringNullableFilter<"SystemSetting"> | string | null
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
    createdAt?: DateTimeFilter<"SystemSetting"> | Date | string
  }

  export type ApprovalRequestUpsertWithWhereUniqueWithoutRequestedByUserInput = {
    where: ApprovalRequestWhereUniqueInput
    update: XOR<ApprovalRequestUpdateWithoutRequestedByUserInput, ApprovalRequestUncheckedUpdateWithoutRequestedByUserInput>
    create: XOR<ApprovalRequestCreateWithoutRequestedByUserInput, ApprovalRequestUncheckedCreateWithoutRequestedByUserInput>
  }

  export type ApprovalRequestUpdateWithWhereUniqueWithoutRequestedByUserInput = {
    where: ApprovalRequestWhereUniqueInput
    data: XOR<ApprovalRequestUpdateWithoutRequestedByUserInput, ApprovalRequestUncheckedUpdateWithoutRequestedByUserInput>
  }

  export type ApprovalRequestUpdateManyWithWhereWithoutRequestedByUserInput = {
    where: ApprovalRequestScalarWhereInput
    data: XOR<ApprovalRequestUpdateManyMutationInput, ApprovalRequestUncheckedUpdateManyWithoutRequestedByUserInput>
  }

  export type ApprovalRequestScalarWhereInput = {
    AND?: ApprovalRequestScalarWhereInput | ApprovalRequestScalarWhereInput[]
    OR?: ApprovalRequestScalarWhereInput[]
    NOT?: ApprovalRequestScalarWhereInput | ApprovalRequestScalarWhereInput[]
    id?: StringFilter<"ApprovalRequest"> | string
    workflowId?: StringFilter<"ApprovalRequest"> | string
    entityType?: StringFilter<"ApprovalRequest"> | string
    entityId?: StringFilter<"ApprovalRequest"> | string
    requestedBy?: StringFilter<"ApprovalRequest"> | string
    currentStepId?: StringNullableFilter<"ApprovalRequest"> | string | null
    status?: StringFilter<"ApprovalRequest"> | string
    requestedAt?: DateTimeFilter<"ApprovalRequest"> | Date | string
    completedAt?: DateTimeNullableFilter<"ApprovalRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"ApprovalRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalRequest"> | Date | string
  }

  export type ApprovalActionUpsertWithWhereUniqueWithoutUserInput = {
    where: ApprovalActionWhereUniqueInput
    update: XOR<ApprovalActionUpdateWithoutUserInput, ApprovalActionUncheckedUpdateWithoutUserInput>
    create: XOR<ApprovalActionCreateWithoutUserInput, ApprovalActionUncheckedCreateWithoutUserInput>
  }

  export type ApprovalActionUpdateWithWhereUniqueWithoutUserInput = {
    where: ApprovalActionWhereUniqueInput
    data: XOR<ApprovalActionUpdateWithoutUserInput, ApprovalActionUncheckedUpdateWithoutUserInput>
  }

  export type ApprovalActionUpdateManyWithWhereWithoutUserInput = {
    where: ApprovalActionScalarWhereInput
    data: XOR<ApprovalActionUpdateManyMutationInput, ApprovalActionUncheckedUpdateManyWithoutUserInput>
  }

  export type ApprovalActionScalarWhereInput = {
    AND?: ApprovalActionScalarWhereInput | ApprovalActionScalarWhereInput[]
    OR?: ApprovalActionScalarWhereInput[]
    NOT?: ApprovalActionScalarWhereInput | ApprovalActionScalarWhereInput[]
    id?: StringFilter<"ApprovalAction"> | string
    requestId?: StringFilter<"ApprovalAction"> | string
    stepId?: StringFilter<"ApprovalAction"> | string
    userId?: StringFilter<"ApprovalAction"> | string
    action?: StringFilter<"ApprovalAction"> | string
    comments?: StringNullableFilter<"ApprovalAction"> | string | null
    actionDate?: DateTimeFilter<"ApprovalAction"> | Date | string
    createdAt?: DateTimeFilter<"ApprovalAction"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalAction"> | Date | string
  }

  export type AssetUpsertWithWhereUniqueWithoutCreatedByUserInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutCreatedByUserInput, AssetUncheckedUpdateWithoutCreatedByUserInput>
    create: XOR<AssetCreateWithoutCreatedByUserInput, AssetUncheckedCreateWithoutCreatedByUserInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutCreatedByUserInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutCreatedByUserInput, AssetUncheckedUpdateWithoutCreatedByUserInput>
  }

  export type AssetUpdateManyWithWhereWithoutCreatedByUserInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutCreatedByUserInput>
  }

  export type AssetScalarWhereInput = {
    AND?: AssetScalarWhereInput | AssetScalarWhereInput[]
    OR?: AssetScalarWhereInput[]
    NOT?: AssetScalarWhereInput | AssetScalarWhereInput[]
    id?: StringFilter<"Asset"> | string
    assetNo?: StringFilter<"Asset"> | string
    name?: StringFilter<"Asset"> | string
    description?: StringNullableFilter<"Asset"> | string | null
    categoryId?: StringFilter<"Asset"> | string
    acquisitionDate?: DateTimeFilter<"Asset"> | Date | string
    acquisitionCost?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFilter<"Asset"> | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFilter<"Asset"> | number
    depreciationMethod?: StringFilter<"Asset"> | string
    locationId?: StringNullableFilter<"Asset"> | string | null
    serialNumber?: StringNullableFilter<"Asset"> | string | null
    supplier?: StringNullableFilter<"Asset"> | string | null
    purchaseOrderId?: StringNullableFilter<"Asset"> | string | null
    status?: StringFilter<"Asset"> | string
    disposalDate?: DateTimeNullableFilter<"Asset"> | Date | string | null
    disposalAmount?: DecimalNullableFilter<"Asset"> | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: StringNullableFilter<"Asset"> | string | null
    createdBy?: StringFilter<"Asset"> | string
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    vendorId?: StringNullableFilter<"Asset"> | string | null
  }

  export type AssetDisposalUpsertWithWhereUniqueWithoutDisposedByUserInput = {
    where: AssetDisposalWhereUniqueInput
    update: XOR<AssetDisposalUpdateWithoutDisposedByUserInput, AssetDisposalUncheckedUpdateWithoutDisposedByUserInput>
    create: XOR<AssetDisposalCreateWithoutDisposedByUserInput, AssetDisposalUncheckedCreateWithoutDisposedByUserInput>
  }

  export type AssetDisposalUpdateWithWhereUniqueWithoutDisposedByUserInput = {
    where: AssetDisposalWhereUniqueInput
    data: XOR<AssetDisposalUpdateWithoutDisposedByUserInput, AssetDisposalUncheckedUpdateWithoutDisposedByUserInput>
  }

  export type AssetDisposalUpdateManyWithWhereWithoutDisposedByUserInput = {
    where: AssetDisposalScalarWhereInput
    data: XOR<AssetDisposalUpdateManyMutationInput, AssetDisposalUncheckedUpdateManyWithoutDisposedByUserInput>
  }

  export type AssetDisposalScalarWhereInput = {
    AND?: AssetDisposalScalarWhereInput | AssetDisposalScalarWhereInput[]
    OR?: AssetDisposalScalarWhereInput[]
    NOT?: AssetDisposalScalarWhereInput | AssetDisposalScalarWhereInput[]
    id?: StringFilter<"AssetDisposal"> | string
    assetId?: StringFilter<"AssetDisposal"> | string
    disposalDate?: DateTimeFilter<"AssetDisposal"> | Date | string
    disposalAmount?: DecimalFilter<"AssetDisposal"> | Decimal | DecimalJsLike | number | string
    disposalMethod?: StringFilter<"AssetDisposal"> | string
    buyerDetails?: StringNullableFilter<"AssetDisposal"> | string | null
    gainLoss?: DecimalFilter<"AssetDisposal"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"AssetDisposal"> | string | null
    journalId?: StringNullableFilter<"AssetDisposal"> | string | null
    disposedBy?: StringFilter<"AssetDisposal"> | string
    createdAt?: DateTimeFilter<"AssetDisposal"> | Date | string
  }

  export type RolePermissionCreateWithoutRoleInput = {
    id?: string
    permission: PermissionCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    id?: string
    permissionId: string
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: RolePermissionCreateManyRoleInput | RolePermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleCreateWithoutRoleInput = {
    id?: string
    user: UserCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    id?: string
    userId: string
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type ApprovalStepCreateWithoutRoleInput = {
    id?: string
    stepOrder: number
    name: string
    isRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workflow: ApprovalWorkflowCreateNestedOneWithoutStepsInput
    ApprovalRequest?: ApprovalRequestCreateNestedManyWithoutCurrentStepInput
    ApprovalAction?: ApprovalActionCreateNestedManyWithoutStepInput
  }

  export type ApprovalStepUncheckedCreateWithoutRoleInput = {
    id?: string
    workflowId: string
    stepOrder: number
    name: string
    isRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ApprovalRequest?: ApprovalRequestUncheckedCreateNestedManyWithoutCurrentStepInput
    ApprovalAction?: ApprovalActionUncheckedCreateNestedManyWithoutStepInput
  }

  export type ApprovalStepCreateOrConnectWithoutRoleInput = {
    where: ApprovalStepWhereUniqueInput
    create: XOR<ApprovalStepCreateWithoutRoleInput, ApprovalStepUncheckedCreateWithoutRoleInput>
  }

  export type ApprovalStepCreateManyRoleInputEnvelope = {
    data: ApprovalStepCreateManyRoleInput | ApprovalStepCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    id?: StringFilter<"RolePermission"> | string
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type ApprovalStepUpsertWithWhereUniqueWithoutRoleInput = {
    where: ApprovalStepWhereUniqueInput
    update: XOR<ApprovalStepUpdateWithoutRoleInput, ApprovalStepUncheckedUpdateWithoutRoleInput>
    create: XOR<ApprovalStepCreateWithoutRoleInput, ApprovalStepUncheckedCreateWithoutRoleInput>
  }

  export type ApprovalStepUpdateWithWhereUniqueWithoutRoleInput = {
    where: ApprovalStepWhereUniqueInput
    data: XOR<ApprovalStepUpdateWithoutRoleInput, ApprovalStepUncheckedUpdateWithoutRoleInput>
  }

  export type ApprovalStepUpdateManyWithWhereWithoutRoleInput = {
    where: ApprovalStepScalarWhereInput
    data: XOR<ApprovalStepUpdateManyMutationInput, ApprovalStepUncheckedUpdateManyWithoutRoleInput>
  }

  export type ApprovalStepScalarWhereInput = {
    AND?: ApprovalStepScalarWhereInput | ApprovalStepScalarWhereInput[]
    OR?: ApprovalStepScalarWhereInput[]
    NOT?: ApprovalStepScalarWhereInput | ApprovalStepScalarWhereInput[]
    id?: StringFilter<"ApprovalStep"> | string
    workflowId?: StringFilter<"ApprovalStep"> | string
    stepOrder?: IntFilter<"ApprovalStep"> | number
    name?: StringFilter<"ApprovalStep"> | string
    roleId?: StringFilter<"ApprovalStep"> | string
    isRequired?: BoolFilter<"ApprovalStep"> | boolean
    createdAt?: DateTimeFilter<"ApprovalStep"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalStep"> | Date | string
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    id?: string
    role: RoleCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    id?: string
    roleId: string
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type UserCreateWithoutUserRolesInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    journals?: JournalCreateNestedManyWithoutPostedByUserInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutUserInput
    salesReceipts?: SalesReceiptCreateNestedManyWithoutUserInput
    purchasePayments?: PurchasePaymentCreateNestedManyWithoutUserInput
    SystemSetting?: SystemSettingCreateNestedManyWithoutUpdatedByUserInput
    ApprovalRequest?: ApprovalRequestCreateNestedManyWithoutRequestedByUserInput
    ApprovalAction?: ApprovalActionCreateNestedManyWithoutUserInput
    assetsCreated?: AssetCreateNestedManyWithoutCreatedByUserInput
    assetDisposals?: AssetDisposalCreateNestedManyWithoutDisposedByUserInput
  }

  export type UserUncheckedCreateWithoutUserRolesInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    journals?: JournalUncheckedCreateNestedManyWithoutPostedByUserInput
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutUserInput
    salesReceipts?: SalesReceiptUncheckedCreateNestedManyWithoutUserInput
    purchasePayments?: PurchasePaymentUncheckedCreateNestedManyWithoutUserInput
    SystemSetting?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    ApprovalRequest?: ApprovalRequestUncheckedCreateNestedManyWithoutRequestedByUserInput
    ApprovalAction?: ApprovalActionUncheckedCreateNestedManyWithoutUserInput
    assetsCreated?: AssetUncheckedCreateNestedManyWithoutCreatedByUserInput
    assetDisposals?: AssetDisposalUncheckedCreateNestedManyWithoutDisposedByUserInput
  }

  export type UserCreateOrConnectWithoutUserRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
  }

  export type RoleCreateWithoutUserRolesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    rolePermissions?: RolePermissionCreateNestedManyWithoutRoleInput
    ApprovalStep?: ApprovalStepCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUserRolesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
    ApprovalStep?: ApprovalStepUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUserRolesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
  }

  export type UserUpsertWithoutUserRolesInput = {
    update: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type UserUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    journals?: JournalUpdateManyWithoutPostedByUserNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutUserNestedInput
    salesReceipts?: SalesReceiptUpdateManyWithoutUserNestedInput
    purchasePayments?: PurchasePaymentUpdateManyWithoutUserNestedInput
    SystemSetting?: SystemSettingUpdateManyWithoutUpdatedByUserNestedInput
    ApprovalRequest?: ApprovalRequestUpdateManyWithoutRequestedByUserNestedInput
    ApprovalAction?: ApprovalActionUpdateManyWithoutUserNestedInput
    assetsCreated?: AssetUpdateManyWithoutCreatedByUserNestedInput
    assetDisposals?: AssetDisposalUpdateManyWithoutDisposedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    journals?: JournalUncheckedUpdateManyWithoutPostedByUserNestedInput
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutUserNestedInput
    salesReceipts?: SalesReceiptUncheckedUpdateManyWithoutUserNestedInput
    purchasePayments?: PurchasePaymentUncheckedUpdateManyWithoutUserNestedInput
    SystemSetting?: SystemSettingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    ApprovalRequest?: ApprovalRequestUncheckedUpdateManyWithoutRequestedByUserNestedInput
    ApprovalAction?: ApprovalActionUncheckedUpdateManyWithoutUserNestedInput
    assetsCreated?: AssetUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assetDisposals?: AssetDisposalUncheckedUpdateManyWithoutDisposedByUserNestedInput
  }

  export type RoleUpsertWithoutUserRolesInput = {
    update: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUpdateManyWithoutRoleNestedInput
    ApprovalStep?: ApprovalStepUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    ApprovalStep?: ApprovalStepUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateWithoutRolePermissionsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput
    ApprovalStep?: ApprovalStepCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutRolePermissionsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
    ApprovalStep?: ApprovalStepUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutRolePermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
  }

  export type PermissionCreateWithoutRolePermissionsInput = {
    id?: string
    name: string
    resource: string
    action: string
    description?: string | null
  }

  export type PermissionUncheckedCreateWithoutRolePermissionsInput = {
    id?: string
    name: string
    resource: string
    action: string
    description?: string | null
  }

  export type PermissionCreateOrConnectWithoutRolePermissionsInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
  }

  export type RoleUpsertWithoutRolePermissionsInput = {
    update: XOR<RoleUpdateWithoutRolePermissionsInput, RoleUncheckedUpdateWithoutRolePermissionsInput>
    create: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutRolePermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutRolePermissionsInput, RoleUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type RoleUpdateWithoutRolePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput
    ApprovalStep?: ApprovalStepUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutRolePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
    ApprovalStep?: ApprovalStepUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type PermissionUpsertWithoutRolePermissionsInput = {
    update: XOR<PermissionUpdateWithoutRolePermissionsInput, PermissionUncheckedUpdateWithoutRolePermissionsInput>
    create: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolePermissionsInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolePermissionsInput, PermissionUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type PermissionUpdateWithoutRolePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionUncheckedUpdateWithoutRolePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WarehouseCreateWithoutLocationInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    bins?: BinCreateNestedManyWithoutWarehouseInput
    inventoryBatches?: InventoryBatchCreateNestedManyWithoutWarehouseInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutWarehouseInput
    productionOrders?: ProductionOrderCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutLocationInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    bins?: BinUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryBatches?: InventoryBatchUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutWarehouseInput
    productionOrders?: ProductionOrderUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutLocationInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutLocationInput, WarehouseUncheckedCreateWithoutLocationInput>
  }

  export type WarehouseCreateManyLocationInputEnvelope = {
    data: WarehouseCreateManyLocationInput | WarehouseCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type AssetCreateWithoutLocationInput = {
    id?: string
    assetNo: string
    name: string
    description?: string | null
    acquisitionDate: Date | string
    acquisitionCost: Decimal | DecimalJsLike | number | string
    residualValue?: Decimal | DecimalJsLike | number | string
    usefulLife: number
    depreciationMethod: string
    serialNumber?: string | null
    supplier?: string | null
    status?: string
    disposalDate?: Date | string | null
    disposalAmount?: Decimal | DecimalJsLike | number | string | null
    disposalMethod?: string | null
    createdAt?: Date | string
    category: AssetCategoryCreateNestedOneWithoutAssetsInput
    purchaseOrder?: PurchaseCreateNestedOneWithoutAssetsInput
    createdByUser: UserCreateNestedOneWithoutAssetsCreatedInput
    depreciationEntries?: AssetDepreciationCreateNestedManyWithoutAssetInput
    disposals?: AssetDisposalCreateNestedManyWithoutAssetInput
    Vendor?: VendorCreateNestedOneWithoutAssetsInput
  }

  export type AssetUncheckedCreateWithoutLocationInput = {
    id?: string
    assetNo: string
    name: string
    description?: string | null
    categoryId: string
    acquisitionDate: Date | string
    acquisitionCost: Decimal | DecimalJsLike | number | string
    residualValue?: Decimal | DecimalJsLike | number | string
    usefulLife: number
    depreciationMethod: string
    serialNumber?: string | null
    supplier?: string | null
    purchaseOrderId?: string | null
    status?: string
    disposalDate?: Date | string | null
    disposalAmount?: Decimal | DecimalJsLike | number | string | null
    disposalMethod?: string | null
    createdBy: string
    createdAt?: Date | string
    vendorId?: string | null
    depreciationEntries?: AssetDepreciationUncheckedCreateNestedManyWithoutAssetInput
    disposals?: AssetDisposalUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutLocationInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutLocationInput, AssetUncheckedCreateWithoutLocationInput>
  }

  export type AssetCreateManyLocationInputEnvelope = {
    data: AssetCreateManyLocationInput | AssetCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseUpsertWithWhereUniqueWithoutLocationInput = {
    where: WarehouseWhereUniqueInput
    update: XOR<WarehouseUpdateWithoutLocationInput, WarehouseUncheckedUpdateWithoutLocationInput>
    create: XOR<WarehouseCreateWithoutLocationInput, WarehouseUncheckedCreateWithoutLocationInput>
  }

  export type WarehouseUpdateWithWhereUniqueWithoutLocationInput = {
    where: WarehouseWhereUniqueInput
    data: XOR<WarehouseUpdateWithoutLocationInput, WarehouseUncheckedUpdateWithoutLocationInput>
  }

  export type WarehouseUpdateManyWithWhereWithoutLocationInput = {
    where: WarehouseScalarWhereInput
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyWithoutLocationInput>
  }

  export type WarehouseScalarWhereInput = {
    AND?: WarehouseScalarWhereInput | WarehouseScalarWhereInput[]
    OR?: WarehouseScalarWhereInput[]
    NOT?: WarehouseScalarWhereInput | WarehouseScalarWhereInput[]
    id?: StringFilter<"Warehouse"> | string
    code?: StringFilter<"Warehouse"> | string
    name?: StringFilter<"Warehouse"> | string
    locationId?: StringFilter<"Warehouse"> | string
    address?: StringNullableFilter<"Warehouse"> | string | null
    isActive?: BoolFilter<"Warehouse"> | boolean
    createdAt?: DateTimeFilter<"Warehouse"> | Date | string
  }

  export type AssetUpsertWithWhereUniqueWithoutLocationInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutLocationInput, AssetUncheckedUpdateWithoutLocationInput>
    create: XOR<AssetCreateWithoutLocationInput, AssetUncheckedCreateWithoutLocationInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutLocationInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutLocationInput, AssetUncheckedUpdateWithoutLocationInput>
  }

  export type AssetUpdateManyWithWhereWithoutLocationInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutLocationInput>
  }

  export type LocationCreateWithoutWarehousesInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string
    isActive?: boolean
    createdAt?: Date | string
    assets?: AssetCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutWarehousesInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string
    isActive?: boolean
    createdAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutWarehousesInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutWarehousesInput, LocationUncheckedCreateWithoutWarehousesInput>
  }

  export type BinCreateWithoutWarehouseInput = {
    id?: string
    code: string
    name?: string | null
    inventoryBatches?: InventoryBatchCreateNestedManyWithoutBinInput
  }

  export type BinUncheckedCreateWithoutWarehouseInput = {
    id?: string
    code: string
    name?: string | null
    inventoryBatches?: InventoryBatchUncheckedCreateNestedManyWithoutBinInput
  }

  export type BinCreateOrConnectWithoutWarehouseInput = {
    where: BinWhereUniqueInput
    create: XOR<BinCreateWithoutWarehouseInput, BinUncheckedCreateWithoutWarehouseInput>
  }

  export type BinCreateManyWarehouseInputEnvelope = {
    data: BinCreateManyWarehouseInput | BinCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type InventoryBatchCreateWithoutWarehouseInput = {
    id?: string
    qtyOnHand: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    receivedAt: Date | string
    item: ItemCreateNestedOneWithoutInventoryBatchesInput
    bin?: BinCreateNestedOneWithoutInventoryBatchesInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutBatchInput
  }

  export type InventoryBatchUncheckedCreateWithoutWarehouseInput = {
    id?: string
    itemId: string
    binId?: string | null
    qtyOnHand: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    receivedAt: Date | string
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutBatchInput
  }

  export type InventoryBatchCreateOrConnectWithoutWarehouseInput = {
    where: InventoryBatchWhereUniqueInput
    create: XOR<InventoryBatchCreateWithoutWarehouseInput, InventoryBatchUncheckedCreateWithoutWarehouseInput>
  }

  export type InventoryBatchCreateManyWarehouseInputEnvelope = {
    data: InventoryBatchCreateManyWarehouseInput | InventoryBatchCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type InventoryLedgerCreateWithoutWarehouseInput = {
    id?: string
    refType: string
    refId: string
    direction: $Enums.LedgerDirection
    qty: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    value: Decimal | DecimalJsLike | number | string
    runningQty: Decimal | DecimalJsLike | number | string
    runningValue: Decimal | DecimalJsLike | number | string
    runningAvgCost: Decimal | DecimalJsLike | number | string
    postedAt?: Date | string
    item: ItemCreateNestedOneWithoutInventoryLedgerInput
    batch?: InventoryBatchCreateNestedOneWithoutInventoryLedgerInput
    user?: UserCreateNestedOneWithoutInventoryLedgerInput
  }

  export type InventoryLedgerUncheckedCreateWithoutWarehouseInput = {
    id?: string
    itemId: string
    refType: string
    refId: string
    direction: $Enums.LedgerDirection
    qty: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    value: Decimal | DecimalJsLike | number | string
    runningQty: Decimal | DecimalJsLike | number | string
    runningValue: Decimal | DecimalJsLike | number | string
    runningAvgCost: Decimal | DecimalJsLike | number | string
    batchId?: string | null
    userId?: string | null
    postedAt?: Date | string
  }

  export type InventoryLedgerCreateOrConnectWithoutWarehouseInput = {
    where: InventoryLedgerWhereUniqueInput
    create: XOR<InventoryLedgerCreateWithoutWarehouseInput, InventoryLedgerUncheckedCreateWithoutWarehouseInput>
  }

  export type InventoryLedgerCreateManyWarehouseInputEnvelope = {
    data: InventoryLedgerCreateManyWarehouseInput | InventoryLedgerCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type ProductionOrderCreateWithoutWarehouseInput = {
    id?: string
    orderNo: string
    qtyTarget: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string
    status?: $Enums.ProductionOrderStatus
    approvalStatus?: string | null
    approvalRequestId?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    item: ItemCreateNestedOneWithoutProductionOrdersInput
    bom?: BomCreateNestedOneWithoutProductionOrdersInput
    wipLedger?: WipLedgerCreateNestedManyWithoutProductionOrderInput
    laborTimes?: LaborTimeCreateNestedManyWithoutProductionOrderInput
  }

  export type ProductionOrderUncheckedCreateWithoutWarehouseInput = {
    id?: string
    orderNo: string
    itemId: string
    qtyTarget: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string
    status?: $Enums.ProductionOrderStatus
    bomId?: string | null
    approvalStatus?: string | null
    approvalRequestId?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    wipLedger?: WipLedgerUncheckedCreateNestedManyWithoutProductionOrderInput
    laborTimes?: LaborTimeUncheckedCreateNestedManyWithoutProductionOrderInput
  }

  export type ProductionOrderCreateOrConnectWithoutWarehouseInput = {
    where: ProductionOrderWhereUniqueInput
    create: XOR<ProductionOrderCreateWithoutWarehouseInput, ProductionOrderUncheckedCreateWithoutWarehouseInput>
  }

  export type ProductionOrderCreateManyWarehouseInputEnvelope = {
    data: ProductionOrderCreateManyWarehouseInput | ProductionOrderCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithoutWarehousesInput = {
    update: XOR<LocationUpdateWithoutWarehousesInput, LocationUncheckedUpdateWithoutWarehousesInput>
    create: XOR<LocationCreateWithoutWarehousesInput, LocationUncheckedCreateWithoutWarehousesInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutWarehousesInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutWarehousesInput, LocationUncheckedUpdateWithoutWarehousesInput>
  }

  export type LocationUpdateWithoutWarehousesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutWarehousesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type BinUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: BinWhereUniqueInput
    update: XOR<BinUpdateWithoutWarehouseInput, BinUncheckedUpdateWithoutWarehouseInput>
    create: XOR<BinCreateWithoutWarehouseInput, BinUncheckedCreateWithoutWarehouseInput>
  }

  export type BinUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: BinWhereUniqueInput
    data: XOR<BinUpdateWithoutWarehouseInput, BinUncheckedUpdateWithoutWarehouseInput>
  }

  export type BinUpdateManyWithWhereWithoutWarehouseInput = {
    where: BinScalarWhereInput
    data: XOR<BinUpdateManyMutationInput, BinUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type BinScalarWhereInput = {
    AND?: BinScalarWhereInput | BinScalarWhereInput[]
    OR?: BinScalarWhereInput[]
    NOT?: BinScalarWhereInput | BinScalarWhereInput[]
    id?: StringFilter<"Bin"> | string
    warehouseId?: StringFilter<"Bin"> | string
    code?: StringFilter<"Bin"> | string
    name?: StringNullableFilter<"Bin"> | string | null
  }

  export type InventoryBatchUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: InventoryBatchWhereUniqueInput
    update: XOR<InventoryBatchUpdateWithoutWarehouseInput, InventoryBatchUncheckedUpdateWithoutWarehouseInput>
    create: XOR<InventoryBatchCreateWithoutWarehouseInput, InventoryBatchUncheckedCreateWithoutWarehouseInput>
  }

  export type InventoryBatchUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: InventoryBatchWhereUniqueInput
    data: XOR<InventoryBatchUpdateWithoutWarehouseInput, InventoryBatchUncheckedUpdateWithoutWarehouseInput>
  }

  export type InventoryBatchUpdateManyWithWhereWithoutWarehouseInput = {
    where: InventoryBatchScalarWhereInput
    data: XOR<InventoryBatchUpdateManyMutationInput, InventoryBatchUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type InventoryBatchScalarWhereInput = {
    AND?: InventoryBatchScalarWhereInput | InventoryBatchScalarWhereInput[]
    OR?: InventoryBatchScalarWhereInput[]
    NOT?: InventoryBatchScalarWhereInput | InventoryBatchScalarWhereInput[]
    id?: StringFilter<"InventoryBatch"> | string
    itemId?: StringFilter<"InventoryBatch"> | string
    warehouseId?: StringFilter<"InventoryBatch"> | string
    binId?: StringNullableFilter<"InventoryBatch"> | string | null
    qtyOnHand?: DecimalFilter<"InventoryBatch"> | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFilter<"InventoryBatch"> | Decimal | DecimalJsLike | number | string
    receivedAt?: DateTimeFilter<"InventoryBatch"> | Date | string
  }

  export type InventoryLedgerUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: InventoryLedgerWhereUniqueInput
    update: XOR<InventoryLedgerUpdateWithoutWarehouseInput, InventoryLedgerUncheckedUpdateWithoutWarehouseInput>
    create: XOR<InventoryLedgerCreateWithoutWarehouseInput, InventoryLedgerUncheckedCreateWithoutWarehouseInput>
  }

  export type InventoryLedgerUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: InventoryLedgerWhereUniqueInput
    data: XOR<InventoryLedgerUpdateWithoutWarehouseInput, InventoryLedgerUncheckedUpdateWithoutWarehouseInput>
  }

  export type InventoryLedgerUpdateManyWithWhereWithoutWarehouseInput = {
    where: InventoryLedgerScalarWhereInput
    data: XOR<InventoryLedgerUpdateManyMutationInput, InventoryLedgerUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type ProductionOrderUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: ProductionOrderWhereUniqueInput
    update: XOR<ProductionOrderUpdateWithoutWarehouseInput, ProductionOrderUncheckedUpdateWithoutWarehouseInput>
    create: XOR<ProductionOrderCreateWithoutWarehouseInput, ProductionOrderUncheckedCreateWithoutWarehouseInput>
  }

  export type ProductionOrderUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: ProductionOrderWhereUniqueInput
    data: XOR<ProductionOrderUpdateWithoutWarehouseInput, ProductionOrderUncheckedUpdateWithoutWarehouseInput>
  }

  export type ProductionOrderUpdateManyWithWhereWithoutWarehouseInput = {
    where: ProductionOrderScalarWhereInput
    data: XOR<ProductionOrderUpdateManyMutationInput, ProductionOrderUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type ProductionOrderScalarWhereInput = {
    AND?: ProductionOrderScalarWhereInput | ProductionOrderScalarWhereInput[]
    OR?: ProductionOrderScalarWhereInput[]
    NOT?: ProductionOrderScalarWhereInput | ProductionOrderScalarWhereInput[]
    id?: StringFilter<"ProductionOrder"> | string
    orderNo?: StringFilter<"ProductionOrder"> | string
    itemId?: StringFilter<"ProductionOrder"> | string
    qtyTarget?: DecimalFilter<"ProductionOrder"> | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalFilter<"ProductionOrder"> | Decimal | DecimalJsLike | number | string
    status?: EnumProductionOrderStatusFilter<"ProductionOrder"> | $Enums.ProductionOrderStatus
    warehouseId?: StringFilter<"ProductionOrder"> | string
    bomId?: StringNullableFilter<"ProductionOrder"> | string | null
    approvalStatus?: StringNullableFilter<"ProductionOrder"> | string | null
    approvalRequestId?: StringNullableFilter<"ProductionOrder"> | string | null
    approvedBy?: StringNullableFilter<"ProductionOrder"> | string | null
    approvedAt?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"ProductionOrder"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductionOrder"> | Date | string
    updatedAt?: DateTimeFilter<"ProductionOrder"> | Date | string
  }

  export type WarehouseCreateWithoutBinsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    location: LocationCreateNestedOneWithoutWarehousesInput
    inventoryBatches?: InventoryBatchCreateNestedManyWithoutWarehouseInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutWarehouseInput
    productionOrders?: ProductionOrderCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutBinsInput = {
    id?: string
    code: string
    name: string
    locationId: string
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    inventoryBatches?: InventoryBatchUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutWarehouseInput
    productionOrders?: ProductionOrderUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutBinsInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutBinsInput, WarehouseUncheckedCreateWithoutBinsInput>
  }

  export type InventoryBatchCreateWithoutBinInput = {
    id?: string
    qtyOnHand: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    receivedAt: Date | string
    item: ItemCreateNestedOneWithoutInventoryBatchesInput
    warehouse: WarehouseCreateNestedOneWithoutInventoryBatchesInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutBatchInput
  }

  export type InventoryBatchUncheckedCreateWithoutBinInput = {
    id?: string
    itemId: string
    warehouseId: string
    qtyOnHand: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    receivedAt: Date | string
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutBatchInput
  }

  export type InventoryBatchCreateOrConnectWithoutBinInput = {
    where: InventoryBatchWhereUniqueInput
    create: XOR<InventoryBatchCreateWithoutBinInput, InventoryBatchUncheckedCreateWithoutBinInput>
  }

  export type InventoryBatchCreateManyBinInputEnvelope = {
    data: InventoryBatchCreateManyBinInput | InventoryBatchCreateManyBinInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseUpsertWithoutBinsInput = {
    update: XOR<WarehouseUpdateWithoutBinsInput, WarehouseUncheckedUpdateWithoutBinsInput>
    create: XOR<WarehouseCreateWithoutBinsInput, WarehouseUncheckedCreateWithoutBinsInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutBinsInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutBinsInput, WarehouseUncheckedUpdateWithoutBinsInput>
  }

  export type WarehouseUpdateWithoutBinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutWarehousesNestedInput
    inventoryBatches?: InventoryBatchUpdateManyWithoutWarehouseNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutWarehouseNestedInput
    productionOrders?: ProductionOrderUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutBinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryBatches?: InventoryBatchUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutWarehouseNestedInput
    productionOrders?: ProductionOrderUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type InventoryBatchUpsertWithWhereUniqueWithoutBinInput = {
    where: InventoryBatchWhereUniqueInput
    update: XOR<InventoryBatchUpdateWithoutBinInput, InventoryBatchUncheckedUpdateWithoutBinInput>
    create: XOR<InventoryBatchCreateWithoutBinInput, InventoryBatchUncheckedCreateWithoutBinInput>
  }

  export type InventoryBatchUpdateWithWhereUniqueWithoutBinInput = {
    where: InventoryBatchWhereUniqueInput
    data: XOR<InventoryBatchUpdateWithoutBinInput, InventoryBatchUncheckedUpdateWithoutBinInput>
  }

  export type InventoryBatchUpdateManyWithWhereWithoutBinInput = {
    where: InventoryBatchScalarWhereInput
    data: XOR<InventoryBatchUpdateManyMutationInput, InventoryBatchUncheckedUpdateManyWithoutBinInput>
  }

  export type BomCreateWithoutItemInput = {
    id?: string
    version?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bomLines?: BomLineCreateNestedManyWithoutBomInput
    productionOrders?: ProductionOrderCreateNestedManyWithoutBomInput
  }

  export type BomUncheckedCreateWithoutItemInput = {
    id?: string
    version?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bomLines?: BomLineUncheckedCreateNestedManyWithoutBomInput
    productionOrders?: ProductionOrderUncheckedCreateNestedManyWithoutBomInput
  }

  export type BomCreateOrConnectWithoutItemInput = {
    where: BomWhereUniqueInput
    create: XOR<BomCreateWithoutItemInput, BomUncheckedCreateWithoutItemInput>
  }

  export type BomCreateManyItemInputEnvelope = {
    data: BomCreateManyItemInput | BomCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type BomLineCreateWithoutComponentItemInput = {
    id?: string
    qtyPer: Decimal | DecimalJsLike | number | string
    scrapPercent?: Decimal | DecimalJsLike | number | string
    bom: BomCreateNestedOneWithoutBomLinesInput
  }

  export type BomLineUncheckedCreateWithoutComponentItemInput = {
    id?: string
    bomId: string
    qtyPer: Decimal | DecimalJsLike | number | string
    scrapPercent?: Decimal | DecimalJsLike | number | string
  }

  export type BomLineCreateOrConnectWithoutComponentItemInput = {
    where: BomLineWhereUniqueInput
    create: XOR<BomLineCreateWithoutComponentItemInput, BomLineUncheckedCreateWithoutComponentItemInput>
  }

  export type BomLineCreateManyComponentItemInputEnvelope = {
    data: BomLineCreateManyComponentItemInput | BomLineCreateManyComponentItemInput[]
    skipDuplicates?: boolean
  }

  export type InventoryBatchCreateWithoutItemInput = {
    id?: string
    qtyOnHand: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    receivedAt: Date | string
    warehouse: WarehouseCreateNestedOneWithoutInventoryBatchesInput
    bin?: BinCreateNestedOneWithoutInventoryBatchesInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutBatchInput
  }

  export type InventoryBatchUncheckedCreateWithoutItemInput = {
    id?: string
    warehouseId: string
    binId?: string | null
    qtyOnHand: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    receivedAt: Date | string
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutBatchInput
  }

  export type InventoryBatchCreateOrConnectWithoutItemInput = {
    where: InventoryBatchWhereUniqueInput
    create: XOR<InventoryBatchCreateWithoutItemInput, InventoryBatchUncheckedCreateWithoutItemInput>
  }

  export type InventoryBatchCreateManyItemInputEnvelope = {
    data: InventoryBatchCreateManyItemInput | InventoryBatchCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type InventoryLedgerCreateWithoutItemInput = {
    id?: string
    refType: string
    refId: string
    direction: $Enums.LedgerDirection
    qty: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    value: Decimal | DecimalJsLike | number | string
    runningQty: Decimal | DecimalJsLike | number | string
    runningValue: Decimal | DecimalJsLike | number | string
    runningAvgCost: Decimal | DecimalJsLike | number | string
    postedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutInventoryLedgerInput
    batch?: InventoryBatchCreateNestedOneWithoutInventoryLedgerInput
    user?: UserCreateNestedOneWithoutInventoryLedgerInput
  }

  export type InventoryLedgerUncheckedCreateWithoutItemInput = {
    id?: string
    warehouseId: string
    refType: string
    refId: string
    direction: $Enums.LedgerDirection
    qty: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    value: Decimal | DecimalJsLike | number | string
    runningQty: Decimal | DecimalJsLike | number | string
    runningValue: Decimal | DecimalJsLike | number | string
    runningAvgCost: Decimal | DecimalJsLike | number | string
    batchId?: string | null
    userId?: string | null
    postedAt?: Date | string
  }

  export type InventoryLedgerCreateOrConnectWithoutItemInput = {
    where: InventoryLedgerWhereUniqueInput
    create: XOR<InventoryLedgerCreateWithoutItemInput, InventoryLedgerUncheckedCreateWithoutItemInput>
  }

  export type InventoryLedgerCreateManyItemInputEnvelope = {
    data: InventoryLedgerCreateManyItemInput | InventoryLedgerCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type ProductionOrderCreateWithoutItemInput = {
    id?: string
    orderNo: string
    qtyTarget: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string
    status?: $Enums.ProductionOrderStatus
    approvalStatus?: string | null
    approvalRequestId?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutProductionOrdersInput
    bom?: BomCreateNestedOneWithoutProductionOrdersInput
    wipLedger?: WipLedgerCreateNestedManyWithoutProductionOrderInput
    laborTimes?: LaborTimeCreateNestedManyWithoutProductionOrderInput
  }

  export type ProductionOrderUncheckedCreateWithoutItemInput = {
    id?: string
    orderNo: string
    qtyTarget: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string
    status?: $Enums.ProductionOrderStatus
    warehouseId: string
    bomId?: string | null
    approvalStatus?: string | null
    approvalRequestId?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    wipLedger?: WipLedgerUncheckedCreateNestedManyWithoutProductionOrderInput
    laborTimes?: LaborTimeUncheckedCreateNestedManyWithoutProductionOrderInput
  }

  export type ProductionOrderCreateOrConnectWithoutItemInput = {
    where: ProductionOrderWhereUniqueInput
    create: XOR<ProductionOrderCreateWithoutItemInput, ProductionOrderUncheckedCreateWithoutItemInput>
  }

  export type ProductionOrderCreateManyItemInputEnvelope = {
    data: ProductionOrderCreateManyItemInput | ProductionOrderCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseLineCreateWithoutItemInput = {
    id?: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    purchase: PurchaseCreateNestedOneWithoutPurchaseLinesInput
  }

  export type PurchaseLineUncheckedCreateWithoutItemInput = {
    id?: string
    purchaseId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type PurchaseLineCreateOrConnectWithoutItemInput = {
    where: PurchaseLineWhereUniqueInput
    create: XOR<PurchaseLineCreateWithoutItemInput, PurchaseLineUncheckedCreateWithoutItemInput>
  }

  export type PurchaseLineCreateManyItemInputEnvelope = {
    data: PurchaseLineCreateManyItemInput | PurchaseLineCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type SaleLineCreateWithoutItemInput = {
    id?: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    sale: SaleCreateNestedOneWithoutSaleLinesInput
  }

  export type SaleLineUncheckedCreateWithoutItemInput = {
    id?: string
    saleId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SaleLineCreateOrConnectWithoutItemInput = {
    where: SaleLineWhereUniqueInput
    create: XOR<SaleLineCreateWithoutItemInput, SaleLineUncheckedCreateWithoutItemInput>
  }

  export type SaleLineCreateManyItemInputEnvelope = {
    data: SaleLineCreateManyItemInput | SaleLineCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type BomUpsertWithWhereUniqueWithoutItemInput = {
    where: BomWhereUniqueInput
    update: XOR<BomUpdateWithoutItemInput, BomUncheckedUpdateWithoutItemInput>
    create: XOR<BomCreateWithoutItemInput, BomUncheckedCreateWithoutItemInput>
  }

  export type BomUpdateWithWhereUniqueWithoutItemInput = {
    where: BomWhereUniqueInput
    data: XOR<BomUpdateWithoutItemInput, BomUncheckedUpdateWithoutItemInput>
  }

  export type BomUpdateManyWithWhereWithoutItemInput = {
    where: BomScalarWhereInput
    data: XOR<BomUpdateManyMutationInput, BomUncheckedUpdateManyWithoutItemInput>
  }

  export type BomScalarWhereInput = {
    AND?: BomScalarWhereInput | BomScalarWhereInput[]
    OR?: BomScalarWhereInput[]
    NOT?: BomScalarWhereInput | BomScalarWhereInput[]
    id?: StringFilter<"Bom"> | string
    itemId?: StringFilter<"Bom"> | string
    version?: StringFilter<"Bom"> | string
    isActive?: BoolFilter<"Bom"> | boolean
    createdAt?: DateTimeFilter<"Bom"> | Date | string
    updatedAt?: DateTimeFilter<"Bom"> | Date | string
  }

  export type BomLineUpsertWithWhereUniqueWithoutComponentItemInput = {
    where: BomLineWhereUniqueInput
    update: XOR<BomLineUpdateWithoutComponentItemInput, BomLineUncheckedUpdateWithoutComponentItemInput>
    create: XOR<BomLineCreateWithoutComponentItemInput, BomLineUncheckedCreateWithoutComponentItemInput>
  }

  export type BomLineUpdateWithWhereUniqueWithoutComponentItemInput = {
    where: BomLineWhereUniqueInput
    data: XOR<BomLineUpdateWithoutComponentItemInput, BomLineUncheckedUpdateWithoutComponentItemInput>
  }

  export type BomLineUpdateManyWithWhereWithoutComponentItemInput = {
    where: BomLineScalarWhereInput
    data: XOR<BomLineUpdateManyMutationInput, BomLineUncheckedUpdateManyWithoutComponentItemInput>
  }

  export type BomLineScalarWhereInput = {
    AND?: BomLineScalarWhereInput | BomLineScalarWhereInput[]
    OR?: BomLineScalarWhereInput[]
    NOT?: BomLineScalarWhereInput | BomLineScalarWhereInput[]
    id?: StringFilter<"BomLine"> | string
    bomId?: StringFilter<"BomLine"> | string
    componentItemId?: StringFilter<"BomLine"> | string
    qtyPer?: DecimalFilter<"BomLine"> | Decimal | DecimalJsLike | number | string
    scrapPercent?: DecimalFilter<"BomLine"> | Decimal | DecimalJsLike | number | string
  }

  export type InventoryBatchUpsertWithWhereUniqueWithoutItemInput = {
    where: InventoryBatchWhereUniqueInput
    update: XOR<InventoryBatchUpdateWithoutItemInput, InventoryBatchUncheckedUpdateWithoutItemInput>
    create: XOR<InventoryBatchCreateWithoutItemInput, InventoryBatchUncheckedCreateWithoutItemInput>
  }

  export type InventoryBatchUpdateWithWhereUniqueWithoutItemInput = {
    where: InventoryBatchWhereUniqueInput
    data: XOR<InventoryBatchUpdateWithoutItemInput, InventoryBatchUncheckedUpdateWithoutItemInput>
  }

  export type InventoryBatchUpdateManyWithWhereWithoutItemInput = {
    where: InventoryBatchScalarWhereInput
    data: XOR<InventoryBatchUpdateManyMutationInput, InventoryBatchUncheckedUpdateManyWithoutItemInput>
  }

  export type InventoryLedgerUpsertWithWhereUniqueWithoutItemInput = {
    where: InventoryLedgerWhereUniqueInput
    update: XOR<InventoryLedgerUpdateWithoutItemInput, InventoryLedgerUncheckedUpdateWithoutItemInput>
    create: XOR<InventoryLedgerCreateWithoutItemInput, InventoryLedgerUncheckedCreateWithoutItemInput>
  }

  export type InventoryLedgerUpdateWithWhereUniqueWithoutItemInput = {
    where: InventoryLedgerWhereUniqueInput
    data: XOR<InventoryLedgerUpdateWithoutItemInput, InventoryLedgerUncheckedUpdateWithoutItemInput>
  }

  export type InventoryLedgerUpdateManyWithWhereWithoutItemInput = {
    where: InventoryLedgerScalarWhereInput
    data: XOR<InventoryLedgerUpdateManyMutationInput, InventoryLedgerUncheckedUpdateManyWithoutItemInput>
  }

  export type ProductionOrderUpsertWithWhereUniqueWithoutItemInput = {
    where: ProductionOrderWhereUniqueInput
    update: XOR<ProductionOrderUpdateWithoutItemInput, ProductionOrderUncheckedUpdateWithoutItemInput>
    create: XOR<ProductionOrderCreateWithoutItemInput, ProductionOrderUncheckedCreateWithoutItemInput>
  }

  export type ProductionOrderUpdateWithWhereUniqueWithoutItemInput = {
    where: ProductionOrderWhereUniqueInput
    data: XOR<ProductionOrderUpdateWithoutItemInput, ProductionOrderUncheckedUpdateWithoutItemInput>
  }

  export type ProductionOrderUpdateManyWithWhereWithoutItemInput = {
    where: ProductionOrderScalarWhereInput
    data: XOR<ProductionOrderUpdateManyMutationInput, ProductionOrderUncheckedUpdateManyWithoutItemInput>
  }

  export type PurchaseLineUpsertWithWhereUniqueWithoutItemInput = {
    where: PurchaseLineWhereUniqueInput
    update: XOR<PurchaseLineUpdateWithoutItemInput, PurchaseLineUncheckedUpdateWithoutItemInput>
    create: XOR<PurchaseLineCreateWithoutItemInput, PurchaseLineUncheckedCreateWithoutItemInput>
  }

  export type PurchaseLineUpdateWithWhereUniqueWithoutItemInput = {
    where: PurchaseLineWhereUniqueInput
    data: XOR<PurchaseLineUpdateWithoutItemInput, PurchaseLineUncheckedUpdateWithoutItemInput>
  }

  export type PurchaseLineUpdateManyWithWhereWithoutItemInput = {
    where: PurchaseLineScalarWhereInput
    data: XOR<PurchaseLineUpdateManyMutationInput, PurchaseLineUncheckedUpdateManyWithoutItemInput>
  }

  export type PurchaseLineScalarWhereInput = {
    AND?: PurchaseLineScalarWhereInput | PurchaseLineScalarWhereInput[]
    OR?: PurchaseLineScalarWhereInput[]
    NOT?: PurchaseLineScalarWhereInput | PurchaseLineScalarWhereInput[]
    id?: StringFilter<"PurchaseLine"> | string
    purchaseId?: StringFilter<"PurchaseLine"> | string
    itemId?: StringFilter<"PurchaseLine"> | string
    qty?: DecimalFilter<"PurchaseLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"PurchaseLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"PurchaseLine"> | Decimal | DecimalJsLike | number | string
  }

  export type SaleLineUpsertWithWhereUniqueWithoutItemInput = {
    where: SaleLineWhereUniqueInput
    update: XOR<SaleLineUpdateWithoutItemInput, SaleLineUncheckedUpdateWithoutItemInput>
    create: XOR<SaleLineCreateWithoutItemInput, SaleLineUncheckedCreateWithoutItemInput>
  }

  export type SaleLineUpdateWithWhereUniqueWithoutItemInput = {
    where: SaleLineWhereUniqueInput
    data: XOR<SaleLineUpdateWithoutItemInput, SaleLineUncheckedUpdateWithoutItemInput>
  }

  export type SaleLineUpdateManyWithWhereWithoutItemInput = {
    where: SaleLineScalarWhereInput
    data: XOR<SaleLineUpdateManyMutationInput, SaleLineUncheckedUpdateManyWithoutItemInput>
  }

  export type SaleLineScalarWhereInput = {
    AND?: SaleLineScalarWhereInput | SaleLineScalarWhereInput[]
    OR?: SaleLineScalarWhereInput[]
    NOT?: SaleLineScalarWhereInput | SaleLineScalarWhereInput[]
    id?: StringFilter<"SaleLine"> | string
    saleId?: StringFilter<"SaleLine"> | string
    itemId?: StringFilter<"SaleLine"> | string
    qty?: DecimalFilter<"SaleLine"> | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFilter<"SaleLine"> | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFilter<"SaleLine"> | Decimal | DecimalJsLike | number | string
  }

  export type ItemCreateWithoutBomsInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ItemType
    uom?: string
    costingMethod?: $Enums.CostingMethod
    standardCost?: Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: Decimal | DecimalJsLike | number | string | null
    taxCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bomLines?: BomLineCreateNestedManyWithoutComponentItemInput
    inventoryBatches?: InventoryBatchCreateNestedManyWithoutItemInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutItemInput
    productionOrders?: ProductionOrderCreateNestedManyWithoutItemInput
    purchaseLines?: PurchaseLineCreateNestedManyWithoutItemInput
    saleLines?: SaleLineCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutBomsInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ItemType
    uom?: string
    costingMethod?: $Enums.CostingMethod
    standardCost?: Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: Decimal | DecimalJsLike | number | string | null
    taxCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bomLines?: BomLineUncheckedCreateNestedManyWithoutComponentItemInput
    inventoryBatches?: InventoryBatchUncheckedCreateNestedManyWithoutItemInput
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutItemInput
    productionOrders?: ProductionOrderUncheckedCreateNestedManyWithoutItemInput
    purchaseLines?: PurchaseLineUncheckedCreateNestedManyWithoutItemInput
    saleLines?: SaleLineUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutBomsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutBomsInput, ItemUncheckedCreateWithoutBomsInput>
  }

  export type BomLineCreateWithoutBomInput = {
    id?: string
    qtyPer: Decimal | DecimalJsLike | number | string
    scrapPercent?: Decimal | DecimalJsLike | number | string
    componentItem: ItemCreateNestedOneWithoutBomLinesInput
  }

  export type BomLineUncheckedCreateWithoutBomInput = {
    id?: string
    componentItemId: string
    qtyPer: Decimal | DecimalJsLike | number | string
    scrapPercent?: Decimal | DecimalJsLike | number | string
  }

  export type BomLineCreateOrConnectWithoutBomInput = {
    where: BomLineWhereUniqueInput
    create: XOR<BomLineCreateWithoutBomInput, BomLineUncheckedCreateWithoutBomInput>
  }

  export type BomLineCreateManyBomInputEnvelope = {
    data: BomLineCreateManyBomInput | BomLineCreateManyBomInput[]
    skipDuplicates?: boolean
  }

  export type ProductionOrderCreateWithoutBomInput = {
    id?: string
    orderNo: string
    qtyTarget: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string
    status?: $Enums.ProductionOrderStatus
    approvalStatus?: string | null
    approvalRequestId?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    item: ItemCreateNestedOneWithoutProductionOrdersInput
    warehouse: WarehouseCreateNestedOneWithoutProductionOrdersInput
    wipLedger?: WipLedgerCreateNestedManyWithoutProductionOrderInput
    laborTimes?: LaborTimeCreateNestedManyWithoutProductionOrderInput
  }

  export type ProductionOrderUncheckedCreateWithoutBomInput = {
    id?: string
    orderNo: string
    itemId: string
    qtyTarget: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string
    status?: $Enums.ProductionOrderStatus
    warehouseId: string
    approvalStatus?: string | null
    approvalRequestId?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    wipLedger?: WipLedgerUncheckedCreateNestedManyWithoutProductionOrderInput
    laborTimes?: LaborTimeUncheckedCreateNestedManyWithoutProductionOrderInput
  }

  export type ProductionOrderCreateOrConnectWithoutBomInput = {
    where: ProductionOrderWhereUniqueInput
    create: XOR<ProductionOrderCreateWithoutBomInput, ProductionOrderUncheckedCreateWithoutBomInput>
  }

  export type ProductionOrderCreateManyBomInputEnvelope = {
    data: ProductionOrderCreateManyBomInput | ProductionOrderCreateManyBomInput[]
    skipDuplicates?: boolean
  }

  export type ItemUpsertWithoutBomsInput = {
    update: XOR<ItemUpdateWithoutBomsInput, ItemUncheckedUpdateWithoutBomsInput>
    create: XOR<ItemCreateWithoutBomsInput, ItemUncheckedCreateWithoutBomsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutBomsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutBomsInput, ItemUncheckedUpdateWithoutBomsInput>
  }

  export type ItemUpdateWithoutBomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    uom?: StringFieldUpdateOperationsInput | string
    costingMethod?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bomLines?: BomLineUpdateManyWithoutComponentItemNestedInput
    inventoryBatches?: InventoryBatchUpdateManyWithoutItemNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutItemNestedInput
    productionOrders?: ProductionOrderUpdateManyWithoutItemNestedInput
    purchaseLines?: PurchaseLineUpdateManyWithoutItemNestedInput
    saleLines?: SaleLineUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutBomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    uom?: StringFieldUpdateOperationsInput | string
    costingMethod?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bomLines?: BomLineUncheckedUpdateManyWithoutComponentItemNestedInput
    inventoryBatches?: InventoryBatchUncheckedUpdateManyWithoutItemNestedInput
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutItemNestedInput
    productionOrders?: ProductionOrderUncheckedUpdateManyWithoutItemNestedInput
    purchaseLines?: PurchaseLineUncheckedUpdateManyWithoutItemNestedInput
    saleLines?: SaleLineUncheckedUpdateManyWithoutItemNestedInput
  }

  export type BomLineUpsertWithWhereUniqueWithoutBomInput = {
    where: BomLineWhereUniqueInput
    update: XOR<BomLineUpdateWithoutBomInput, BomLineUncheckedUpdateWithoutBomInput>
    create: XOR<BomLineCreateWithoutBomInput, BomLineUncheckedCreateWithoutBomInput>
  }

  export type BomLineUpdateWithWhereUniqueWithoutBomInput = {
    where: BomLineWhereUniqueInput
    data: XOR<BomLineUpdateWithoutBomInput, BomLineUncheckedUpdateWithoutBomInput>
  }

  export type BomLineUpdateManyWithWhereWithoutBomInput = {
    where: BomLineScalarWhereInput
    data: XOR<BomLineUpdateManyMutationInput, BomLineUncheckedUpdateManyWithoutBomInput>
  }

  export type ProductionOrderUpsertWithWhereUniqueWithoutBomInput = {
    where: ProductionOrderWhereUniqueInput
    update: XOR<ProductionOrderUpdateWithoutBomInput, ProductionOrderUncheckedUpdateWithoutBomInput>
    create: XOR<ProductionOrderCreateWithoutBomInput, ProductionOrderUncheckedCreateWithoutBomInput>
  }

  export type ProductionOrderUpdateWithWhereUniqueWithoutBomInput = {
    where: ProductionOrderWhereUniqueInput
    data: XOR<ProductionOrderUpdateWithoutBomInput, ProductionOrderUncheckedUpdateWithoutBomInput>
  }

  export type ProductionOrderUpdateManyWithWhereWithoutBomInput = {
    where: ProductionOrderScalarWhereInput
    data: XOR<ProductionOrderUpdateManyMutationInput, ProductionOrderUncheckedUpdateManyWithoutBomInput>
  }

  export type BomCreateWithoutBomLinesInput = {
    id?: string
    version?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    item: ItemCreateNestedOneWithoutBomsInput
    productionOrders?: ProductionOrderCreateNestedManyWithoutBomInput
  }

  export type BomUncheckedCreateWithoutBomLinesInput = {
    id?: string
    itemId: string
    version?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    productionOrders?: ProductionOrderUncheckedCreateNestedManyWithoutBomInput
  }

  export type BomCreateOrConnectWithoutBomLinesInput = {
    where: BomWhereUniqueInput
    create: XOR<BomCreateWithoutBomLinesInput, BomUncheckedCreateWithoutBomLinesInput>
  }

  export type ItemCreateWithoutBomLinesInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ItemType
    uom?: string
    costingMethod?: $Enums.CostingMethod
    standardCost?: Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: Decimal | DecimalJsLike | number | string | null
    taxCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    boms?: BomCreateNestedManyWithoutItemInput
    inventoryBatches?: InventoryBatchCreateNestedManyWithoutItemInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutItemInput
    productionOrders?: ProductionOrderCreateNestedManyWithoutItemInput
    purchaseLines?: PurchaseLineCreateNestedManyWithoutItemInput
    saleLines?: SaleLineCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutBomLinesInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ItemType
    uom?: string
    costingMethod?: $Enums.CostingMethod
    standardCost?: Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: Decimal | DecimalJsLike | number | string | null
    taxCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    boms?: BomUncheckedCreateNestedManyWithoutItemInput
    inventoryBatches?: InventoryBatchUncheckedCreateNestedManyWithoutItemInput
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutItemInput
    productionOrders?: ProductionOrderUncheckedCreateNestedManyWithoutItemInput
    purchaseLines?: PurchaseLineUncheckedCreateNestedManyWithoutItemInput
    saleLines?: SaleLineUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutBomLinesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutBomLinesInput, ItemUncheckedCreateWithoutBomLinesInput>
  }

  export type BomUpsertWithoutBomLinesInput = {
    update: XOR<BomUpdateWithoutBomLinesInput, BomUncheckedUpdateWithoutBomLinesInput>
    create: XOR<BomCreateWithoutBomLinesInput, BomUncheckedCreateWithoutBomLinesInput>
    where?: BomWhereInput
  }

  export type BomUpdateToOneWithWhereWithoutBomLinesInput = {
    where?: BomWhereInput
    data: XOR<BomUpdateWithoutBomLinesInput, BomUncheckedUpdateWithoutBomLinesInput>
  }

  export type BomUpdateWithoutBomLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutBomsNestedInput
    productionOrders?: ProductionOrderUpdateManyWithoutBomNestedInput
  }

  export type BomUncheckedUpdateWithoutBomLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionOrders?: ProductionOrderUncheckedUpdateManyWithoutBomNestedInput
  }

  export type ItemUpsertWithoutBomLinesInput = {
    update: XOR<ItemUpdateWithoutBomLinesInput, ItemUncheckedUpdateWithoutBomLinesInput>
    create: XOR<ItemCreateWithoutBomLinesInput, ItemUncheckedCreateWithoutBomLinesInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutBomLinesInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutBomLinesInput, ItemUncheckedUpdateWithoutBomLinesInput>
  }

  export type ItemUpdateWithoutBomLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    uom?: StringFieldUpdateOperationsInput | string
    costingMethod?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boms?: BomUpdateManyWithoutItemNestedInput
    inventoryBatches?: InventoryBatchUpdateManyWithoutItemNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutItemNestedInput
    productionOrders?: ProductionOrderUpdateManyWithoutItemNestedInput
    purchaseLines?: PurchaseLineUpdateManyWithoutItemNestedInput
    saleLines?: SaleLineUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutBomLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    uom?: StringFieldUpdateOperationsInput | string
    costingMethod?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boms?: BomUncheckedUpdateManyWithoutItemNestedInput
    inventoryBatches?: InventoryBatchUncheckedUpdateManyWithoutItemNestedInput
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutItemNestedInput
    productionOrders?: ProductionOrderUncheckedUpdateManyWithoutItemNestedInput
    purchaseLines?: PurchaseLineUncheckedUpdateManyWithoutItemNestedInput
    saleLines?: SaleLineUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateWithoutInventoryBatchesInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ItemType
    uom?: string
    costingMethod?: $Enums.CostingMethod
    standardCost?: Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: Decimal | DecimalJsLike | number | string | null
    taxCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    boms?: BomCreateNestedManyWithoutItemInput
    bomLines?: BomLineCreateNestedManyWithoutComponentItemInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutItemInput
    productionOrders?: ProductionOrderCreateNestedManyWithoutItemInput
    purchaseLines?: PurchaseLineCreateNestedManyWithoutItemInput
    saleLines?: SaleLineCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutInventoryBatchesInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ItemType
    uom?: string
    costingMethod?: $Enums.CostingMethod
    standardCost?: Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: Decimal | DecimalJsLike | number | string | null
    taxCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    boms?: BomUncheckedCreateNestedManyWithoutItemInput
    bomLines?: BomLineUncheckedCreateNestedManyWithoutComponentItemInput
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutItemInput
    productionOrders?: ProductionOrderUncheckedCreateNestedManyWithoutItemInput
    purchaseLines?: PurchaseLineUncheckedCreateNestedManyWithoutItemInput
    saleLines?: SaleLineUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutInventoryBatchesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutInventoryBatchesInput, ItemUncheckedCreateWithoutInventoryBatchesInput>
  }

  export type WarehouseCreateWithoutInventoryBatchesInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    location: LocationCreateNestedOneWithoutWarehousesInput
    bins?: BinCreateNestedManyWithoutWarehouseInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutWarehouseInput
    productionOrders?: ProductionOrderCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutInventoryBatchesInput = {
    id?: string
    code: string
    name: string
    locationId: string
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    bins?: BinUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutWarehouseInput
    productionOrders?: ProductionOrderUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutInventoryBatchesInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutInventoryBatchesInput, WarehouseUncheckedCreateWithoutInventoryBatchesInput>
  }

  export type BinCreateWithoutInventoryBatchesInput = {
    id?: string
    code: string
    name?: string | null
    warehouse: WarehouseCreateNestedOneWithoutBinsInput
  }

  export type BinUncheckedCreateWithoutInventoryBatchesInput = {
    id?: string
    warehouseId: string
    code: string
    name?: string | null
  }

  export type BinCreateOrConnectWithoutInventoryBatchesInput = {
    where: BinWhereUniqueInput
    create: XOR<BinCreateWithoutInventoryBatchesInput, BinUncheckedCreateWithoutInventoryBatchesInput>
  }

  export type InventoryLedgerCreateWithoutBatchInput = {
    id?: string
    refType: string
    refId: string
    direction: $Enums.LedgerDirection
    qty: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    value: Decimal | DecimalJsLike | number | string
    runningQty: Decimal | DecimalJsLike | number | string
    runningValue: Decimal | DecimalJsLike | number | string
    runningAvgCost: Decimal | DecimalJsLike | number | string
    postedAt?: Date | string
    item: ItemCreateNestedOneWithoutInventoryLedgerInput
    warehouse: WarehouseCreateNestedOneWithoutInventoryLedgerInput
    user?: UserCreateNestedOneWithoutInventoryLedgerInput
  }

  export type InventoryLedgerUncheckedCreateWithoutBatchInput = {
    id?: string
    itemId: string
    warehouseId: string
    refType: string
    refId: string
    direction: $Enums.LedgerDirection
    qty: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    value: Decimal | DecimalJsLike | number | string
    runningQty: Decimal | DecimalJsLike | number | string
    runningValue: Decimal | DecimalJsLike | number | string
    runningAvgCost: Decimal | DecimalJsLike | number | string
    userId?: string | null
    postedAt?: Date | string
  }

  export type InventoryLedgerCreateOrConnectWithoutBatchInput = {
    where: InventoryLedgerWhereUniqueInput
    create: XOR<InventoryLedgerCreateWithoutBatchInput, InventoryLedgerUncheckedCreateWithoutBatchInput>
  }

  export type InventoryLedgerCreateManyBatchInputEnvelope = {
    data: InventoryLedgerCreateManyBatchInput | InventoryLedgerCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type ItemUpsertWithoutInventoryBatchesInput = {
    update: XOR<ItemUpdateWithoutInventoryBatchesInput, ItemUncheckedUpdateWithoutInventoryBatchesInput>
    create: XOR<ItemCreateWithoutInventoryBatchesInput, ItemUncheckedCreateWithoutInventoryBatchesInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutInventoryBatchesInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutInventoryBatchesInput, ItemUncheckedUpdateWithoutInventoryBatchesInput>
  }

  export type ItemUpdateWithoutInventoryBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    uom?: StringFieldUpdateOperationsInput | string
    costingMethod?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boms?: BomUpdateManyWithoutItemNestedInput
    bomLines?: BomLineUpdateManyWithoutComponentItemNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutItemNestedInput
    productionOrders?: ProductionOrderUpdateManyWithoutItemNestedInput
    purchaseLines?: PurchaseLineUpdateManyWithoutItemNestedInput
    saleLines?: SaleLineUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutInventoryBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    uom?: StringFieldUpdateOperationsInput | string
    costingMethod?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boms?: BomUncheckedUpdateManyWithoutItemNestedInput
    bomLines?: BomLineUncheckedUpdateManyWithoutComponentItemNestedInput
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutItemNestedInput
    productionOrders?: ProductionOrderUncheckedUpdateManyWithoutItemNestedInput
    purchaseLines?: PurchaseLineUncheckedUpdateManyWithoutItemNestedInput
    saleLines?: SaleLineUncheckedUpdateManyWithoutItemNestedInput
  }

  export type WarehouseUpsertWithoutInventoryBatchesInput = {
    update: XOR<WarehouseUpdateWithoutInventoryBatchesInput, WarehouseUncheckedUpdateWithoutInventoryBatchesInput>
    create: XOR<WarehouseCreateWithoutInventoryBatchesInput, WarehouseUncheckedCreateWithoutInventoryBatchesInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutInventoryBatchesInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutInventoryBatchesInput, WarehouseUncheckedUpdateWithoutInventoryBatchesInput>
  }

  export type WarehouseUpdateWithoutInventoryBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutWarehousesNestedInput
    bins?: BinUpdateManyWithoutWarehouseNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutWarehouseNestedInput
    productionOrders?: ProductionOrderUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutInventoryBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bins?: BinUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutWarehouseNestedInput
    productionOrders?: ProductionOrderUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type BinUpsertWithoutInventoryBatchesInput = {
    update: XOR<BinUpdateWithoutInventoryBatchesInput, BinUncheckedUpdateWithoutInventoryBatchesInput>
    create: XOR<BinCreateWithoutInventoryBatchesInput, BinUncheckedCreateWithoutInventoryBatchesInput>
    where?: BinWhereInput
  }

  export type BinUpdateToOneWithWhereWithoutInventoryBatchesInput = {
    where?: BinWhereInput
    data: XOR<BinUpdateWithoutInventoryBatchesInput, BinUncheckedUpdateWithoutInventoryBatchesInput>
  }

  export type BinUpdateWithoutInventoryBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    warehouse?: WarehouseUpdateOneRequiredWithoutBinsNestedInput
  }

  export type BinUncheckedUpdateWithoutInventoryBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryLedgerUpsertWithWhereUniqueWithoutBatchInput = {
    where: InventoryLedgerWhereUniqueInput
    update: XOR<InventoryLedgerUpdateWithoutBatchInput, InventoryLedgerUncheckedUpdateWithoutBatchInput>
    create: XOR<InventoryLedgerCreateWithoutBatchInput, InventoryLedgerUncheckedCreateWithoutBatchInput>
  }

  export type InventoryLedgerUpdateWithWhereUniqueWithoutBatchInput = {
    where: InventoryLedgerWhereUniqueInput
    data: XOR<InventoryLedgerUpdateWithoutBatchInput, InventoryLedgerUncheckedUpdateWithoutBatchInput>
  }

  export type InventoryLedgerUpdateManyWithWhereWithoutBatchInput = {
    where: InventoryLedgerScalarWhereInput
    data: XOR<InventoryLedgerUpdateManyMutationInput, InventoryLedgerUncheckedUpdateManyWithoutBatchInput>
  }

  export type ItemCreateWithoutInventoryLedgerInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ItemType
    uom?: string
    costingMethod?: $Enums.CostingMethod
    standardCost?: Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: Decimal | DecimalJsLike | number | string | null
    taxCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    boms?: BomCreateNestedManyWithoutItemInput
    bomLines?: BomLineCreateNestedManyWithoutComponentItemInput
    inventoryBatches?: InventoryBatchCreateNestedManyWithoutItemInput
    productionOrders?: ProductionOrderCreateNestedManyWithoutItemInput
    purchaseLines?: PurchaseLineCreateNestedManyWithoutItemInput
    saleLines?: SaleLineCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutInventoryLedgerInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ItemType
    uom?: string
    costingMethod?: $Enums.CostingMethod
    standardCost?: Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: Decimal | DecimalJsLike | number | string | null
    taxCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    boms?: BomUncheckedCreateNestedManyWithoutItemInput
    bomLines?: BomLineUncheckedCreateNestedManyWithoutComponentItemInput
    inventoryBatches?: InventoryBatchUncheckedCreateNestedManyWithoutItemInput
    productionOrders?: ProductionOrderUncheckedCreateNestedManyWithoutItemInput
    purchaseLines?: PurchaseLineUncheckedCreateNestedManyWithoutItemInput
    saleLines?: SaleLineUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutInventoryLedgerInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutInventoryLedgerInput, ItemUncheckedCreateWithoutInventoryLedgerInput>
  }

  export type WarehouseCreateWithoutInventoryLedgerInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    location: LocationCreateNestedOneWithoutWarehousesInput
    bins?: BinCreateNestedManyWithoutWarehouseInput
    inventoryBatches?: InventoryBatchCreateNestedManyWithoutWarehouseInput
    productionOrders?: ProductionOrderCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutInventoryLedgerInput = {
    id?: string
    code: string
    name: string
    locationId: string
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    bins?: BinUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryBatches?: InventoryBatchUncheckedCreateNestedManyWithoutWarehouseInput
    productionOrders?: ProductionOrderUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutInventoryLedgerInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutInventoryLedgerInput, WarehouseUncheckedCreateWithoutInventoryLedgerInput>
  }

  export type InventoryBatchCreateWithoutInventoryLedgerInput = {
    id?: string
    qtyOnHand: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    receivedAt: Date | string
    item: ItemCreateNestedOneWithoutInventoryBatchesInput
    warehouse: WarehouseCreateNestedOneWithoutInventoryBatchesInput
    bin?: BinCreateNestedOneWithoutInventoryBatchesInput
  }

  export type InventoryBatchUncheckedCreateWithoutInventoryLedgerInput = {
    id?: string
    itemId: string
    warehouseId: string
    binId?: string | null
    qtyOnHand: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    receivedAt: Date | string
  }

  export type InventoryBatchCreateOrConnectWithoutInventoryLedgerInput = {
    where: InventoryBatchWhereUniqueInput
    create: XOR<InventoryBatchCreateWithoutInventoryLedgerInput, InventoryBatchUncheckedCreateWithoutInventoryLedgerInput>
  }

  export type UserCreateWithoutInventoryLedgerInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    journals?: JournalCreateNestedManyWithoutPostedByUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutUserInput
    salesReceipts?: SalesReceiptCreateNestedManyWithoutUserInput
    purchasePayments?: PurchasePaymentCreateNestedManyWithoutUserInput
    SystemSetting?: SystemSettingCreateNestedManyWithoutUpdatedByUserInput
    ApprovalRequest?: ApprovalRequestCreateNestedManyWithoutRequestedByUserInput
    ApprovalAction?: ApprovalActionCreateNestedManyWithoutUserInput
    assetsCreated?: AssetCreateNestedManyWithoutCreatedByUserInput
    assetDisposals?: AssetDisposalCreateNestedManyWithoutDisposedByUserInput
  }

  export type UserUncheckedCreateWithoutInventoryLedgerInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    journals?: JournalUncheckedCreateNestedManyWithoutPostedByUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutUserInput
    salesReceipts?: SalesReceiptUncheckedCreateNestedManyWithoutUserInput
    purchasePayments?: PurchasePaymentUncheckedCreateNestedManyWithoutUserInput
    SystemSetting?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    ApprovalRequest?: ApprovalRequestUncheckedCreateNestedManyWithoutRequestedByUserInput
    ApprovalAction?: ApprovalActionUncheckedCreateNestedManyWithoutUserInput
    assetsCreated?: AssetUncheckedCreateNestedManyWithoutCreatedByUserInput
    assetDisposals?: AssetDisposalUncheckedCreateNestedManyWithoutDisposedByUserInput
  }

  export type UserCreateOrConnectWithoutInventoryLedgerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryLedgerInput, UserUncheckedCreateWithoutInventoryLedgerInput>
  }

  export type ItemUpsertWithoutInventoryLedgerInput = {
    update: XOR<ItemUpdateWithoutInventoryLedgerInput, ItemUncheckedUpdateWithoutInventoryLedgerInput>
    create: XOR<ItemCreateWithoutInventoryLedgerInput, ItemUncheckedCreateWithoutInventoryLedgerInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutInventoryLedgerInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutInventoryLedgerInput, ItemUncheckedUpdateWithoutInventoryLedgerInput>
  }

  export type ItemUpdateWithoutInventoryLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    uom?: StringFieldUpdateOperationsInput | string
    costingMethod?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boms?: BomUpdateManyWithoutItemNestedInput
    bomLines?: BomLineUpdateManyWithoutComponentItemNestedInput
    inventoryBatches?: InventoryBatchUpdateManyWithoutItemNestedInput
    productionOrders?: ProductionOrderUpdateManyWithoutItemNestedInput
    purchaseLines?: PurchaseLineUpdateManyWithoutItemNestedInput
    saleLines?: SaleLineUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutInventoryLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    uom?: StringFieldUpdateOperationsInput | string
    costingMethod?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boms?: BomUncheckedUpdateManyWithoutItemNestedInput
    bomLines?: BomLineUncheckedUpdateManyWithoutComponentItemNestedInput
    inventoryBatches?: InventoryBatchUncheckedUpdateManyWithoutItemNestedInput
    productionOrders?: ProductionOrderUncheckedUpdateManyWithoutItemNestedInput
    purchaseLines?: PurchaseLineUncheckedUpdateManyWithoutItemNestedInput
    saleLines?: SaleLineUncheckedUpdateManyWithoutItemNestedInput
  }

  export type WarehouseUpsertWithoutInventoryLedgerInput = {
    update: XOR<WarehouseUpdateWithoutInventoryLedgerInput, WarehouseUncheckedUpdateWithoutInventoryLedgerInput>
    create: XOR<WarehouseCreateWithoutInventoryLedgerInput, WarehouseUncheckedCreateWithoutInventoryLedgerInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutInventoryLedgerInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutInventoryLedgerInput, WarehouseUncheckedUpdateWithoutInventoryLedgerInput>
  }

  export type WarehouseUpdateWithoutInventoryLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutWarehousesNestedInput
    bins?: BinUpdateManyWithoutWarehouseNestedInput
    inventoryBatches?: InventoryBatchUpdateManyWithoutWarehouseNestedInput
    productionOrders?: ProductionOrderUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutInventoryLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bins?: BinUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryBatches?: InventoryBatchUncheckedUpdateManyWithoutWarehouseNestedInput
    productionOrders?: ProductionOrderUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type InventoryBatchUpsertWithoutInventoryLedgerInput = {
    update: XOR<InventoryBatchUpdateWithoutInventoryLedgerInput, InventoryBatchUncheckedUpdateWithoutInventoryLedgerInput>
    create: XOR<InventoryBatchCreateWithoutInventoryLedgerInput, InventoryBatchUncheckedCreateWithoutInventoryLedgerInput>
    where?: InventoryBatchWhereInput
  }

  export type InventoryBatchUpdateToOneWithWhereWithoutInventoryLedgerInput = {
    where?: InventoryBatchWhereInput
    data: XOR<InventoryBatchUpdateWithoutInventoryLedgerInput, InventoryBatchUncheckedUpdateWithoutInventoryLedgerInput>
  }

  export type InventoryBatchUpdateWithoutInventoryLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutInventoryBatchesNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutInventoryBatchesNestedInput
    bin?: BinUpdateOneWithoutInventoryBatchesNestedInput
  }

  export type InventoryBatchUncheckedUpdateWithoutInventoryLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutInventoryLedgerInput = {
    update: XOR<UserUpdateWithoutInventoryLedgerInput, UserUncheckedUpdateWithoutInventoryLedgerInput>
    create: XOR<UserCreateWithoutInventoryLedgerInput, UserUncheckedCreateWithoutInventoryLedgerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryLedgerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryLedgerInput, UserUncheckedUpdateWithoutInventoryLedgerInput>
  }

  export type UserUpdateWithoutInventoryLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    journals?: JournalUpdateManyWithoutPostedByUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutUserNestedInput
    salesReceipts?: SalesReceiptUpdateManyWithoutUserNestedInput
    purchasePayments?: PurchasePaymentUpdateManyWithoutUserNestedInput
    SystemSetting?: SystemSettingUpdateManyWithoutUpdatedByUserNestedInput
    ApprovalRequest?: ApprovalRequestUpdateManyWithoutRequestedByUserNestedInput
    ApprovalAction?: ApprovalActionUpdateManyWithoutUserNestedInput
    assetsCreated?: AssetUpdateManyWithoutCreatedByUserNestedInput
    assetDisposals?: AssetDisposalUpdateManyWithoutDisposedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    journals?: JournalUncheckedUpdateManyWithoutPostedByUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutUserNestedInput
    salesReceipts?: SalesReceiptUncheckedUpdateManyWithoutUserNestedInput
    purchasePayments?: PurchasePaymentUncheckedUpdateManyWithoutUserNestedInput
    SystemSetting?: SystemSettingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    ApprovalRequest?: ApprovalRequestUncheckedUpdateManyWithoutRequestedByUserNestedInput
    ApprovalAction?: ApprovalActionUncheckedUpdateManyWithoutUserNestedInput
    assetsCreated?: AssetUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assetDisposals?: AssetDisposalUncheckedUpdateManyWithoutDisposedByUserNestedInput
  }

  export type ItemCreateWithoutProductionOrdersInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ItemType
    uom?: string
    costingMethod?: $Enums.CostingMethod
    standardCost?: Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: Decimal | DecimalJsLike | number | string | null
    taxCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    boms?: BomCreateNestedManyWithoutItemInput
    bomLines?: BomLineCreateNestedManyWithoutComponentItemInput
    inventoryBatches?: InventoryBatchCreateNestedManyWithoutItemInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutItemInput
    purchaseLines?: PurchaseLineCreateNestedManyWithoutItemInput
    saleLines?: SaleLineCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutProductionOrdersInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ItemType
    uom?: string
    costingMethod?: $Enums.CostingMethod
    standardCost?: Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: Decimal | DecimalJsLike | number | string | null
    taxCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    boms?: BomUncheckedCreateNestedManyWithoutItemInput
    bomLines?: BomLineUncheckedCreateNestedManyWithoutComponentItemInput
    inventoryBatches?: InventoryBatchUncheckedCreateNestedManyWithoutItemInput
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutItemInput
    purchaseLines?: PurchaseLineUncheckedCreateNestedManyWithoutItemInput
    saleLines?: SaleLineUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutProductionOrdersInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutProductionOrdersInput, ItemUncheckedCreateWithoutProductionOrdersInput>
  }

  export type WarehouseCreateWithoutProductionOrdersInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    location: LocationCreateNestedOneWithoutWarehousesInput
    bins?: BinCreateNestedManyWithoutWarehouseInput
    inventoryBatches?: InventoryBatchCreateNestedManyWithoutWarehouseInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutProductionOrdersInput = {
    id?: string
    code: string
    name: string
    locationId: string
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
    bins?: BinUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryBatches?: InventoryBatchUncheckedCreateNestedManyWithoutWarehouseInput
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutProductionOrdersInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutProductionOrdersInput, WarehouseUncheckedCreateWithoutProductionOrdersInput>
  }

  export type BomCreateWithoutProductionOrdersInput = {
    id?: string
    version?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    item: ItemCreateNestedOneWithoutBomsInput
    bomLines?: BomLineCreateNestedManyWithoutBomInput
  }

  export type BomUncheckedCreateWithoutProductionOrdersInput = {
    id?: string
    itemId: string
    version?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bomLines?: BomLineUncheckedCreateNestedManyWithoutBomInput
  }

  export type BomCreateOrConnectWithoutProductionOrdersInput = {
    where: BomWhereUniqueInput
    create: XOR<BomCreateWithoutProductionOrdersInput, BomUncheckedCreateWithoutProductionOrdersInput>
  }

  export type WipLedgerCreateWithoutProductionOrderInput = {
    id?: string
    type: $Enums.WipLedgerType
    amount: Decimal | DecimalJsLike | number | string
    note?: string | null
    postedAt?: Date | string
  }

  export type WipLedgerUncheckedCreateWithoutProductionOrderInput = {
    id?: string
    type: $Enums.WipLedgerType
    amount: Decimal | DecimalJsLike | number | string
    note?: string | null
    postedAt?: Date | string
  }

  export type WipLedgerCreateOrConnectWithoutProductionOrderInput = {
    where: WipLedgerWhereUniqueInput
    create: XOR<WipLedgerCreateWithoutProductionOrderInput, WipLedgerUncheckedCreateWithoutProductionOrderInput>
  }

  export type WipLedgerCreateManyProductionOrderInputEnvelope = {
    data: WipLedgerCreateManyProductionOrderInput | WipLedgerCreateManyProductionOrderInput[]
    skipDuplicates?: boolean
  }

  export type LaborTimeCreateWithoutProductionOrderInput = {
    id?: string
    hours: Decimal | DecimalJsLike | number | string
    rate: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    employeeName?: string | null
  }

  export type LaborTimeUncheckedCreateWithoutProductionOrderInput = {
    id?: string
    hours: Decimal | DecimalJsLike | number | string
    rate: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    employeeName?: string | null
  }

  export type LaborTimeCreateOrConnectWithoutProductionOrderInput = {
    where: LaborTimeWhereUniqueInput
    create: XOR<LaborTimeCreateWithoutProductionOrderInput, LaborTimeUncheckedCreateWithoutProductionOrderInput>
  }

  export type LaborTimeCreateManyProductionOrderInputEnvelope = {
    data: LaborTimeCreateManyProductionOrderInput | LaborTimeCreateManyProductionOrderInput[]
    skipDuplicates?: boolean
  }

  export type ItemUpsertWithoutProductionOrdersInput = {
    update: XOR<ItemUpdateWithoutProductionOrdersInput, ItemUncheckedUpdateWithoutProductionOrdersInput>
    create: XOR<ItemCreateWithoutProductionOrdersInput, ItemUncheckedCreateWithoutProductionOrdersInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutProductionOrdersInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutProductionOrdersInput, ItemUncheckedUpdateWithoutProductionOrdersInput>
  }

  export type ItemUpdateWithoutProductionOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    uom?: StringFieldUpdateOperationsInput | string
    costingMethod?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boms?: BomUpdateManyWithoutItemNestedInput
    bomLines?: BomLineUpdateManyWithoutComponentItemNestedInput
    inventoryBatches?: InventoryBatchUpdateManyWithoutItemNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutItemNestedInput
    purchaseLines?: PurchaseLineUpdateManyWithoutItemNestedInput
    saleLines?: SaleLineUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutProductionOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    uom?: StringFieldUpdateOperationsInput | string
    costingMethod?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boms?: BomUncheckedUpdateManyWithoutItemNestedInput
    bomLines?: BomLineUncheckedUpdateManyWithoutComponentItemNestedInput
    inventoryBatches?: InventoryBatchUncheckedUpdateManyWithoutItemNestedInput
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutItemNestedInput
    purchaseLines?: PurchaseLineUncheckedUpdateManyWithoutItemNestedInput
    saleLines?: SaleLineUncheckedUpdateManyWithoutItemNestedInput
  }

  export type WarehouseUpsertWithoutProductionOrdersInput = {
    update: XOR<WarehouseUpdateWithoutProductionOrdersInput, WarehouseUncheckedUpdateWithoutProductionOrdersInput>
    create: XOR<WarehouseCreateWithoutProductionOrdersInput, WarehouseUncheckedCreateWithoutProductionOrdersInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutProductionOrdersInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutProductionOrdersInput, WarehouseUncheckedUpdateWithoutProductionOrdersInput>
  }

  export type WarehouseUpdateWithoutProductionOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutWarehousesNestedInput
    bins?: BinUpdateManyWithoutWarehouseNestedInput
    inventoryBatches?: InventoryBatchUpdateManyWithoutWarehouseNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutProductionOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bins?: BinUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryBatches?: InventoryBatchUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type BomUpsertWithoutProductionOrdersInput = {
    update: XOR<BomUpdateWithoutProductionOrdersInput, BomUncheckedUpdateWithoutProductionOrdersInput>
    create: XOR<BomCreateWithoutProductionOrdersInput, BomUncheckedCreateWithoutProductionOrdersInput>
    where?: BomWhereInput
  }

  export type BomUpdateToOneWithWhereWithoutProductionOrdersInput = {
    where?: BomWhereInput
    data: XOR<BomUpdateWithoutProductionOrdersInput, BomUncheckedUpdateWithoutProductionOrdersInput>
  }

  export type BomUpdateWithoutProductionOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutBomsNestedInput
    bomLines?: BomLineUpdateManyWithoutBomNestedInput
  }

  export type BomUncheckedUpdateWithoutProductionOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bomLines?: BomLineUncheckedUpdateManyWithoutBomNestedInput
  }

  export type WipLedgerUpsertWithWhereUniqueWithoutProductionOrderInput = {
    where: WipLedgerWhereUniqueInput
    update: XOR<WipLedgerUpdateWithoutProductionOrderInput, WipLedgerUncheckedUpdateWithoutProductionOrderInput>
    create: XOR<WipLedgerCreateWithoutProductionOrderInput, WipLedgerUncheckedCreateWithoutProductionOrderInput>
  }

  export type WipLedgerUpdateWithWhereUniqueWithoutProductionOrderInput = {
    where: WipLedgerWhereUniqueInput
    data: XOR<WipLedgerUpdateWithoutProductionOrderInput, WipLedgerUncheckedUpdateWithoutProductionOrderInput>
  }

  export type WipLedgerUpdateManyWithWhereWithoutProductionOrderInput = {
    where: WipLedgerScalarWhereInput
    data: XOR<WipLedgerUpdateManyMutationInput, WipLedgerUncheckedUpdateManyWithoutProductionOrderInput>
  }

  export type WipLedgerScalarWhereInput = {
    AND?: WipLedgerScalarWhereInput | WipLedgerScalarWhereInput[]
    OR?: WipLedgerScalarWhereInput[]
    NOT?: WipLedgerScalarWhereInput | WipLedgerScalarWhereInput[]
    id?: StringFilter<"WipLedger"> | string
    productionOrderId?: StringFilter<"WipLedger"> | string
    type?: EnumWipLedgerTypeFilter<"WipLedger"> | $Enums.WipLedgerType
    amount?: DecimalFilter<"WipLedger"> | Decimal | DecimalJsLike | number | string
    note?: StringNullableFilter<"WipLedger"> | string | null
    postedAt?: DateTimeFilter<"WipLedger"> | Date | string
  }

  export type LaborTimeUpsertWithWhereUniqueWithoutProductionOrderInput = {
    where: LaborTimeWhereUniqueInput
    update: XOR<LaborTimeUpdateWithoutProductionOrderInput, LaborTimeUncheckedUpdateWithoutProductionOrderInput>
    create: XOR<LaborTimeCreateWithoutProductionOrderInput, LaborTimeUncheckedCreateWithoutProductionOrderInput>
  }

  export type LaborTimeUpdateWithWhereUniqueWithoutProductionOrderInput = {
    where: LaborTimeWhereUniqueInput
    data: XOR<LaborTimeUpdateWithoutProductionOrderInput, LaborTimeUncheckedUpdateWithoutProductionOrderInput>
  }

  export type LaborTimeUpdateManyWithWhereWithoutProductionOrderInput = {
    where: LaborTimeScalarWhereInput
    data: XOR<LaborTimeUpdateManyMutationInput, LaborTimeUncheckedUpdateManyWithoutProductionOrderInput>
  }

  export type LaborTimeScalarWhereInput = {
    AND?: LaborTimeScalarWhereInput | LaborTimeScalarWhereInput[]
    OR?: LaborTimeScalarWhereInput[]
    NOT?: LaborTimeScalarWhereInput | LaborTimeScalarWhereInput[]
    id?: StringFilter<"LaborTime"> | string
    productionOrderId?: StringFilter<"LaborTime"> | string
    hours?: DecimalFilter<"LaborTime"> | Decimal | DecimalJsLike | number | string
    rate?: DecimalFilter<"LaborTime"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalFilter<"LaborTime"> | Decimal | DecimalJsLike | number | string
    employeeName?: StringNullableFilter<"LaborTime"> | string | null
  }

  export type ProductionOrderCreateWithoutWipLedgerInput = {
    id?: string
    orderNo: string
    qtyTarget: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string
    status?: $Enums.ProductionOrderStatus
    approvalStatus?: string | null
    approvalRequestId?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    item: ItemCreateNestedOneWithoutProductionOrdersInput
    warehouse: WarehouseCreateNestedOneWithoutProductionOrdersInput
    bom?: BomCreateNestedOneWithoutProductionOrdersInput
    laborTimes?: LaborTimeCreateNestedManyWithoutProductionOrderInput
  }

  export type ProductionOrderUncheckedCreateWithoutWipLedgerInput = {
    id?: string
    orderNo: string
    itemId: string
    qtyTarget: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string
    status?: $Enums.ProductionOrderStatus
    warehouseId: string
    bomId?: string | null
    approvalStatus?: string | null
    approvalRequestId?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    laborTimes?: LaborTimeUncheckedCreateNestedManyWithoutProductionOrderInput
  }

  export type ProductionOrderCreateOrConnectWithoutWipLedgerInput = {
    where: ProductionOrderWhereUniqueInput
    create: XOR<ProductionOrderCreateWithoutWipLedgerInput, ProductionOrderUncheckedCreateWithoutWipLedgerInput>
  }

  export type ProductionOrderUpsertWithoutWipLedgerInput = {
    update: XOR<ProductionOrderUpdateWithoutWipLedgerInput, ProductionOrderUncheckedUpdateWithoutWipLedgerInput>
    create: XOR<ProductionOrderCreateWithoutWipLedgerInput, ProductionOrderUncheckedCreateWithoutWipLedgerInput>
    where?: ProductionOrderWhereInput
  }

  export type ProductionOrderUpdateToOneWithWhereWithoutWipLedgerInput = {
    where?: ProductionOrderWhereInput
    data: XOR<ProductionOrderUpdateWithoutWipLedgerInput, ProductionOrderUncheckedUpdateWithoutWipLedgerInput>
  }

  export type ProductionOrderUpdateWithoutWipLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    qtyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumProductionOrderStatusFieldUpdateOperationsInput | $Enums.ProductionOrderStatus
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    approvalRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutProductionOrdersNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutProductionOrdersNestedInput
    bom?: BomUpdateOneWithoutProductionOrdersNestedInput
    laborTimes?: LaborTimeUpdateManyWithoutProductionOrderNestedInput
  }

  export type ProductionOrderUncheckedUpdateWithoutWipLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qtyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumProductionOrderStatusFieldUpdateOperationsInput | $Enums.ProductionOrderStatus
    warehouseId?: StringFieldUpdateOperationsInput | string
    bomId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    approvalRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    laborTimes?: LaborTimeUncheckedUpdateManyWithoutProductionOrderNestedInput
  }

  export type ProductionOrderCreateWithoutLaborTimesInput = {
    id?: string
    orderNo: string
    qtyTarget: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string
    status?: $Enums.ProductionOrderStatus
    approvalStatus?: string | null
    approvalRequestId?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    item: ItemCreateNestedOneWithoutProductionOrdersInput
    warehouse: WarehouseCreateNestedOneWithoutProductionOrdersInput
    bom?: BomCreateNestedOneWithoutProductionOrdersInput
    wipLedger?: WipLedgerCreateNestedManyWithoutProductionOrderInput
  }

  export type ProductionOrderUncheckedCreateWithoutLaborTimesInput = {
    id?: string
    orderNo: string
    itemId: string
    qtyTarget: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string
    status?: $Enums.ProductionOrderStatus
    warehouseId: string
    bomId?: string | null
    approvalStatus?: string | null
    approvalRequestId?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    wipLedger?: WipLedgerUncheckedCreateNestedManyWithoutProductionOrderInput
  }

  export type ProductionOrderCreateOrConnectWithoutLaborTimesInput = {
    where: ProductionOrderWhereUniqueInput
    create: XOR<ProductionOrderCreateWithoutLaborTimesInput, ProductionOrderUncheckedCreateWithoutLaborTimesInput>
  }

  export type ProductionOrderUpsertWithoutLaborTimesInput = {
    update: XOR<ProductionOrderUpdateWithoutLaborTimesInput, ProductionOrderUncheckedUpdateWithoutLaborTimesInput>
    create: XOR<ProductionOrderCreateWithoutLaborTimesInput, ProductionOrderUncheckedCreateWithoutLaborTimesInput>
    where?: ProductionOrderWhereInput
  }

  export type ProductionOrderUpdateToOneWithWhereWithoutLaborTimesInput = {
    where?: ProductionOrderWhereInput
    data: XOR<ProductionOrderUpdateWithoutLaborTimesInput, ProductionOrderUncheckedUpdateWithoutLaborTimesInput>
  }

  export type ProductionOrderUpdateWithoutLaborTimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    qtyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumProductionOrderStatusFieldUpdateOperationsInput | $Enums.ProductionOrderStatus
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    approvalRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutProductionOrdersNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutProductionOrdersNestedInput
    bom?: BomUpdateOneWithoutProductionOrdersNestedInput
    wipLedger?: WipLedgerUpdateManyWithoutProductionOrderNestedInput
  }

  export type ProductionOrderUncheckedUpdateWithoutLaborTimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qtyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumProductionOrderStatusFieldUpdateOperationsInput | $Enums.ProductionOrderStatus
    warehouseId?: StringFieldUpdateOperationsInput | string
    bomId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    approvalRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wipLedger?: WipLedgerUncheckedUpdateManyWithoutProductionOrderNestedInput
  }

  export type PurchaseCreateWithoutVendorInput = {
    id?: string
    orderNo: string
    orderDate: Date | string
    status?: $Enums.PurchaseStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseLines?: PurchaseLineCreateNestedManyWithoutPurchaseInput
    purchasePayments?: PurchasePaymentCreateNestedManyWithoutPurchaseInput
    assets?: AssetCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseUncheckedCreateWithoutVendorInput = {
    id?: string
    orderNo: string
    orderDate: Date | string
    status?: $Enums.PurchaseStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseLines?: PurchaseLineUncheckedCreateNestedManyWithoutPurchaseInput
    purchasePayments?: PurchasePaymentUncheckedCreateNestedManyWithoutPurchaseInput
    assets?: AssetUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseCreateOrConnectWithoutVendorInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutVendorInput, PurchaseUncheckedCreateWithoutVendorInput>
  }

  export type PurchaseCreateManyVendorInputEnvelope = {
    data: PurchaseCreateManyVendorInput | PurchaseCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type PurchasePaymentCreateWithoutVendorInput = {
    id?: string
    paymentNo: string
    amountPaid: Decimal | DecimalJsLike | number | string
    paymentDate: Date | string
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutPurchasePaymentsInput
    cashAccount: CashAccountCreateNestedOneWithoutPurchasePaymentsInput
    user: UserCreateNestedOneWithoutPurchasePaymentsInput
  }

  export type PurchasePaymentUncheckedCreateWithoutVendorInput = {
    id?: string
    paymentNo: string
    purchaseId: string
    cashAccountId: string
    amountPaid: Decimal | DecimalJsLike | number | string
    paymentDate: Date | string
    reference?: string | null
    notes?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type PurchasePaymentCreateOrConnectWithoutVendorInput = {
    where: PurchasePaymentWhereUniqueInput
    create: XOR<PurchasePaymentCreateWithoutVendorInput, PurchasePaymentUncheckedCreateWithoutVendorInput>
  }

  export type PurchasePaymentCreateManyVendorInputEnvelope = {
    data: PurchasePaymentCreateManyVendorInput | PurchasePaymentCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type AssetCreateWithoutVendorInput = {
    id?: string
    assetNo: string
    name: string
    description?: string | null
    acquisitionDate: Date | string
    acquisitionCost: Decimal | DecimalJsLike | number | string
    residualValue?: Decimal | DecimalJsLike | number | string
    usefulLife: number
    depreciationMethod: string
    serialNumber?: string | null
    supplier?: string | null
    status?: string
    disposalDate?: Date | string | null
    disposalAmount?: Decimal | DecimalJsLike | number | string | null
    disposalMethod?: string | null
    createdAt?: Date | string
    category: AssetCategoryCreateNestedOneWithoutAssetsInput
    location?: LocationCreateNestedOneWithoutAssetsInput
    purchaseOrder?: PurchaseCreateNestedOneWithoutAssetsInput
    createdByUser: UserCreateNestedOneWithoutAssetsCreatedInput
    depreciationEntries?: AssetDepreciationCreateNestedManyWithoutAssetInput
    disposals?: AssetDisposalCreateNestedManyWithoutAssetInput
  }

  export type AssetUncheckedCreateWithoutVendorInput = {
    id?: string
    assetNo: string
    name: string
    description?: string | null
    categoryId: string
    acquisitionDate: Date | string
    acquisitionCost: Decimal | DecimalJsLike | number | string
    residualValue?: Decimal | DecimalJsLike | number | string
    usefulLife: number
    depreciationMethod: string
    locationId?: string | null
    serialNumber?: string | null
    supplier?: string | null
    purchaseOrderId?: string | null
    status?: string
    disposalDate?: Date | string | null
    disposalAmount?: Decimal | DecimalJsLike | number | string | null
    disposalMethod?: string | null
    createdBy: string
    createdAt?: Date | string
    depreciationEntries?: AssetDepreciationUncheckedCreateNestedManyWithoutAssetInput
    disposals?: AssetDisposalUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutVendorInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutVendorInput, AssetUncheckedCreateWithoutVendorInput>
  }

  export type AssetCreateManyVendorInputEnvelope = {
    data: AssetCreateManyVendorInput | AssetCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseUpsertWithWhereUniqueWithoutVendorInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutVendorInput, PurchaseUncheckedUpdateWithoutVendorInput>
    create: XOR<PurchaseCreateWithoutVendorInput, PurchaseUncheckedCreateWithoutVendorInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutVendorInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutVendorInput, PurchaseUncheckedUpdateWithoutVendorInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutVendorInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutVendorInput>
  }

  export type PurchaseScalarWhereInput = {
    AND?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    OR?: PurchaseScalarWhereInput[]
    NOT?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    id?: StringFilter<"Purchase"> | string
    orderNo?: StringFilter<"Purchase"> | string
    vendorId?: StringFilter<"Purchase"> | string
    orderDate?: DateTimeFilter<"Purchase"> | Date | string
    status?: EnumPurchaseStatusFilter<"Purchase"> | $Enums.PurchaseStatus
    totalAmount?: DecimalFilter<"Purchase"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Purchase"> | string | null
    createdAt?: DateTimeFilter<"Purchase"> | Date | string
    updatedAt?: DateTimeFilter<"Purchase"> | Date | string
  }

  export type PurchasePaymentUpsertWithWhereUniqueWithoutVendorInput = {
    where: PurchasePaymentWhereUniqueInput
    update: XOR<PurchasePaymentUpdateWithoutVendorInput, PurchasePaymentUncheckedUpdateWithoutVendorInput>
    create: XOR<PurchasePaymentCreateWithoutVendorInput, PurchasePaymentUncheckedCreateWithoutVendorInput>
  }

  export type PurchasePaymentUpdateWithWhereUniqueWithoutVendorInput = {
    where: PurchasePaymentWhereUniqueInput
    data: XOR<PurchasePaymentUpdateWithoutVendorInput, PurchasePaymentUncheckedUpdateWithoutVendorInput>
  }

  export type PurchasePaymentUpdateManyWithWhereWithoutVendorInput = {
    where: PurchasePaymentScalarWhereInput
    data: XOR<PurchasePaymentUpdateManyMutationInput, PurchasePaymentUncheckedUpdateManyWithoutVendorInput>
  }

  export type AssetUpsertWithWhereUniqueWithoutVendorInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutVendorInput, AssetUncheckedUpdateWithoutVendorInput>
    create: XOR<AssetCreateWithoutVendorInput, AssetUncheckedCreateWithoutVendorInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutVendorInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutVendorInput, AssetUncheckedUpdateWithoutVendorInput>
  }

  export type AssetUpdateManyWithWhereWithoutVendorInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutVendorInput>
  }

  export type SaleCreateWithoutCustomerInput = {
    id?: string
    orderNo: string
    orderDate: Date | string
    status?: $Enums.SaleStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    saleLines?: SaleLineCreateNestedManyWithoutSaleInput
    salesReceipts?: SalesReceiptCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutCustomerInput = {
    id?: string
    orderNo: string
    orderDate: Date | string
    status?: $Enums.SaleStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    saleLines?: SaleLineUncheckedCreateNestedManyWithoutSaleInput
    salesReceipts?: SalesReceiptUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutCustomerInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput>
  }

  export type SaleCreateManyCustomerInputEnvelope = {
    data: SaleCreateManyCustomerInput | SaleCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SalesReceiptCreateWithoutCustomerInput = {
    id?: string
    receiptNo: string
    amountReceived: Decimal | DecimalJsLike | number | string
    receiptDate: Date | string
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    sale: SaleCreateNestedOneWithoutSalesReceiptsInput
    cashAccount: CashAccountCreateNestedOneWithoutSalesReceiptsInput
    user: UserCreateNestedOneWithoutSalesReceiptsInput
  }

  export type SalesReceiptUncheckedCreateWithoutCustomerInput = {
    id?: string
    receiptNo: string
    saleId: string
    cashAccountId: string
    amountReceived: Decimal | DecimalJsLike | number | string
    receiptDate: Date | string
    reference?: string | null
    notes?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type SalesReceiptCreateOrConnectWithoutCustomerInput = {
    where: SalesReceiptWhereUniqueInput
    create: XOR<SalesReceiptCreateWithoutCustomerInput, SalesReceiptUncheckedCreateWithoutCustomerInput>
  }

  export type SalesReceiptCreateManyCustomerInputEnvelope = {
    data: SalesReceiptCreateManyCustomerInput | SalesReceiptCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SaleUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutCustomerInput, SaleUncheckedUpdateWithoutCustomerInput>
    create: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutCustomerInput, SaleUncheckedUpdateWithoutCustomerInput>
  }

  export type SaleUpdateManyWithWhereWithoutCustomerInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SaleScalarWhereInput = {
    AND?: SaleScalarWhereInput | SaleScalarWhereInput[]
    OR?: SaleScalarWhereInput[]
    NOT?: SaleScalarWhereInput | SaleScalarWhereInput[]
    id?: StringFilter<"Sale"> | string
    orderNo?: StringFilter<"Sale"> | string
    customerId?: StringFilter<"Sale"> | string
    orderDate?: DateTimeFilter<"Sale"> | Date | string
    status?: EnumSaleStatusFilter<"Sale"> | $Enums.SaleStatus
    totalAmount?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Sale"> | string | null
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    updatedAt?: DateTimeFilter<"Sale"> | Date | string
  }

  export type SalesReceiptUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SalesReceiptWhereUniqueInput
    update: XOR<SalesReceiptUpdateWithoutCustomerInput, SalesReceiptUncheckedUpdateWithoutCustomerInput>
    create: XOR<SalesReceiptCreateWithoutCustomerInput, SalesReceiptUncheckedCreateWithoutCustomerInput>
  }

  export type SalesReceiptUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SalesReceiptWhereUniqueInput
    data: XOR<SalesReceiptUpdateWithoutCustomerInput, SalesReceiptUncheckedUpdateWithoutCustomerInput>
  }

  export type SalesReceiptUpdateManyWithWhereWithoutCustomerInput = {
    where: SalesReceiptScalarWhereInput
    data: XOR<SalesReceiptUpdateManyMutationInput, SalesReceiptUncheckedUpdateManyWithoutCustomerInput>
  }

  export type VendorCreateWithoutPurchasesInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    paymentTerms?: string | null
    isActive?: boolean
    createdAt?: Date | string
    purchasePayments?: PurchasePaymentCreateNestedManyWithoutVendorInput
    assets?: AssetCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutPurchasesInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    paymentTerms?: string | null
    isActive?: boolean
    createdAt?: Date | string
    purchasePayments?: PurchasePaymentUncheckedCreateNestedManyWithoutVendorInput
    assets?: AssetUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutPurchasesInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutPurchasesInput, VendorUncheckedCreateWithoutPurchasesInput>
  }

  export type PurchaseLineCreateWithoutPurchaseInput = {
    id?: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    item: ItemCreateNestedOneWithoutPurchaseLinesInput
  }

  export type PurchaseLineUncheckedCreateWithoutPurchaseInput = {
    id?: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type PurchaseLineCreateOrConnectWithoutPurchaseInput = {
    where: PurchaseLineWhereUniqueInput
    create: XOR<PurchaseLineCreateWithoutPurchaseInput, PurchaseLineUncheckedCreateWithoutPurchaseInput>
  }

  export type PurchaseLineCreateManyPurchaseInputEnvelope = {
    data: PurchaseLineCreateManyPurchaseInput | PurchaseLineCreateManyPurchaseInput[]
    skipDuplicates?: boolean
  }

  export type PurchasePaymentCreateWithoutPurchaseInput = {
    id?: string
    paymentNo: string
    amountPaid: Decimal | DecimalJsLike | number | string
    paymentDate: Date | string
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    vendor: VendorCreateNestedOneWithoutPurchasePaymentsInput
    cashAccount: CashAccountCreateNestedOneWithoutPurchasePaymentsInput
    user: UserCreateNestedOneWithoutPurchasePaymentsInput
  }

  export type PurchasePaymentUncheckedCreateWithoutPurchaseInput = {
    id?: string
    paymentNo: string
    vendorId: string
    cashAccountId: string
    amountPaid: Decimal | DecimalJsLike | number | string
    paymentDate: Date | string
    reference?: string | null
    notes?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type PurchasePaymentCreateOrConnectWithoutPurchaseInput = {
    where: PurchasePaymentWhereUniqueInput
    create: XOR<PurchasePaymentCreateWithoutPurchaseInput, PurchasePaymentUncheckedCreateWithoutPurchaseInput>
  }

  export type PurchasePaymentCreateManyPurchaseInputEnvelope = {
    data: PurchasePaymentCreateManyPurchaseInput | PurchasePaymentCreateManyPurchaseInput[]
    skipDuplicates?: boolean
  }

  export type AssetCreateWithoutPurchaseOrderInput = {
    id?: string
    assetNo: string
    name: string
    description?: string | null
    acquisitionDate: Date | string
    acquisitionCost: Decimal | DecimalJsLike | number | string
    residualValue?: Decimal | DecimalJsLike | number | string
    usefulLife: number
    depreciationMethod: string
    serialNumber?: string | null
    supplier?: string | null
    status?: string
    disposalDate?: Date | string | null
    disposalAmount?: Decimal | DecimalJsLike | number | string | null
    disposalMethod?: string | null
    createdAt?: Date | string
    category: AssetCategoryCreateNestedOneWithoutAssetsInput
    location?: LocationCreateNestedOneWithoutAssetsInput
    createdByUser: UserCreateNestedOneWithoutAssetsCreatedInput
    depreciationEntries?: AssetDepreciationCreateNestedManyWithoutAssetInput
    disposals?: AssetDisposalCreateNestedManyWithoutAssetInput
    Vendor?: VendorCreateNestedOneWithoutAssetsInput
  }

  export type AssetUncheckedCreateWithoutPurchaseOrderInput = {
    id?: string
    assetNo: string
    name: string
    description?: string | null
    categoryId: string
    acquisitionDate: Date | string
    acquisitionCost: Decimal | DecimalJsLike | number | string
    residualValue?: Decimal | DecimalJsLike | number | string
    usefulLife: number
    depreciationMethod: string
    locationId?: string | null
    serialNumber?: string | null
    supplier?: string | null
    status?: string
    disposalDate?: Date | string | null
    disposalAmount?: Decimal | DecimalJsLike | number | string | null
    disposalMethod?: string | null
    createdBy: string
    createdAt?: Date | string
    vendorId?: string | null
    depreciationEntries?: AssetDepreciationUncheckedCreateNestedManyWithoutAssetInput
    disposals?: AssetDisposalUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutPurchaseOrderInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutPurchaseOrderInput, AssetUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type AssetCreateManyPurchaseOrderInputEnvelope = {
    data: AssetCreateManyPurchaseOrderInput | AssetCreateManyPurchaseOrderInput[]
    skipDuplicates?: boolean
  }

  export type VendorUpsertWithoutPurchasesInput = {
    update: XOR<VendorUpdateWithoutPurchasesInput, VendorUncheckedUpdateWithoutPurchasesInput>
    create: XOR<VendorCreateWithoutPurchasesInput, VendorUncheckedCreateWithoutPurchasesInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutPurchasesInput, VendorUncheckedUpdateWithoutPurchasesInput>
  }

  export type VendorUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchasePayments?: PurchasePaymentUpdateManyWithoutVendorNestedInput
    assets?: AssetUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutPurchasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchasePayments?: PurchasePaymentUncheckedUpdateManyWithoutVendorNestedInput
    assets?: AssetUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type PurchaseLineUpsertWithWhereUniqueWithoutPurchaseInput = {
    where: PurchaseLineWhereUniqueInput
    update: XOR<PurchaseLineUpdateWithoutPurchaseInput, PurchaseLineUncheckedUpdateWithoutPurchaseInput>
    create: XOR<PurchaseLineCreateWithoutPurchaseInput, PurchaseLineUncheckedCreateWithoutPurchaseInput>
  }

  export type PurchaseLineUpdateWithWhereUniqueWithoutPurchaseInput = {
    where: PurchaseLineWhereUniqueInput
    data: XOR<PurchaseLineUpdateWithoutPurchaseInput, PurchaseLineUncheckedUpdateWithoutPurchaseInput>
  }

  export type PurchaseLineUpdateManyWithWhereWithoutPurchaseInput = {
    where: PurchaseLineScalarWhereInput
    data: XOR<PurchaseLineUpdateManyMutationInput, PurchaseLineUncheckedUpdateManyWithoutPurchaseInput>
  }

  export type PurchasePaymentUpsertWithWhereUniqueWithoutPurchaseInput = {
    where: PurchasePaymentWhereUniqueInput
    update: XOR<PurchasePaymentUpdateWithoutPurchaseInput, PurchasePaymentUncheckedUpdateWithoutPurchaseInput>
    create: XOR<PurchasePaymentCreateWithoutPurchaseInput, PurchasePaymentUncheckedCreateWithoutPurchaseInput>
  }

  export type PurchasePaymentUpdateWithWhereUniqueWithoutPurchaseInput = {
    where: PurchasePaymentWhereUniqueInput
    data: XOR<PurchasePaymentUpdateWithoutPurchaseInput, PurchasePaymentUncheckedUpdateWithoutPurchaseInput>
  }

  export type PurchasePaymentUpdateManyWithWhereWithoutPurchaseInput = {
    where: PurchasePaymentScalarWhereInput
    data: XOR<PurchasePaymentUpdateManyMutationInput, PurchasePaymentUncheckedUpdateManyWithoutPurchaseInput>
  }

  export type AssetUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutPurchaseOrderInput, AssetUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<AssetCreateWithoutPurchaseOrderInput, AssetUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutPurchaseOrderInput, AssetUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type AssetUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type PurchaseCreateWithoutPurchaseLinesInput = {
    id?: string
    orderNo: string
    orderDate: Date | string
    status?: $Enums.PurchaseStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutPurchasesInput
    purchasePayments?: PurchasePaymentCreateNestedManyWithoutPurchaseInput
    assets?: AssetCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseUncheckedCreateWithoutPurchaseLinesInput = {
    id?: string
    orderNo: string
    vendorId: string
    orderDate: Date | string
    status?: $Enums.PurchaseStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchasePayments?: PurchasePaymentUncheckedCreateNestedManyWithoutPurchaseInput
    assets?: AssetUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseCreateOrConnectWithoutPurchaseLinesInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutPurchaseLinesInput, PurchaseUncheckedCreateWithoutPurchaseLinesInput>
  }

  export type ItemCreateWithoutPurchaseLinesInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ItemType
    uom?: string
    costingMethod?: $Enums.CostingMethod
    standardCost?: Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: Decimal | DecimalJsLike | number | string | null
    taxCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    boms?: BomCreateNestedManyWithoutItemInput
    bomLines?: BomLineCreateNestedManyWithoutComponentItemInput
    inventoryBatches?: InventoryBatchCreateNestedManyWithoutItemInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutItemInput
    productionOrders?: ProductionOrderCreateNestedManyWithoutItemInput
    saleLines?: SaleLineCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutPurchaseLinesInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ItemType
    uom?: string
    costingMethod?: $Enums.CostingMethod
    standardCost?: Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: Decimal | DecimalJsLike | number | string | null
    taxCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    boms?: BomUncheckedCreateNestedManyWithoutItemInput
    bomLines?: BomLineUncheckedCreateNestedManyWithoutComponentItemInput
    inventoryBatches?: InventoryBatchUncheckedCreateNestedManyWithoutItemInput
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutItemInput
    productionOrders?: ProductionOrderUncheckedCreateNestedManyWithoutItemInput
    saleLines?: SaleLineUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutPurchaseLinesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutPurchaseLinesInput, ItemUncheckedCreateWithoutPurchaseLinesInput>
  }

  export type PurchaseUpsertWithoutPurchaseLinesInput = {
    update: XOR<PurchaseUpdateWithoutPurchaseLinesInput, PurchaseUncheckedUpdateWithoutPurchaseLinesInput>
    create: XOR<PurchaseCreateWithoutPurchaseLinesInput, PurchaseUncheckedCreateWithoutPurchaseLinesInput>
    where?: PurchaseWhereInput
  }

  export type PurchaseUpdateToOneWithWhereWithoutPurchaseLinesInput = {
    where?: PurchaseWhereInput
    data: XOR<PurchaseUpdateWithoutPurchaseLinesInput, PurchaseUncheckedUpdateWithoutPurchaseLinesInput>
  }

  export type PurchaseUpdateWithoutPurchaseLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutPurchasesNestedInput
    purchasePayments?: PurchasePaymentUpdateManyWithoutPurchaseNestedInput
    assets?: AssetUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutPurchaseLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchasePayments?: PurchasePaymentUncheckedUpdateManyWithoutPurchaseNestedInput
    assets?: AssetUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type ItemUpsertWithoutPurchaseLinesInput = {
    update: XOR<ItemUpdateWithoutPurchaseLinesInput, ItemUncheckedUpdateWithoutPurchaseLinesInput>
    create: XOR<ItemCreateWithoutPurchaseLinesInput, ItemUncheckedCreateWithoutPurchaseLinesInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutPurchaseLinesInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutPurchaseLinesInput, ItemUncheckedUpdateWithoutPurchaseLinesInput>
  }

  export type ItemUpdateWithoutPurchaseLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    uom?: StringFieldUpdateOperationsInput | string
    costingMethod?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boms?: BomUpdateManyWithoutItemNestedInput
    bomLines?: BomLineUpdateManyWithoutComponentItemNestedInput
    inventoryBatches?: InventoryBatchUpdateManyWithoutItemNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutItemNestedInput
    productionOrders?: ProductionOrderUpdateManyWithoutItemNestedInput
    saleLines?: SaleLineUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutPurchaseLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    uom?: StringFieldUpdateOperationsInput | string
    costingMethod?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boms?: BomUncheckedUpdateManyWithoutItemNestedInput
    bomLines?: BomLineUncheckedUpdateManyWithoutComponentItemNestedInput
    inventoryBatches?: InventoryBatchUncheckedUpdateManyWithoutItemNestedInput
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutItemNestedInput
    productionOrders?: ProductionOrderUncheckedUpdateManyWithoutItemNestedInput
    saleLines?: SaleLineUncheckedUpdateManyWithoutItemNestedInput
  }

  export type CustomerCreateWithoutSalesInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    CustomerGroup: string
    isActive?: boolean
    createdAt?: Date | string
    salesReceipts?: SalesReceiptCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSalesInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    CustomerGroup: string
    isActive?: boolean
    createdAt?: Date | string
    salesReceipts?: SalesReceiptUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSalesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
  }

  export type SaleLineCreateWithoutSaleInput = {
    id?: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
    item: ItemCreateNestedOneWithoutSaleLinesInput
  }

  export type SaleLineUncheckedCreateWithoutSaleInput = {
    id?: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SaleLineCreateOrConnectWithoutSaleInput = {
    where: SaleLineWhereUniqueInput
    create: XOR<SaleLineCreateWithoutSaleInput, SaleLineUncheckedCreateWithoutSaleInput>
  }

  export type SaleLineCreateManySaleInputEnvelope = {
    data: SaleLineCreateManySaleInput | SaleLineCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type SalesReceiptCreateWithoutSaleInput = {
    id?: string
    receiptNo: string
    amountReceived: Decimal | DecimalJsLike | number | string
    receiptDate: Date | string
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSalesReceiptsInput
    cashAccount: CashAccountCreateNestedOneWithoutSalesReceiptsInput
    user: UserCreateNestedOneWithoutSalesReceiptsInput
  }

  export type SalesReceiptUncheckedCreateWithoutSaleInput = {
    id?: string
    receiptNo: string
    customerId: string
    cashAccountId: string
    amountReceived: Decimal | DecimalJsLike | number | string
    receiptDate: Date | string
    reference?: string | null
    notes?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type SalesReceiptCreateOrConnectWithoutSaleInput = {
    where: SalesReceiptWhereUniqueInput
    create: XOR<SalesReceiptCreateWithoutSaleInput, SalesReceiptUncheckedCreateWithoutSaleInput>
  }

  export type SalesReceiptCreateManySaleInputEnvelope = {
    data: SalesReceiptCreateManySaleInput | SalesReceiptCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutSalesInput = {
    update: XOR<CustomerUpdateWithoutSalesInput, CustomerUncheckedUpdateWithoutSalesInput>
    create: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSalesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSalesInput, CustomerUncheckedUpdateWithoutSalesInput>
  }

  export type CustomerUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    CustomerGroup?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesReceipts?: SalesReceiptUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    CustomerGroup?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesReceipts?: SalesReceiptUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type SaleLineUpsertWithWhereUniqueWithoutSaleInput = {
    where: SaleLineWhereUniqueInput
    update: XOR<SaleLineUpdateWithoutSaleInput, SaleLineUncheckedUpdateWithoutSaleInput>
    create: XOR<SaleLineCreateWithoutSaleInput, SaleLineUncheckedCreateWithoutSaleInput>
  }

  export type SaleLineUpdateWithWhereUniqueWithoutSaleInput = {
    where: SaleLineWhereUniqueInput
    data: XOR<SaleLineUpdateWithoutSaleInput, SaleLineUncheckedUpdateWithoutSaleInput>
  }

  export type SaleLineUpdateManyWithWhereWithoutSaleInput = {
    where: SaleLineScalarWhereInput
    data: XOR<SaleLineUpdateManyMutationInput, SaleLineUncheckedUpdateManyWithoutSaleInput>
  }

  export type SalesReceiptUpsertWithWhereUniqueWithoutSaleInput = {
    where: SalesReceiptWhereUniqueInput
    update: XOR<SalesReceiptUpdateWithoutSaleInput, SalesReceiptUncheckedUpdateWithoutSaleInput>
    create: XOR<SalesReceiptCreateWithoutSaleInput, SalesReceiptUncheckedCreateWithoutSaleInput>
  }

  export type SalesReceiptUpdateWithWhereUniqueWithoutSaleInput = {
    where: SalesReceiptWhereUniqueInput
    data: XOR<SalesReceiptUpdateWithoutSaleInput, SalesReceiptUncheckedUpdateWithoutSaleInput>
  }

  export type SalesReceiptUpdateManyWithWhereWithoutSaleInput = {
    where: SalesReceiptScalarWhereInput
    data: XOR<SalesReceiptUpdateManyMutationInput, SalesReceiptUncheckedUpdateManyWithoutSaleInput>
  }

  export type SaleCreateWithoutSaleLinesInput = {
    id?: string
    orderNo: string
    orderDate: Date | string
    status?: $Enums.SaleStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSalesInput
    salesReceipts?: SalesReceiptCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutSaleLinesInput = {
    id?: string
    orderNo: string
    customerId: string
    orderDate: Date | string
    status?: $Enums.SaleStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    salesReceipts?: SalesReceiptUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutSaleLinesInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutSaleLinesInput, SaleUncheckedCreateWithoutSaleLinesInput>
  }

  export type ItemCreateWithoutSaleLinesInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ItemType
    uom?: string
    costingMethod?: $Enums.CostingMethod
    standardCost?: Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: Decimal | DecimalJsLike | number | string | null
    taxCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    boms?: BomCreateNestedManyWithoutItemInput
    bomLines?: BomLineCreateNestedManyWithoutComponentItemInput
    inventoryBatches?: InventoryBatchCreateNestedManyWithoutItemInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutItemInput
    productionOrders?: ProductionOrderCreateNestedManyWithoutItemInput
    purchaseLines?: PurchaseLineCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutSaleLinesInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    type: $Enums.ItemType
    uom?: string
    costingMethod?: $Enums.CostingMethod
    standardCost?: Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: Decimal | DecimalJsLike | number | string | null
    taxCode?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    boms?: BomUncheckedCreateNestedManyWithoutItemInput
    bomLines?: BomLineUncheckedCreateNestedManyWithoutComponentItemInput
    inventoryBatches?: InventoryBatchUncheckedCreateNestedManyWithoutItemInput
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutItemInput
    productionOrders?: ProductionOrderUncheckedCreateNestedManyWithoutItemInput
    purchaseLines?: PurchaseLineUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutSaleLinesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutSaleLinesInput, ItemUncheckedCreateWithoutSaleLinesInput>
  }

  export type SaleUpsertWithoutSaleLinesInput = {
    update: XOR<SaleUpdateWithoutSaleLinesInput, SaleUncheckedUpdateWithoutSaleLinesInput>
    create: XOR<SaleCreateWithoutSaleLinesInput, SaleUncheckedCreateWithoutSaleLinesInput>
    where?: SaleWhereInput
  }

  export type SaleUpdateToOneWithWhereWithoutSaleLinesInput = {
    where?: SaleWhereInput
    data: XOR<SaleUpdateWithoutSaleLinesInput, SaleUncheckedUpdateWithoutSaleLinesInput>
  }

  export type SaleUpdateWithoutSaleLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSalesNestedInput
    salesReceipts?: SalesReceiptUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutSaleLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesReceipts?: SalesReceiptUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type ItemUpsertWithoutSaleLinesInput = {
    update: XOR<ItemUpdateWithoutSaleLinesInput, ItemUncheckedUpdateWithoutSaleLinesInput>
    create: XOR<ItemCreateWithoutSaleLinesInput, ItemUncheckedCreateWithoutSaleLinesInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutSaleLinesInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutSaleLinesInput, ItemUncheckedUpdateWithoutSaleLinesInput>
  }

  export type ItemUpdateWithoutSaleLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    uom?: StringFieldUpdateOperationsInput | string
    costingMethod?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boms?: BomUpdateManyWithoutItemNestedInput
    bomLines?: BomLineUpdateManyWithoutComponentItemNestedInput
    inventoryBatches?: InventoryBatchUpdateManyWithoutItemNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutItemNestedInput
    productionOrders?: ProductionOrderUpdateManyWithoutItemNestedInput
    purchaseLines?: PurchaseLineUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutSaleLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    uom?: StringFieldUpdateOperationsInput | string
    costingMethod?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    standardCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceOrdinary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceBulk?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellingPriceWIC?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taxCode?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boms?: BomUncheckedUpdateManyWithoutItemNestedInput
    bomLines?: BomLineUncheckedUpdateManyWithoutComponentItemNestedInput
    inventoryBatches?: InventoryBatchUncheckedUpdateManyWithoutItemNestedInput
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutItemNestedInput
    productionOrders?: ProductionOrderUncheckedUpdateManyWithoutItemNestedInput
    purchaseLines?: PurchaseLineUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ChartOfAccountCreateWithoutChildrenInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    accountType: string
    isActive?: boolean
    createdAt?: Date | string
    parent?: ChartOfAccountCreateNestedOneWithoutChildrenInput
    journalLines?: JournalLineCreateNestedManyWithoutAccountInput
    cashTransactionsGL?: CashTransactionCreateNestedManyWithoutGlAccountInput
    cashTransactionsContra?: CashTransactionCreateNestedManyWithoutContraAccountInput
    cashAccounts?: CashAccountCreateNestedManyWithoutChartOfAccountInput
    assetCategoriesAsset?: AssetCategoryCreateNestedManyWithoutGlAssetAccountInput
    assetCategoriesDepreciation?: AssetCategoryCreateNestedManyWithoutGlDepreciationAccountInput
    assetCategoriesAccumulated?: AssetCategoryCreateNestedManyWithoutGlAccumulatedDepreciationAccountInput
  }

  export type ChartOfAccountUncheckedCreateWithoutChildrenInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    accountType: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAccountInput
    cashTransactionsGL?: CashTransactionUncheckedCreateNestedManyWithoutGlAccountInput
    cashTransactionsContra?: CashTransactionUncheckedCreateNestedManyWithoutContraAccountInput
    cashAccounts?: CashAccountUncheckedCreateNestedManyWithoutChartOfAccountInput
    assetCategoriesAsset?: AssetCategoryUncheckedCreateNestedManyWithoutGlAssetAccountInput
    assetCategoriesDepreciation?: AssetCategoryUncheckedCreateNestedManyWithoutGlDepreciationAccountInput
    assetCategoriesAccumulated?: AssetCategoryUncheckedCreateNestedManyWithoutGlAccumulatedDepreciationAccountInput
  }

  export type ChartOfAccountCreateOrConnectWithoutChildrenInput = {
    where: ChartOfAccountWhereUniqueInput
    create: XOR<ChartOfAccountCreateWithoutChildrenInput, ChartOfAccountUncheckedCreateWithoutChildrenInput>
  }

  export type ChartOfAccountCreateWithoutParentInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    accountType: string
    isActive?: boolean
    createdAt?: Date | string
    children?: ChartOfAccountCreateNestedManyWithoutParentInput
    journalLines?: JournalLineCreateNestedManyWithoutAccountInput
    cashTransactionsGL?: CashTransactionCreateNestedManyWithoutGlAccountInput
    cashTransactionsContra?: CashTransactionCreateNestedManyWithoutContraAccountInput
    cashAccounts?: CashAccountCreateNestedManyWithoutChartOfAccountInput
    assetCategoriesAsset?: AssetCategoryCreateNestedManyWithoutGlAssetAccountInput
    assetCategoriesDepreciation?: AssetCategoryCreateNestedManyWithoutGlDepreciationAccountInput
    assetCategoriesAccumulated?: AssetCategoryCreateNestedManyWithoutGlAccumulatedDepreciationAccountInput
  }

  export type ChartOfAccountUncheckedCreateWithoutParentInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    accountType: string
    isActive?: boolean
    createdAt?: Date | string
    children?: ChartOfAccountUncheckedCreateNestedManyWithoutParentInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAccountInput
    cashTransactionsGL?: CashTransactionUncheckedCreateNestedManyWithoutGlAccountInput
    cashTransactionsContra?: CashTransactionUncheckedCreateNestedManyWithoutContraAccountInput
    cashAccounts?: CashAccountUncheckedCreateNestedManyWithoutChartOfAccountInput
    assetCategoriesAsset?: AssetCategoryUncheckedCreateNestedManyWithoutGlAssetAccountInput
    assetCategoriesDepreciation?: AssetCategoryUncheckedCreateNestedManyWithoutGlDepreciationAccountInput
    assetCategoriesAccumulated?: AssetCategoryUncheckedCreateNestedManyWithoutGlAccumulatedDepreciationAccountInput
  }

  export type ChartOfAccountCreateOrConnectWithoutParentInput = {
    where: ChartOfAccountWhereUniqueInput
    create: XOR<ChartOfAccountCreateWithoutParentInput, ChartOfAccountUncheckedCreateWithoutParentInput>
  }

  export type ChartOfAccountCreateManyParentInputEnvelope = {
    data: ChartOfAccountCreateManyParentInput | ChartOfAccountCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type JournalLineCreateWithoutAccountInput = {
    id?: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    refType?: string | null
    refId?: string | null
    journal: JournalCreateNestedOneWithoutJournalLinesInput
  }

  export type JournalLineUncheckedCreateWithoutAccountInput = {
    id?: string
    journalId: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    refType?: string | null
    refId?: string | null
  }

  export type JournalLineCreateOrConnectWithoutAccountInput = {
    where: JournalLineWhereUniqueInput
    create: XOR<JournalLineCreateWithoutAccountInput, JournalLineUncheckedCreateWithoutAccountInput>
  }

  export type JournalLineCreateManyAccountInputEnvelope = {
    data: JournalLineCreateManyAccountInput | JournalLineCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type CashTransactionCreateWithoutGlAccountInput = {
    id?: string
    transactionNo: string
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    refType?: string | null
    refId?: string | null
    transactionDate: Date | string
    isReconciled?: boolean
    reconciledAt?: Date | string | null
    createdAt?: Date | string
    reference: string
    cashAccount: CashAccountCreateNestedOneWithoutCashTransactionsInput
    contraAccount?: ChartOfAccountCreateNestedOneWithoutCashTransactionsContraInput
    user: UserCreateNestedOneWithoutCashTransactionsInput
  }

  export type CashTransactionUncheckedCreateWithoutGlAccountInput = {
    id?: string
    transactionNo: string
    cashAccountId: string
    contraAccountId?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    refType?: string | null
    refId?: string | null
    transactionDate: Date | string
    isReconciled?: boolean
    reconciledAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    reference: string
  }

  export type CashTransactionCreateOrConnectWithoutGlAccountInput = {
    where: CashTransactionWhereUniqueInput
    create: XOR<CashTransactionCreateWithoutGlAccountInput, CashTransactionUncheckedCreateWithoutGlAccountInput>
  }

  export type CashTransactionCreateManyGlAccountInputEnvelope = {
    data: CashTransactionCreateManyGlAccountInput | CashTransactionCreateManyGlAccountInput[]
    skipDuplicates?: boolean
  }

  export type CashTransactionCreateWithoutContraAccountInput = {
    id?: string
    transactionNo: string
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    refType?: string | null
    refId?: string | null
    transactionDate: Date | string
    isReconciled?: boolean
    reconciledAt?: Date | string | null
    createdAt?: Date | string
    reference: string
    cashAccount: CashAccountCreateNestedOneWithoutCashTransactionsInput
    glAccount?: ChartOfAccountCreateNestedOneWithoutCashTransactionsGLInput
    user: UserCreateNestedOneWithoutCashTransactionsInput
  }

  export type CashTransactionUncheckedCreateWithoutContraAccountInput = {
    id?: string
    transactionNo: string
    cashAccountId: string
    glAccountId?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    refType?: string | null
    refId?: string | null
    transactionDate: Date | string
    isReconciled?: boolean
    reconciledAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    reference: string
  }

  export type CashTransactionCreateOrConnectWithoutContraAccountInput = {
    where: CashTransactionWhereUniqueInput
    create: XOR<CashTransactionCreateWithoutContraAccountInput, CashTransactionUncheckedCreateWithoutContraAccountInput>
  }

  export type CashTransactionCreateManyContraAccountInputEnvelope = {
    data: CashTransactionCreateManyContraAccountInput | CashTransactionCreateManyContraAccountInput[]
    skipDuplicates?: boolean
  }

  export type CashAccountCreateWithoutChartOfAccountInput = {
    id?: string
    code: string
    name: string
    accountType: string
    accountNumber?: string | null
    glAccountId?: string | null
    bankName?: string | null
    balance?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    cashTransactions?: CashTransactionCreateNestedManyWithoutCashAccountInput
    salesReceipts?: SalesReceiptCreateNestedManyWithoutCashAccountInput
    purchasePayments?: PurchasePaymentCreateNestedManyWithoutCashAccountInput
  }

  export type CashAccountUncheckedCreateWithoutChartOfAccountInput = {
    id?: string
    code: string
    name: string
    accountType: string
    accountNumber?: string | null
    glAccountId?: string | null
    bankName?: string | null
    balance?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCashAccountInput
    salesReceipts?: SalesReceiptUncheckedCreateNestedManyWithoutCashAccountInput
    purchasePayments?: PurchasePaymentUncheckedCreateNestedManyWithoutCashAccountInput
  }

  export type CashAccountCreateOrConnectWithoutChartOfAccountInput = {
    where: CashAccountWhereUniqueInput
    create: XOR<CashAccountCreateWithoutChartOfAccountInput, CashAccountUncheckedCreateWithoutChartOfAccountInput>
  }

  export type CashAccountCreateManyChartOfAccountInputEnvelope = {
    data: CashAccountCreateManyChartOfAccountInput | CashAccountCreateManyChartOfAccountInput[]
    skipDuplicates?: boolean
  }

  export type AssetCategoryCreateWithoutGlAssetAccountInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    depreciationMethod: string
    usefulLife?: number
    residualValue?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    assets?: AssetCreateNestedManyWithoutCategoryInput
    glDepreciationAccount: ChartOfAccountCreateNestedOneWithoutAssetCategoriesDepreciationInput
    glAccumulatedDepreciationAccount: ChartOfAccountCreateNestedOneWithoutAssetCategoriesAccumulatedInput
  }

  export type AssetCategoryUncheckedCreateWithoutGlAssetAccountInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    depreciationMethod: string
    usefulLife?: number
    residualValue?: Decimal | DecimalJsLike | number | string
    glDepreciationAccountId: string
    glAccumulatedDepreciationAccountId: string
    isActive?: boolean
    createdAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type AssetCategoryCreateOrConnectWithoutGlAssetAccountInput = {
    where: AssetCategoryWhereUniqueInput
    create: XOR<AssetCategoryCreateWithoutGlAssetAccountInput, AssetCategoryUncheckedCreateWithoutGlAssetAccountInput>
  }

  export type AssetCategoryCreateManyGlAssetAccountInputEnvelope = {
    data: AssetCategoryCreateManyGlAssetAccountInput | AssetCategoryCreateManyGlAssetAccountInput[]
    skipDuplicates?: boolean
  }

  export type AssetCategoryCreateWithoutGlDepreciationAccountInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    depreciationMethod: string
    usefulLife?: number
    residualValue?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    assets?: AssetCreateNestedManyWithoutCategoryInput
    glAssetAccount: ChartOfAccountCreateNestedOneWithoutAssetCategoriesAssetInput
    glAccumulatedDepreciationAccount: ChartOfAccountCreateNestedOneWithoutAssetCategoriesAccumulatedInput
  }

  export type AssetCategoryUncheckedCreateWithoutGlDepreciationAccountInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    depreciationMethod: string
    usefulLife?: number
    residualValue?: Decimal | DecimalJsLike | number | string
    glAssetAccountId: string
    glAccumulatedDepreciationAccountId: string
    isActive?: boolean
    createdAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type AssetCategoryCreateOrConnectWithoutGlDepreciationAccountInput = {
    where: AssetCategoryWhereUniqueInput
    create: XOR<AssetCategoryCreateWithoutGlDepreciationAccountInput, AssetCategoryUncheckedCreateWithoutGlDepreciationAccountInput>
  }

  export type AssetCategoryCreateManyGlDepreciationAccountInputEnvelope = {
    data: AssetCategoryCreateManyGlDepreciationAccountInput | AssetCategoryCreateManyGlDepreciationAccountInput[]
    skipDuplicates?: boolean
  }

  export type AssetCategoryCreateWithoutGlAccumulatedDepreciationAccountInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    depreciationMethod: string
    usefulLife?: number
    residualValue?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    assets?: AssetCreateNestedManyWithoutCategoryInput
    glAssetAccount: ChartOfAccountCreateNestedOneWithoutAssetCategoriesAssetInput
    glDepreciationAccount: ChartOfAccountCreateNestedOneWithoutAssetCategoriesDepreciationInput
  }

  export type AssetCategoryUncheckedCreateWithoutGlAccumulatedDepreciationAccountInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    depreciationMethod: string
    usefulLife?: number
    residualValue?: Decimal | DecimalJsLike | number | string
    glAssetAccountId: string
    glDepreciationAccountId: string
    isActive?: boolean
    createdAt?: Date | string
    assets?: AssetUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type AssetCategoryCreateOrConnectWithoutGlAccumulatedDepreciationAccountInput = {
    where: AssetCategoryWhereUniqueInput
    create: XOR<AssetCategoryCreateWithoutGlAccumulatedDepreciationAccountInput, AssetCategoryUncheckedCreateWithoutGlAccumulatedDepreciationAccountInput>
  }

  export type AssetCategoryCreateManyGlAccumulatedDepreciationAccountInputEnvelope = {
    data: AssetCategoryCreateManyGlAccumulatedDepreciationAccountInput | AssetCategoryCreateManyGlAccumulatedDepreciationAccountInput[]
    skipDuplicates?: boolean
  }

  export type ChartOfAccountUpsertWithoutChildrenInput = {
    update: XOR<ChartOfAccountUpdateWithoutChildrenInput, ChartOfAccountUncheckedUpdateWithoutChildrenInput>
    create: XOR<ChartOfAccountCreateWithoutChildrenInput, ChartOfAccountUncheckedCreateWithoutChildrenInput>
    where?: ChartOfAccountWhereInput
  }

  export type ChartOfAccountUpdateToOneWithWhereWithoutChildrenInput = {
    where?: ChartOfAccountWhereInput
    data: XOR<ChartOfAccountUpdateWithoutChildrenInput, ChartOfAccountUncheckedUpdateWithoutChildrenInput>
  }

  export type ChartOfAccountUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ChartOfAccountUpdateOneWithoutChildrenNestedInput
    journalLines?: JournalLineUpdateManyWithoutAccountNestedInput
    cashTransactionsGL?: CashTransactionUpdateManyWithoutGlAccountNestedInput
    cashTransactionsContra?: CashTransactionUpdateManyWithoutContraAccountNestedInput
    cashAccounts?: CashAccountUpdateManyWithoutChartOfAccountNestedInput
    assetCategoriesAsset?: AssetCategoryUpdateManyWithoutGlAssetAccountNestedInput
    assetCategoriesDepreciation?: AssetCategoryUpdateManyWithoutGlDepreciationAccountNestedInput
    assetCategoriesAccumulated?: AssetCategoryUpdateManyWithoutGlAccumulatedDepreciationAccountNestedInput
  }

  export type ChartOfAccountUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journalLines?: JournalLineUncheckedUpdateManyWithoutAccountNestedInput
    cashTransactionsGL?: CashTransactionUncheckedUpdateManyWithoutGlAccountNestedInput
    cashTransactionsContra?: CashTransactionUncheckedUpdateManyWithoutContraAccountNestedInput
    cashAccounts?: CashAccountUncheckedUpdateManyWithoutChartOfAccountNestedInput
    assetCategoriesAsset?: AssetCategoryUncheckedUpdateManyWithoutGlAssetAccountNestedInput
    assetCategoriesDepreciation?: AssetCategoryUncheckedUpdateManyWithoutGlDepreciationAccountNestedInput
    assetCategoriesAccumulated?: AssetCategoryUncheckedUpdateManyWithoutGlAccumulatedDepreciationAccountNestedInput
  }

  export type ChartOfAccountUpsertWithWhereUniqueWithoutParentInput = {
    where: ChartOfAccountWhereUniqueInput
    update: XOR<ChartOfAccountUpdateWithoutParentInput, ChartOfAccountUncheckedUpdateWithoutParentInput>
    create: XOR<ChartOfAccountCreateWithoutParentInput, ChartOfAccountUncheckedCreateWithoutParentInput>
  }

  export type ChartOfAccountUpdateWithWhereUniqueWithoutParentInput = {
    where: ChartOfAccountWhereUniqueInput
    data: XOR<ChartOfAccountUpdateWithoutParentInput, ChartOfAccountUncheckedUpdateWithoutParentInput>
  }

  export type ChartOfAccountUpdateManyWithWhereWithoutParentInput = {
    where: ChartOfAccountScalarWhereInput
    data: XOR<ChartOfAccountUpdateManyMutationInput, ChartOfAccountUncheckedUpdateManyWithoutParentInput>
  }

  export type ChartOfAccountScalarWhereInput = {
    AND?: ChartOfAccountScalarWhereInput | ChartOfAccountScalarWhereInput[]
    OR?: ChartOfAccountScalarWhereInput[]
    NOT?: ChartOfAccountScalarWhereInput | ChartOfAccountScalarWhereInput[]
    id?: StringFilter<"ChartOfAccount"> | string
    code?: StringFilter<"ChartOfAccount"> | string
    name?: StringFilter<"ChartOfAccount"> | string
    description?: StringNullableFilter<"ChartOfAccount"> | string | null
    accountType?: StringFilter<"ChartOfAccount"> | string
    parentId?: StringNullableFilter<"ChartOfAccount"> | string | null
    isActive?: BoolFilter<"ChartOfAccount"> | boolean
    createdAt?: DateTimeFilter<"ChartOfAccount"> | Date | string
  }

  export type JournalLineUpsertWithWhereUniqueWithoutAccountInput = {
    where: JournalLineWhereUniqueInput
    update: XOR<JournalLineUpdateWithoutAccountInput, JournalLineUncheckedUpdateWithoutAccountInput>
    create: XOR<JournalLineCreateWithoutAccountInput, JournalLineUncheckedCreateWithoutAccountInput>
  }

  export type JournalLineUpdateWithWhereUniqueWithoutAccountInput = {
    where: JournalLineWhereUniqueInput
    data: XOR<JournalLineUpdateWithoutAccountInput, JournalLineUncheckedUpdateWithoutAccountInput>
  }

  export type JournalLineUpdateManyWithWhereWithoutAccountInput = {
    where: JournalLineScalarWhereInput
    data: XOR<JournalLineUpdateManyMutationInput, JournalLineUncheckedUpdateManyWithoutAccountInput>
  }

  export type JournalLineScalarWhereInput = {
    AND?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
    OR?: JournalLineScalarWhereInput[]
    NOT?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
    id?: StringFilter<"JournalLine"> | string
    journalId?: StringFilter<"JournalLine"> | string
    accountId?: StringFilter<"JournalLine"> | string
    debit?: DecimalFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalFilter<"JournalLine"> | Decimal | DecimalJsLike | number | string
    refType?: StringNullableFilter<"JournalLine"> | string | null
    refId?: StringNullableFilter<"JournalLine"> | string | null
  }

  export type CashTransactionUpsertWithWhereUniqueWithoutGlAccountInput = {
    where: CashTransactionWhereUniqueInput
    update: XOR<CashTransactionUpdateWithoutGlAccountInput, CashTransactionUncheckedUpdateWithoutGlAccountInput>
    create: XOR<CashTransactionCreateWithoutGlAccountInput, CashTransactionUncheckedCreateWithoutGlAccountInput>
  }

  export type CashTransactionUpdateWithWhereUniqueWithoutGlAccountInput = {
    where: CashTransactionWhereUniqueInput
    data: XOR<CashTransactionUpdateWithoutGlAccountInput, CashTransactionUncheckedUpdateWithoutGlAccountInput>
  }

  export type CashTransactionUpdateManyWithWhereWithoutGlAccountInput = {
    where: CashTransactionScalarWhereInput
    data: XOR<CashTransactionUpdateManyMutationInput, CashTransactionUncheckedUpdateManyWithoutGlAccountInput>
  }

  export type CashTransactionUpsertWithWhereUniqueWithoutContraAccountInput = {
    where: CashTransactionWhereUniqueInput
    update: XOR<CashTransactionUpdateWithoutContraAccountInput, CashTransactionUncheckedUpdateWithoutContraAccountInput>
    create: XOR<CashTransactionCreateWithoutContraAccountInput, CashTransactionUncheckedCreateWithoutContraAccountInput>
  }

  export type CashTransactionUpdateWithWhereUniqueWithoutContraAccountInput = {
    where: CashTransactionWhereUniqueInput
    data: XOR<CashTransactionUpdateWithoutContraAccountInput, CashTransactionUncheckedUpdateWithoutContraAccountInput>
  }

  export type CashTransactionUpdateManyWithWhereWithoutContraAccountInput = {
    where: CashTransactionScalarWhereInput
    data: XOR<CashTransactionUpdateManyMutationInput, CashTransactionUncheckedUpdateManyWithoutContraAccountInput>
  }

  export type CashAccountUpsertWithWhereUniqueWithoutChartOfAccountInput = {
    where: CashAccountWhereUniqueInput
    update: XOR<CashAccountUpdateWithoutChartOfAccountInput, CashAccountUncheckedUpdateWithoutChartOfAccountInput>
    create: XOR<CashAccountCreateWithoutChartOfAccountInput, CashAccountUncheckedCreateWithoutChartOfAccountInput>
  }

  export type CashAccountUpdateWithWhereUniqueWithoutChartOfAccountInput = {
    where: CashAccountWhereUniqueInput
    data: XOR<CashAccountUpdateWithoutChartOfAccountInput, CashAccountUncheckedUpdateWithoutChartOfAccountInput>
  }

  export type CashAccountUpdateManyWithWhereWithoutChartOfAccountInput = {
    where: CashAccountScalarWhereInput
    data: XOR<CashAccountUpdateManyMutationInput, CashAccountUncheckedUpdateManyWithoutChartOfAccountInput>
  }

  export type CashAccountScalarWhereInput = {
    AND?: CashAccountScalarWhereInput | CashAccountScalarWhereInput[]
    OR?: CashAccountScalarWhereInput[]
    NOT?: CashAccountScalarWhereInput | CashAccountScalarWhereInput[]
    id?: StringFilter<"CashAccount"> | string
    code?: StringFilter<"CashAccount"> | string
    name?: StringFilter<"CashAccount"> | string
    accountType?: StringFilter<"CashAccount"> | string
    accountNumber?: StringNullableFilter<"CashAccount"> | string | null
    glAccountId?: StringNullableFilter<"CashAccount"> | string | null
    bankName?: StringNullableFilter<"CashAccount"> | string | null
    balance?: DecimalFilter<"CashAccount"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"CashAccount"> | boolean
    createdAt?: DateTimeFilter<"CashAccount"> | Date | string
    chartOfAccountId?: StringNullableFilter<"CashAccount"> | string | null
  }

  export type AssetCategoryUpsertWithWhereUniqueWithoutGlAssetAccountInput = {
    where: AssetCategoryWhereUniqueInput
    update: XOR<AssetCategoryUpdateWithoutGlAssetAccountInput, AssetCategoryUncheckedUpdateWithoutGlAssetAccountInput>
    create: XOR<AssetCategoryCreateWithoutGlAssetAccountInput, AssetCategoryUncheckedCreateWithoutGlAssetAccountInput>
  }

  export type AssetCategoryUpdateWithWhereUniqueWithoutGlAssetAccountInput = {
    where: AssetCategoryWhereUniqueInput
    data: XOR<AssetCategoryUpdateWithoutGlAssetAccountInput, AssetCategoryUncheckedUpdateWithoutGlAssetAccountInput>
  }

  export type AssetCategoryUpdateManyWithWhereWithoutGlAssetAccountInput = {
    where: AssetCategoryScalarWhereInput
    data: XOR<AssetCategoryUpdateManyMutationInput, AssetCategoryUncheckedUpdateManyWithoutGlAssetAccountInput>
  }

  export type AssetCategoryScalarWhereInput = {
    AND?: AssetCategoryScalarWhereInput | AssetCategoryScalarWhereInput[]
    OR?: AssetCategoryScalarWhereInput[]
    NOT?: AssetCategoryScalarWhereInput | AssetCategoryScalarWhereInput[]
    id?: StringFilter<"AssetCategory"> | string
    code?: StringFilter<"AssetCategory"> | string
    name?: StringFilter<"AssetCategory"> | string
    description?: StringNullableFilter<"AssetCategory"> | string | null
    depreciationMethod?: StringFilter<"AssetCategory"> | string
    usefulLife?: IntFilter<"AssetCategory"> | number
    residualValue?: DecimalFilter<"AssetCategory"> | Decimal | DecimalJsLike | number | string
    glAssetAccountId?: StringFilter<"AssetCategory"> | string
    glDepreciationAccountId?: StringFilter<"AssetCategory"> | string
    glAccumulatedDepreciationAccountId?: StringFilter<"AssetCategory"> | string
    isActive?: BoolFilter<"AssetCategory"> | boolean
    createdAt?: DateTimeFilter<"AssetCategory"> | Date | string
  }

  export type AssetCategoryUpsertWithWhereUniqueWithoutGlDepreciationAccountInput = {
    where: AssetCategoryWhereUniqueInput
    update: XOR<AssetCategoryUpdateWithoutGlDepreciationAccountInput, AssetCategoryUncheckedUpdateWithoutGlDepreciationAccountInput>
    create: XOR<AssetCategoryCreateWithoutGlDepreciationAccountInput, AssetCategoryUncheckedCreateWithoutGlDepreciationAccountInput>
  }

  export type AssetCategoryUpdateWithWhereUniqueWithoutGlDepreciationAccountInput = {
    where: AssetCategoryWhereUniqueInput
    data: XOR<AssetCategoryUpdateWithoutGlDepreciationAccountInput, AssetCategoryUncheckedUpdateWithoutGlDepreciationAccountInput>
  }

  export type AssetCategoryUpdateManyWithWhereWithoutGlDepreciationAccountInput = {
    where: AssetCategoryScalarWhereInput
    data: XOR<AssetCategoryUpdateManyMutationInput, AssetCategoryUncheckedUpdateManyWithoutGlDepreciationAccountInput>
  }

  export type AssetCategoryUpsertWithWhereUniqueWithoutGlAccumulatedDepreciationAccountInput = {
    where: AssetCategoryWhereUniqueInput
    update: XOR<AssetCategoryUpdateWithoutGlAccumulatedDepreciationAccountInput, AssetCategoryUncheckedUpdateWithoutGlAccumulatedDepreciationAccountInput>
    create: XOR<AssetCategoryCreateWithoutGlAccumulatedDepreciationAccountInput, AssetCategoryUncheckedCreateWithoutGlAccumulatedDepreciationAccountInput>
  }

  export type AssetCategoryUpdateWithWhereUniqueWithoutGlAccumulatedDepreciationAccountInput = {
    where: AssetCategoryWhereUniqueInput
    data: XOR<AssetCategoryUpdateWithoutGlAccumulatedDepreciationAccountInput, AssetCategoryUncheckedUpdateWithoutGlAccumulatedDepreciationAccountInput>
  }

  export type AssetCategoryUpdateManyWithWhereWithoutGlAccumulatedDepreciationAccountInput = {
    where: AssetCategoryScalarWhereInput
    data: XOR<AssetCategoryUpdateManyMutationInput, AssetCategoryUncheckedUpdateManyWithoutGlAccumulatedDepreciationAccountInput>
  }

  export type UserCreateWithoutJournalsInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutUserInput
    salesReceipts?: SalesReceiptCreateNestedManyWithoutUserInput
    purchasePayments?: PurchasePaymentCreateNestedManyWithoutUserInput
    SystemSetting?: SystemSettingCreateNestedManyWithoutUpdatedByUserInput
    ApprovalRequest?: ApprovalRequestCreateNestedManyWithoutRequestedByUserInput
    ApprovalAction?: ApprovalActionCreateNestedManyWithoutUserInput
    assetsCreated?: AssetCreateNestedManyWithoutCreatedByUserInput
    assetDisposals?: AssetDisposalCreateNestedManyWithoutDisposedByUserInput
  }

  export type UserUncheckedCreateWithoutJournalsInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutUserInput
    salesReceipts?: SalesReceiptUncheckedCreateNestedManyWithoutUserInput
    purchasePayments?: PurchasePaymentUncheckedCreateNestedManyWithoutUserInput
    SystemSetting?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    ApprovalRequest?: ApprovalRequestUncheckedCreateNestedManyWithoutRequestedByUserInput
    ApprovalAction?: ApprovalActionUncheckedCreateNestedManyWithoutUserInput
    assetsCreated?: AssetUncheckedCreateNestedManyWithoutCreatedByUserInput
    assetDisposals?: AssetDisposalUncheckedCreateNestedManyWithoutDisposedByUserInput
  }

  export type UserCreateOrConnectWithoutJournalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJournalsInput, UserUncheckedCreateWithoutJournalsInput>
  }

  export type JournalLineCreateWithoutJournalInput = {
    id?: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    refType?: string | null
    refId?: string | null
    account: ChartOfAccountCreateNestedOneWithoutJournalLinesInput
  }

  export type JournalLineUncheckedCreateWithoutJournalInput = {
    id?: string
    accountId: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    refType?: string | null
    refId?: string | null
  }

  export type JournalLineCreateOrConnectWithoutJournalInput = {
    where: JournalLineWhereUniqueInput
    create: XOR<JournalLineCreateWithoutJournalInput, JournalLineUncheckedCreateWithoutJournalInput>
  }

  export type JournalLineCreateManyJournalInputEnvelope = {
    data: JournalLineCreateManyJournalInput | JournalLineCreateManyJournalInput[]
    skipDuplicates?: boolean
  }

  export type AssetDepreciationCreateWithoutJournalInput = {
    id?: string
    periodYear: number
    periodMonth: number
    depreciationAmount: Decimal | DecimalJsLike | number | string
    accumulatedDepreciation: Decimal | DecimalJsLike | number | string
    netBookValue: Decimal | DecimalJsLike | number | string
    isPosted?: boolean
    postedAt?: Date | string | null
    createdAt?: Date | string
    asset: AssetCreateNestedOneWithoutDepreciationEntriesInput
  }

  export type AssetDepreciationUncheckedCreateWithoutJournalInput = {
    id?: string
    assetId: string
    periodYear: number
    periodMonth: number
    depreciationAmount: Decimal | DecimalJsLike | number | string
    accumulatedDepreciation: Decimal | DecimalJsLike | number | string
    netBookValue: Decimal | DecimalJsLike | number | string
    isPosted?: boolean
    postedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AssetDepreciationCreateOrConnectWithoutJournalInput = {
    where: AssetDepreciationWhereUniqueInput
    create: XOR<AssetDepreciationCreateWithoutJournalInput, AssetDepreciationUncheckedCreateWithoutJournalInput>
  }

  export type AssetDepreciationCreateManyJournalInputEnvelope = {
    data: AssetDepreciationCreateManyJournalInput | AssetDepreciationCreateManyJournalInput[]
    skipDuplicates?: boolean
  }

  export type AssetDisposalCreateWithoutJournalInput = {
    id?: string
    disposalDate: Date | string
    disposalAmount: Decimal | DecimalJsLike | number | string
    disposalMethod: string
    buyerDetails?: string | null
    gainLoss: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    asset: AssetCreateNestedOneWithoutDisposalsInput
    disposedByUser: UserCreateNestedOneWithoutAssetDisposalsInput
  }

  export type AssetDisposalUncheckedCreateWithoutJournalInput = {
    id?: string
    assetId: string
    disposalDate: Date | string
    disposalAmount: Decimal | DecimalJsLike | number | string
    disposalMethod: string
    buyerDetails?: string | null
    gainLoss: Decimal | DecimalJsLike | number | string
    notes?: string | null
    disposedBy: string
    createdAt?: Date | string
  }

  export type AssetDisposalCreateOrConnectWithoutJournalInput = {
    where: AssetDisposalWhereUniqueInput
    create: XOR<AssetDisposalCreateWithoutJournalInput, AssetDisposalUncheckedCreateWithoutJournalInput>
  }

  export type AssetDisposalCreateManyJournalInputEnvelope = {
    data: AssetDisposalCreateManyJournalInput | AssetDisposalCreateManyJournalInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutJournalsInput = {
    update: XOR<UserUpdateWithoutJournalsInput, UserUncheckedUpdateWithoutJournalsInput>
    create: XOR<UserCreateWithoutJournalsInput, UserUncheckedCreateWithoutJournalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutJournalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutJournalsInput, UserUncheckedUpdateWithoutJournalsInput>
  }

  export type UserUpdateWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutUserNestedInput
    salesReceipts?: SalesReceiptUpdateManyWithoutUserNestedInput
    purchasePayments?: PurchasePaymentUpdateManyWithoutUserNestedInput
    SystemSetting?: SystemSettingUpdateManyWithoutUpdatedByUserNestedInput
    ApprovalRequest?: ApprovalRequestUpdateManyWithoutRequestedByUserNestedInput
    ApprovalAction?: ApprovalActionUpdateManyWithoutUserNestedInput
    assetsCreated?: AssetUpdateManyWithoutCreatedByUserNestedInput
    assetDisposals?: AssetDisposalUpdateManyWithoutDisposedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutJournalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutUserNestedInput
    salesReceipts?: SalesReceiptUncheckedUpdateManyWithoutUserNestedInput
    purchasePayments?: PurchasePaymentUncheckedUpdateManyWithoutUserNestedInput
    SystemSetting?: SystemSettingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    ApprovalRequest?: ApprovalRequestUncheckedUpdateManyWithoutRequestedByUserNestedInput
    ApprovalAction?: ApprovalActionUncheckedUpdateManyWithoutUserNestedInput
    assetsCreated?: AssetUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assetDisposals?: AssetDisposalUncheckedUpdateManyWithoutDisposedByUserNestedInput
  }

  export type JournalLineUpsertWithWhereUniqueWithoutJournalInput = {
    where: JournalLineWhereUniqueInput
    update: XOR<JournalLineUpdateWithoutJournalInput, JournalLineUncheckedUpdateWithoutJournalInput>
    create: XOR<JournalLineCreateWithoutJournalInput, JournalLineUncheckedCreateWithoutJournalInput>
  }

  export type JournalLineUpdateWithWhereUniqueWithoutJournalInput = {
    where: JournalLineWhereUniqueInput
    data: XOR<JournalLineUpdateWithoutJournalInput, JournalLineUncheckedUpdateWithoutJournalInput>
  }

  export type JournalLineUpdateManyWithWhereWithoutJournalInput = {
    where: JournalLineScalarWhereInput
    data: XOR<JournalLineUpdateManyMutationInput, JournalLineUncheckedUpdateManyWithoutJournalInput>
  }

  export type AssetDepreciationUpsertWithWhereUniqueWithoutJournalInput = {
    where: AssetDepreciationWhereUniqueInput
    update: XOR<AssetDepreciationUpdateWithoutJournalInput, AssetDepreciationUncheckedUpdateWithoutJournalInput>
    create: XOR<AssetDepreciationCreateWithoutJournalInput, AssetDepreciationUncheckedCreateWithoutJournalInput>
  }

  export type AssetDepreciationUpdateWithWhereUniqueWithoutJournalInput = {
    where: AssetDepreciationWhereUniqueInput
    data: XOR<AssetDepreciationUpdateWithoutJournalInput, AssetDepreciationUncheckedUpdateWithoutJournalInput>
  }

  export type AssetDepreciationUpdateManyWithWhereWithoutJournalInput = {
    where: AssetDepreciationScalarWhereInput
    data: XOR<AssetDepreciationUpdateManyMutationInput, AssetDepreciationUncheckedUpdateManyWithoutJournalInput>
  }

  export type AssetDepreciationScalarWhereInput = {
    AND?: AssetDepreciationScalarWhereInput | AssetDepreciationScalarWhereInput[]
    OR?: AssetDepreciationScalarWhereInput[]
    NOT?: AssetDepreciationScalarWhereInput | AssetDepreciationScalarWhereInput[]
    id?: StringFilter<"AssetDepreciation"> | string
    assetId?: StringFilter<"AssetDepreciation"> | string
    periodYear?: IntFilter<"AssetDepreciation"> | number
    periodMonth?: IntFilter<"AssetDepreciation"> | number
    depreciationAmount?: DecimalFilter<"AssetDepreciation"> | Decimal | DecimalJsLike | number | string
    accumulatedDepreciation?: DecimalFilter<"AssetDepreciation"> | Decimal | DecimalJsLike | number | string
    netBookValue?: DecimalFilter<"AssetDepreciation"> | Decimal | DecimalJsLike | number | string
    isPosted?: BoolFilter<"AssetDepreciation"> | boolean
    postedAt?: DateTimeNullableFilter<"AssetDepreciation"> | Date | string | null
    journalId?: StringNullableFilter<"AssetDepreciation"> | string | null
    createdAt?: DateTimeFilter<"AssetDepreciation"> | Date | string
  }

  export type AssetDisposalUpsertWithWhereUniqueWithoutJournalInput = {
    where: AssetDisposalWhereUniqueInput
    update: XOR<AssetDisposalUpdateWithoutJournalInput, AssetDisposalUncheckedUpdateWithoutJournalInput>
    create: XOR<AssetDisposalCreateWithoutJournalInput, AssetDisposalUncheckedCreateWithoutJournalInput>
  }

  export type AssetDisposalUpdateWithWhereUniqueWithoutJournalInput = {
    where: AssetDisposalWhereUniqueInput
    data: XOR<AssetDisposalUpdateWithoutJournalInput, AssetDisposalUncheckedUpdateWithoutJournalInput>
  }

  export type AssetDisposalUpdateManyWithWhereWithoutJournalInput = {
    where: AssetDisposalScalarWhereInput
    data: XOR<AssetDisposalUpdateManyMutationInput, AssetDisposalUncheckedUpdateManyWithoutJournalInput>
  }

  export type JournalCreateWithoutJournalLinesInput = {
    id?: string
    journalNo: string
    date: Date | string
    memo?: string | null
    postedAt?: Date | string
    postedByUser: UserCreateNestedOneWithoutJournalsInput
    assetDepreciation?: AssetDepreciationCreateNestedManyWithoutJournalInput
    assetDisposals?: AssetDisposalCreateNestedManyWithoutJournalInput
  }

  export type JournalUncheckedCreateWithoutJournalLinesInput = {
    id?: string
    journalNo: string
    date: Date | string
    memo?: string | null
    postedBy: string
    postedAt?: Date | string
    assetDepreciation?: AssetDepreciationUncheckedCreateNestedManyWithoutJournalInput
    assetDisposals?: AssetDisposalUncheckedCreateNestedManyWithoutJournalInput
  }

  export type JournalCreateOrConnectWithoutJournalLinesInput = {
    where: JournalWhereUniqueInput
    create: XOR<JournalCreateWithoutJournalLinesInput, JournalUncheckedCreateWithoutJournalLinesInput>
  }

  export type ChartOfAccountCreateWithoutJournalLinesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    accountType: string
    isActive?: boolean
    createdAt?: Date | string
    parent?: ChartOfAccountCreateNestedOneWithoutChildrenInput
    children?: ChartOfAccountCreateNestedManyWithoutParentInput
    cashTransactionsGL?: CashTransactionCreateNestedManyWithoutGlAccountInput
    cashTransactionsContra?: CashTransactionCreateNestedManyWithoutContraAccountInput
    cashAccounts?: CashAccountCreateNestedManyWithoutChartOfAccountInput
    assetCategoriesAsset?: AssetCategoryCreateNestedManyWithoutGlAssetAccountInput
    assetCategoriesDepreciation?: AssetCategoryCreateNestedManyWithoutGlDepreciationAccountInput
    assetCategoriesAccumulated?: AssetCategoryCreateNestedManyWithoutGlAccumulatedDepreciationAccountInput
  }

  export type ChartOfAccountUncheckedCreateWithoutJournalLinesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    accountType: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    children?: ChartOfAccountUncheckedCreateNestedManyWithoutParentInput
    cashTransactionsGL?: CashTransactionUncheckedCreateNestedManyWithoutGlAccountInput
    cashTransactionsContra?: CashTransactionUncheckedCreateNestedManyWithoutContraAccountInput
    cashAccounts?: CashAccountUncheckedCreateNestedManyWithoutChartOfAccountInput
    assetCategoriesAsset?: AssetCategoryUncheckedCreateNestedManyWithoutGlAssetAccountInput
    assetCategoriesDepreciation?: AssetCategoryUncheckedCreateNestedManyWithoutGlDepreciationAccountInput
    assetCategoriesAccumulated?: AssetCategoryUncheckedCreateNestedManyWithoutGlAccumulatedDepreciationAccountInput
  }

  export type ChartOfAccountCreateOrConnectWithoutJournalLinesInput = {
    where: ChartOfAccountWhereUniqueInput
    create: XOR<ChartOfAccountCreateWithoutJournalLinesInput, ChartOfAccountUncheckedCreateWithoutJournalLinesInput>
  }

  export type JournalUpsertWithoutJournalLinesInput = {
    update: XOR<JournalUpdateWithoutJournalLinesInput, JournalUncheckedUpdateWithoutJournalLinesInput>
    create: XOR<JournalCreateWithoutJournalLinesInput, JournalUncheckedCreateWithoutJournalLinesInput>
    where?: JournalWhereInput
  }

  export type JournalUpdateToOneWithWhereWithoutJournalLinesInput = {
    where?: JournalWhereInput
    data: XOR<JournalUpdateWithoutJournalLinesInput, JournalUncheckedUpdateWithoutJournalLinesInput>
  }

  export type JournalUpdateWithoutJournalLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByUser?: UserUpdateOneRequiredWithoutJournalsNestedInput
    assetDepreciation?: AssetDepreciationUpdateManyWithoutJournalNestedInput
    assetDisposals?: AssetDisposalUpdateManyWithoutJournalNestedInput
  }

  export type JournalUncheckedUpdateWithoutJournalLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    postedBy?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetDepreciation?: AssetDepreciationUncheckedUpdateManyWithoutJournalNestedInput
    assetDisposals?: AssetDisposalUncheckedUpdateManyWithoutJournalNestedInput
  }

  export type ChartOfAccountUpsertWithoutJournalLinesInput = {
    update: XOR<ChartOfAccountUpdateWithoutJournalLinesInput, ChartOfAccountUncheckedUpdateWithoutJournalLinesInput>
    create: XOR<ChartOfAccountCreateWithoutJournalLinesInput, ChartOfAccountUncheckedCreateWithoutJournalLinesInput>
    where?: ChartOfAccountWhereInput
  }

  export type ChartOfAccountUpdateToOneWithWhereWithoutJournalLinesInput = {
    where?: ChartOfAccountWhereInput
    data: XOR<ChartOfAccountUpdateWithoutJournalLinesInput, ChartOfAccountUncheckedUpdateWithoutJournalLinesInput>
  }

  export type ChartOfAccountUpdateWithoutJournalLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ChartOfAccountUpdateOneWithoutChildrenNestedInput
    children?: ChartOfAccountUpdateManyWithoutParentNestedInput
    cashTransactionsGL?: CashTransactionUpdateManyWithoutGlAccountNestedInput
    cashTransactionsContra?: CashTransactionUpdateManyWithoutContraAccountNestedInput
    cashAccounts?: CashAccountUpdateManyWithoutChartOfAccountNestedInput
    assetCategoriesAsset?: AssetCategoryUpdateManyWithoutGlAssetAccountNestedInput
    assetCategoriesDepreciation?: AssetCategoryUpdateManyWithoutGlDepreciationAccountNestedInput
    assetCategoriesAccumulated?: AssetCategoryUpdateManyWithoutGlAccumulatedDepreciationAccountNestedInput
  }

  export type ChartOfAccountUncheckedUpdateWithoutJournalLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChartOfAccountUncheckedUpdateManyWithoutParentNestedInput
    cashTransactionsGL?: CashTransactionUncheckedUpdateManyWithoutGlAccountNestedInput
    cashTransactionsContra?: CashTransactionUncheckedUpdateManyWithoutContraAccountNestedInput
    cashAccounts?: CashAccountUncheckedUpdateManyWithoutChartOfAccountNestedInput
    assetCategoriesAsset?: AssetCategoryUncheckedUpdateManyWithoutGlAssetAccountNestedInput
    assetCategoriesDepreciation?: AssetCategoryUncheckedUpdateManyWithoutGlDepreciationAccountNestedInput
    assetCategoriesAccumulated?: AssetCategoryUncheckedUpdateManyWithoutGlAccumulatedDepreciationAccountNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    journals?: JournalCreateNestedManyWithoutPostedByUserInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutUserInput
    salesReceipts?: SalesReceiptCreateNestedManyWithoutUserInput
    purchasePayments?: PurchasePaymentCreateNestedManyWithoutUserInput
    SystemSetting?: SystemSettingCreateNestedManyWithoutUpdatedByUserInput
    ApprovalRequest?: ApprovalRequestCreateNestedManyWithoutRequestedByUserInput
    ApprovalAction?: ApprovalActionCreateNestedManyWithoutUserInput
    assetsCreated?: AssetCreateNestedManyWithoutCreatedByUserInput
    assetDisposals?: AssetDisposalCreateNestedManyWithoutDisposedByUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    journals?: JournalUncheckedCreateNestedManyWithoutPostedByUserInput
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutUserInput
    salesReceipts?: SalesReceiptUncheckedCreateNestedManyWithoutUserInput
    purchasePayments?: PurchasePaymentUncheckedCreateNestedManyWithoutUserInput
    SystemSetting?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    ApprovalRequest?: ApprovalRequestUncheckedCreateNestedManyWithoutRequestedByUserInput
    ApprovalAction?: ApprovalActionUncheckedCreateNestedManyWithoutUserInput
    assetsCreated?: AssetUncheckedCreateNestedManyWithoutCreatedByUserInput
    assetDisposals?: AssetDisposalUncheckedCreateNestedManyWithoutDisposedByUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    journals?: JournalUpdateManyWithoutPostedByUserNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutUserNestedInput
    salesReceipts?: SalesReceiptUpdateManyWithoutUserNestedInput
    purchasePayments?: PurchasePaymentUpdateManyWithoutUserNestedInput
    SystemSetting?: SystemSettingUpdateManyWithoutUpdatedByUserNestedInput
    ApprovalRequest?: ApprovalRequestUpdateManyWithoutRequestedByUserNestedInput
    ApprovalAction?: ApprovalActionUpdateManyWithoutUserNestedInput
    assetsCreated?: AssetUpdateManyWithoutCreatedByUserNestedInput
    assetDisposals?: AssetDisposalUpdateManyWithoutDisposedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    journals?: JournalUncheckedUpdateManyWithoutPostedByUserNestedInput
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutUserNestedInput
    salesReceipts?: SalesReceiptUncheckedUpdateManyWithoutUserNestedInput
    purchasePayments?: PurchasePaymentUncheckedUpdateManyWithoutUserNestedInput
    SystemSetting?: SystemSettingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    ApprovalRequest?: ApprovalRequestUncheckedUpdateManyWithoutRequestedByUserNestedInput
    ApprovalAction?: ApprovalActionUncheckedUpdateManyWithoutUserNestedInput
    assetsCreated?: AssetUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assetDisposals?: AssetDisposalUncheckedUpdateManyWithoutDisposedByUserNestedInput
  }

  export type CashTransactionCreateWithoutCashAccountInput = {
    id?: string
    transactionNo: string
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    refType?: string | null
    refId?: string | null
    transactionDate: Date | string
    isReconciled?: boolean
    reconciledAt?: Date | string | null
    createdAt?: Date | string
    reference: string
    glAccount?: ChartOfAccountCreateNestedOneWithoutCashTransactionsGLInput
    contraAccount?: ChartOfAccountCreateNestedOneWithoutCashTransactionsContraInput
    user: UserCreateNestedOneWithoutCashTransactionsInput
  }

  export type CashTransactionUncheckedCreateWithoutCashAccountInput = {
    id?: string
    transactionNo: string
    glAccountId?: string | null
    contraAccountId?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    refType?: string | null
    refId?: string | null
    transactionDate: Date | string
    isReconciled?: boolean
    reconciledAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    reference: string
  }

  export type CashTransactionCreateOrConnectWithoutCashAccountInput = {
    where: CashTransactionWhereUniqueInput
    create: XOR<CashTransactionCreateWithoutCashAccountInput, CashTransactionUncheckedCreateWithoutCashAccountInput>
  }

  export type CashTransactionCreateManyCashAccountInputEnvelope = {
    data: CashTransactionCreateManyCashAccountInput | CashTransactionCreateManyCashAccountInput[]
    skipDuplicates?: boolean
  }

  export type SalesReceiptCreateWithoutCashAccountInput = {
    id?: string
    receiptNo: string
    amountReceived: Decimal | DecimalJsLike | number | string
    receiptDate: Date | string
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    sale: SaleCreateNestedOneWithoutSalesReceiptsInput
    customer: CustomerCreateNestedOneWithoutSalesReceiptsInput
    user: UserCreateNestedOneWithoutSalesReceiptsInput
  }

  export type SalesReceiptUncheckedCreateWithoutCashAccountInput = {
    id?: string
    receiptNo: string
    saleId: string
    customerId: string
    amountReceived: Decimal | DecimalJsLike | number | string
    receiptDate: Date | string
    reference?: string | null
    notes?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type SalesReceiptCreateOrConnectWithoutCashAccountInput = {
    where: SalesReceiptWhereUniqueInput
    create: XOR<SalesReceiptCreateWithoutCashAccountInput, SalesReceiptUncheckedCreateWithoutCashAccountInput>
  }

  export type SalesReceiptCreateManyCashAccountInputEnvelope = {
    data: SalesReceiptCreateManyCashAccountInput | SalesReceiptCreateManyCashAccountInput[]
    skipDuplicates?: boolean
  }

  export type PurchasePaymentCreateWithoutCashAccountInput = {
    id?: string
    paymentNo: string
    amountPaid: Decimal | DecimalJsLike | number | string
    paymentDate: Date | string
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    purchase: PurchaseCreateNestedOneWithoutPurchasePaymentsInput
    vendor: VendorCreateNestedOneWithoutPurchasePaymentsInput
    user: UserCreateNestedOneWithoutPurchasePaymentsInput
  }

  export type PurchasePaymentUncheckedCreateWithoutCashAccountInput = {
    id?: string
    paymentNo: string
    purchaseId: string
    vendorId: string
    amountPaid: Decimal | DecimalJsLike | number | string
    paymentDate: Date | string
    reference?: string | null
    notes?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type PurchasePaymentCreateOrConnectWithoutCashAccountInput = {
    where: PurchasePaymentWhereUniqueInput
    create: XOR<PurchasePaymentCreateWithoutCashAccountInput, PurchasePaymentUncheckedCreateWithoutCashAccountInput>
  }

  export type PurchasePaymentCreateManyCashAccountInputEnvelope = {
    data: PurchasePaymentCreateManyCashAccountInput | PurchasePaymentCreateManyCashAccountInput[]
    skipDuplicates?: boolean
  }

  export type ChartOfAccountCreateWithoutCashAccountsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    accountType: string
    isActive?: boolean
    createdAt?: Date | string
    parent?: ChartOfAccountCreateNestedOneWithoutChildrenInput
    children?: ChartOfAccountCreateNestedManyWithoutParentInput
    journalLines?: JournalLineCreateNestedManyWithoutAccountInput
    cashTransactionsGL?: CashTransactionCreateNestedManyWithoutGlAccountInput
    cashTransactionsContra?: CashTransactionCreateNestedManyWithoutContraAccountInput
    assetCategoriesAsset?: AssetCategoryCreateNestedManyWithoutGlAssetAccountInput
    assetCategoriesDepreciation?: AssetCategoryCreateNestedManyWithoutGlDepreciationAccountInput
    assetCategoriesAccumulated?: AssetCategoryCreateNestedManyWithoutGlAccumulatedDepreciationAccountInput
  }

  export type ChartOfAccountUncheckedCreateWithoutCashAccountsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    accountType: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    children?: ChartOfAccountUncheckedCreateNestedManyWithoutParentInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAccountInput
    cashTransactionsGL?: CashTransactionUncheckedCreateNestedManyWithoutGlAccountInput
    cashTransactionsContra?: CashTransactionUncheckedCreateNestedManyWithoutContraAccountInput
    assetCategoriesAsset?: AssetCategoryUncheckedCreateNestedManyWithoutGlAssetAccountInput
    assetCategoriesDepreciation?: AssetCategoryUncheckedCreateNestedManyWithoutGlDepreciationAccountInput
    assetCategoriesAccumulated?: AssetCategoryUncheckedCreateNestedManyWithoutGlAccumulatedDepreciationAccountInput
  }

  export type ChartOfAccountCreateOrConnectWithoutCashAccountsInput = {
    where: ChartOfAccountWhereUniqueInput
    create: XOR<ChartOfAccountCreateWithoutCashAccountsInput, ChartOfAccountUncheckedCreateWithoutCashAccountsInput>
  }

  export type CashTransactionUpsertWithWhereUniqueWithoutCashAccountInput = {
    where: CashTransactionWhereUniqueInput
    update: XOR<CashTransactionUpdateWithoutCashAccountInput, CashTransactionUncheckedUpdateWithoutCashAccountInput>
    create: XOR<CashTransactionCreateWithoutCashAccountInput, CashTransactionUncheckedCreateWithoutCashAccountInput>
  }

  export type CashTransactionUpdateWithWhereUniqueWithoutCashAccountInput = {
    where: CashTransactionWhereUniqueInput
    data: XOR<CashTransactionUpdateWithoutCashAccountInput, CashTransactionUncheckedUpdateWithoutCashAccountInput>
  }

  export type CashTransactionUpdateManyWithWhereWithoutCashAccountInput = {
    where: CashTransactionScalarWhereInput
    data: XOR<CashTransactionUpdateManyMutationInput, CashTransactionUncheckedUpdateManyWithoutCashAccountInput>
  }

  export type SalesReceiptUpsertWithWhereUniqueWithoutCashAccountInput = {
    where: SalesReceiptWhereUniqueInput
    update: XOR<SalesReceiptUpdateWithoutCashAccountInput, SalesReceiptUncheckedUpdateWithoutCashAccountInput>
    create: XOR<SalesReceiptCreateWithoutCashAccountInput, SalesReceiptUncheckedCreateWithoutCashAccountInput>
  }

  export type SalesReceiptUpdateWithWhereUniqueWithoutCashAccountInput = {
    where: SalesReceiptWhereUniqueInput
    data: XOR<SalesReceiptUpdateWithoutCashAccountInput, SalesReceiptUncheckedUpdateWithoutCashAccountInput>
  }

  export type SalesReceiptUpdateManyWithWhereWithoutCashAccountInput = {
    where: SalesReceiptScalarWhereInput
    data: XOR<SalesReceiptUpdateManyMutationInput, SalesReceiptUncheckedUpdateManyWithoutCashAccountInput>
  }

  export type PurchasePaymentUpsertWithWhereUniqueWithoutCashAccountInput = {
    where: PurchasePaymentWhereUniqueInput
    update: XOR<PurchasePaymentUpdateWithoutCashAccountInput, PurchasePaymentUncheckedUpdateWithoutCashAccountInput>
    create: XOR<PurchasePaymentCreateWithoutCashAccountInput, PurchasePaymentUncheckedCreateWithoutCashAccountInput>
  }

  export type PurchasePaymentUpdateWithWhereUniqueWithoutCashAccountInput = {
    where: PurchasePaymentWhereUniqueInput
    data: XOR<PurchasePaymentUpdateWithoutCashAccountInput, PurchasePaymentUncheckedUpdateWithoutCashAccountInput>
  }

  export type PurchasePaymentUpdateManyWithWhereWithoutCashAccountInput = {
    where: PurchasePaymentScalarWhereInput
    data: XOR<PurchasePaymentUpdateManyMutationInput, PurchasePaymentUncheckedUpdateManyWithoutCashAccountInput>
  }

  export type ChartOfAccountUpsertWithoutCashAccountsInput = {
    update: XOR<ChartOfAccountUpdateWithoutCashAccountsInput, ChartOfAccountUncheckedUpdateWithoutCashAccountsInput>
    create: XOR<ChartOfAccountCreateWithoutCashAccountsInput, ChartOfAccountUncheckedCreateWithoutCashAccountsInput>
    where?: ChartOfAccountWhereInput
  }

  export type ChartOfAccountUpdateToOneWithWhereWithoutCashAccountsInput = {
    where?: ChartOfAccountWhereInput
    data: XOR<ChartOfAccountUpdateWithoutCashAccountsInput, ChartOfAccountUncheckedUpdateWithoutCashAccountsInput>
  }

  export type ChartOfAccountUpdateWithoutCashAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ChartOfAccountUpdateOneWithoutChildrenNestedInput
    children?: ChartOfAccountUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUpdateManyWithoutAccountNestedInput
    cashTransactionsGL?: CashTransactionUpdateManyWithoutGlAccountNestedInput
    cashTransactionsContra?: CashTransactionUpdateManyWithoutContraAccountNestedInput
    assetCategoriesAsset?: AssetCategoryUpdateManyWithoutGlAssetAccountNestedInput
    assetCategoriesDepreciation?: AssetCategoryUpdateManyWithoutGlDepreciationAccountNestedInput
    assetCategoriesAccumulated?: AssetCategoryUpdateManyWithoutGlAccumulatedDepreciationAccountNestedInput
  }

  export type ChartOfAccountUncheckedUpdateWithoutCashAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChartOfAccountUncheckedUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutAccountNestedInput
    cashTransactionsGL?: CashTransactionUncheckedUpdateManyWithoutGlAccountNestedInput
    cashTransactionsContra?: CashTransactionUncheckedUpdateManyWithoutContraAccountNestedInput
    assetCategoriesAsset?: AssetCategoryUncheckedUpdateManyWithoutGlAssetAccountNestedInput
    assetCategoriesDepreciation?: AssetCategoryUncheckedUpdateManyWithoutGlDepreciationAccountNestedInput
    assetCategoriesAccumulated?: AssetCategoryUncheckedUpdateManyWithoutGlAccumulatedDepreciationAccountNestedInput
  }

  export type CashAccountCreateWithoutCashTransactionsInput = {
    id?: string
    code: string
    name: string
    accountType: string
    accountNumber?: string | null
    glAccountId?: string | null
    bankName?: string | null
    balance?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    salesReceipts?: SalesReceiptCreateNestedManyWithoutCashAccountInput
    purchasePayments?: PurchasePaymentCreateNestedManyWithoutCashAccountInput
    chartOfAccount?: ChartOfAccountCreateNestedOneWithoutCashAccountsInput
  }

  export type CashAccountUncheckedCreateWithoutCashTransactionsInput = {
    id?: string
    code: string
    name: string
    accountType: string
    accountNumber?: string | null
    glAccountId?: string | null
    bankName?: string | null
    balance?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    chartOfAccountId?: string | null
    salesReceipts?: SalesReceiptUncheckedCreateNestedManyWithoutCashAccountInput
    purchasePayments?: PurchasePaymentUncheckedCreateNestedManyWithoutCashAccountInput
  }

  export type CashAccountCreateOrConnectWithoutCashTransactionsInput = {
    where: CashAccountWhereUniqueInput
    create: XOR<CashAccountCreateWithoutCashTransactionsInput, CashAccountUncheckedCreateWithoutCashTransactionsInput>
  }

  export type ChartOfAccountCreateWithoutCashTransactionsGLInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    accountType: string
    isActive?: boolean
    createdAt?: Date | string
    parent?: ChartOfAccountCreateNestedOneWithoutChildrenInput
    children?: ChartOfAccountCreateNestedManyWithoutParentInput
    journalLines?: JournalLineCreateNestedManyWithoutAccountInput
    cashTransactionsContra?: CashTransactionCreateNestedManyWithoutContraAccountInput
    cashAccounts?: CashAccountCreateNestedManyWithoutChartOfAccountInput
    assetCategoriesAsset?: AssetCategoryCreateNestedManyWithoutGlAssetAccountInput
    assetCategoriesDepreciation?: AssetCategoryCreateNestedManyWithoutGlDepreciationAccountInput
    assetCategoriesAccumulated?: AssetCategoryCreateNestedManyWithoutGlAccumulatedDepreciationAccountInput
  }

  export type ChartOfAccountUncheckedCreateWithoutCashTransactionsGLInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    accountType: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    children?: ChartOfAccountUncheckedCreateNestedManyWithoutParentInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAccountInput
    cashTransactionsContra?: CashTransactionUncheckedCreateNestedManyWithoutContraAccountInput
    cashAccounts?: CashAccountUncheckedCreateNestedManyWithoutChartOfAccountInput
    assetCategoriesAsset?: AssetCategoryUncheckedCreateNestedManyWithoutGlAssetAccountInput
    assetCategoriesDepreciation?: AssetCategoryUncheckedCreateNestedManyWithoutGlDepreciationAccountInput
    assetCategoriesAccumulated?: AssetCategoryUncheckedCreateNestedManyWithoutGlAccumulatedDepreciationAccountInput
  }

  export type ChartOfAccountCreateOrConnectWithoutCashTransactionsGLInput = {
    where: ChartOfAccountWhereUniqueInput
    create: XOR<ChartOfAccountCreateWithoutCashTransactionsGLInput, ChartOfAccountUncheckedCreateWithoutCashTransactionsGLInput>
  }

  export type ChartOfAccountCreateWithoutCashTransactionsContraInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    accountType: string
    isActive?: boolean
    createdAt?: Date | string
    parent?: ChartOfAccountCreateNestedOneWithoutChildrenInput
    children?: ChartOfAccountCreateNestedManyWithoutParentInput
    journalLines?: JournalLineCreateNestedManyWithoutAccountInput
    cashTransactionsGL?: CashTransactionCreateNestedManyWithoutGlAccountInput
    cashAccounts?: CashAccountCreateNestedManyWithoutChartOfAccountInput
    assetCategoriesAsset?: AssetCategoryCreateNestedManyWithoutGlAssetAccountInput
    assetCategoriesDepreciation?: AssetCategoryCreateNestedManyWithoutGlDepreciationAccountInput
    assetCategoriesAccumulated?: AssetCategoryCreateNestedManyWithoutGlAccumulatedDepreciationAccountInput
  }

  export type ChartOfAccountUncheckedCreateWithoutCashTransactionsContraInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    accountType: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    children?: ChartOfAccountUncheckedCreateNestedManyWithoutParentInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAccountInput
    cashTransactionsGL?: CashTransactionUncheckedCreateNestedManyWithoutGlAccountInput
    cashAccounts?: CashAccountUncheckedCreateNestedManyWithoutChartOfAccountInput
    assetCategoriesAsset?: AssetCategoryUncheckedCreateNestedManyWithoutGlAssetAccountInput
    assetCategoriesDepreciation?: AssetCategoryUncheckedCreateNestedManyWithoutGlDepreciationAccountInput
    assetCategoriesAccumulated?: AssetCategoryUncheckedCreateNestedManyWithoutGlAccumulatedDepreciationAccountInput
  }

  export type ChartOfAccountCreateOrConnectWithoutCashTransactionsContraInput = {
    where: ChartOfAccountWhereUniqueInput
    create: XOR<ChartOfAccountCreateWithoutCashTransactionsContraInput, ChartOfAccountUncheckedCreateWithoutCashTransactionsContraInput>
  }

  export type UserCreateWithoutCashTransactionsInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    journals?: JournalCreateNestedManyWithoutPostedByUserInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutUserInput
    salesReceipts?: SalesReceiptCreateNestedManyWithoutUserInput
    purchasePayments?: PurchasePaymentCreateNestedManyWithoutUserInput
    SystemSetting?: SystemSettingCreateNestedManyWithoutUpdatedByUserInput
    ApprovalRequest?: ApprovalRequestCreateNestedManyWithoutRequestedByUserInput
    ApprovalAction?: ApprovalActionCreateNestedManyWithoutUserInput
    assetsCreated?: AssetCreateNestedManyWithoutCreatedByUserInput
    assetDisposals?: AssetDisposalCreateNestedManyWithoutDisposedByUserInput
  }

  export type UserUncheckedCreateWithoutCashTransactionsInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    journals?: JournalUncheckedCreateNestedManyWithoutPostedByUserInput
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutUserInput
    salesReceipts?: SalesReceiptUncheckedCreateNestedManyWithoutUserInput
    purchasePayments?: PurchasePaymentUncheckedCreateNestedManyWithoutUserInput
    SystemSetting?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    ApprovalRequest?: ApprovalRequestUncheckedCreateNestedManyWithoutRequestedByUserInput
    ApprovalAction?: ApprovalActionUncheckedCreateNestedManyWithoutUserInput
    assetsCreated?: AssetUncheckedCreateNestedManyWithoutCreatedByUserInput
    assetDisposals?: AssetDisposalUncheckedCreateNestedManyWithoutDisposedByUserInput
  }

  export type UserCreateOrConnectWithoutCashTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCashTransactionsInput, UserUncheckedCreateWithoutCashTransactionsInput>
  }

  export type CashAccountUpsertWithoutCashTransactionsInput = {
    update: XOR<CashAccountUpdateWithoutCashTransactionsInput, CashAccountUncheckedUpdateWithoutCashTransactionsInput>
    create: XOR<CashAccountCreateWithoutCashTransactionsInput, CashAccountUncheckedCreateWithoutCashTransactionsInput>
    where?: CashAccountWhereInput
  }

  export type CashAccountUpdateToOneWithWhereWithoutCashTransactionsInput = {
    where?: CashAccountWhereInput
    data: XOR<CashAccountUpdateWithoutCashTransactionsInput, CashAccountUncheckedUpdateWithoutCashTransactionsInput>
  }

  export type CashAccountUpdateWithoutCashTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesReceipts?: SalesReceiptUpdateManyWithoutCashAccountNestedInput
    purchasePayments?: PurchasePaymentUpdateManyWithoutCashAccountNestedInput
    chartOfAccount?: ChartOfAccountUpdateOneWithoutCashAccountsNestedInput
  }

  export type CashAccountUncheckedUpdateWithoutCashTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chartOfAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    salesReceipts?: SalesReceiptUncheckedUpdateManyWithoutCashAccountNestedInput
    purchasePayments?: PurchasePaymentUncheckedUpdateManyWithoutCashAccountNestedInput
  }

  export type ChartOfAccountUpsertWithoutCashTransactionsGLInput = {
    update: XOR<ChartOfAccountUpdateWithoutCashTransactionsGLInput, ChartOfAccountUncheckedUpdateWithoutCashTransactionsGLInput>
    create: XOR<ChartOfAccountCreateWithoutCashTransactionsGLInput, ChartOfAccountUncheckedCreateWithoutCashTransactionsGLInput>
    where?: ChartOfAccountWhereInput
  }

  export type ChartOfAccountUpdateToOneWithWhereWithoutCashTransactionsGLInput = {
    where?: ChartOfAccountWhereInput
    data: XOR<ChartOfAccountUpdateWithoutCashTransactionsGLInput, ChartOfAccountUncheckedUpdateWithoutCashTransactionsGLInput>
  }

  export type ChartOfAccountUpdateWithoutCashTransactionsGLInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ChartOfAccountUpdateOneWithoutChildrenNestedInput
    children?: ChartOfAccountUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUpdateManyWithoutAccountNestedInput
    cashTransactionsContra?: CashTransactionUpdateManyWithoutContraAccountNestedInput
    cashAccounts?: CashAccountUpdateManyWithoutChartOfAccountNestedInput
    assetCategoriesAsset?: AssetCategoryUpdateManyWithoutGlAssetAccountNestedInput
    assetCategoriesDepreciation?: AssetCategoryUpdateManyWithoutGlDepreciationAccountNestedInput
    assetCategoriesAccumulated?: AssetCategoryUpdateManyWithoutGlAccumulatedDepreciationAccountNestedInput
  }

  export type ChartOfAccountUncheckedUpdateWithoutCashTransactionsGLInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChartOfAccountUncheckedUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutAccountNestedInput
    cashTransactionsContra?: CashTransactionUncheckedUpdateManyWithoutContraAccountNestedInput
    cashAccounts?: CashAccountUncheckedUpdateManyWithoutChartOfAccountNestedInput
    assetCategoriesAsset?: AssetCategoryUncheckedUpdateManyWithoutGlAssetAccountNestedInput
    assetCategoriesDepreciation?: AssetCategoryUncheckedUpdateManyWithoutGlDepreciationAccountNestedInput
    assetCategoriesAccumulated?: AssetCategoryUncheckedUpdateManyWithoutGlAccumulatedDepreciationAccountNestedInput
  }

  export type ChartOfAccountUpsertWithoutCashTransactionsContraInput = {
    update: XOR<ChartOfAccountUpdateWithoutCashTransactionsContraInput, ChartOfAccountUncheckedUpdateWithoutCashTransactionsContraInput>
    create: XOR<ChartOfAccountCreateWithoutCashTransactionsContraInput, ChartOfAccountUncheckedCreateWithoutCashTransactionsContraInput>
    where?: ChartOfAccountWhereInput
  }

  export type ChartOfAccountUpdateToOneWithWhereWithoutCashTransactionsContraInput = {
    where?: ChartOfAccountWhereInput
    data: XOR<ChartOfAccountUpdateWithoutCashTransactionsContraInput, ChartOfAccountUncheckedUpdateWithoutCashTransactionsContraInput>
  }

  export type ChartOfAccountUpdateWithoutCashTransactionsContraInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ChartOfAccountUpdateOneWithoutChildrenNestedInput
    children?: ChartOfAccountUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUpdateManyWithoutAccountNestedInput
    cashTransactionsGL?: CashTransactionUpdateManyWithoutGlAccountNestedInput
    cashAccounts?: CashAccountUpdateManyWithoutChartOfAccountNestedInput
    assetCategoriesAsset?: AssetCategoryUpdateManyWithoutGlAssetAccountNestedInput
    assetCategoriesDepreciation?: AssetCategoryUpdateManyWithoutGlDepreciationAccountNestedInput
    assetCategoriesAccumulated?: AssetCategoryUpdateManyWithoutGlAccumulatedDepreciationAccountNestedInput
  }

  export type ChartOfAccountUncheckedUpdateWithoutCashTransactionsContraInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChartOfAccountUncheckedUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutAccountNestedInput
    cashTransactionsGL?: CashTransactionUncheckedUpdateManyWithoutGlAccountNestedInput
    cashAccounts?: CashAccountUncheckedUpdateManyWithoutChartOfAccountNestedInput
    assetCategoriesAsset?: AssetCategoryUncheckedUpdateManyWithoutGlAssetAccountNestedInput
    assetCategoriesDepreciation?: AssetCategoryUncheckedUpdateManyWithoutGlDepreciationAccountNestedInput
    assetCategoriesAccumulated?: AssetCategoryUncheckedUpdateManyWithoutGlAccumulatedDepreciationAccountNestedInput
  }

  export type UserUpsertWithoutCashTransactionsInput = {
    update: XOR<UserUpdateWithoutCashTransactionsInput, UserUncheckedUpdateWithoutCashTransactionsInput>
    create: XOR<UserCreateWithoutCashTransactionsInput, UserUncheckedCreateWithoutCashTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCashTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCashTransactionsInput, UserUncheckedUpdateWithoutCashTransactionsInput>
  }

  export type UserUpdateWithoutCashTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    journals?: JournalUpdateManyWithoutPostedByUserNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutUserNestedInput
    salesReceipts?: SalesReceiptUpdateManyWithoutUserNestedInput
    purchasePayments?: PurchasePaymentUpdateManyWithoutUserNestedInput
    SystemSetting?: SystemSettingUpdateManyWithoutUpdatedByUserNestedInput
    ApprovalRequest?: ApprovalRequestUpdateManyWithoutRequestedByUserNestedInput
    ApprovalAction?: ApprovalActionUpdateManyWithoutUserNestedInput
    assetsCreated?: AssetUpdateManyWithoutCreatedByUserNestedInput
    assetDisposals?: AssetDisposalUpdateManyWithoutDisposedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCashTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    journals?: JournalUncheckedUpdateManyWithoutPostedByUserNestedInput
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutUserNestedInput
    salesReceipts?: SalesReceiptUncheckedUpdateManyWithoutUserNestedInput
    purchasePayments?: PurchasePaymentUncheckedUpdateManyWithoutUserNestedInput
    SystemSetting?: SystemSettingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    ApprovalRequest?: ApprovalRequestUncheckedUpdateManyWithoutRequestedByUserNestedInput
    ApprovalAction?: ApprovalActionUncheckedUpdateManyWithoutUserNestedInput
    assetsCreated?: AssetUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assetDisposals?: AssetDisposalUncheckedUpdateManyWithoutDisposedByUserNestedInput
  }

  export type SaleCreateWithoutSalesReceiptsInput = {
    id?: string
    orderNo: string
    orderDate: Date | string
    status?: $Enums.SaleStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSalesInput
    saleLines?: SaleLineCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutSalesReceiptsInput = {
    id?: string
    orderNo: string
    customerId: string
    orderDate: Date | string
    status?: $Enums.SaleStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    saleLines?: SaleLineUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutSalesReceiptsInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutSalesReceiptsInput, SaleUncheckedCreateWithoutSalesReceiptsInput>
  }

  export type CustomerCreateWithoutSalesReceiptsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    CustomerGroup: string
    isActive?: boolean
    createdAt?: Date | string
    sales?: SaleCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSalesReceiptsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    creditLimit?: Decimal | DecimalJsLike | number | string | null
    CustomerGroup: string
    isActive?: boolean
    createdAt?: Date | string
    sales?: SaleUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSalesReceiptsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSalesReceiptsInput, CustomerUncheckedCreateWithoutSalesReceiptsInput>
  }

  export type CashAccountCreateWithoutSalesReceiptsInput = {
    id?: string
    code: string
    name: string
    accountType: string
    accountNumber?: string | null
    glAccountId?: string | null
    bankName?: string | null
    balance?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    cashTransactions?: CashTransactionCreateNestedManyWithoutCashAccountInput
    purchasePayments?: PurchasePaymentCreateNestedManyWithoutCashAccountInput
    chartOfAccount?: ChartOfAccountCreateNestedOneWithoutCashAccountsInput
  }

  export type CashAccountUncheckedCreateWithoutSalesReceiptsInput = {
    id?: string
    code: string
    name: string
    accountType: string
    accountNumber?: string | null
    glAccountId?: string | null
    bankName?: string | null
    balance?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    chartOfAccountId?: string | null
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCashAccountInput
    purchasePayments?: PurchasePaymentUncheckedCreateNestedManyWithoutCashAccountInput
  }

  export type CashAccountCreateOrConnectWithoutSalesReceiptsInput = {
    where: CashAccountWhereUniqueInput
    create: XOR<CashAccountCreateWithoutSalesReceiptsInput, CashAccountUncheckedCreateWithoutSalesReceiptsInput>
  }

  export type UserCreateWithoutSalesReceiptsInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    journals?: JournalCreateNestedManyWithoutPostedByUserInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutUserInput
    purchasePayments?: PurchasePaymentCreateNestedManyWithoutUserInput
    SystemSetting?: SystemSettingCreateNestedManyWithoutUpdatedByUserInput
    ApprovalRequest?: ApprovalRequestCreateNestedManyWithoutRequestedByUserInput
    ApprovalAction?: ApprovalActionCreateNestedManyWithoutUserInput
    assetsCreated?: AssetCreateNestedManyWithoutCreatedByUserInput
    assetDisposals?: AssetDisposalCreateNestedManyWithoutDisposedByUserInput
  }

  export type UserUncheckedCreateWithoutSalesReceiptsInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    journals?: JournalUncheckedCreateNestedManyWithoutPostedByUserInput
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutUserInput
    purchasePayments?: PurchasePaymentUncheckedCreateNestedManyWithoutUserInput
    SystemSetting?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    ApprovalRequest?: ApprovalRequestUncheckedCreateNestedManyWithoutRequestedByUserInput
    ApprovalAction?: ApprovalActionUncheckedCreateNestedManyWithoutUserInput
    assetsCreated?: AssetUncheckedCreateNestedManyWithoutCreatedByUserInput
    assetDisposals?: AssetDisposalUncheckedCreateNestedManyWithoutDisposedByUserInput
  }

  export type UserCreateOrConnectWithoutSalesReceiptsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalesReceiptsInput, UserUncheckedCreateWithoutSalesReceiptsInput>
  }

  export type SaleUpsertWithoutSalesReceiptsInput = {
    update: XOR<SaleUpdateWithoutSalesReceiptsInput, SaleUncheckedUpdateWithoutSalesReceiptsInput>
    create: XOR<SaleCreateWithoutSalesReceiptsInput, SaleUncheckedCreateWithoutSalesReceiptsInput>
    where?: SaleWhereInput
  }

  export type SaleUpdateToOneWithWhereWithoutSalesReceiptsInput = {
    where?: SaleWhereInput
    data: XOR<SaleUpdateWithoutSalesReceiptsInput, SaleUncheckedUpdateWithoutSalesReceiptsInput>
  }

  export type SaleUpdateWithoutSalesReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSalesNestedInput
    saleLines?: SaleLineUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutSalesReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleLines?: SaleLineUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type CustomerUpsertWithoutSalesReceiptsInput = {
    update: XOR<CustomerUpdateWithoutSalesReceiptsInput, CustomerUncheckedUpdateWithoutSalesReceiptsInput>
    create: XOR<CustomerCreateWithoutSalesReceiptsInput, CustomerUncheckedCreateWithoutSalesReceiptsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSalesReceiptsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSalesReceiptsInput, CustomerUncheckedUpdateWithoutSalesReceiptsInput>
  }

  export type CustomerUpdateWithoutSalesReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    CustomerGroup?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSalesReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    creditLimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    CustomerGroup?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CashAccountUpsertWithoutSalesReceiptsInput = {
    update: XOR<CashAccountUpdateWithoutSalesReceiptsInput, CashAccountUncheckedUpdateWithoutSalesReceiptsInput>
    create: XOR<CashAccountCreateWithoutSalesReceiptsInput, CashAccountUncheckedCreateWithoutSalesReceiptsInput>
    where?: CashAccountWhereInput
  }

  export type CashAccountUpdateToOneWithWhereWithoutSalesReceiptsInput = {
    where?: CashAccountWhereInput
    data: XOR<CashAccountUpdateWithoutSalesReceiptsInput, CashAccountUncheckedUpdateWithoutSalesReceiptsInput>
  }

  export type CashAccountUpdateWithoutSalesReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashTransactions?: CashTransactionUpdateManyWithoutCashAccountNestedInput
    purchasePayments?: PurchasePaymentUpdateManyWithoutCashAccountNestedInput
    chartOfAccount?: ChartOfAccountUpdateOneWithoutCashAccountsNestedInput
  }

  export type CashAccountUncheckedUpdateWithoutSalesReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chartOfAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCashAccountNestedInput
    purchasePayments?: PurchasePaymentUncheckedUpdateManyWithoutCashAccountNestedInput
  }

  export type UserUpsertWithoutSalesReceiptsInput = {
    update: XOR<UserUpdateWithoutSalesReceiptsInput, UserUncheckedUpdateWithoutSalesReceiptsInput>
    create: XOR<UserCreateWithoutSalesReceiptsInput, UserUncheckedCreateWithoutSalesReceiptsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSalesReceiptsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSalesReceiptsInput, UserUncheckedUpdateWithoutSalesReceiptsInput>
  }

  export type UserUpdateWithoutSalesReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    journals?: JournalUpdateManyWithoutPostedByUserNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutUserNestedInput
    purchasePayments?: PurchasePaymentUpdateManyWithoutUserNestedInput
    SystemSetting?: SystemSettingUpdateManyWithoutUpdatedByUserNestedInput
    ApprovalRequest?: ApprovalRequestUpdateManyWithoutRequestedByUserNestedInput
    ApprovalAction?: ApprovalActionUpdateManyWithoutUserNestedInput
    assetsCreated?: AssetUpdateManyWithoutCreatedByUserNestedInput
    assetDisposals?: AssetDisposalUpdateManyWithoutDisposedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSalesReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    journals?: JournalUncheckedUpdateManyWithoutPostedByUserNestedInput
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutUserNestedInput
    purchasePayments?: PurchasePaymentUncheckedUpdateManyWithoutUserNestedInput
    SystemSetting?: SystemSettingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    ApprovalRequest?: ApprovalRequestUncheckedUpdateManyWithoutRequestedByUserNestedInput
    ApprovalAction?: ApprovalActionUncheckedUpdateManyWithoutUserNestedInput
    assetsCreated?: AssetUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assetDisposals?: AssetDisposalUncheckedUpdateManyWithoutDisposedByUserNestedInput
  }

  export type PurchaseCreateWithoutPurchasePaymentsInput = {
    id?: string
    orderNo: string
    orderDate: Date | string
    status?: $Enums.PurchaseStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutPurchasesInput
    purchaseLines?: PurchaseLineCreateNestedManyWithoutPurchaseInput
    assets?: AssetCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseUncheckedCreateWithoutPurchasePaymentsInput = {
    id?: string
    orderNo: string
    vendorId: string
    orderDate: Date | string
    status?: $Enums.PurchaseStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseLines?: PurchaseLineUncheckedCreateNestedManyWithoutPurchaseInput
    assets?: AssetUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseCreateOrConnectWithoutPurchasePaymentsInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutPurchasePaymentsInput, PurchaseUncheckedCreateWithoutPurchasePaymentsInput>
  }

  export type VendorCreateWithoutPurchasePaymentsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    paymentTerms?: string | null
    isActive?: boolean
    createdAt?: Date | string
    purchases?: PurchaseCreateNestedManyWithoutVendorInput
    assets?: AssetCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutPurchasePaymentsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    paymentTerms?: string | null
    isActive?: boolean
    createdAt?: Date | string
    purchases?: PurchaseUncheckedCreateNestedManyWithoutVendorInput
    assets?: AssetUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutPurchasePaymentsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutPurchasePaymentsInput, VendorUncheckedCreateWithoutPurchasePaymentsInput>
  }

  export type CashAccountCreateWithoutPurchasePaymentsInput = {
    id?: string
    code: string
    name: string
    accountType: string
    accountNumber?: string | null
    glAccountId?: string | null
    bankName?: string | null
    balance?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    cashTransactions?: CashTransactionCreateNestedManyWithoutCashAccountInput
    salesReceipts?: SalesReceiptCreateNestedManyWithoutCashAccountInput
    chartOfAccount?: ChartOfAccountCreateNestedOneWithoutCashAccountsInput
  }

  export type CashAccountUncheckedCreateWithoutPurchasePaymentsInput = {
    id?: string
    code: string
    name: string
    accountType: string
    accountNumber?: string | null
    glAccountId?: string | null
    bankName?: string | null
    balance?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    chartOfAccountId?: string | null
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutCashAccountInput
    salesReceipts?: SalesReceiptUncheckedCreateNestedManyWithoutCashAccountInput
  }

  export type CashAccountCreateOrConnectWithoutPurchasePaymentsInput = {
    where: CashAccountWhereUniqueInput
    create: XOR<CashAccountCreateWithoutPurchasePaymentsInput, CashAccountUncheckedCreateWithoutPurchasePaymentsInput>
  }

  export type UserCreateWithoutPurchasePaymentsInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    journals?: JournalCreateNestedManyWithoutPostedByUserInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutUserInput
    salesReceipts?: SalesReceiptCreateNestedManyWithoutUserInput
    SystemSetting?: SystemSettingCreateNestedManyWithoutUpdatedByUserInput
    ApprovalRequest?: ApprovalRequestCreateNestedManyWithoutRequestedByUserInput
    ApprovalAction?: ApprovalActionCreateNestedManyWithoutUserInput
    assetsCreated?: AssetCreateNestedManyWithoutCreatedByUserInput
    assetDisposals?: AssetDisposalCreateNestedManyWithoutDisposedByUserInput
  }

  export type UserUncheckedCreateWithoutPurchasePaymentsInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    journals?: JournalUncheckedCreateNestedManyWithoutPostedByUserInput
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutUserInput
    salesReceipts?: SalesReceiptUncheckedCreateNestedManyWithoutUserInput
    SystemSetting?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    ApprovalRequest?: ApprovalRequestUncheckedCreateNestedManyWithoutRequestedByUserInput
    ApprovalAction?: ApprovalActionUncheckedCreateNestedManyWithoutUserInput
    assetsCreated?: AssetUncheckedCreateNestedManyWithoutCreatedByUserInput
    assetDisposals?: AssetDisposalUncheckedCreateNestedManyWithoutDisposedByUserInput
  }

  export type UserCreateOrConnectWithoutPurchasePaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPurchasePaymentsInput, UserUncheckedCreateWithoutPurchasePaymentsInput>
  }

  export type PurchaseUpsertWithoutPurchasePaymentsInput = {
    update: XOR<PurchaseUpdateWithoutPurchasePaymentsInput, PurchaseUncheckedUpdateWithoutPurchasePaymentsInput>
    create: XOR<PurchaseCreateWithoutPurchasePaymentsInput, PurchaseUncheckedCreateWithoutPurchasePaymentsInput>
    where?: PurchaseWhereInput
  }

  export type PurchaseUpdateToOneWithWhereWithoutPurchasePaymentsInput = {
    where?: PurchaseWhereInput
    data: XOR<PurchaseUpdateWithoutPurchasePaymentsInput, PurchaseUncheckedUpdateWithoutPurchasePaymentsInput>
  }

  export type PurchaseUpdateWithoutPurchasePaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutPurchasesNestedInput
    purchaseLines?: PurchaseLineUpdateManyWithoutPurchaseNestedInput
    assets?: AssetUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutPurchasePaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseLines?: PurchaseLineUncheckedUpdateManyWithoutPurchaseNestedInput
    assets?: AssetUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type VendorUpsertWithoutPurchasePaymentsInput = {
    update: XOR<VendorUpdateWithoutPurchasePaymentsInput, VendorUncheckedUpdateWithoutPurchasePaymentsInput>
    create: XOR<VendorCreateWithoutPurchasePaymentsInput, VendorUncheckedCreateWithoutPurchasePaymentsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutPurchasePaymentsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutPurchasePaymentsInput, VendorUncheckedUpdateWithoutPurchasePaymentsInput>
  }

  export type VendorUpdateWithoutPurchasePaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchaseUpdateManyWithoutVendorNestedInput
    assets?: AssetUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutPurchasePaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchaseUncheckedUpdateManyWithoutVendorNestedInput
    assets?: AssetUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type CashAccountUpsertWithoutPurchasePaymentsInput = {
    update: XOR<CashAccountUpdateWithoutPurchasePaymentsInput, CashAccountUncheckedUpdateWithoutPurchasePaymentsInput>
    create: XOR<CashAccountCreateWithoutPurchasePaymentsInput, CashAccountUncheckedCreateWithoutPurchasePaymentsInput>
    where?: CashAccountWhereInput
  }

  export type CashAccountUpdateToOneWithWhereWithoutPurchasePaymentsInput = {
    where?: CashAccountWhereInput
    data: XOR<CashAccountUpdateWithoutPurchasePaymentsInput, CashAccountUncheckedUpdateWithoutPurchasePaymentsInput>
  }

  export type CashAccountUpdateWithoutPurchasePaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashTransactions?: CashTransactionUpdateManyWithoutCashAccountNestedInput
    salesReceipts?: SalesReceiptUpdateManyWithoutCashAccountNestedInput
    chartOfAccount?: ChartOfAccountUpdateOneWithoutCashAccountsNestedInput
  }

  export type CashAccountUncheckedUpdateWithoutPurchasePaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chartOfAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCashAccountNestedInput
    salesReceipts?: SalesReceiptUncheckedUpdateManyWithoutCashAccountNestedInput
  }

  export type UserUpsertWithoutPurchasePaymentsInput = {
    update: XOR<UserUpdateWithoutPurchasePaymentsInput, UserUncheckedUpdateWithoutPurchasePaymentsInput>
    create: XOR<UserCreateWithoutPurchasePaymentsInput, UserUncheckedCreateWithoutPurchasePaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPurchasePaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPurchasePaymentsInput, UserUncheckedUpdateWithoutPurchasePaymentsInput>
  }

  export type UserUpdateWithoutPurchasePaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    journals?: JournalUpdateManyWithoutPostedByUserNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutUserNestedInput
    salesReceipts?: SalesReceiptUpdateManyWithoutUserNestedInput
    SystemSetting?: SystemSettingUpdateManyWithoutUpdatedByUserNestedInput
    ApprovalRequest?: ApprovalRequestUpdateManyWithoutRequestedByUserNestedInput
    ApprovalAction?: ApprovalActionUpdateManyWithoutUserNestedInput
    assetsCreated?: AssetUpdateManyWithoutCreatedByUserNestedInput
    assetDisposals?: AssetDisposalUpdateManyWithoutDisposedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPurchasePaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    journals?: JournalUncheckedUpdateManyWithoutPostedByUserNestedInput
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutUserNestedInput
    salesReceipts?: SalesReceiptUncheckedUpdateManyWithoutUserNestedInput
    SystemSetting?: SystemSettingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    ApprovalRequest?: ApprovalRequestUncheckedUpdateManyWithoutRequestedByUserNestedInput
    ApprovalAction?: ApprovalActionUncheckedUpdateManyWithoutUserNestedInput
    assetsCreated?: AssetUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assetDisposals?: AssetDisposalUncheckedUpdateManyWithoutDisposedByUserNestedInput
  }

  export type UserCreateWithoutSystemSettingInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    journals?: JournalCreateNestedManyWithoutPostedByUserInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutUserInput
    salesReceipts?: SalesReceiptCreateNestedManyWithoutUserInput
    purchasePayments?: PurchasePaymentCreateNestedManyWithoutUserInput
    ApprovalRequest?: ApprovalRequestCreateNestedManyWithoutRequestedByUserInput
    ApprovalAction?: ApprovalActionCreateNestedManyWithoutUserInput
    assetsCreated?: AssetCreateNestedManyWithoutCreatedByUserInput
    assetDisposals?: AssetDisposalCreateNestedManyWithoutDisposedByUserInput
  }

  export type UserUncheckedCreateWithoutSystemSettingInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    journals?: JournalUncheckedCreateNestedManyWithoutPostedByUserInput
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutUserInput
    salesReceipts?: SalesReceiptUncheckedCreateNestedManyWithoutUserInput
    purchasePayments?: PurchasePaymentUncheckedCreateNestedManyWithoutUserInput
    ApprovalRequest?: ApprovalRequestUncheckedCreateNestedManyWithoutRequestedByUserInput
    ApprovalAction?: ApprovalActionUncheckedCreateNestedManyWithoutUserInput
    assetsCreated?: AssetUncheckedCreateNestedManyWithoutCreatedByUserInput
    assetDisposals?: AssetDisposalUncheckedCreateNestedManyWithoutDisposedByUserInput
  }

  export type UserCreateOrConnectWithoutSystemSettingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSystemSettingInput, UserUncheckedCreateWithoutSystemSettingInput>
  }

  export type UserUpsertWithoutSystemSettingInput = {
    update: XOR<UserUpdateWithoutSystemSettingInput, UserUncheckedUpdateWithoutSystemSettingInput>
    create: XOR<UserCreateWithoutSystemSettingInput, UserUncheckedCreateWithoutSystemSettingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSystemSettingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSystemSettingInput, UserUncheckedUpdateWithoutSystemSettingInput>
  }

  export type UserUpdateWithoutSystemSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    journals?: JournalUpdateManyWithoutPostedByUserNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutUserNestedInput
    salesReceipts?: SalesReceiptUpdateManyWithoutUserNestedInput
    purchasePayments?: PurchasePaymentUpdateManyWithoutUserNestedInput
    ApprovalRequest?: ApprovalRequestUpdateManyWithoutRequestedByUserNestedInput
    ApprovalAction?: ApprovalActionUpdateManyWithoutUserNestedInput
    assetsCreated?: AssetUpdateManyWithoutCreatedByUserNestedInput
    assetDisposals?: AssetDisposalUpdateManyWithoutDisposedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSystemSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    journals?: JournalUncheckedUpdateManyWithoutPostedByUserNestedInput
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutUserNestedInput
    salesReceipts?: SalesReceiptUncheckedUpdateManyWithoutUserNestedInput
    purchasePayments?: PurchasePaymentUncheckedUpdateManyWithoutUserNestedInput
    ApprovalRequest?: ApprovalRequestUncheckedUpdateManyWithoutRequestedByUserNestedInput
    ApprovalAction?: ApprovalActionUncheckedUpdateManyWithoutUserNestedInput
    assetsCreated?: AssetUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assetDisposals?: AssetDisposalUncheckedUpdateManyWithoutDisposedByUserNestedInput
  }

  export type FiscalPeriodCreateWithoutFiscalYearInput = {
    id?: string
    periodNumber: number
    name: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FiscalPeriodUncheckedCreateWithoutFiscalYearInput = {
    id?: string
    periodNumber: number
    name: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FiscalPeriodCreateOrConnectWithoutFiscalYearInput = {
    where: FiscalPeriodWhereUniqueInput
    create: XOR<FiscalPeriodCreateWithoutFiscalYearInput, FiscalPeriodUncheckedCreateWithoutFiscalYearInput>
  }

  export type FiscalPeriodCreateManyFiscalYearInputEnvelope = {
    data: FiscalPeriodCreateManyFiscalYearInput | FiscalPeriodCreateManyFiscalYearInput[]
    skipDuplicates?: boolean
  }

  export type FiscalPeriodUpsertWithWhereUniqueWithoutFiscalYearInput = {
    where: FiscalPeriodWhereUniqueInput
    update: XOR<FiscalPeriodUpdateWithoutFiscalYearInput, FiscalPeriodUncheckedUpdateWithoutFiscalYearInput>
    create: XOR<FiscalPeriodCreateWithoutFiscalYearInput, FiscalPeriodUncheckedCreateWithoutFiscalYearInput>
  }

  export type FiscalPeriodUpdateWithWhereUniqueWithoutFiscalYearInput = {
    where: FiscalPeriodWhereUniqueInput
    data: XOR<FiscalPeriodUpdateWithoutFiscalYearInput, FiscalPeriodUncheckedUpdateWithoutFiscalYearInput>
  }

  export type FiscalPeriodUpdateManyWithWhereWithoutFiscalYearInput = {
    where: FiscalPeriodScalarWhereInput
    data: XOR<FiscalPeriodUpdateManyMutationInput, FiscalPeriodUncheckedUpdateManyWithoutFiscalYearInput>
  }

  export type FiscalPeriodScalarWhereInput = {
    AND?: FiscalPeriodScalarWhereInput | FiscalPeriodScalarWhereInput[]
    OR?: FiscalPeriodScalarWhereInput[]
    NOT?: FiscalPeriodScalarWhereInput | FiscalPeriodScalarWhereInput[]
    id?: StringFilter<"FiscalPeriod"> | string
    fiscalYearId?: StringFilter<"FiscalPeriod"> | string
    periodNumber?: IntFilter<"FiscalPeriod"> | number
    name?: StringFilter<"FiscalPeriod"> | string
    startDate?: DateTimeFilter<"FiscalPeriod"> | Date | string
    endDate?: DateTimeFilter<"FiscalPeriod"> | Date | string
    isActive?: BoolFilter<"FiscalPeriod"> | boolean
    isClosed?: BoolFilter<"FiscalPeriod"> | boolean
    createdAt?: DateTimeFilter<"FiscalPeriod"> | Date | string
    updatedAt?: DateTimeFilter<"FiscalPeriod"> | Date | string
  }

  export type FiscalYearCreateWithoutPeriodsInput = {
    id?: string
    year: number
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FiscalYearUncheckedCreateWithoutPeriodsInput = {
    id?: string
    year: number
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FiscalYearCreateOrConnectWithoutPeriodsInput = {
    where: FiscalYearWhereUniqueInput
    create: XOR<FiscalYearCreateWithoutPeriodsInput, FiscalYearUncheckedCreateWithoutPeriodsInput>
  }

  export type FiscalYearUpsertWithoutPeriodsInput = {
    update: XOR<FiscalYearUpdateWithoutPeriodsInput, FiscalYearUncheckedUpdateWithoutPeriodsInput>
    create: XOR<FiscalYearCreateWithoutPeriodsInput, FiscalYearUncheckedCreateWithoutPeriodsInput>
    where?: FiscalYearWhereInput
  }

  export type FiscalYearUpdateToOneWithWhereWithoutPeriodsInput = {
    where?: FiscalYearWhereInput
    data: XOR<FiscalYearUpdateWithoutPeriodsInput, FiscalYearUncheckedUpdateWithoutPeriodsInput>
  }

  export type FiscalYearUpdateWithoutPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiscalYearUncheckedUpdateWithoutPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalStepCreateWithoutWorkflowInput = {
    id?: string
    stepOrder: number
    name: string
    isRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutApprovalStepInput
    ApprovalRequest?: ApprovalRequestCreateNestedManyWithoutCurrentStepInput
    ApprovalAction?: ApprovalActionCreateNestedManyWithoutStepInput
  }

  export type ApprovalStepUncheckedCreateWithoutWorkflowInput = {
    id?: string
    stepOrder: number
    name: string
    roleId: string
    isRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ApprovalRequest?: ApprovalRequestUncheckedCreateNestedManyWithoutCurrentStepInput
    ApprovalAction?: ApprovalActionUncheckedCreateNestedManyWithoutStepInput
  }

  export type ApprovalStepCreateOrConnectWithoutWorkflowInput = {
    where: ApprovalStepWhereUniqueInput
    create: XOR<ApprovalStepCreateWithoutWorkflowInput, ApprovalStepUncheckedCreateWithoutWorkflowInput>
  }

  export type ApprovalStepCreateManyWorkflowInputEnvelope = {
    data: ApprovalStepCreateManyWorkflowInput | ApprovalStepCreateManyWorkflowInput[]
    skipDuplicates?: boolean
  }

  export type ApprovalRequestCreateWithoutWorkflowInput = {
    id?: string
    entityType: string
    entityId: string
    status: string
    requestedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requestedByUser: UserCreateNestedOneWithoutApprovalRequestInput
    currentStep?: ApprovalStepCreateNestedOneWithoutApprovalRequestInput
    actions?: ApprovalActionCreateNestedManyWithoutRequestInput
  }

  export type ApprovalRequestUncheckedCreateWithoutWorkflowInput = {
    id?: string
    entityType: string
    entityId: string
    requestedBy: string
    currentStepId?: string | null
    status: string
    requestedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actions?: ApprovalActionUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ApprovalRequestCreateOrConnectWithoutWorkflowInput = {
    where: ApprovalRequestWhereUniqueInput
    create: XOR<ApprovalRequestCreateWithoutWorkflowInput, ApprovalRequestUncheckedCreateWithoutWorkflowInput>
  }

  export type ApprovalRequestCreateManyWorkflowInputEnvelope = {
    data: ApprovalRequestCreateManyWorkflowInput | ApprovalRequestCreateManyWorkflowInput[]
    skipDuplicates?: boolean
  }

  export type ApprovalStepUpsertWithWhereUniqueWithoutWorkflowInput = {
    where: ApprovalStepWhereUniqueInput
    update: XOR<ApprovalStepUpdateWithoutWorkflowInput, ApprovalStepUncheckedUpdateWithoutWorkflowInput>
    create: XOR<ApprovalStepCreateWithoutWorkflowInput, ApprovalStepUncheckedCreateWithoutWorkflowInput>
  }

  export type ApprovalStepUpdateWithWhereUniqueWithoutWorkflowInput = {
    where: ApprovalStepWhereUniqueInput
    data: XOR<ApprovalStepUpdateWithoutWorkflowInput, ApprovalStepUncheckedUpdateWithoutWorkflowInput>
  }

  export type ApprovalStepUpdateManyWithWhereWithoutWorkflowInput = {
    where: ApprovalStepScalarWhereInput
    data: XOR<ApprovalStepUpdateManyMutationInput, ApprovalStepUncheckedUpdateManyWithoutWorkflowInput>
  }

  export type ApprovalRequestUpsertWithWhereUniqueWithoutWorkflowInput = {
    where: ApprovalRequestWhereUniqueInput
    update: XOR<ApprovalRequestUpdateWithoutWorkflowInput, ApprovalRequestUncheckedUpdateWithoutWorkflowInput>
    create: XOR<ApprovalRequestCreateWithoutWorkflowInput, ApprovalRequestUncheckedCreateWithoutWorkflowInput>
  }

  export type ApprovalRequestUpdateWithWhereUniqueWithoutWorkflowInput = {
    where: ApprovalRequestWhereUniqueInput
    data: XOR<ApprovalRequestUpdateWithoutWorkflowInput, ApprovalRequestUncheckedUpdateWithoutWorkflowInput>
  }

  export type ApprovalRequestUpdateManyWithWhereWithoutWorkflowInput = {
    where: ApprovalRequestScalarWhereInput
    data: XOR<ApprovalRequestUpdateManyMutationInput, ApprovalRequestUncheckedUpdateManyWithoutWorkflowInput>
  }

  export type ApprovalWorkflowCreateWithoutStepsInput = {
    id?: string
    name: string
    entity: string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ApprovalRequest?: ApprovalRequestCreateNestedManyWithoutWorkflowInput
  }

  export type ApprovalWorkflowUncheckedCreateWithoutStepsInput = {
    id?: string
    name: string
    entity: string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ApprovalRequest?: ApprovalRequestUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type ApprovalWorkflowCreateOrConnectWithoutStepsInput = {
    where: ApprovalWorkflowWhereUniqueInput
    create: XOR<ApprovalWorkflowCreateWithoutStepsInput, ApprovalWorkflowUncheckedCreateWithoutStepsInput>
  }

  export type RoleCreateWithoutApprovalStepInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    rolePermissions?: RolePermissionCreateNestedManyWithoutRoleInput
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutApprovalStepInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutApprovalStepInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutApprovalStepInput, RoleUncheckedCreateWithoutApprovalStepInput>
  }

  export type ApprovalRequestCreateWithoutCurrentStepInput = {
    id?: string
    entityType: string
    entityId: string
    status: string
    requestedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workflow: ApprovalWorkflowCreateNestedOneWithoutApprovalRequestInput
    requestedByUser: UserCreateNestedOneWithoutApprovalRequestInput
    actions?: ApprovalActionCreateNestedManyWithoutRequestInput
  }

  export type ApprovalRequestUncheckedCreateWithoutCurrentStepInput = {
    id?: string
    workflowId: string
    entityType: string
    entityId: string
    requestedBy: string
    status: string
    requestedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actions?: ApprovalActionUncheckedCreateNestedManyWithoutRequestInput
  }

  export type ApprovalRequestCreateOrConnectWithoutCurrentStepInput = {
    where: ApprovalRequestWhereUniqueInput
    create: XOR<ApprovalRequestCreateWithoutCurrentStepInput, ApprovalRequestUncheckedCreateWithoutCurrentStepInput>
  }

  export type ApprovalRequestCreateManyCurrentStepInputEnvelope = {
    data: ApprovalRequestCreateManyCurrentStepInput | ApprovalRequestCreateManyCurrentStepInput[]
    skipDuplicates?: boolean
  }

  export type ApprovalActionCreateWithoutStepInput = {
    id?: string
    action: string
    comments?: string | null
    actionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    request: ApprovalRequestCreateNestedOneWithoutActionsInput
    user: UserCreateNestedOneWithoutApprovalActionInput
  }

  export type ApprovalActionUncheckedCreateWithoutStepInput = {
    id?: string
    requestId: string
    userId: string
    action: string
    comments?: string | null
    actionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalActionCreateOrConnectWithoutStepInput = {
    where: ApprovalActionWhereUniqueInput
    create: XOR<ApprovalActionCreateWithoutStepInput, ApprovalActionUncheckedCreateWithoutStepInput>
  }

  export type ApprovalActionCreateManyStepInputEnvelope = {
    data: ApprovalActionCreateManyStepInput | ApprovalActionCreateManyStepInput[]
    skipDuplicates?: boolean
  }

  export type ApprovalWorkflowUpsertWithoutStepsInput = {
    update: XOR<ApprovalWorkflowUpdateWithoutStepsInput, ApprovalWorkflowUncheckedUpdateWithoutStepsInput>
    create: XOR<ApprovalWorkflowCreateWithoutStepsInput, ApprovalWorkflowUncheckedCreateWithoutStepsInput>
    where?: ApprovalWorkflowWhereInput
  }

  export type ApprovalWorkflowUpdateToOneWithWhereWithoutStepsInput = {
    where?: ApprovalWorkflowWhereInput
    data: XOR<ApprovalWorkflowUpdateWithoutStepsInput, ApprovalWorkflowUncheckedUpdateWithoutStepsInput>
  }

  export type ApprovalWorkflowUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ApprovalRequest?: ApprovalRequestUpdateManyWithoutWorkflowNestedInput
  }

  export type ApprovalWorkflowUncheckedUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ApprovalRequest?: ApprovalRequestUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type RoleUpsertWithoutApprovalStepInput = {
    update: XOR<RoleUpdateWithoutApprovalStepInput, RoleUncheckedUpdateWithoutApprovalStepInput>
    create: XOR<RoleCreateWithoutApprovalStepInput, RoleUncheckedCreateWithoutApprovalStepInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutApprovalStepInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutApprovalStepInput, RoleUncheckedUpdateWithoutApprovalStepInput>
  }

  export type RoleUpdateWithoutApprovalStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUpdateManyWithoutRoleNestedInput
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutApprovalStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type ApprovalRequestUpsertWithWhereUniqueWithoutCurrentStepInput = {
    where: ApprovalRequestWhereUniqueInput
    update: XOR<ApprovalRequestUpdateWithoutCurrentStepInput, ApprovalRequestUncheckedUpdateWithoutCurrentStepInput>
    create: XOR<ApprovalRequestCreateWithoutCurrentStepInput, ApprovalRequestUncheckedCreateWithoutCurrentStepInput>
  }

  export type ApprovalRequestUpdateWithWhereUniqueWithoutCurrentStepInput = {
    where: ApprovalRequestWhereUniqueInput
    data: XOR<ApprovalRequestUpdateWithoutCurrentStepInput, ApprovalRequestUncheckedUpdateWithoutCurrentStepInput>
  }

  export type ApprovalRequestUpdateManyWithWhereWithoutCurrentStepInput = {
    where: ApprovalRequestScalarWhereInput
    data: XOR<ApprovalRequestUpdateManyMutationInput, ApprovalRequestUncheckedUpdateManyWithoutCurrentStepInput>
  }

  export type ApprovalActionUpsertWithWhereUniqueWithoutStepInput = {
    where: ApprovalActionWhereUniqueInput
    update: XOR<ApprovalActionUpdateWithoutStepInput, ApprovalActionUncheckedUpdateWithoutStepInput>
    create: XOR<ApprovalActionCreateWithoutStepInput, ApprovalActionUncheckedCreateWithoutStepInput>
  }

  export type ApprovalActionUpdateWithWhereUniqueWithoutStepInput = {
    where: ApprovalActionWhereUniqueInput
    data: XOR<ApprovalActionUpdateWithoutStepInput, ApprovalActionUncheckedUpdateWithoutStepInput>
  }

  export type ApprovalActionUpdateManyWithWhereWithoutStepInput = {
    where: ApprovalActionScalarWhereInput
    data: XOR<ApprovalActionUpdateManyMutationInput, ApprovalActionUncheckedUpdateManyWithoutStepInput>
  }

  export type ApprovalWorkflowCreateWithoutApprovalRequestInput = {
    id?: string
    name: string
    entity: string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: ApprovalStepCreateNestedManyWithoutWorkflowInput
  }

  export type ApprovalWorkflowUncheckedCreateWithoutApprovalRequestInput = {
    id?: string
    name: string
    entity: string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: ApprovalStepUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type ApprovalWorkflowCreateOrConnectWithoutApprovalRequestInput = {
    where: ApprovalWorkflowWhereUniqueInput
    create: XOR<ApprovalWorkflowCreateWithoutApprovalRequestInput, ApprovalWorkflowUncheckedCreateWithoutApprovalRequestInput>
  }

  export type UserCreateWithoutApprovalRequestInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    journals?: JournalCreateNestedManyWithoutPostedByUserInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutUserInput
    salesReceipts?: SalesReceiptCreateNestedManyWithoutUserInput
    purchasePayments?: PurchasePaymentCreateNestedManyWithoutUserInput
    SystemSetting?: SystemSettingCreateNestedManyWithoutUpdatedByUserInput
    ApprovalAction?: ApprovalActionCreateNestedManyWithoutUserInput
    assetsCreated?: AssetCreateNestedManyWithoutCreatedByUserInput
    assetDisposals?: AssetDisposalCreateNestedManyWithoutDisposedByUserInput
  }

  export type UserUncheckedCreateWithoutApprovalRequestInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    journals?: JournalUncheckedCreateNestedManyWithoutPostedByUserInput
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutUserInput
    salesReceipts?: SalesReceiptUncheckedCreateNestedManyWithoutUserInput
    purchasePayments?: PurchasePaymentUncheckedCreateNestedManyWithoutUserInput
    SystemSetting?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    ApprovalAction?: ApprovalActionUncheckedCreateNestedManyWithoutUserInput
    assetsCreated?: AssetUncheckedCreateNestedManyWithoutCreatedByUserInput
    assetDisposals?: AssetDisposalUncheckedCreateNestedManyWithoutDisposedByUserInput
  }

  export type UserCreateOrConnectWithoutApprovalRequestInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovalRequestInput, UserUncheckedCreateWithoutApprovalRequestInput>
  }

  export type ApprovalStepCreateWithoutApprovalRequestInput = {
    id?: string
    stepOrder: number
    name: string
    isRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workflow: ApprovalWorkflowCreateNestedOneWithoutStepsInput
    role: RoleCreateNestedOneWithoutApprovalStepInput
    ApprovalAction?: ApprovalActionCreateNestedManyWithoutStepInput
  }

  export type ApprovalStepUncheckedCreateWithoutApprovalRequestInput = {
    id?: string
    workflowId: string
    stepOrder: number
    name: string
    roleId: string
    isRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ApprovalAction?: ApprovalActionUncheckedCreateNestedManyWithoutStepInput
  }

  export type ApprovalStepCreateOrConnectWithoutApprovalRequestInput = {
    where: ApprovalStepWhereUniqueInput
    create: XOR<ApprovalStepCreateWithoutApprovalRequestInput, ApprovalStepUncheckedCreateWithoutApprovalRequestInput>
  }

  export type ApprovalActionCreateWithoutRequestInput = {
    id?: string
    action: string
    comments?: string | null
    actionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    step: ApprovalStepCreateNestedOneWithoutApprovalActionInput
    user: UserCreateNestedOneWithoutApprovalActionInput
  }

  export type ApprovalActionUncheckedCreateWithoutRequestInput = {
    id?: string
    stepId: string
    userId: string
    action: string
    comments?: string | null
    actionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalActionCreateOrConnectWithoutRequestInput = {
    where: ApprovalActionWhereUniqueInput
    create: XOR<ApprovalActionCreateWithoutRequestInput, ApprovalActionUncheckedCreateWithoutRequestInput>
  }

  export type ApprovalActionCreateManyRequestInputEnvelope = {
    data: ApprovalActionCreateManyRequestInput | ApprovalActionCreateManyRequestInput[]
    skipDuplicates?: boolean
  }

  export type ApprovalWorkflowUpsertWithoutApprovalRequestInput = {
    update: XOR<ApprovalWorkflowUpdateWithoutApprovalRequestInput, ApprovalWorkflowUncheckedUpdateWithoutApprovalRequestInput>
    create: XOR<ApprovalWorkflowCreateWithoutApprovalRequestInput, ApprovalWorkflowUncheckedCreateWithoutApprovalRequestInput>
    where?: ApprovalWorkflowWhereInput
  }

  export type ApprovalWorkflowUpdateToOneWithWhereWithoutApprovalRequestInput = {
    where?: ApprovalWorkflowWhereInput
    data: XOR<ApprovalWorkflowUpdateWithoutApprovalRequestInput, ApprovalWorkflowUncheckedUpdateWithoutApprovalRequestInput>
  }

  export type ApprovalWorkflowUpdateWithoutApprovalRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: ApprovalStepUpdateManyWithoutWorkflowNestedInput
  }

  export type ApprovalWorkflowUncheckedUpdateWithoutApprovalRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: ApprovalStepUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type UserUpsertWithoutApprovalRequestInput = {
    update: XOR<UserUpdateWithoutApprovalRequestInput, UserUncheckedUpdateWithoutApprovalRequestInput>
    create: XOR<UserCreateWithoutApprovalRequestInput, UserUncheckedCreateWithoutApprovalRequestInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovalRequestInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovalRequestInput, UserUncheckedUpdateWithoutApprovalRequestInput>
  }

  export type UserUpdateWithoutApprovalRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    journals?: JournalUpdateManyWithoutPostedByUserNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutUserNestedInput
    salesReceipts?: SalesReceiptUpdateManyWithoutUserNestedInput
    purchasePayments?: PurchasePaymentUpdateManyWithoutUserNestedInput
    SystemSetting?: SystemSettingUpdateManyWithoutUpdatedByUserNestedInput
    ApprovalAction?: ApprovalActionUpdateManyWithoutUserNestedInput
    assetsCreated?: AssetUpdateManyWithoutCreatedByUserNestedInput
    assetDisposals?: AssetDisposalUpdateManyWithoutDisposedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovalRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    journals?: JournalUncheckedUpdateManyWithoutPostedByUserNestedInput
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutUserNestedInput
    salesReceipts?: SalesReceiptUncheckedUpdateManyWithoutUserNestedInput
    purchasePayments?: PurchasePaymentUncheckedUpdateManyWithoutUserNestedInput
    SystemSetting?: SystemSettingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    ApprovalAction?: ApprovalActionUncheckedUpdateManyWithoutUserNestedInput
    assetsCreated?: AssetUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assetDisposals?: AssetDisposalUncheckedUpdateManyWithoutDisposedByUserNestedInput
  }

  export type ApprovalStepUpsertWithoutApprovalRequestInput = {
    update: XOR<ApprovalStepUpdateWithoutApprovalRequestInput, ApprovalStepUncheckedUpdateWithoutApprovalRequestInput>
    create: XOR<ApprovalStepCreateWithoutApprovalRequestInput, ApprovalStepUncheckedCreateWithoutApprovalRequestInput>
    where?: ApprovalStepWhereInput
  }

  export type ApprovalStepUpdateToOneWithWhereWithoutApprovalRequestInput = {
    where?: ApprovalStepWhereInput
    data: XOR<ApprovalStepUpdateWithoutApprovalRequestInput, ApprovalStepUncheckedUpdateWithoutApprovalRequestInput>
  }

  export type ApprovalStepUpdateWithoutApprovalRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: ApprovalWorkflowUpdateOneRequiredWithoutStepsNestedInput
    role?: RoleUpdateOneRequiredWithoutApprovalStepNestedInput
    ApprovalAction?: ApprovalActionUpdateManyWithoutStepNestedInput
  }

  export type ApprovalStepUncheckedUpdateWithoutApprovalRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ApprovalAction?: ApprovalActionUncheckedUpdateManyWithoutStepNestedInput
  }

  export type ApprovalActionUpsertWithWhereUniqueWithoutRequestInput = {
    where: ApprovalActionWhereUniqueInput
    update: XOR<ApprovalActionUpdateWithoutRequestInput, ApprovalActionUncheckedUpdateWithoutRequestInput>
    create: XOR<ApprovalActionCreateWithoutRequestInput, ApprovalActionUncheckedCreateWithoutRequestInput>
  }

  export type ApprovalActionUpdateWithWhereUniqueWithoutRequestInput = {
    where: ApprovalActionWhereUniqueInput
    data: XOR<ApprovalActionUpdateWithoutRequestInput, ApprovalActionUncheckedUpdateWithoutRequestInput>
  }

  export type ApprovalActionUpdateManyWithWhereWithoutRequestInput = {
    where: ApprovalActionScalarWhereInput
    data: XOR<ApprovalActionUpdateManyMutationInput, ApprovalActionUncheckedUpdateManyWithoutRequestInput>
  }

  export type ApprovalRequestCreateWithoutActionsInput = {
    id?: string
    entityType: string
    entityId: string
    status: string
    requestedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workflow: ApprovalWorkflowCreateNestedOneWithoutApprovalRequestInput
    requestedByUser: UserCreateNestedOneWithoutApprovalRequestInput
    currentStep?: ApprovalStepCreateNestedOneWithoutApprovalRequestInput
  }

  export type ApprovalRequestUncheckedCreateWithoutActionsInput = {
    id?: string
    workflowId: string
    entityType: string
    entityId: string
    requestedBy: string
    currentStepId?: string | null
    status: string
    requestedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalRequestCreateOrConnectWithoutActionsInput = {
    where: ApprovalRequestWhereUniqueInput
    create: XOR<ApprovalRequestCreateWithoutActionsInput, ApprovalRequestUncheckedCreateWithoutActionsInput>
  }

  export type ApprovalStepCreateWithoutApprovalActionInput = {
    id?: string
    stepOrder: number
    name: string
    isRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workflow: ApprovalWorkflowCreateNestedOneWithoutStepsInput
    role: RoleCreateNestedOneWithoutApprovalStepInput
    ApprovalRequest?: ApprovalRequestCreateNestedManyWithoutCurrentStepInput
  }

  export type ApprovalStepUncheckedCreateWithoutApprovalActionInput = {
    id?: string
    workflowId: string
    stepOrder: number
    name: string
    roleId: string
    isRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ApprovalRequest?: ApprovalRequestUncheckedCreateNestedManyWithoutCurrentStepInput
  }

  export type ApprovalStepCreateOrConnectWithoutApprovalActionInput = {
    where: ApprovalStepWhereUniqueInput
    create: XOR<ApprovalStepCreateWithoutApprovalActionInput, ApprovalStepUncheckedCreateWithoutApprovalActionInput>
  }

  export type UserCreateWithoutApprovalActionInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    journals?: JournalCreateNestedManyWithoutPostedByUserInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutUserInput
    salesReceipts?: SalesReceiptCreateNestedManyWithoutUserInput
    purchasePayments?: PurchasePaymentCreateNestedManyWithoutUserInput
    SystemSetting?: SystemSettingCreateNestedManyWithoutUpdatedByUserInput
    ApprovalRequest?: ApprovalRequestCreateNestedManyWithoutRequestedByUserInput
    assetsCreated?: AssetCreateNestedManyWithoutCreatedByUserInput
    assetDisposals?: AssetDisposalCreateNestedManyWithoutDisposedByUserInput
  }

  export type UserUncheckedCreateWithoutApprovalActionInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    journals?: JournalUncheckedCreateNestedManyWithoutPostedByUserInput
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutUserInput
    salesReceipts?: SalesReceiptUncheckedCreateNestedManyWithoutUserInput
    purchasePayments?: PurchasePaymentUncheckedCreateNestedManyWithoutUserInput
    SystemSetting?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    ApprovalRequest?: ApprovalRequestUncheckedCreateNestedManyWithoutRequestedByUserInput
    assetsCreated?: AssetUncheckedCreateNestedManyWithoutCreatedByUserInput
    assetDisposals?: AssetDisposalUncheckedCreateNestedManyWithoutDisposedByUserInput
  }

  export type UserCreateOrConnectWithoutApprovalActionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovalActionInput, UserUncheckedCreateWithoutApprovalActionInput>
  }

  export type ApprovalRequestUpsertWithoutActionsInput = {
    update: XOR<ApprovalRequestUpdateWithoutActionsInput, ApprovalRequestUncheckedUpdateWithoutActionsInput>
    create: XOR<ApprovalRequestCreateWithoutActionsInput, ApprovalRequestUncheckedCreateWithoutActionsInput>
    where?: ApprovalRequestWhereInput
  }

  export type ApprovalRequestUpdateToOneWithWhereWithoutActionsInput = {
    where?: ApprovalRequestWhereInput
    data: XOR<ApprovalRequestUpdateWithoutActionsInput, ApprovalRequestUncheckedUpdateWithoutActionsInput>
  }

  export type ApprovalRequestUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: ApprovalWorkflowUpdateOneRequiredWithoutApprovalRequestNestedInput
    requestedByUser?: UserUpdateOneRequiredWithoutApprovalRequestNestedInput
    currentStep?: ApprovalStepUpdateOneWithoutApprovalRequestNestedInput
  }

  export type ApprovalRequestUncheckedUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalStepUpsertWithoutApprovalActionInput = {
    update: XOR<ApprovalStepUpdateWithoutApprovalActionInput, ApprovalStepUncheckedUpdateWithoutApprovalActionInput>
    create: XOR<ApprovalStepCreateWithoutApprovalActionInput, ApprovalStepUncheckedCreateWithoutApprovalActionInput>
    where?: ApprovalStepWhereInput
  }

  export type ApprovalStepUpdateToOneWithWhereWithoutApprovalActionInput = {
    where?: ApprovalStepWhereInput
    data: XOR<ApprovalStepUpdateWithoutApprovalActionInput, ApprovalStepUncheckedUpdateWithoutApprovalActionInput>
  }

  export type ApprovalStepUpdateWithoutApprovalActionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: ApprovalWorkflowUpdateOneRequiredWithoutStepsNestedInput
    role?: RoleUpdateOneRequiredWithoutApprovalStepNestedInput
    ApprovalRequest?: ApprovalRequestUpdateManyWithoutCurrentStepNestedInput
  }

  export type ApprovalStepUncheckedUpdateWithoutApprovalActionInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ApprovalRequest?: ApprovalRequestUncheckedUpdateManyWithoutCurrentStepNestedInput
  }

  export type UserUpsertWithoutApprovalActionInput = {
    update: XOR<UserUpdateWithoutApprovalActionInput, UserUncheckedUpdateWithoutApprovalActionInput>
    create: XOR<UserCreateWithoutApprovalActionInput, UserUncheckedCreateWithoutApprovalActionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovalActionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovalActionInput, UserUncheckedUpdateWithoutApprovalActionInput>
  }

  export type UserUpdateWithoutApprovalActionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    journals?: JournalUpdateManyWithoutPostedByUserNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutUserNestedInput
    salesReceipts?: SalesReceiptUpdateManyWithoutUserNestedInput
    purchasePayments?: PurchasePaymentUpdateManyWithoutUserNestedInput
    SystemSetting?: SystemSettingUpdateManyWithoutUpdatedByUserNestedInput
    ApprovalRequest?: ApprovalRequestUpdateManyWithoutRequestedByUserNestedInput
    assetsCreated?: AssetUpdateManyWithoutCreatedByUserNestedInput
    assetDisposals?: AssetDisposalUpdateManyWithoutDisposedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovalActionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    journals?: JournalUncheckedUpdateManyWithoutPostedByUserNestedInput
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutUserNestedInput
    salesReceipts?: SalesReceiptUncheckedUpdateManyWithoutUserNestedInput
    purchasePayments?: PurchasePaymentUncheckedUpdateManyWithoutUserNestedInput
    SystemSetting?: SystemSettingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    ApprovalRequest?: ApprovalRequestUncheckedUpdateManyWithoutRequestedByUserNestedInput
    assetsCreated?: AssetUncheckedUpdateManyWithoutCreatedByUserNestedInput
    assetDisposals?: AssetDisposalUncheckedUpdateManyWithoutDisposedByUserNestedInput
  }

  export type AssetCreateWithoutCategoryInput = {
    id?: string
    assetNo: string
    name: string
    description?: string | null
    acquisitionDate: Date | string
    acquisitionCost: Decimal | DecimalJsLike | number | string
    residualValue?: Decimal | DecimalJsLike | number | string
    usefulLife: number
    depreciationMethod: string
    serialNumber?: string | null
    supplier?: string | null
    status?: string
    disposalDate?: Date | string | null
    disposalAmount?: Decimal | DecimalJsLike | number | string | null
    disposalMethod?: string | null
    createdAt?: Date | string
    location?: LocationCreateNestedOneWithoutAssetsInput
    purchaseOrder?: PurchaseCreateNestedOneWithoutAssetsInput
    createdByUser: UserCreateNestedOneWithoutAssetsCreatedInput
    depreciationEntries?: AssetDepreciationCreateNestedManyWithoutAssetInput
    disposals?: AssetDisposalCreateNestedManyWithoutAssetInput
    Vendor?: VendorCreateNestedOneWithoutAssetsInput
  }

  export type AssetUncheckedCreateWithoutCategoryInput = {
    id?: string
    assetNo: string
    name: string
    description?: string | null
    acquisitionDate: Date | string
    acquisitionCost: Decimal | DecimalJsLike | number | string
    residualValue?: Decimal | DecimalJsLike | number | string
    usefulLife: number
    depreciationMethod: string
    locationId?: string | null
    serialNumber?: string | null
    supplier?: string | null
    purchaseOrderId?: string | null
    status?: string
    disposalDate?: Date | string | null
    disposalAmount?: Decimal | DecimalJsLike | number | string | null
    disposalMethod?: string | null
    createdBy: string
    createdAt?: Date | string
    vendorId?: string | null
    depreciationEntries?: AssetDepreciationUncheckedCreateNestedManyWithoutAssetInput
    disposals?: AssetDisposalUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutCategoryInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutCategoryInput, AssetUncheckedCreateWithoutCategoryInput>
  }

  export type AssetCreateManyCategoryInputEnvelope = {
    data: AssetCreateManyCategoryInput | AssetCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ChartOfAccountCreateWithoutAssetCategoriesAssetInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    accountType: string
    isActive?: boolean
    createdAt?: Date | string
    parent?: ChartOfAccountCreateNestedOneWithoutChildrenInput
    children?: ChartOfAccountCreateNestedManyWithoutParentInput
    journalLines?: JournalLineCreateNestedManyWithoutAccountInput
    cashTransactionsGL?: CashTransactionCreateNestedManyWithoutGlAccountInput
    cashTransactionsContra?: CashTransactionCreateNestedManyWithoutContraAccountInput
    cashAccounts?: CashAccountCreateNestedManyWithoutChartOfAccountInput
    assetCategoriesDepreciation?: AssetCategoryCreateNestedManyWithoutGlDepreciationAccountInput
    assetCategoriesAccumulated?: AssetCategoryCreateNestedManyWithoutGlAccumulatedDepreciationAccountInput
  }

  export type ChartOfAccountUncheckedCreateWithoutAssetCategoriesAssetInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    accountType: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    children?: ChartOfAccountUncheckedCreateNestedManyWithoutParentInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAccountInput
    cashTransactionsGL?: CashTransactionUncheckedCreateNestedManyWithoutGlAccountInput
    cashTransactionsContra?: CashTransactionUncheckedCreateNestedManyWithoutContraAccountInput
    cashAccounts?: CashAccountUncheckedCreateNestedManyWithoutChartOfAccountInput
    assetCategoriesDepreciation?: AssetCategoryUncheckedCreateNestedManyWithoutGlDepreciationAccountInput
    assetCategoriesAccumulated?: AssetCategoryUncheckedCreateNestedManyWithoutGlAccumulatedDepreciationAccountInput
  }

  export type ChartOfAccountCreateOrConnectWithoutAssetCategoriesAssetInput = {
    where: ChartOfAccountWhereUniqueInput
    create: XOR<ChartOfAccountCreateWithoutAssetCategoriesAssetInput, ChartOfAccountUncheckedCreateWithoutAssetCategoriesAssetInput>
  }

  export type ChartOfAccountCreateWithoutAssetCategoriesDepreciationInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    accountType: string
    isActive?: boolean
    createdAt?: Date | string
    parent?: ChartOfAccountCreateNestedOneWithoutChildrenInput
    children?: ChartOfAccountCreateNestedManyWithoutParentInput
    journalLines?: JournalLineCreateNestedManyWithoutAccountInput
    cashTransactionsGL?: CashTransactionCreateNestedManyWithoutGlAccountInput
    cashTransactionsContra?: CashTransactionCreateNestedManyWithoutContraAccountInput
    cashAccounts?: CashAccountCreateNestedManyWithoutChartOfAccountInput
    assetCategoriesAsset?: AssetCategoryCreateNestedManyWithoutGlAssetAccountInput
    assetCategoriesAccumulated?: AssetCategoryCreateNestedManyWithoutGlAccumulatedDepreciationAccountInput
  }

  export type ChartOfAccountUncheckedCreateWithoutAssetCategoriesDepreciationInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    accountType: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    children?: ChartOfAccountUncheckedCreateNestedManyWithoutParentInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAccountInput
    cashTransactionsGL?: CashTransactionUncheckedCreateNestedManyWithoutGlAccountInput
    cashTransactionsContra?: CashTransactionUncheckedCreateNestedManyWithoutContraAccountInput
    cashAccounts?: CashAccountUncheckedCreateNestedManyWithoutChartOfAccountInput
    assetCategoriesAsset?: AssetCategoryUncheckedCreateNestedManyWithoutGlAssetAccountInput
    assetCategoriesAccumulated?: AssetCategoryUncheckedCreateNestedManyWithoutGlAccumulatedDepreciationAccountInput
  }

  export type ChartOfAccountCreateOrConnectWithoutAssetCategoriesDepreciationInput = {
    where: ChartOfAccountWhereUniqueInput
    create: XOR<ChartOfAccountCreateWithoutAssetCategoriesDepreciationInput, ChartOfAccountUncheckedCreateWithoutAssetCategoriesDepreciationInput>
  }

  export type ChartOfAccountCreateWithoutAssetCategoriesAccumulatedInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    accountType: string
    isActive?: boolean
    createdAt?: Date | string
    parent?: ChartOfAccountCreateNestedOneWithoutChildrenInput
    children?: ChartOfAccountCreateNestedManyWithoutParentInput
    journalLines?: JournalLineCreateNestedManyWithoutAccountInput
    cashTransactionsGL?: CashTransactionCreateNestedManyWithoutGlAccountInput
    cashTransactionsContra?: CashTransactionCreateNestedManyWithoutContraAccountInput
    cashAccounts?: CashAccountCreateNestedManyWithoutChartOfAccountInput
    assetCategoriesAsset?: AssetCategoryCreateNestedManyWithoutGlAssetAccountInput
    assetCategoriesDepreciation?: AssetCategoryCreateNestedManyWithoutGlDepreciationAccountInput
  }

  export type ChartOfAccountUncheckedCreateWithoutAssetCategoriesAccumulatedInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    accountType: string
    parentId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    children?: ChartOfAccountUncheckedCreateNestedManyWithoutParentInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAccountInput
    cashTransactionsGL?: CashTransactionUncheckedCreateNestedManyWithoutGlAccountInput
    cashTransactionsContra?: CashTransactionUncheckedCreateNestedManyWithoutContraAccountInput
    cashAccounts?: CashAccountUncheckedCreateNestedManyWithoutChartOfAccountInput
    assetCategoriesAsset?: AssetCategoryUncheckedCreateNestedManyWithoutGlAssetAccountInput
    assetCategoriesDepreciation?: AssetCategoryUncheckedCreateNestedManyWithoutGlDepreciationAccountInput
  }

  export type ChartOfAccountCreateOrConnectWithoutAssetCategoriesAccumulatedInput = {
    where: ChartOfAccountWhereUniqueInput
    create: XOR<ChartOfAccountCreateWithoutAssetCategoriesAccumulatedInput, ChartOfAccountUncheckedCreateWithoutAssetCategoriesAccumulatedInput>
  }

  export type AssetUpsertWithWhereUniqueWithoutCategoryInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutCategoryInput, AssetUncheckedUpdateWithoutCategoryInput>
    create: XOR<AssetCreateWithoutCategoryInput, AssetUncheckedCreateWithoutCategoryInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutCategoryInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutCategoryInput, AssetUncheckedUpdateWithoutCategoryInput>
  }

  export type AssetUpdateManyWithWhereWithoutCategoryInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ChartOfAccountUpsertWithoutAssetCategoriesAssetInput = {
    update: XOR<ChartOfAccountUpdateWithoutAssetCategoriesAssetInput, ChartOfAccountUncheckedUpdateWithoutAssetCategoriesAssetInput>
    create: XOR<ChartOfAccountCreateWithoutAssetCategoriesAssetInput, ChartOfAccountUncheckedCreateWithoutAssetCategoriesAssetInput>
    where?: ChartOfAccountWhereInput
  }

  export type ChartOfAccountUpdateToOneWithWhereWithoutAssetCategoriesAssetInput = {
    where?: ChartOfAccountWhereInput
    data: XOR<ChartOfAccountUpdateWithoutAssetCategoriesAssetInput, ChartOfAccountUncheckedUpdateWithoutAssetCategoriesAssetInput>
  }

  export type ChartOfAccountUpdateWithoutAssetCategoriesAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ChartOfAccountUpdateOneWithoutChildrenNestedInput
    children?: ChartOfAccountUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUpdateManyWithoutAccountNestedInput
    cashTransactionsGL?: CashTransactionUpdateManyWithoutGlAccountNestedInput
    cashTransactionsContra?: CashTransactionUpdateManyWithoutContraAccountNestedInput
    cashAccounts?: CashAccountUpdateManyWithoutChartOfAccountNestedInput
    assetCategoriesDepreciation?: AssetCategoryUpdateManyWithoutGlDepreciationAccountNestedInput
    assetCategoriesAccumulated?: AssetCategoryUpdateManyWithoutGlAccumulatedDepreciationAccountNestedInput
  }

  export type ChartOfAccountUncheckedUpdateWithoutAssetCategoriesAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChartOfAccountUncheckedUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutAccountNestedInput
    cashTransactionsGL?: CashTransactionUncheckedUpdateManyWithoutGlAccountNestedInput
    cashTransactionsContra?: CashTransactionUncheckedUpdateManyWithoutContraAccountNestedInput
    cashAccounts?: CashAccountUncheckedUpdateManyWithoutChartOfAccountNestedInput
    assetCategoriesDepreciation?: AssetCategoryUncheckedUpdateManyWithoutGlDepreciationAccountNestedInput
    assetCategoriesAccumulated?: AssetCategoryUncheckedUpdateManyWithoutGlAccumulatedDepreciationAccountNestedInput
  }

  export type ChartOfAccountUpsertWithoutAssetCategoriesDepreciationInput = {
    update: XOR<ChartOfAccountUpdateWithoutAssetCategoriesDepreciationInput, ChartOfAccountUncheckedUpdateWithoutAssetCategoriesDepreciationInput>
    create: XOR<ChartOfAccountCreateWithoutAssetCategoriesDepreciationInput, ChartOfAccountUncheckedCreateWithoutAssetCategoriesDepreciationInput>
    where?: ChartOfAccountWhereInput
  }

  export type ChartOfAccountUpdateToOneWithWhereWithoutAssetCategoriesDepreciationInput = {
    where?: ChartOfAccountWhereInput
    data: XOR<ChartOfAccountUpdateWithoutAssetCategoriesDepreciationInput, ChartOfAccountUncheckedUpdateWithoutAssetCategoriesDepreciationInput>
  }

  export type ChartOfAccountUpdateWithoutAssetCategoriesDepreciationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ChartOfAccountUpdateOneWithoutChildrenNestedInput
    children?: ChartOfAccountUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUpdateManyWithoutAccountNestedInput
    cashTransactionsGL?: CashTransactionUpdateManyWithoutGlAccountNestedInput
    cashTransactionsContra?: CashTransactionUpdateManyWithoutContraAccountNestedInput
    cashAccounts?: CashAccountUpdateManyWithoutChartOfAccountNestedInput
    assetCategoriesAsset?: AssetCategoryUpdateManyWithoutGlAssetAccountNestedInput
    assetCategoriesAccumulated?: AssetCategoryUpdateManyWithoutGlAccumulatedDepreciationAccountNestedInput
  }

  export type ChartOfAccountUncheckedUpdateWithoutAssetCategoriesDepreciationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChartOfAccountUncheckedUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutAccountNestedInput
    cashTransactionsGL?: CashTransactionUncheckedUpdateManyWithoutGlAccountNestedInput
    cashTransactionsContra?: CashTransactionUncheckedUpdateManyWithoutContraAccountNestedInput
    cashAccounts?: CashAccountUncheckedUpdateManyWithoutChartOfAccountNestedInput
    assetCategoriesAsset?: AssetCategoryUncheckedUpdateManyWithoutGlAssetAccountNestedInput
    assetCategoriesAccumulated?: AssetCategoryUncheckedUpdateManyWithoutGlAccumulatedDepreciationAccountNestedInput
  }

  export type ChartOfAccountUpsertWithoutAssetCategoriesAccumulatedInput = {
    update: XOR<ChartOfAccountUpdateWithoutAssetCategoriesAccumulatedInput, ChartOfAccountUncheckedUpdateWithoutAssetCategoriesAccumulatedInput>
    create: XOR<ChartOfAccountCreateWithoutAssetCategoriesAccumulatedInput, ChartOfAccountUncheckedCreateWithoutAssetCategoriesAccumulatedInput>
    where?: ChartOfAccountWhereInput
  }

  export type ChartOfAccountUpdateToOneWithWhereWithoutAssetCategoriesAccumulatedInput = {
    where?: ChartOfAccountWhereInput
    data: XOR<ChartOfAccountUpdateWithoutAssetCategoriesAccumulatedInput, ChartOfAccountUncheckedUpdateWithoutAssetCategoriesAccumulatedInput>
  }

  export type ChartOfAccountUpdateWithoutAssetCategoriesAccumulatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ChartOfAccountUpdateOneWithoutChildrenNestedInput
    children?: ChartOfAccountUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUpdateManyWithoutAccountNestedInput
    cashTransactionsGL?: CashTransactionUpdateManyWithoutGlAccountNestedInput
    cashTransactionsContra?: CashTransactionUpdateManyWithoutContraAccountNestedInput
    cashAccounts?: CashAccountUpdateManyWithoutChartOfAccountNestedInput
    assetCategoriesAsset?: AssetCategoryUpdateManyWithoutGlAssetAccountNestedInput
    assetCategoriesDepreciation?: AssetCategoryUpdateManyWithoutGlDepreciationAccountNestedInput
  }

  export type ChartOfAccountUncheckedUpdateWithoutAssetCategoriesAccumulatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChartOfAccountUncheckedUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutAccountNestedInput
    cashTransactionsGL?: CashTransactionUncheckedUpdateManyWithoutGlAccountNestedInput
    cashTransactionsContra?: CashTransactionUncheckedUpdateManyWithoutContraAccountNestedInput
    cashAccounts?: CashAccountUncheckedUpdateManyWithoutChartOfAccountNestedInput
    assetCategoriesAsset?: AssetCategoryUncheckedUpdateManyWithoutGlAssetAccountNestedInput
    assetCategoriesDepreciation?: AssetCategoryUncheckedUpdateManyWithoutGlDepreciationAccountNestedInput
  }

  export type AssetCategoryCreateWithoutAssetsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    depreciationMethod: string
    usefulLife?: number
    residualValue?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    glAssetAccount: ChartOfAccountCreateNestedOneWithoutAssetCategoriesAssetInput
    glDepreciationAccount: ChartOfAccountCreateNestedOneWithoutAssetCategoriesDepreciationInput
    glAccumulatedDepreciationAccount: ChartOfAccountCreateNestedOneWithoutAssetCategoriesAccumulatedInput
  }

  export type AssetCategoryUncheckedCreateWithoutAssetsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    depreciationMethod: string
    usefulLife?: number
    residualValue?: Decimal | DecimalJsLike | number | string
    glAssetAccountId: string
    glDepreciationAccountId: string
    glAccumulatedDepreciationAccountId: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type AssetCategoryCreateOrConnectWithoutAssetsInput = {
    where: AssetCategoryWhereUniqueInput
    create: XOR<AssetCategoryCreateWithoutAssetsInput, AssetCategoryUncheckedCreateWithoutAssetsInput>
  }

  export type LocationCreateWithoutAssetsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string
    isActive?: boolean
    createdAt?: Date | string
    warehouses?: WarehouseCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutAssetsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string
    isActive?: boolean
    createdAt?: Date | string
    warehouses?: WarehouseUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutAssetsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutAssetsInput, LocationUncheckedCreateWithoutAssetsInput>
  }

  export type PurchaseCreateWithoutAssetsInput = {
    id?: string
    orderNo: string
    orderDate: Date | string
    status?: $Enums.PurchaseStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutPurchasesInput
    purchaseLines?: PurchaseLineCreateNestedManyWithoutPurchaseInput
    purchasePayments?: PurchasePaymentCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutAssetsInput = {
    id?: string
    orderNo: string
    vendorId: string
    orderDate: Date | string
    status?: $Enums.PurchaseStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseLines?: PurchaseLineUncheckedCreateNestedManyWithoutPurchaseInput
    purchasePayments?: PurchasePaymentUncheckedCreateNestedManyWithoutPurchaseInput
  }

  export type PurchaseCreateOrConnectWithoutAssetsInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutAssetsInput, PurchaseUncheckedCreateWithoutAssetsInput>
  }

  export type UserCreateWithoutAssetsCreatedInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    journals?: JournalCreateNestedManyWithoutPostedByUserInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutUserInput
    salesReceipts?: SalesReceiptCreateNestedManyWithoutUserInput
    purchasePayments?: PurchasePaymentCreateNestedManyWithoutUserInput
    SystemSetting?: SystemSettingCreateNestedManyWithoutUpdatedByUserInput
    ApprovalRequest?: ApprovalRequestCreateNestedManyWithoutRequestedByUserInput
    ApprovalAction?: ApprovalActionCreateNestedManyWithoutUserInput
    assetDisposals?: AssetDisposalCreateNestedManyWithoutDisposedByUserInput
  }

  export type UserUncheckedCreateWithoutAssetsCreatedInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    journals?: JournalUncheckedCreateNestedManyWithoutPostedByUserInput
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutUserInput
    salesReceipts?: SalesReceiptUncheckedCreateNestedManyWithoutUserInput
    purchasePayments?: PurchasePaymentUncheckedCreateNestedManyWithoutUserInput
    SystemSetting?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    ApprovalRequest?: ApprovalRequestUncheckedCreateNestedManyWithoutRequestedByUserInput
    ApprovalAction?: ApprovalActionUncheckedCreateNestedManyWithoutUserInput
    assetDisposals?: AssetDisposalUncheckedCreateNestedManyWithoutDisposedByUserInput
  }

  export type UserCreateOrConnectWithoutAssetsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssetsCreatedInput, UserUncheckedCreateWithoutAssetsCreatedInput>
  }

  export type AssetDepreciationCreateWithoutAssetInput = {
    id?: string
    periodYear: number
    periodMonth: number
    depreciationAmount: Decimal | DecimalJsLike | number | string
    accumulatedDepreciation: Decimal | DecimalJsLike | number | string
    netBookValue: Decimal | DecimalJsLike | number | string
    isPosted?: boolean
    postedAt?: Date | string | null
    createdAt?: Date | string
    journal?: JournalCreateNestedOneWithoutAssetDepreciationInput
  }

  export type AssetDepreciationUncheckedCreateWithoutAssetInput = {
    id?: string
    periodYear: number
    periodMonth: number
    depreciationAmount: Decimal | DecimalJsLike | number | string
    accumulatedDepreciation: Decimal | DecimalJsLike | number | string
    netBookValue: Decimal | DecimalJsLike | number | string
    isPosted?: boolean
    postedAt?: Date | string | null
    journalId?: string | null
    createdAt?: Date | string
  }

  export type AssetDepreciationCreateOrConnectWithoutAssetInput = {
    where: AssetDepreciationWhereUniqueInput
    create: XOR<AssetDepreciationCreateWithoutAssetInput, AssetDepreciationUncheckedCreateWithoutAssetInput>
  }

  export type AssetDepreciationCreateManyAssetInputEnvelope = {
    data: AssetDepreciationCreateManyAssetInput | AssetDepreciationCreateManyAssetInput[]
    skipDuplicates?: boolean
  }

  export type AssetDisposalCreateWithoutAssetInput = {
    id?: string
    disposalDate: Date | string
    disposalAmount: Decimal | DecimalJsLike | number | string
    disposalMethod: string
    buyerDetails?: string | null
    gainLoss: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    journal?: JournalCreateNestedOneWithoutAssetDisposalsInput
    disposedByUser: UserCreateNestedOneWithoutAssetDisposalsInput
  }

  export type AssetDisposalUncheckedCreateWithoutAssetInput = {
    id?: string
    disposalDate: Date | string
    disposalAmount: Decimal | DecimalJsLike | number | string
    disposalMethod: string
    buyerDetails?: string | null
    gainLoss: Decimal | DecimalJsLike | number | string
    notes?: string | null
    journalId?: string | null
    disposedBy: string
    createdAt?: Date | string
  }

  export type AssetDisposalCreateOrConnectWithoutAssetInput = {
    where: AssetDisposalWhereUniqueInput
    create: XOR<AssetDisposalCreateWithoutAssetInput, AssetDisposalUncheckedCreateWithoutAssetInput>
  }

  export type AssetDisposalCreateManyAssetInputEnvelope = {
    data: AssetDisposalCreateManyAssetInput | AssetDisposalCreateManyAssetInput[]
    skipDuplicates?: boolean
  }

  export type VendorCreateWithoutAssetsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    paymentTerms?: string | null
    isActive?: boolean
    createdAt?: Date | string
    purchases?: PurchaseCreateNestedManyWithoutVendorInput
    purchasePayments?: PurchasePaymentCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutAssetsInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    paymentTerms?: string | null
    isActive?: boolean
    createdAt?: Date | string
    purchases?: PurchaseUncheckedCreateNestedManyWithoutVendorInput
    purchasePayments?: PurchasePaymentUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutAssetsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutAssetsInput, VendorUncheckedCreateWithoutAssetsInput>
  }

  export type AssetCategoryUpsertWithoutAssetsInput = {
    update: XOR<AssetCategoryUpdateWithoutAssetsInput, AssetCategoryUncheckedUpdateWithoutAssetsInput>
    create: XOR<AssetCategoryCreateWithoutAssetsInput, AssetCategoryUncheckedCreateWithoutAssetsInput>
    where?: AssetCategoryWhereInput
  }

  export type AssetCategoryUpdateToOneWithWhereWithoutAssetsInput = {
    where?: AssetCategoryWhereInput
    data: XOR<AssetCategoryUpdateWithoutAssetsInput, AssetCategoryUncheckedUpdateWithoutAssetsInput>
  }

  export type AssetCategoryUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    glAssetAccount?: ChartOfAccountUpdateOneRequiredWithoutAssetCategoriesAssetNestedInput
    glDepreciationAccount?: ChartOfAccountUpdateOneRequiredWithoutAssetCategoriesDepreciationNestedInput
    glAccumulatedDepreciationAccount?: ChartOfAccountUpdateOneRequiredWithoutAssetCategoriesAccumulatedNestedInput
  }

  export type AssetCategoryUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    glAssetAccountId?: StringFieldUpdateOperationsInput | string
    glDepreciationAccountId?: StringFieldUpdateOperationsInput | string
    glAccumulatedDepreciationAccountId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUpsertWithoutAssetsInput = {
    update: XOR<LocationUpdateWithoutAssetsInput, LocationUncheckedUpdateWithoutAssetsInput>
    create: XOR<LocationCreateWithoutAssetsInput, LocationUncheckedCreateWithoutAssetsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutAssetsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutAssetsInput, LocationUncheckedUpdateWithoutAssetsInput>
  }

  export type LocationUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouses?: WarehouseUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouses?: WarehouseUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type PurchaseUpsertWithoutAssetsInput = {
    update: XOR<PurchaseUpdateWithoutAssetsInput, PurchaseUncheckedUpdateWithoutAssetsInput>
    create: XOR<PurchaseCreateWithoutAssetsInput, PurchaseUncheckedCreateWithoutAssetsInput>
    where?: PurchaseWhereInput
  }

  export type PurchaseUpdateToOneWithWhereWithoutAssetsInput = {
    where?: PurchaseWhereInput
    data: XOR<PurchaseUpdateWithoutAssetsInput, PurchaseUncheckedUpdateWithoutAssetsInput>
  }

  export type PurchaseUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutPurchasesNestedInput
    purchaseLines?: PurchaseLineUpdateManyWithoutPurchaseNestedInput
    purchasePayments?: PurchasePaymentUpdateManyWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseLines?: PurchaseLineUncheckedUpdateManyWithoutPurchaseNestedInput
    purchasePayments?: PurchasePaymentUncheckedUpdateManyWithoutPurchaseNestedInput
  }

  export type UserUpsertWithoutAssetsCreatedInput = {
    update: XOR<UserUpdateWithoutAssetsCreatedInput, UserUncheckedUpdateWithoutAssetsCreatedInput>
    create: XOR<UserCreateWithoutAssetsCreatedInput, UserUncheckedCreateWithoutAssetsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssetsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssetsCreatedInput, UserUncheckedUpdateWithoutAssetsCreatedInput>
  }

  export type UserUpdateWithoutAssetsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    journals?: JournalUpdateManyWithoutPostedByUserNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutUserNestedInput
    salesReceipts?: SalesReceiptUpdateManyWithoutUserNestedInput
    purchasePayments?: PurchasePaymentUpdateManyWithoutUserNestedInput
    SystemSetting?: SystemSettingUpdateManyWithoutUpdatedByUserNestedInput
    ApprovalRequest?: ApprovalRequestUpdateManyWithoutRequestedByUserNestedInput
    ApprovalAction?: ApprovalActionUpdateManyWithoutUserNestedInput
    assetDisposals?: AssetDisposalUpdateManyWithoutDisposedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssetsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    journals?: JournalUncheckedUpdateManyWithoutPostedByUserNestedInput
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutUserNestedInput
    salesReceipts?: SalesReceiptUncheckedUpdateManyWithoutUserNestedInput
    purchasePayments?: PurchasePaymentUncheckedUpdateManyWithoutUserNestedInput
    SystemSetting?: SystemSettingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    ApprovalRequest?: ApprovalRequestUncheckedUpdateManyWithoutRequestedByUserNestedInput
    ApprovalAction?: ApprovalActionUncheckedUpdateManyWithoutUserNestedInput
    assetDisposals?: AssetDisposalUncheckedUpdateManyWithoutDisposedByUserNestedInput
  }

  export type AssetDepreciationUpsertWithWhereUniqueWithoutAssetInput = {
    where: AssetDepreciationWhereUniqueInput
    update: XOR<AssetDepreciationUpdateWithoutAssetInput, AssetDepreciationUncheckedUpdateWithoutAssetInput>
    create: XOR<AssetDepreciationCreateWithoutAssetInput, AssetDepreciationUncheckedCreateWithoutAssetInput>
  }

  export type AssetDepreciationUpdateWithWhereUniqueWithoutAssetInput = {
    where: AssetDepreciationWhereUniqueInput
    data: XOR<AssetDepreciationUpdateWithoutAssetInput, AssetDepreciationUncheckedUpdateWithoutAssetInput>
  }

  export type AssetDepreciationUpdateManyWithWhereWithoutAssetInput = {
    where: AssetDepreciationScalarWhereInput
    data: XOR<AssetDepreciationUpdateManyMutationInput, AssetDepreciationUncheckedUpdateManyWithoutAssetInput>
  }

  export type AssetDisposalUpsertWithWhereUniqueWithoutAssetInput = {
    where: AssetDisposalWhereUniqueInput
    update: XOR<AssetDisposalUpdateWithoutAssetInput, AssetDisposalUncheckedUpdateWithoutAssetInput>
    create: XOR<AssetDisposalCreateWithoutAssetInput, AssetDisposalUncheckedCreateWithoutAssetInput>
  }

  export type AssetDisposalUpdateWithWhereUniqueWithoutAssetInput = {
    where: AssetDisposalWhereUniqueInput
    data: XOR<AssetDisposalUpdateWithoutAssetInput, AssetDisposalUncheckedUpdateWithoutAssetInput>
  }

  export type AssetDisposalUpdateManyWithWhereWithoutAssetInput = {
    where: AssetDisposalScalarWhereInput
    data: XOR<AssetDisposalUpdateManyMutationInput, AssetDisposalUncheckedUpdateManyWithoutAssetInput>
  }

  export type VendorUpsertWithoutAssetsInput = {
    update: XOR<VendorUpdateWithoutAssetsInput, VendorUncheckedUpdateWithoutAssetsInput>
    create: XOR<VendorCreateWithoutAssetsInput, VendorUncheckedCreateWithoutAssetsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutAssetsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutAssetsInput, VendorUncheckedUpdateWithoutAssetsInput>
  }

  export type VendorUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchaseUpdateManyWithoutVendorNestedInput
    purchasePayments?: PurchasePaymentUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchases?: PurchaseUncheckedUpdateManyWithoutVendorNestedInput
    purchasePayments?: PurchasePaymentUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type AssetCreateWithoutDepreciationEntriesInput = {
    id?: string
    assetNo: string
    name: string
    description?: string | null
    acquisitionDate: Date | string
    acquisitionCost: Decimal | DecimalJsLike | number | string
    residualValue?: Decimal | DecimalJsLike | number | string
    usefulLife: number
    depreciationMethod: string
    serialNumber?: string | null
    supplier?: string | null
    status?: string
    disposalDate?: Date | string | null
    disposalAmount?: Decimal | DecimalJsLike | number | string | null
    disposalMethod?: string | null
    createdAt?: Date | string
    category: AssetCategoryCreateNestedOneWithoutAssetsInput
    location?: LocationCreateNestedOneWithoutAssetsInput
    purchaseOrder?: PurchaseCreateNestedOneWithoutAssetsInput
    createdByUser: UserCreateNestedOneWithoutAssetsCreatedInput
    disposals?: AssetDisposalCreateNestedManyWithoutAssetInput
    Vendor?: VendorCreateNestedOneWithoutAssetsInput
  }

  export type AssetUncheckedCreateWithoutDepreciationEntriesInput = {
    id?: string
    assetNo: string
    name: string
    description?: string | null
    categoryId: string
    acquisitionDate: Date | string
    acquisitionCost: Decimal | DecimalJsLike | number | string
    residualValue?: Decimal | DecimalJsLike | number | string
    usefulLife: number
    depreciationMethod: string
    locationId?: string | null
    serialNumber?: string | null
    supplier?: string | null
    purchaseOrderId?: string | null
    status?: string
    disposalDate?: Date | string | null
    disposalAmount?: Decimal | DecimalJsLike | number | string | null
    disposalMethod?: string | null
    createdBy: string
    createdAt?: Date | string
    vendorId?: string | null
    disposals?: AssetDisposalUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutDepreciationEntriesInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutDepreciationEntriesInput, AssetUncheckedCreateWithoutDepreciationEntriesInput>
  }

  export type JournalCreateWithoutAssetDepreciationInput = {
    id?: string
    journalNo: string
    date: Date | string
    memo?: string | null
    postedAt?: Date | string
    postedByUser: UserCreateNestedOneWithoutJournalsInput
    journalLines?: JournalLineCreateNestedManyWithoutJournalInput
    assetDisposals?: AssetDisposalCreateNestedManyWithoutJournalInput
  }

  export type JournalUncheckedCreateWithoutAssetDepreciationInput = {
    id?: string
    journalNo: string
    date: Date | string
    memo?: string | null
    postedBy: string
    postedAt?: Date | string
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutJournalInput
    assetDisposals?: AssetDisposalUncheckedCreateNestedManyWithoutJournalInput
  }

  export type JournalCreateOrConnectWithoutAssetDepreciationInput = {
    where: JournalWhereUniqueInput
    create: XOR<JournalCreateWithoutAssetDepreciationInput, JournalUncheckedCreateWithoutAssetDepreciationInput>
  }

  export type AssetUpsertWithoutDepreciationEntriesInput = {
    update: XOR<AssetUpdateWithoutDepreciationEntriesInput, AssetUncheckedUpdateWithoutDepreciationEntriesInput>
    create: XOR<AssetCreateWithoutDepreciationEntriesInput, AssetUncheckedCreateWithoutDepreciationEntriesInput>
    where?: AssetWhereInput
  }

  export type AssetUpdateToOneWithWhereWithoutDepreciationEntriesInput = {
    where?: AssetWhereInput
    data: XOR<AssetUpdateWithoutDepreciationEntriesInput, AssetUncheckedUpdateWithoutDepreciationEntriesInput>
  }

  export type AssetUpdateWithoutDepreciationEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquisitionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disposalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: AssetCategoryUpdateOneRequiredWithoutAssetsNestedInput
    location?: LocationUpdateOneWithoutAssetsNestedInput
    purchaseOrder?: PurchaseUpdateOneWithoutAssetsNestedInput
    createdByUser?: UserUpdateOneRequiredWithoutAssetsCreatedNestedInput
    disposals?: AssetDisposalUpdateManyWithoutAssetNestedInput
    Vendor?: VendorUpdateOneWithoutAssetsNestedInput
  }

  export type AssetUncheckedUpdateWithoutDepreciationEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquisitionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disposalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    disposals?: AssetDisposalUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type JournalUpsertWithoutAssetDepreciationInput = {
    update: XOR<JournalUpdateWithoutAssetDepreciationInput, JournalUncheckedUpdateWithoutAssetDepreciationInput>
    create: XOR<JournalCreateWithoutAssetDepreciationInput, JournalUncheckedCreateWithoutAssetDepreciationInput>
    where?: JournalWhereInput
  }

  export type JournalUpdateToOneWithWhereWithoutAssetDepreciationInput = {
    where?: JournalWhereInput
    data: XOR<JournalUpdateWithoutAssetDepreciationInput, JournalUncheckedUpdateWithoutAssetDepreciationInput>
  }

  export type JournalUpdateWithoutAssetDepreciationInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByUser?: UserUpdateOneRequiredWithoutJournalsNestedInput
    journalLines?: JournalLineUpdateManyWithoutJournalNestedInput
    assetDisposals?: AssetDisposalUpdateManyWithoutJournalNestedInput
  }

  export type JournalUncheckedUpdateWithoutAssetDepreciationInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    postedBy?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journalLines?: JournalLineUncheckedUpdateManyWithoutJournalNestedInput
    assetDisposals?: AssetDisposalUncheckedUpdateManyWithoutJournalNestedInput
  }

  export type AssetCreateWithoutDisposalsInput = {
    id?: string
    assetNo: string
    name: string
    description?: string | null
    acquisitionDate: Date | string
    acquisitionCost: Decimal | DecimalJsLike | number | string
    residualValue?: Decimal | DecimalJsLike | number | string
    usefulLife: number
    depreciationMethod: string
    serialNumber?: string | null
    supplier?: string | null
    status?: string
    disposalDate?: Date | string | null
    disposalAmount?: Decimal | DecimalJsLike | number | string | null
    disposalMethod?: string | null
    createdAt?: Date | string
    category: AssetCategoryCreateNestedOneWithoutAssetsInput
    location?: LocationCreateNestedOneWithoutAssetsInput
    purchaseOrder?: PurchaseCreateNestedOneWithoutAssetsInput
    createdByUser: UserCreateNestedOneWithoutAssetsCreatedInput
    depreciationEntries?: AssetDepreciationCreateNestedManyWithoutAssetInput
    Vendor?: VendorCreateNestedOneWithoutAssetsInput
  }

  export type AssetUncheckedCreateWithoutDisposalsInput = {
    id?: string
    assetNo: string
    name: string
    description?: string | null
    categoryId: string
    acquisitionDate: Date | string
    acquisitionCost: Decimal | DecimalJsLike | number | string
    residualValue?: Decimal | DecimalJsLike | number | string
    usefulLife: number
    depreciationMethod: string
    locationId?: string | null
    serialNumber?: string | null
    supplier?: string | null
    purchaseOrderId?: string | null
    status?: string
    disposalDate?: Date | string | null
    disposalAmount?: Decimal | DecimalJsLike | number | string | null
    disposalMethod?: string | null
    createdBy: string
    createdAt?: Date | string
    vendorId?: string | null
    depreciationEntries?: AssetDepreciationUncheckedCreateNestedManyWithoutAssetInput
  }

  export type AssetCreateOrConnectWithoutDisposalsInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutDisposalsInput, AssetUncheckedCreateWithoutDisposalsInput>
  }

  export type JournalCreateWithoutAssetDisposalsInput = {
    id?: string
    journalNo: string
    date: Date | string
    memo?: string | null
    postedAt?: Date | string
    postedByUser: UserCreateNestedOneWithoutJournalsInput
    journalLines?: JournalLineCreateNestedManyWithoutJournalInput
    assetDepreciation?: AssetDepreciationCreateNestedManyWithoutJournalInput
  }

  export type JournalUncheckedCreateWithoutAssetDisposalsInput = {
    id?: string
    journalNo: string
    date: Date | string
    memo?: string | null
    postedBy: string
    postedAt?: Date | string
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutJournalInput
    assetDepreciation?: AssetDepreciationUncheckedCreateNestedManyWithoutJournalInput
  }

  export type JournalCreateOrConnectWithoutAssetDisposalsInput = {
    where: JournalWhereUniqueInput
    create: XOR<JournalCreateWithoutAssetDisposalsInput, JournalUncheckedCreateWithoutAssetDisposalsInput>
  }

  export type UserCreateWithoutAssetDisposalsInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    journals?: JournalCreateNestedManyWithoutPostedByUserInput
    inventoryLedger?: InventoryLedgerCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutUserInput
    salesReceipts?: SalesReceiptCreateNestedManyWithoutUserInput
    purchasePayments?: PurchasePaymentCreateNestedManyWithoutUserInput
    SystemSetting?: SystemSettingCreateNestedManyWithoutUpdatedByUserInput
    ApprovalRequest?: ApprovalRequestCreateNestedManyWithoutRequestedByUserInput
    ApprovalAction?: ApprovalActionCreateNestedManyWithoutUserInput
    assetsCreated?: AssetCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserUncheckedCreateWithoutAssetDisposalsInput = {
    id?: string
    email: string
    name: string
    password: string
    status?: string
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    journals?: JournalUncheckedCreateNestedManyWithoutPostedByUserInput
    inventoryLedger?: InventoryLedgerUncheckedCreateNestedManyWithoutUserInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutUserInput
    salesReceipts?: SalesReceiptUncheckedCreateNestedManyWithoutUserInput
    purchasePayments?: PurchasePaymentUncheckedCreateNestedManyWithoutUserInput
    SystemSetting?: SystemSettingUncheckedCreateNestedManyWithoutUpdatedByUserInput
    ApprovalRequest?: ApprovalRequestUncheckedCreateNestedManyWithoutRequestedByUserInput
    ApprovalAction?: ApprovalActionUncheckedCreateNestedManyWithoutUserInput
    assetsCreated?: AssetUncheckedCreateNestedManyWithoutCreatedByUserInput
  }

  export type UserCreateOrConnectWithoutAssetDisposalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssetDisposalsInput, UserUncheckedCreateWithoutAssetDisposalsInput>
  }

  export type AssetUpsertWithoutDisposalsInput = {
    update: XOR<AssetUpdateWithoutDisposalsInput, AssetUncheckedUpdateWithoutDisposalsInput>
    create: XOR<AssetCreateWithoutDisposalsInput, AssetUncheckedCreateWithoutDisposalsInput>
    where?: AssetWhereInput
  }

  export type AssetUpdateToOneWithWhereWithoutDisposalsInput = {
    where?: AssetWhereInput
    data: XOR<AssetUpdateWithoutDisposalsInput, AssetUncheckedUpdateWithoutDisposalsInput>
  }

  export type AssetUpdateWithoutDisposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquisitionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disposalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: AssetCategoryUpdateOneRequiredWithoutAssetsNestedInput
    location?: LocationUpdateOneWithoutAssetsNestedInput
    purchaseOrder?: PurchaseUpdateOneWithoutAssetsNestedInput
    createdByUser?: UserUpdateOneRequiredWithoutAssetsCreatedNestedInput
    depreciationEntries?: AssetDepreciationUpdateManyWithoutAssetNestedInput
    Vendor?: VendorUpdateOneWithoutAssetsNestedInput
  }

  export type AssetUncheckedUpdateWithoutDisposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquisitionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disposalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    depreciationEntries?: AssetDepreciationUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type JournalUpsertWithoutAssetDisposalsInput = {
    update: XOR<JournalUpdateWithoutAssetDisposalsInput, JournalUncheckedUpdateWithoutAssetDisposalsInput>
    create: XOR<JournalCreateWithoutAssetDisposalsInput, JournalUncheckedCreateWithoutAssetDisposalsInput>
    where?: JournalWhereInput
  }

  export type JournalUpdateToOneWithWhereWithoutAssetDisposalsInput = {
    where?: JournalWhereInput
    data: XOR<JournalUpdateWithoutAssetDisposalsInput, JournalUncheckedUpdateWithoutAssetDisposalsInput>
  }

  export type JournalUpdateWithoutAssetDisposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postedByUser?: UserUpdateOneRequiredWithoutJournalsNestedInput
    journalLines?: JournalLineUpdateManyWithoutJournalNestedInput
    assetDepreciation?: AssetDepreciationUpdateManyWithoutJournalNestedInput
  }

  export type JournalUncheckedUpdateWithoutAssetDisposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    postedBy?: StringFieldUpdateOperationsInput | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journalLines?: JournalLineUncheckedUpdateManyWithoutJournalNestedInput
    assetDepreciation?: AssetDepreciationUncheckedUpdateManyWithoutJournalNestedInput
  }

  export type UserUpsertWithoutAssetDisposalsInput = {
    update: XOR<UserUpdateWithoutAssetDisposalsInput, UserUncheckedUpdateWithoutAssetDisposalsInput>
    create: XOR<UserCreateWithoutAssetDisposalsInput, UserUncheckedCreateWithoutAssetDisposalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssetDisposalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssetDisposalsInput, UserUncheckedUpdateWithoutAssetDisposalsInput>
  }

  export type UserUpdateWithoutAssetDisposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    journals?: JournalUpdateManyWithoutPostedByUserNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutUserNestedInput
    salesReceipts?: SalesReceiptUpdateManyWithoutUserNestedInput
    purchasePayments?: PurchasePaymentUpdateManyWithoutUserNestedInput
    SystemSetting?: SystemSettingUpdateManyWithoutUpdatedByUserNestedInput
    ApprovalRequest?: ApprovalRequestUpdateManyWithoutRequestedByUserNestedInput
    ApprovalAction?: ApprovalActionUpdateManyWithoutUserNestedInput
    assetsCreated?: AssetUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssetDisposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    journals?: JournalUncheckedUpdateManyWithoutPostedByUserNestedInput
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutUserNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutUserNestedInput
    salesReceipts?: SalesReceiptUncheckedUpdateManyWithoutUserNestedInput
    purchasePayments?: PurchasePaymentUncheckedUpdateManyWithoutUserNestedInput
    SystemSetting?: SystemSettingUncheckedUpdateManyWithoutUpdatedByUserNestedInput
    ApprovalRequest?: ApprovalRequestUncheckedUpdateManyWithoutRequestedByUserNestedInput
    ApprovalAction?: ApprovalActionUncheckedUpdateManyWithoutUserNestedInput
    assetsCreated?: AssetUncheckedUpdateManyWithoutCreatedByUserNestedInput
  }

  export type UserRoleCreateManyUserInput = {
    id?: string
    roleId: string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type JournalCreateManyPostedByUserInput = {
    id?: string
    journalNo: string
    date: Date | string
    memo?: string | null
    postedAt?: Date | string
  }

  export type InventoryLedgerCreateManyUserInput = {
    id?: string
    itemId: string
    warehouseId: string
    refType: string
    refId: string
    direction: $Enums.LedgerDirection
    qty: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    value: Decimal | DecimalJsLike | number | string
    runningQty: Decimal | DecimalJsLike | number | string
    runningValue: Decimal | DecimalJsLike | number | string
    runningAvgCost: Decimal | DecimalJsLike | number | string
    batchId?: string | null
    postedAt?: Date | string
  }

  export type CashTransactionCreateManyUserInput = {
    id?: string
    transactionNo: string
    cashAccountId: string
    glAccountId?: string | null
    contraAccountId?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    refType?: string | null
    refId?: string | null
    transactionDate: Date | string
    isReconciled?: boolean
    reconciledAt?: Date | string | null
    createdAt?: Date | string
    reference: string
  }

  export type SalesReceiptCreateManyUserInput = {
    id?: string
    receiptNo: string
    saleId: string
    customerId: string
    cashAccountId: string
    amountReceived: Decimal | DecimalJsLike | number | string
    receiptDate: Date | string
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type PurchasePaymentCreateManyUserInput = {
    id?: string
    paymentNo: string
    purchaseId: string
    vendorId: string
    cashAccountId: string
    amountPaid: Decimal | DecimalJsLike | number | string
    paymentDate: Date | string
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type SystemSettingCreateManyUpdatedByUserInput = {
    id?: string
    category: string
    key: string
    value?: string | null
    dataType?: string | null
    description?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type ApprovalRequestCreateManyRequestedByUserInput = {
    id?: string
    workflowId: string
    entityType: string
    entityId: string
    currentStepId?: string | null
    status: string
    requestedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalActionCreateManyUserInput = {
    id?: string
    requestId: string
    stepId: string
    action: string
    comments?: string | null
    actionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetCreateManyCreatedByUserInput = {
    id?: string
    assetNo: string
    name: string
    description?: string | null
    categoryId: string
    acquisitionDate: Date | string
    acquisitionCost: Decimal | DecimalJsLike | number | string
    residualValue?: Decimal | DecimalJsLike | number | string
    usefulLife: number
    depreciationMethod: string
    locationId?: string | null
    serialNumber?: string | null
    supplier?: string | null
    purchaseOrderId?: string | null
    status?: string
    disposalDate?: Date | string | null
    disposalAmount?: Decimal | DecimalJsLike | number | string | null
    disposalMethod?: string | null
    createdAt?: Date | string
    vendorId?: string | null
  }

  export type AssetDisposalCreateManyDisposedByUserInput = {
    id?: string
    assetId: string
    disposalDate: Date | string
    disposalAmount: Decimal | DecimalJsLike | number | string
    disposalMethod: string
    buyerDetails?: string | null
    gainLoss: Decimal | DecimalJsLike | number | string
    notes?: string | null
    journalId?: string | null
    createdAt?: Date | string
  }

  export type UserRoleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    beforeJson?: NullableJsonNullValueInput | InputJsonValue
    afterJson?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalUpdateWithoutPostedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journalLines?: JournalLineUpdateManyWithoutJournalNestedInput
    assetDepreciation?: AssetDepreciationUpdateManyWithoutJournalNestedInput
    assetDisposals?: AssetDisposalUpdateManyWithoutJournalNestedInput
  }

  export type JournalUncheckedUpdateWithoutPostedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journalLines?: JournalLineUncheckedUpdateManyWithoutJournalNestedInput
    assetDepreciation?: AssetDepreciationUncheckedUpdateManyWithoutJournalNestedInput
    assetDisposals?: AssetDisposalUncheckedUpdateManyWithoutJournalNestedInput
  }

  export type JournalUncheckedUpdateManyWithoutPostedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalNo?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryLedgerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningAvgCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutInventoryLedgerNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutInventoryLedgerNestedInput
    batch?: InventoryBatchUpdateOneWithoutInventoryLedgerNestedInput
  }

  export type InventoryLedgerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningAvgCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryLedgerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningAvgCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashTransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionNo?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    cashAccount?: CashAccountUpdateOneRequiredWithoutCashTransactionsNestedInput
    glAccount?: ChartOfAccountUpdateOneWithoutCashTransactionsGLNestedInput
    contraAccount?: ChartOfAccountUpdateOneWithoutCashTransactionsContraNestedInput
  }

  export type CashTransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionNo?: StringFieldUpdateOperationsInput | string
    cashAccountId?: StringFieldUpdateOperationsInput | string
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    contraAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
  }

  export type CashTransactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionNo?: StringFieldUpdateOperationsInput | string
    cashAccountId?: StringFieldUpdateOperationsInput | string
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    contraAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
  }

  export type SalesReceiptUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNo?: StringFieldUpdateOperationsInput | string
    amountReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutSalesReceiptsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSalesReceiptsNestedInput
    cashAccount?: CashAccountUpdateOneRequiredWithoutSalesReceiptsNestedInput
  }

  export type SalesReceiptUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNo?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    cashAccountId?: StringFieldUpdateOperationsInput | string
    amountReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesReceiptUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNo?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    cashAccountId?: StringFieldUpdateOperationsInput | string
    amountReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNo?: StringFieldUpdateOperationsInput | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutPurchasePaymentsNestedInput
    vendor?: VendorUpdateOneRequiredWithoutPurchasePaymentsNestedInput
    cashAccount?: CashAccountUpdateOneRequiredWithoutPurchasePaymentsNestedInput
  }

  export type PurchasePaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNo?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    cashAccountId?: StringFieldUpdateOperationsInput | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePaymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNo?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    cashAccountId?: StringFieldUpdateOperationsInput | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUpdateWithoutUpdatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateWithoutUpdatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateManyWithoutUpdatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    dataType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalRequestUpdateWithoutRequestedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: ApprovalWorkflowUpdateOneRequiredWithoutApprovalRequestNestedInput
    currentStep?: ApprovalStepUpdateOneWithoutApprovalRequestNestedInput
    actions?: ApprovalActionUpdateManyWithoutRequestNestedInput
  }

  export type ApprovalRequestUncheckedUpdateWithoutRequestedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actions?: ApprovalActionUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type ApprovalRequestUncheckedUpdateManyWithoutRequestedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalActionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: ApprovalRequestUpdateOneRequiredWithoutActionsNestedInput
    step?: ApprovalStepUpdateOneRequiredWithoutApprovalActionNestedInput
  }

  export type ApprovalActionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalActionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquisitionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disposalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: AssetCategoryUpdateOneRequiredWithoutAssetsNestedInput
    location?: LocationUpdateOneWithoutAssetsNestedInput
    purchaseOrder?: PurchaseUpdateOneWithoutAssetsNestedInput
    depreciationEntries?: AssetDepreciationUpdateManyWithoutAssetNestedInput
    disposals?: AssetDisposalUpdateManyWithoutAssetNestedInput
    Vendor?: VendorUpdateOneWithoutAssetsNestedInput
  }

  export type AssetUncheckedUpdateWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquisitionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disposalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    depreciationEntries?: AssetDepreciationUncheckedUpdateManyWithoutAssetNestedInput
    disposals?: AssetDisposalUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateManyWithoutCreatedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquisitionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disposalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetDisposalUpdateWithoutDisposedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    disposalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    disposalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disposalMethod?: StringFieldUpdateOperationsInput | string
    buyerDetails?: NullableStringFieldUpdateOperationsInput | string | null
    gainLoss?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asset?: AssetUpdateOneRequiredWithoutDisposalsNestedInput
    journal?: JournalUpdateOneWithoutAssetDisposalsNestedInput
  }

  export type AssetDisposalUncheckedUpdateWithoutDisposedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    disposalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    disposalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disposalMethod?: StringFieldUpdateOperationsInput | string
    buyerDetails?: NullableStringFieldUpdateOperationsInput | string | null
    gainLoss?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    journalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetDisposalUncheckedUpdateManyWithoutDisposedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    disposalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    disposalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disposalMethod?: StringFieldUpdateOperationsInput | string
    buyerDetails?: NullableStringFieldUpdateOperationsInput | string | null
    gainLoss?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    journalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyRoleInput = {
    id?: string
    permissionId: string
  }

  export type UserRoleCreateManyRoleInput = {
    id?: string
    userId: string
  }

  export type ApprovalStepCreateManyRoleInput = {
    id?: string
    workflowId: string
    stepOrder: number
    name: string
    isRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ApprovalStepUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: ApprovalWorkflowUpdateOneRequiredWithoutStepsNestedInput
    ApprovalRequest?: ApprovalRequestUpdateManyWithoutCurrentStepNestedInput
    ApprovalAction?: ApprovalActionUpdateManyWithoutStepNestedInput
  }

  export type ApprovalStepUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ApprovalRequest?: ApprovalRequestUncheckedUpdateManyWithoutCurrentStepNestedInput
    ApprovalAction?: ApprovalActionUncheckedUpdateManyWithoutStepNestedInput
  }

  export type ApprovalStepUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyPermissionInput = {
    id?: string
    roleId: string
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: RoleUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type WarehouseCreateManyLocationInput = {
    id?: string
    code: string
    name: string
    address?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type AssetCreateManyLocationInput = {
    id?: string
    assetNo: string
    name: string
    description?: string | null
    categoryId: string
    acquisitionDate: Date | string
    acquisitionCost: Decimal | DecimalJsLike | number | string
    residualValue?: Decimal | DecimalJsLike | number | string
    usefulLife: number
    depreciationMethod: string
    serialNumber?: string | null
    supplier?: string | null
    purchaseOrderId?: string | null
    status?: string
    disposalDate?: Date | string | null
    disposalAmount?: Decimal | DecimalJsLike | number | string | null
    disposalMethod?: string | null
    createdBy: string
    createdAt?: Date | string
    vendorId?: string | null
  }

  export type WarehouseUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bins?: BinUpdateManyWithoutWarehouseNestedInput
    inventoryBatches?: InventoryBatchUpdateManyWithoutWarehouseNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutWarehouseNestedInput
    productionOrders?: ProductionOrderUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bins?: BinUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryBatches?: InventoryBatchUncheckedUpdateManyWithoutWarehouseNestedInput
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutWarehouseNestedInput
    productionOrders?: ProductionOrderUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquisitionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disposalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: AssetCategoryUpdateOneRequiredWithoutAssetsNestedInput
    purchaseOrder?: PurchaseUpdateOneWithoutAssetsNestedInput
    createdByUser?: UserUpdateOneRequiredWithoutAssetsCreatedNestedInput
    depreciationEntries?: AssetDepreciationUpdateManyWithoutAssetNestedInput
    disposals?: AssetDisposalUpdateManyWithoutAssetNestedInput
    Vendor?: VendorUpdateOneWithoutAssetsNestedInput
  }

  export type AssetUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquisitionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disposalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    depreciationEntries?: AssetDepreciationUncheckedUpdateManyWithoutAssetNestedInput
    disposals?: AssetDisposalUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquisitionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disposalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BinCreateManyWarehouseInput = {
    id?: string
    code: string
    name?: string | null
  }

  export type InventoryBatchCreateManyWarehouseInput = {
    id?: string
    itemId: string
    binId?: string | null
    qtyOnHand: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    receivedAt: Date | string
  }

  export type InventoryLedgerCreateManyWarehouseInput = {
    id?: string
    itemId: string
    refType: string
    refId: string
    direction: $Enums.LedgerDirection
    qty: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    value: Decimal | DecimalJsLike | number | string
    runningQty: Decimal | DecimalJsLike | number | string
    runningValue: Decimal | DecimalJsLike | number | string
    runningAvgCost: Decimal | DecimalJsLike | number | string
    batchId?: string | null
    userId?: string | null
    postedAt?: Date | string
  }

  export type ProductionOrderCreateManyWarehouseInput = {
    id?: string
    orderNo: string
    itemId: string
    qtyTarget: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string
    status?: $Enums.ProductionOrderStatus
    bomId?: string | null
    approvalStatus?: string | null
    approvalRequestId?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BinUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryBatches?: InventoryBatchUpdateManyWithoutBinNestedInput
  }

  export type BinUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryBatches?: InventoryBatchUncheckedUpdateManyWithoutBinNestedInput
  }

  export type BinUncheckedUpdateManyWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryBatchUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutInventoryBatchesNestedInput
    bin?: BinUpdateOneWithoutInventoryBatchesNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutBatchNestedInput
  }

  export type InventoryBatchUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type InventoryBatchUncheckedUpdateManyWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryLedgerUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningAvgCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutInventoryLedgerNestedInput
    batch?: InventoryBatchUpdateOneWithoutInventoryLedgerNestedInput
    user?: UserUpdateOneWithoutInventoryLedgerNestedInput
  }

  export type InventoryLedgerUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningAvgCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryLedgerUncheckedUpdateManyWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningAvgCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionOrderUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    qtyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumProductionOrderStatusFieldUpdateOperationsInput | $Enums.ProductionOrderStatus
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    approvalRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutProductionOrdersNestedInput
    bom?: BomUpdateOneWithoutProductionOrdersNestedInput
    wipLedger?: WipLedgerUpdateManyWithoutProductionOrderNestedInput
    laborTimes?: LaborTimeUpdateManyWithoutProductionOrderNestedInput
  }

  export type ProductionOrderUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qtyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumProductionOrderStatusFieldUpdateOperationsInput | $Enums.ProductionOrderStatus
    bomId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    approvalRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wipLedger?: WipLedgerUncheckedUpdateManyWithoutProductionOrderNestedInput
    laborTimes?: LaborTimeUncheckedUpdateManyWithoutProductionOrderNestedInput
  }

  export type ProductionOrderUncheckedUpdateManyWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qtyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumProductionOrderStatusFieldUpdateOperationsInput | $Enums.ProductionOrderStatus
    bomId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    approvalRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryBatchCreateManyBinInput = {
    id?: string
    itemId: string
    warehouseId: string
    qtyOnHand: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    receivedAt: Date | string
  }

  export type InventoryBatchUpdateWithoutBinInput = {
    id?: StringFieldUpdateOperationsInput | string
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutInventoryBatchesNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutInventoryBatchesNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutBatchNestedInput
  }

  export type InventoryBatchUncheckedUpdateWithoutBinInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type InventoryBatchUncheckedUpdateManyWithoutBinInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BomCreateManyItemInput = {
    id?: string
    version?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BomLineCreateManyComponentItemInput = {
    id?: string
    bomId: string
    qtyPer: Decimal | DecimalJsLike | number | string
    scrapPercent?: Decimal | DecimalJsLike | number | string
  }

  export type InventoryBatchCreateManyItemInput = {
    id?: string
    warehouseId: string
    binId?: string | null
    qtyOnHand: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    receivedAt: Date | string
  }

  export type InventoryLedgerCreateManyItemInput = {
    id?: string
    warehouseId: string
    refType: string
    refId: string
    direction: $Enums.LedgerDirection
    qty: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    value: Decimal | DecimalJsLike | number | string
    runningQty: Decimal | DecimalJsLike | number | string
    runningValue: Decimal | DecimalJsLike | number | string
    runningAvgCost: Decimal | DecimalJsLike | number | string
    batchId?: string | null
    userId?: string | null
    postedAt?: Date | string
  }

  export type ProductionOrderCreateManyItemInput = {
    id?: string
    orderNo: string
    qtyTarget: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string
    status?: $Enums.ProductionOrderStatus
    warehouseId: string
    bomId?: string | null
    approvalStatus?: string | null
    approvalRequestId?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseLineCreateManyItemInput = {
    id?: string
    purchaseId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SaleLineCreateManyItemInput = {
    id?: string
    saleId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type BomUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bomLines?: BomLineUpdateManyWithoutBomNestedInput
    productionOrders?: ProductionOrderUpdateManyWithoutBomNestedInput
  }

  export type BomUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bomLines?: BomLineUncheckedUpdateManyWithoutBomNestedInput
    productionOrders?: ProductionOrderUncheckedUpdateManyWithoutBomNestedInput
  }

  export type BomUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BomLineUpdateWithoutComponentItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    qtyPer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bom?: BomUpdateOneRequiredWithoutBomLinesNestedInput
  }

  export type BomLineUncheckedUpdateWithoutComponentItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    bomId?: StringFieldUpdateOperationsInput | string
    qtyPer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BomLineUncheckedUpdateManyWithoutComponentItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    bomId?: StringFieldUpdateOperationsInput | string
    qtyPer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InventoryBatchUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutInventoryBatchesNestedInput
    bin?: BinUpdateOneWithoutInventoryBatchesNestedInput
    inventoryLedger?: InventoryLedgerUpdateManyWithoutBatchNestedInput
  }

  export type InventoryBatchUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryLedger?: InventoryLedgerUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type InventoryBatchUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    binId?: NullableStringFieldUpdateOperationsInput | string | null
    qtyOnHand?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryLedgerUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningAvgCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutInventoryLedgerNestedInput
    batch?: InventoryBatchUpdateOneWithoutInventoryLedgerNestedInput
    user?: UserUpdateOneWithoutInventoryLedgerNestedInput
  }

  export type InventoryLedgerUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningAvgCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryLedgerUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningAvgCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionOrderUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    qtyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumProductionOrderStatusFieldUpdateOperationsInput | $Enums.ProductionOrderStatus
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    approvalRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutProductionOrdersNestedInput
    bom?: BomUpdateOneWithoutProductionOrdersNestedInput
    wipLedger?: WipLedgerUpdateManyWithoutProductionOrderNestedInput
    laborTimes?: LaborTimeUpdateManyWithoutProductionOrderNestedInput
  }

  export type ProductionOrderUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    qtyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumProductionOrderStatusFieldUpdateOperationsInput | $Enums.ProductionOrderStatus
    warehouseId?: StringFieldUpdateOperationsInput | string
    bomId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    approvalRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wipLedger?: WipLedgerUncheckedUpdateManyWithoutProductionOrderNestedInput
    laborTimes?: LaborTimeUncheckedUpdateManyWithoutProductionOrderNestedInput
  }

  export type ProductionOrderUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    qtyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumProductionOrderStatusFieldUpdateOperationsInput | $Enums.ProductionOrderStatus
    warehouseId?: StringFieldUpdateOperationsInput | string
    bomId?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    approvalRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseLineUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchase?: PurchaseUpdateOneRequiredWithoutPurchaseLinesNestedInput
  }

  export type PurchaseLineUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchaseLineUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleLineUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sale?: SaleUpdateOneRequiredWithoutSaleLinesNestedInput
  }

  export type SaleLineUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleLineUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BomLineCreateManyBomInput = {
    id?: string
    componentItemId: string
    qtyPer: Decimal | DecimalJsLike | number | string
    scrapPercent?: Decimal | DecimalJsLike | number | string
  }

  export type ProductionOrderCreateManyBomInput = {
    id?: string
    orderNo: string
    itemId: string
    qtyTarget: Decimal | DecimalJsLike | number | string
    qtyProduced?: Decimal | DecimalJsLike | number | string
    status?: $Enums.ProductionOrderStatus
    warehouseId: string
    approvalStatus?: string | null
    approvalRequestId?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BomLineUpdateWithoutBomInput = {
    id?: StringFieldUpdateOperationsInput | string
    qtyPer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    componentItem?: ItemUpdateOneRequiredWithoutBomLinesNestedInput
  }

  export type BomLineUncheckedUpdateWithoutBomInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentItemId?: StringFieldUpdateOperationsInput | string
    qtyPer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BomLineUncheckedUpdateManyWithoutBomInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentItemId?: StringFieldUpdateOperationsInput | string
    qtyPer?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scrapPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ProductionOrderUpdateWithoutBomInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    qtyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumProductionOrderStatusFieldUpdateOperationsInput | $Enums.ProductionOrderStatus
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    approvalRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutProductionOrdersNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutProductionOrdersNestedInput
    wipLedger?: WipLedgerUpdateManyWithoutProductionOrderNestedInput
    laborTimes?: LaborTimeUpdateManyWithoutProductionOrderNestedInput
  }

  export type ProductionOrderUncheckedUpdateWithoutBomInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qtyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumProductionOrderStatusFieldUpdateOperationsInput | $Enums.ProductionOrderStatus
    warehouseId?: StringFieldUpdateOperationsInput | string
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    approvalRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wipLedger?: WipLedgerUncheckedUpdateManyWithoutProductionOrderNestedInput
    laborTimes?: LaborTimeUncheckedUpdateManyWithoutProductionOrderNestedInput
  }

  export type ProductionOrderUncheckedUpdateManyWithoutBomInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qtyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtyProduced?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumProductionOrderStatusFieldUpdateOperationsInput | $Enums.ProductionOrderStatus
    warehouseId?: StringFieldUpdateOperationsInput | string
    approvalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    approvalRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryLedgerCreateManyBatchInput = {
    id?: string
    itemId: string
    warehouseId: string
    refType: string
    refId: string
    direction: $Enums.LedgerDirection
    qty: Decimal | DecimalJsLike | number | string
    unitCost: Decimal | DecimalJsLike | number | string
    value: Decimal | DecimalJsLike | number | string
    runningQty: Decimal | DecimalJsLike | number | string
    runningValue: Decimal | DecimalJsLike | number | string
    runningAvgCost: Decimal | DecimalJsLike | number | string
    userId?: string | null
    postedAt?: Date | string
  }

  export type InventoryLedgerUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningAvgCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutInventoryLedgerNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutInventoryLedgerNestedInput
    user?: UserUpdateOneWithoutInventoryLedgerNestedInput
  }

  export type InventoryLedgerUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningAvgCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryLedgerUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    warehouseId?: StringFieldUpdateOperationsInput | string
    refType?: StringFieldUpdateOperationsInput | string
    refId?: StringFieldUpdateOperationsInput | string
    direction?: EnumLedgerDirectionFieldUpdateOperationsInput | $Enums.LedgerDirection
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningQty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    runningAvgCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WipLedgerCreateManyProductionOrderInput = {
    id?: string
    type: $Enums.WipLedgerType
    amount: Decimal | DecimalJsLike | number | string
    note?: string | null
    postedAt?: Date | string
  }

  export type LaborTimeCreateManyProductionOrderInput = {
    id?: string
    hours: Decimal | DecimalJsLike | number | string
    rate: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    employeeName?: string | null
  }

  export type WipLedgerUpdateWithoutProductionOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWipLedgerTypeFieldUpdateOperationsInput | $Enums.WipLedgerType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WipLedgerUncheckedUpdateWithoutProductionOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWipLedgerTypeFieldUpdateOperationsInput | $Enums.WipLedgerType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WipLedgerUncheckedUpdateManyWithoutProductionOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWipLedgerTypeFieldUpdateOperationsInput | $Enums.WipLedgerType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaborTimeUpdateWithoutProductionOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    hours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LaborTimeUncheckedUpdateWithoutProductionOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    hours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LaborTimeUncheckedUpdateManyWithoutProductionOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    hours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseCreateManyVendorInput = {
    id?: string
    orderNo: string
    orderDate: Date | string
    status?: $Enums.PurchaseStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchasePaymentCreateManyVendorInput = {
    id?: string
    paymentNo: string
    purchaseId: string
    cashAccountId: string
    amountPaid: Decimal | DecimalJsLike | number | string
    paymentDate: Date | string
    reference?: string | null
    notes?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type AssetCreateManyVendorInput = {
    id?: string
    assetNo: string
    name: string
    description?: string | null
    categoryId: string
    acquisitionDate: Date | string
    acquisitionCost: Decimal | DecimalJsLike | number | string
    residualValue?: Decimal | DecimalJsLike | number | string
    usefulLife: number
    depreciationMethod: string
    locationId?: string | null
    serialNumber?: string | null
    supplier?: string | null
    purchaseOrderId?: string | null
    status?: string
    disposalDate?: Date | string | null
    disposalAmount?: Decimal | DecimalJsLike | number | string | null
    disposalMethod?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type PurchaseUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseLines?: PurchaseLineUpdateManyWithoutPurchaseNestedInput
    purchasePayments?: PurchasePaymentUpdateManyWithoutPurchaseNestedInput
    assets?: AssetUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseLines?: PurchaseLineUncheckedUpdateManyWithoutPurchaseNestedInput
    purchasePayments?: PurchasePaymentUncheckedUpdateManyWithoutPurchaseNestedInput
    assets?: AssetUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePaymentUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNo?: StringFieldUpdateOperationsInput | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutPurchasePaymentsNestedInput
    cashAccount?: CashAccountUpdateOneRequiredWithoutPurchasePaymentsNestedInput
    user?: UserUpdateOneRequiredWithoutPurchasePaymentsNestedInput
  }

  export type PurchasePaymentUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNo?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    cashAccountId?: StringFieldUpdateOperationsInput | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePaymentUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNo?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    cashAccountId?: StringFieldUpdateOperationsInput | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquisitionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disposalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: AssetCategoryUpdateOneRequiredWithoutAssetsNestedInput
    location?: LocationUpdateOneWithoutAssetsNestedInput
    purchaseOrder?: PurchaseUpdateOneWithoutAssetsNestedInput
    createdByUser?: UserUpdateOneRequiredWithoutAssetsCreatedNestedInput
    depreciationEntries?: AssetDepreciationUpdateManyWithoutAssetNestedInput
    disposals?: AssetDisposalUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquisitionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disposalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depreciationEntries?: AssetDepreciationUncheckedUpdateManyWithoutAssetNestedInput
    disposals?: AssetDisposalUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquisitionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disposalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleCreateManyCustomerInput = {
    id?: string
    orderNo: string
    orderDate: Date | string
    status?: $Enums.SaleStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesReceiptCreateManyCustomerInput = {
    id?: string
    receiptNo: string
    saleId: string
    cashAccountId: string
    amountReceived: Decimal | DecimalJsLike | number | string
    receiptDate: Date | string
    reference?: string | null
    notes?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type SaleUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleLines?: SaleLineUpdateManyWithoutSaleNestedInput
    salesReceipts?: SalesReceiptUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleLines?: SaleLineUncheckedUpdateManyWithoutSaleNestedInput
    salesReceipts?: SalesReceiptUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSaleStatusFieldUpdateOperationsInput | $Enums.SaleStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesReceiptUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNo?: StringFieldUpdateOperationsInput | string
    amountReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutSalesReceiptsNestedInput
    cashAccount?: CashAccountUpdateOneRequiredWithoutSalesReceiptsNestedInput
    user?: UserUpdateOneRequiredWithoutSalesReceiptsNestedInput
  }

  export type SalesReceiptUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNo?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    cashAccountId?: StringFieldUpdateOperationsInput | string
    amountReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesReceiptUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNo?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    cashAccountId?: StringFieldUpdateOperationsInput | string
    amountReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseLineCreateManyPurchaseInput = {
    id?: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type PurchasePaymentCreateManyPurchaseInput = {
    id?: string
    paymentNo: string
    vendorId: string
    cashAccountId: string
    amountPaid: Decimal | DecimalJsLike | number | string
    paymentDate: Date | string
    reference?: string | null
    notes?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type AssetCreateManyPurchaseOrderInput = {
    id?: string
    assetNo: string
    name: string
    description?: string | null
    categoryId: string
    acquisitionDate: Date | string
    acquisitionCost: Decimal | DecimalJsLike | number | string
    residualValue?: Decimal | DecimalJsLike | number | string
    usefulLife: number
    depreciationMethod: string
    locationId?: string | null
    serialNumber?: string | null
    supplier?: string | null
    status?: string
    disposalDate?: Date | string | null
    disposalAmount?: Decimal | DecimalJsLike | number | string | null
    disposalMethod?: string | null
    createdBy: string
    createdAt?: Date | string
    vendorId?: string | null
  }

  export type PurchaseLineUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    item?: ItemUpdateOneRequiredWithoutPurchaseLinesNestedInput
  }

  export type PurchaseLineUncheckedUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchaseLineUncheckedUpdateManyWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PurchasePaymentUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNo?: StringFieldUpdateOperationsInput | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutPurchasePaymentsNestedInput
    cashAccount?: CashAccountUpdateOneRequiredWithoutPurchasePaymentsNestedInput
    user?: UserUpdateOneRequiredWithoutPurchasePaymentsNestedInput
  }

  export type PurchasePaymentUncheckedUpdateWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNo?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    cashAccountId?: StringFieldUpdateOperationsInput | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePaymentUncheckedUpdateManyWithoutPurchaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNo?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    cashAccountId?: StringFieldUpdateOperationsInput | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquisitionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disposalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: AssetCategoryUpdateOneRequiredWithoutAssetsNestedInput
    location?: LocationUpdateOneWithoutAssetsNestedInput
    createdByUser?: UserUpdateOneRequiredWithoutAssetsCreatedNestedInput
    depreciationEntries?: AssetDepreciationUpdateManyWithoutAssetNestedInput
    disposals?: AssetDisposalUpdateManyWithoutAssetNestedInput
    Vendor?: VendorUpdateOneWithoutAssetsNestedInput
  }

  export type AssetUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquisitionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disposalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    depreciationEntries?: AssetDepreciationUncheckedUpdateManyWithoutAssetNestedInput
    disposals?: AssetDisposalUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateManyWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquisitionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disposalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SaleLineCreateManySaleInput = {
    id?: string
    itemId: string
    qty: Decimal | DecimalJsLike | number | string
    unitPrice: Decimal | DecimalJsLike | number | string
    lineTotal: Decimal | DecimalJsLike | number | string
  }

  export type SalesReceiptCreateManySaleInput = {
    id?: string
    receiptNo: string
    customerId: string
    cashAccountId: string
    amountReceived: Decimal | DecimalJsLike | number | string
    receiptDate: Date | string
    reference?: string | null
    notes?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type SaleLineUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    item?: ItemUpdateOneRequiredWithoutSaleLinesNestedInput
  }

  export type SaleLineUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleLineUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lineTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SalesReceiptUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNo?: StringFieldUpdateOperationsInput | string
    amountReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSalesReceiptsNestedInput
    cashAccount?: CashAccountUpdateOneRequiredWithoutSalesReceiptsNestedInput
    user?: UserUpdateOneRequiredWithoutSalesReceiptsNestedInput
  }

  export type SalesReceiptUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNo?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    cashAccountId?: StringFieldUpdateOperationsInput | string
    amountReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesReceiptUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNo?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    cashAccountId?: StringFieldUpdateOperationsInput | string
    amountReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChartOfAccountCreateManyParentInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    accountType: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type JournalLineCreateManyAccountInput = {
    id?: string
    journalId: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    refType?: string | null
    refId?: string | null
  }

  export type CashTransactionCreateManyGlAccountInput = {
    id?: string
    transactionNo: string
    cashAccountId: string
    contraAccountId?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    refType?: string | null
    refId?: string | null
    transactionDate: Date | string
    isReconciled?: boolean
    reconciledAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    reference: string
  }

  export type CashTransactionCreateManyContraAccountInput = {
    id?: string
    transactionNo: string
    cashAccountId: string
    glAccountId?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    refType?: string | null
    refId?: string | null
    transactionDate: Date | string
    isReconciled?: boolean
    reconciledAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    reference: string
  }

  export type CashAccountCreateManyChartOfAccountInput = {
    id?: string
    code: string
    name: string
    accountType: string
    accountNumber?: string | null
    glAccountId?: string | null
    bankName?: string | null
    balance?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type AssetCategoryCreateManyGlAssetAccountInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    depreciationMethod: string
    usefulLife?: number
    residualValue?: Decimal | DecimalJsLike | number | string
    glDepreciationAccountId: string
    glAccumulatedDepreciationAccountId: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type AssetCategoryCreateManyGlDepreciationAccountInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    depreciationMethod: string
    usefulLife?: number
    residualValue?: Decimal | DecimalJsLike | number | string
    glAssetAccountId: string
    glAccumulatedDepreciationAccountId: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type AssetCategoryCreateManyGlAccumulatedDepreciationAccountInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    depreciationMethod: string
    usefulLife?: number
    residualValue?: Decimal | DecimalJsLike | number | string
    glAssetAccountId: string
    glDepreciationAccountId: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ChartOfAccountUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChartOfAccountUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUpdateManyWithoutAccountNestedInput
    cashTransactionsGL?: CashTransactionUpdateManyWithoutGlAccountNestedInput
    cashTransactionsContra?: CashTransactionUpdateManyWithoutContraAccountNestedInput
    cashAccounts?: CashAccountUpdateManyWithoutChartOfAccountNestedInput
    assetCategoriesAsset?: AssetCategoryUpdateManyWithoutGlAssetAccountNestedInput
    assetCategoriesDepreciation?: AssetCategoryUpdateManyWithoutGlDepreciationAccountNestedInput
    assetCategoriesAccumulated?: AssetCategoryUpdateManyWithoutGlAccumulatedDepreciationAccountNestedInput
  }

  export type ChartOfAccountUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ChartOfAccountUncheckedUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutAccountNestedInput
    cashTransactionsGL?: CashTransactionUncheckedUpdateManyWithoutGlAccountNestedInput
    cashTransactionsContra?: CashTransactionUncheckedUpdateManyWithoutContraAccountNestedInput
    cashAccounts?: CashAccountUncheckedUpdateManyWithoutChartOfAccountNestedInput
    assetCategoriesAsset?: AssetCategoryUncheckedUpdateManyWithoutGlAssetAccountNestedInput
    assetCategoriesDepreciation?: AssetCategoryUncheckedUpdateManyWithoutGlDepreciationAccountNestedInput
    assetCategoriesAccumulated?: AssetCategoryUncheckedUpdateManyWithoutGlAccumulatedDepreciationAccountNestedInput
  }

  export type ChartOfAccountUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLineUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    journal?: JournalUpdateOneRequiredWithoutJournalLinesNestedInput
  }

  export type JournalLineUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalLineUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CashTransactionUpdateWithoutGlAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionNo?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    cashAccount?: CashAccountUpdateOneRequiredWithoutCashTransactionsNestedInput
    contraAccount?: ChartOfAccountUpdateOneWithoutCashTransactionsContraNestedInput
    user?: UserUpdateOneRequiredWithoutCashTransactionsNestedInput
  }

  export type CashTransactionUncheckedUpdateWithoutGlAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionNo?: StringFieldUpdateOperationsInput | string
    cashAccountId?: StringFieldUpdateOperationsInput | string
    contraAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
  }

  export type CashTransactionUncheckedUpdateManyWithoutGlAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionNo?: StringFieldUpdateOperationsInput | string
    cashAccountId?: StringFieldUpdateOperationsInput | string
    contraAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
  }

  export type CashTransactionUpdateWithoutContraAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionNo?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    cashAccount?: CashAccountUpdateOneRequiredWithoutCashTransactionsNestedInput
    glAccount?: ChartOfAccountUpdateOneWithoutCashTransactionsGLNestedInput
    user?: UserUpdateOneRequiredWithoutCashTransactionsNestedInput
  }

  export type CashTransactionUncheckedUpdateWithoutContraAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionNo?: StringFieldUpdateOperationsInput | string
    cashAccountId?: StringFieldUpdateOperationsInput | string
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
  }

  export type CashTransactionUncheckedUpdateManyWithoutContraAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionNo?: StringFieldUpdateOperationsInput | string
    cashAccountId?: StringFieldUpdateOperationsInput | string
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
  }

  export type CashAccountUpdateWithoutChartOfAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashTransactions?: CashTransactionUpdateManyWithoutCashAccountNestedInput
    salesReceipts?: SalesReceiptUpdateManyWithoutCashAccountNestedInput
    purchasePayments?: PurchasePaymentUpdateManyWithoutCashAccountNestedInput
  }

  export type CashAccountUncheckedUpdateWithoutChartOfAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutCashAccountNestedInput
    salesReceipts?: SalesReceiptUncheckedUpdateManyWithoutCashAccountNestedInput
    purchasePayments?: PurchasePaymentUncheckedUpdateManyWithoutCashAccountNestedInput
  }

  export type CashAccountUncheckedUpdateManyWithoutChartOfAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCategoryUpdateWithoutGlAssetAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUpdateManyWithoutCategoryNestedInput
    glDepreciationAccount?: ChartOfAccountUpdateOneRequiredWithoutAssetCategoriesDepreciationNestedInput
    glAccumulatedDepreciationAccount?: ChartOfAccountUpdateOneRequiredWithoutAssetCategoriesAccumulatedNestedInput
  }

  export type AssetCategoryUncheckedUpdateWithoutGlAssetAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    glDepreciationAccountId?: StringFieldUpdateOperationsInput | string
    glAccumulatedDepreciationAccountId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type AssetCategoryUncheckedUpdateManyWithoutGlAssetAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    glDepreciationAccountId?: StringFieldUpdateOperationsInput | string
    glAccumulatedDepreciationAccountId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCategoryUpdateWithoutGlDepreciationAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUpdateManyWithoutCategoryNestedInput
    glAssetAccount?: ChartOfAccountUpdateOneRequiredWithoutAssetCategoriesAssetNestedInput
    glAccumulatedDepreciationAccount?: ChartOfAccountUpdateOneRequiredWithoutAssetCategoriesAccumulatedNestedInput
  }

  export type AssetCategoryUncheckedUpdateWithoutGlDepreciationAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    glAssetAccountId?: StringFieldUpdateOperationsInput | string
    glAccumulatedDepreciationAccountId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type AssetCategoryUncheckedUpdateManyWithoutGlDepreciationAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    glAssetAccountId?: StringFieldUpdateOperationsInput | string
    glAccumulatedDepreciationAccountId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCategoryUpdateWithoutGlAccumulatedDepreciationAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUpdateManyWithoutCategoryNestedInput
    glAssetAccount?: ChartOfAccountUpdateOneRequiredWithoutAssetCategoriesAssetNestedInput
    glDepreciationAccount?: ChartOfAccountUpdateOneRequiredWithoutAssetCategoriesDepreciationNestedInput
  }

  export type AssetCategoryUncheckedUpdateWithoutGlAccumulatedDepreciationAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    glAssetAccountId?: StringFieldUpdateOperationsInput | string
    glDepreciationAccountId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: AssetUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type AssetCategoryUncheckedUpdateManyWithoutGlAccumulatedDepreciationAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    glAssetAccountId?: StringFieldUpdateOperationsInput | string
    glDepreciationAccountId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLineCreateManyJournalInput = {
    id?: string
    accountId: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    refType?: string | null
    refId?: string | null
  }

  export type AssetDepreciationCreateManyJournalInput = {
    id?: string
    assetId: string
    periodYear: number
    periodMonth: number
    depreciationAmount: Decimal | DecimalJsLike | number | string
    accumulatedDepreciation: Decimal | DecimalJsLike | number | string
    netBookValue: Decimal | DecimalJsLike | number | string
    isPosted?: boolean
    postedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AssetDisposalCreateManyJournalInput = {
    id?: string
    assetId: string
    disposalDate: Date | string
    disposalAmount: Decimal | DecimalJsLike | number | string
    disposalMethod: string
    buyerDetails?: string | null
    gainLoss: Decimal | DecimalJsLike | number | string
    notes?: string | null
    disposedBy: string
    createdAt?: Date | string
  }

  export type JournalLineUpdateWithoutJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    account?: ChartOfAccountUpdateOneRequiredWithoutJournalLinesNestedInput
  }

  export type JournalLineUncheckedUpdateWithoutJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalLineUncheckedUpdateManyWithoutJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetDepreciationUpdateWithoutJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodYear?: IntFieldUpdateOperationsInput | number
    periodMonth?: IntFieldUpdateOperationsInput | number
    depreciationAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accumulatedDepreciation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netBookValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asset?: AssetUpdateOneRequiredWithoutDepreciationEntriesNestedInput
  }

  export type AssetDepreciationUncheckedUpdateWithoutJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    periodYear?: IntFieldUpdateOperationsInput | number
    periodMonth?: IntFieldUpdateOperationsInput | number
    depreciationAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accumulatedDepreciation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netBookValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetDepreciationUncheckedUpdateManyWithoutJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    periodYear?: IntFieldUpdateOperationsInput | number
    periodMonth?: IntFieldUpdateOperationsInput | number
    depreciationAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accumulatedDepreciation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netBookValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetDisposalUpdateWithoutJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    disposalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    disposalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disposalMethod?: StringFieldUpdateOperationsInput | string
    buyerDetails?: NullableStringFieldUpdateOperationsInput | string | null
    gainLoss?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asset?: AssetUpdateOneRequiredWithoutDisposalsNestedInput
    disposedByUser?: UserUpdateOneRequiredWithoutAssetDisposalsNestedInput
  }

  export type AssetDisposalUncheckedUpdateWithoutJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    disposalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    disposalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disposalMethod?: StringFieldUpdateOperationsInput | string
    buyerDetails?: NullableStringFieldUpdateOperationsInput | string | null
    gainLoss?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    disposedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetDisposalUncheckedUpdateManyWithoutJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetId?: StringFieldUpdateOperationsInput | string
    disposalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    disposalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disposalMethod?: StringFieldUpdateOperationsInput | string
    buyerDetails?: NullableStringFieldUpdateOperationsInput | string | null
    gainLoss?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    disposedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashTransactionCreateManyCashAccountInput = {
    id?: string
    transactionNo: string
    glAccountId?: string | null
    contraAccountId?: string | null
    transactionType: string
    amount: Decimal | DecimalJsLike | number | string
    description: string
    refType?: string | null
    refId?: string | null
    transactionDate: Date | string
    isReconciled?: boolean
    reconciledAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    reference: string
  }

  export type SalesReceiptCreateManyCashAccountInput = {
    id?: string
    receiptNo: string
    saleId: string
    customerId: string
    amountReceived: Decimal | DecimalJsLike | number | string
    receiptDate: Date | string
    reference?: string | null
    notes?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type PurchasePaymentCreateManyCashAccountInput = {
    id?: string
    paymentNo: string
    purchaseId: string
    vendorId: string
    amountPaid: Decimal | DecimalJsLike | number | string
    paymentDate: Date | string
    reference?: string | null
    notes?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type CashTransactionUpdateWithoutCashAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionNo?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    glAccount?: ChartOfAccountUpdateOneWithoutCashTransactionsGLNestedInput
    contraAccount?: ChartOfAccountUpdateOneWithoutCashTransactionsContraNestedInput
    user?: UserUpdateOneRequiredWithoutCashTransactionsNestedInput
  }

  export type CashTransactionUncheckedUpdateWithoutCashAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionNo?: StringFieldUpdateOperationsInput | string
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    contraAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
  }

  export type CashTransactionUncheckedUpdateManyWithoutCashAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionNo?: StringFieldUpdateOperationsInput | string
    glAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    contraAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionType?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    refType?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isReconciled?: BoolFieldUpdateOperationsInput | boolean
    reconciledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
  }

  export type SalesReceiptUpdateWithoutCashAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNo?: StringFieldUpdateOperationsInput | string
    amountReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutSalesReceiptsNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSalesReceiptsNestedInput
    user?: UserUpdateOneRequiredWithoutSalesReceiptsNestedInput
  }

  export type SalesReceiptUncheckedUpdateWithoutCashAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNo?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    amountReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesReceiptUncheckedUpdateManyWithoutCashAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiptNo?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    amountReceived?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receiptDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePaymentUpdateWithoutCashAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNo?: StringFieldUpdateOperationsInput | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase?: PurchaseUpdateOneRequiredWithoutPurchasePaymentsNestedInput
    vendor?: VendorUpdateOneRequiredWithoutPurchasePaymentsNestedInput
    user?: UserUpdateOneRequiredWithoutPurchasePaymentsNestedInput
  }

  export type PurchasePaymentUncheckedUpdateWithoutCashAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNo?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchasePaymentUncheckedUpdateManyWithoutCashAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNo?: StringFieldUpdateOperationsInput | string
    purchaseId?: StringFieldUpdateOperationsInput | string
    vendorId?: StringFieldUpdateOperationsInput | string
    amountPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiscalPeriodCreateManyFiscalYearInput = {
    id?: string
    periodNumber: number
    name: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FiscalPeriodUpdateWithoutFiscalYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiscalPeriodUncheckedUpdateWithoutFiscalYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiscalPeriodUncheckedUpdateManyWithoutFiscalYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalStepCreateManyWorkflowInput = {
    id?: string
    stepOrder: number
    name: string
    roleId: string
    isRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalRequestCreateManyWorkflowInput = {
    id?: string
    entityType: string
    entityId: string
    requestedBy: string
    currentStepId?: string | null
    status: string
    requestedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalStepUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutApprovalStepNestedInput
    ApprovalRequest?: ApprovalRequestUpdateManyWithoutCurrentStepNestedInput
    ApprovalAction?: ApprovalActionUpdateManyWithoutStepNestedInput
  }

  export type ApprovalStepUncheckedUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ApprovalRequest?: ApprovalRequestUncheckedUpdateManyWithoutCurrentStepNestedInput
    ApprovalAction?: ApprovalActionUncheckedUpdateManyWithoutStepNestedInput
  }

  export type ApprovalStepUncheckedUpdateManyWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepOrder?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalRequestUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedByUser?: UserUpdateOneRequiredWithoutApprovalRequestNestedInput
    currentStep?: ApprovalStepUpdateOneWithoutApprovalRequestNestedInput
    actions?: ApprovalActionUpdateManyWithoutRequestNestedInput
  }

  export type ApprovalRequestUncheckedUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actions?: ApprovalActionUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type ApprovalRequestUncheckedUpdateManyWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    currentStepId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalRequestCreateManyCurrentStepInput = {
    id?: string
    workflowId: string
    entityType: string
    entityId: string
    requestedBy: string
    status: string
    requestedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalActionCreateManyStepInput = {
    id?: string
    requestId: string
    userId: string
    action: string
    comments?: string | null
    actionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalRequestUpdateWithoutCurrentStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflow?: ApprovalWorkflowUpdateOneRequiredWithoutApprovalRequestNestedInput
    requestedByUser?: UserUpdateOneRequiredWithoutApprovalRequestNestedInput
    actions?: ApprovalActionUpdateManyWithoutRequestNestedInput
  }

  export type ApprovalRequestUncheckedUpdateWithoutCurrentStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actions?: ApprovalActionUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type ApprovalRequestUncheckedUpdateManyWithoutCurrentStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalActionUpdateWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: ApprovalRequestUpdateOneRequiredWithoutActionsNestedInput
    user?: UserUpdateOneRequiredWithoutApprovalActionNestedInput
  }

  export type ApprovalActionUncheckedUpdateWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalActionUncheckedUpdateManyWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalActionCreateManyRequestInput = {
    id?: string
    stepId: string
    userId: string
    action: string
    comments?: string | null
    actionDate?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalActionUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    step?: ApprovalStepUpdateOneRequiredWithoutApprovalActionNestedInput
    user?: UserUpdateOneRequiredWithoutApprovalActionNestedInput
  }

  export type ApprovalActionUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalActionUncheckedUpdateManyWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateManyCategoryInput = {
    id?: string
    assetNo: string
    name: string
    description?: string | null
    acquisitionDate: Date | string
    acquisitionCost: Decimal | DecimalJsLike | number | string
    residualValue?: Decimal | DecimalJsLike | number | string
    usefulLife: number
    depreciationMethod: string
    locationId?: string | null
    serialNumber?: string | null
    supplier?: string | null
    purchaseOrderId?: string | null
    status?: string
    disposalDate?: Date | string | null
    disposalAmount?: Decimal | DecimalJsLike | number | string | null
    disposalMethod?: string | null
    createdBy: string
    createdAt?: Date | string
    vendorId?: string | null
  }

  export type AssetUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquisitionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disposalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutAssetsNestedInput
    purchaseOrder?: PurchaseUpdateOneWithoutAssetsNestedInput
    createdByUser?: UserUpdateOneRequiredWithoutAssetsCreatedNestedInput
    depreciationEntries?: AssetDepreciationUpdateManyWithoutAssetNestedInput
    disposals?: AssetDisposalUpdateManyWithoutAssetNestedInput
    Vendor?: VendorUpdateOneWithoutAssetsNestedInput
  }

  export type AssetUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquisitionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disposalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
    depreciationEntries?: AssetDepreciationUncheckedUpdateManyWithoutAssetNestedInput
    disposals?: AssetDisposalUncheckedUpdateManyWithoutAssetNestedInput
  }

  export type AssetUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetNo?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    acquisitionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    acquisitionCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    residualValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usefulLife?: IntFieldUpdateOperationsInput | number
    depreciationMethod?: StringFieldUpdateOperationsInput | string
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    disposalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disposalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    disposalMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssetDepreciationCreateManyAssetInput = {
    id?: string
    periodYear: number
    periodMonth: number
    depreciationAmount: Decimal | DecimalJsLike | number | string
    accumulatedDepreciation: Decimal | DecimalJsLike | number | string
    netBookValue: Decimal | DecimalJsLike | number | string
    isPosted?: boolean
    postedAt?: Date | string | null
    journalId?: string | null
    createdAt?: Date | string
  }

  export type AssetDisposalCreateManyAssetInput = {
    id?: string
    disposalDate: Date | string
    disposalAmount: Decimal | DecimalJsLike | number | string
    disposalMethod: string
    buyerDetails?: string | null
    gainLoss: Decimal | DecimalJsLike | number | string
    notes?: string | null
    journalId?: string | null
    disposedBy: string
    createdAt?: Date | string
  }

  export type AssetDepreciationUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodYear?: IntFieldUpdateOperationsInput | number
    periodMonth?: IntFieldUpdateOperationsInput | number
    depreciationAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accumulatedDepreciation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netBookValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journal?: JournalUpdateOneWithoutAssetDepreciationNestedInput
  }

  export type AssetDepreciationUncheckedUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodYear?: IntFieldUpdateOperationsInput | number
    periodMonth?: IntFieldUpdateOperationsInput | number
    depreciationAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accumulatedDepreciation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netBookValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetDepreciationUncheckedUpdateManyWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodYear?: IntFieldUpdateOperationsInput | number
    periodMonth?: IntFieldUpdateOperationsInput | number
    depreciationAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accumulatedDepreciation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netBookValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isPosted?: BoolFieldUpdateOperationsInput | boolean
    postedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetDisposalUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    disposalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    disposalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disposalMethod?: StringFieldUpdateOperationsInput | string
    buyerDetails?: NullableStringFieldUpdateOperationsInput | string | null
    gainLoss?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journal?: JournalUpdateOneWithoutAssetDisposalsNestedInput
    disposedByUser?: UserUpdateOneRequiredWithoutAssetDisposalsNestedInput
  }

  export type AssetDisposalUncheckedUpdateWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    disposalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    disposalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disposalMethod?: StringFieldUpdateOperationsInput | string
    buyerDetails?: NullableStringFieldUpdateOperationsInput | string | null
    gainLoss?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    journalId?: NullableStringFieldUpdateOperationsInput | string | null
    disposedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetDisposalUncheckedUpdateManyWithoutAssetInput = {
    id?: StringFieldUpdateOperationsInput | string
    disposalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    disposalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    disposalMethod?: StringFieldUpdateOperationsInput | string
    buyerDetails?: NullableStringFieldUpdateOperationsInput | string | null
    gainLoss?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    journalId?: NullableStringFieldUpdateOperationsInput | string | null
    disposedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionCountOutputTypeDefaultArgs instead
     */
    export type PermissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationCountOutputTypeDefaultArgs instead
     */
    export type LocationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WarehouseCountOutputTypeDefaultArgs instead
     */
    export type WarehouseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WarehouseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BinCountOutputTypeDefaultArgs instead
     */
    export type BinCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BinCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemCountOutputTypeDefaultArgs instead
     */
    export type ItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BomCountOutputTypeDefaultArgs instead
     */
    export type BomCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BomCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryBatchCountOutputTypeDefaultArgs instead
     */
    export type InventoryBatchCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryBatchCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductionOrderCountOutputTypeDefaultArgs instead
     */
    export type ProductionOrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductionOrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VendorCountOutputTypeDefaultArgs instead
     */
    export type VendorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VendorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerCountOutputTypeDefaultArgs instead
     */
    export type CustomerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseCountOutputTypeDefaultArgs instead
     */
    export type PurchaseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaleCountOutputTypeDefaultArgs instead
     */
    export type SaleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChartOfAccountCountOutputTypeDefaultArgs instead
     */
    export type ChartOfAccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChartOfAccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JournalCountOutputTypeDefaultArgs instead
     */
    export type JournalCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JournalCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CashAccountCountOutputTypeDefaultArgs instead
     */
    export type CashAccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CashAccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FiscalYearCountOutputTypeDefaultArgs instead
     */
    export type FiscalYearCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FiscalYearCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApprovalWorkflowCountOutputTypeDefaultArgs instead
     */
    export type ApprovalWorkflowCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApprovalWorkflowCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApprovalStepCountOutputTypeDefaultArgs instead
     */
    export type ApprovalStepCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApprovalStepCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApprovalRequestCountOutputTypeDefaultArgs instead
     */
    export type ApprovalRequestCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApprovalRequestCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssetCategoryCountOutputTypeDefaultArgs instead
     */
    export type AssetCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssetCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssetCountOutputTypeDefaultArgs instead
     */
    export type AssetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionDefaultArgs instead
     */
    export type PermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserRoleDefaultArgs instead
     */
    export type UserRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserRoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolePermissionDefaultArgs instead
     */
    export type RolePermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolePermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyDefaultArgs instead
     */
    export type CompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationDefaultArgs instead
     */
    export type LocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WarehouseDefaultArgs instead
     */
    export type WarehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WarehouseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BinDefaultArgs instead
     */
    export type BinArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BinDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemDefaultArgs instead
     */
    export type ItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BomDefaultArgs instead
     */
    export type BomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BomLineDefaultArgs instead
     */
    export type BomLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BomLineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryBatchDefaultArgs instead
     */
    export type InventoryBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryBatchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryLedgerDefaultArgs instead
     */
    export type InventoryLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryLedgerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductionOrderDefaultArgs instead
     */
    export type ProductionOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductionOrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WipLedgerDefaultArgs instead
     */
    export type WipLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WipLedgerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LaborTimeDefaultArgs instead
     */
    export type LaborTimeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LaborTimeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VendorDefaultArgs instead
     */
    export type VendorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VendorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerDefaultArgs instead
     */
    export type CustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseDefaultArgs instead
     */
    export type PurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseLineDefaultArgs instead
     */
    export type PurchaseLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseLineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaleDefaultArgs instead
     */
    export type SaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaleLineDefaultArgs instead
     */
    export type SaleLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaleLineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChartOfAccountDefaultArgs instead
     */
    export type ChartOfAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChartOfAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JournalDefaultArgs instead
     */
    export type JournalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JournalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JournalLineDefaultArgs instead
     */
    export type JournalLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JournalLineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PolicyDefaultArgs instead
     */
    export type PolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PolicyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CashAccountDefaultArgs instead
     */
    export type CashAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CashAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CashTransactionDefaultArgs instead
     */
    export type CashTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CashTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SalesReceiptDefaultArgs instead
     */
    export type SalesReceiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalesReceiptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchasePaymentDefaultArgs instead
     */
    export type PurchasePaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchasePaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemSettingDefaultArgs instead
     */
    export type SystemSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemSettingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FiscalYearDefaultArgs instead
     */
    export type FiscalYearArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FiscalYearDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FiscalPeriodDefaultArgs instead
     */
    export type FiscalPeriodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FiscalPeriodDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApprovalWorkflowDefaultArgs instead
     */
    export type ApprovalWorkflowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApprovalWorkflowDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApprovalStepDefaultArgs instead
     */
    export type ApprovalStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApprovalStepDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApprovalRequestDefaultArgs instead
     */
    export type ApprovalRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApprovalRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApprovalActionDefaultArgs instead
     */
    export type ApprovalActionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApprovalActionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssetCategoryDefaultArgs instead
     */
    export type AssetCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssetCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssetDefaultArgs instead
     */
    export type AssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssetDepreciationDefaultArgs instead
     */
    export type AssetDepreciationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssetDepreciationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssetDisposalDefaultArgs instead
     */
    export type AssetDisposalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssetDisposalDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}